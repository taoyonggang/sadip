// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v2x.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_v2x_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_v2x_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_v2x_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_v2x_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_v2x_2eproto;
namespace cn {
namespace seisys {
namespace v2x {
namespace pb {
class AccelerationConfidence;
struct AccelerationConfidenceDefaultTypeInternal;
extern AccelerationConfidenceDefaultTypeInternal _AccelerationConfidence_default_instance_;
class AccelerationSet4Way;
struct AccelerationSet4WayDefaultTypeInternal;
extern AccelerationSet4WayDefaultTypeInternal _AccelerationSet4Way_default_instance_;
class AllowedManeuvers;
struct AllowedManeuversDefaultTypeInternal;
extern AllowedManeuversDefaultTypeInternal _AllowedManeuvers_default_instance_;
class BrakeSystemStatus;
struct BrakeSystemStatusDefaultTypeInternal;
extern BrakeSystemStatusDefaultTypeInternal _BrakeSystemStatus_default_instance_;
class BsmData;
struct BsmDataDefaultTypeInternal;
extern BsmDataDefaultTypeInternal _BsmData_default_instance_;
class CamData;
struct CamDataDefaultTypeInternal;
extern CamDataDefaultTypeInternal _CamData_default_instance_;
class ConnectingLane;
struct ConnectingLaneDefaultTypeInternal;
extern ConnectingLaneDefaultTypeInternal _ConnectingLane_default_instance_;
class ConnectingLaneEx;
struct ConnectingLaneExDefaultTypeInternal;
extern ConnectingLaneExDefaultTypeInternal _ConnectingLaneEx_default_instance_;
class Connection;
struct ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class ConnectionEx;
struct ConnectionExDefaultTypeInternal;
extern ConnectionExDefaultTypeInternal _ConnectionEx_default_instance_;
class CoordinationInfo;
struct CoordinationInfoDefaultTypeInternal;
extern CoordinationInfoDefaultTypeInternal _CoordinationInfo_default_instance_;
class DenmData;
struct DenmDataDefaultTypeInternal;
extern DenmDataDefaultTypeInternal _DenmData_default_instance_;
class DetectorArea;
struct DetectorAreaDefaultTypeInternal;
extern DetectorAreaDefaultTypeInternal _DetectorArea_default_instance_;
class DriveBehavior;
struct DriveBehaviorDefaultTypeInternal;
extern DriveBehaviorDefaultTypeInternal _DriveBehavior_default_instance_;
class DriveRequest;
struct DriveRequestDefaultTypeInternal;
extern DriveRequestDefaultTypeInternal _DriveRequest_default_instance_;
class DriveSuggestion;
struct DriveSuggestionDefaultTypeInternal;
extern DriveSuggestionDefaultTypeInternal _DriveSuggestion_default_instance_;
class IarData;
struct IarDataDefaultTypeInternal;
extern IarDataDefaultTypeInternal _IarData_default_instance_;
class IntersectionState;
struct IntersectionStateDefaultTypeInternal;
extern IntersectionStateDefaultTypeInternal _IntersectionState_default_instance_;
class Lane;
struct LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneAttributes;
struct LaneAttributesDefaultTypeInternal;
extern LaneAttributesDefaultTypeInternal _LaneAttributes_default_instance_;
class LaneAttributesBarrier;
struct LaneAttributesBarrierDefaultTypeInternal;
extern LaneAttributesBarrierDefaultTypeInternal _LaneAttributesBarrier_default_instance_;
class LaneAttributesBike;
struct LaneAttributesBikeDefaultTypeInternal;
extern LaneAttributesBikeDefaultTypeInternal _LaneAttributesBike_default_instance_;
class LaneAttributesCrosswalk;
struct LaneAttributesCrosswalkDefaultTypeInternal;
extern LaneAttributesCrosswalkDefaultTypeInternal _LaneAttributesCrosswalk_default_instance_;
class LaneAttributesParking;
struct LaneAttributesParkingDefaultTypeInternal;
extern LaneAttributesParkingDefaultTypeInternal _LaneAttributesParking_default_instance_;
class LaneAttributesSidewalk;
struct LaneAttributesSidewalkDefaultTypeInternal;
extern LaneAttributesSidewalkDefaultTypeInternal _LaneAttributesSidewalk_default_instance_;
class LaneAttributesStriping;
struct LaneAttributesStripingDefaultTypeInternal;
extern LaneAttributesStripingDefaultTypeInternal _LaneAttributesStriping_default_instance_;
class LaneAttributesTrackedVehicle;
struct LaneAttributesTrackedVehicleDefaultTypeInternal;
extern LaneAttributesTrackedVehicleDefaultTypeInternal _LaneAttributesTrackedVehicle_default_instance_;
class LaneAttributesVehicle;
struct LaneAttributesVehicleDefaultTypeInternal;
extern LaneAttributesVehicleDefaultTypeInternal _LaneAttributesVehicle_default_instance_;
class LaneBoundary;
struct LaneBoundaryDefaultTypeInternal;
extern LaneBoundaryDefaultTypeInternal _LaneBoundary_default_instance_;
class LaneCoordination;
struct LaneCoordinationDefaultTypeInternal;
extern LaneCoordinationDefaultTypeInternal _LaneCoordination_default_instance_;
class LaneEx;
struct LaneExDefaultTypeInternal;
extern LaneExDefaultTypeInternal _LaneEx_default_instance_;
class LaneIndexAdded;
struct LaneIndexAddedDefaultTypeInternal;
extern LaneIndexAddedDefaultTypeInternal _LaneIndexAdded_default_instance_;
class LaneSharing;
struct LaneSharingDefaultTypeInternal;
extern LaneSharingDefaultTypeInternal _LaneSharing_default_instance_;
class LaneStatInfo;
struct LaneStatInfoDefaultTypeInternal;
extern LaneStatInfoDefaultTypeInternal _LaneStatInfo_default_instance_;
class LaneType;
struct LaneTypeDefaultTypeInternal;
extern LaneTypeDefaultTypeInternal _LaneType_default_instance_;
class LaneTypeAttributes;
struct LaneTypeAttributesDefaultTypeInternal;
extern LaneTypeAttributesDefaultTypeInternal _LaneTypeAttributes_default_instance_;
class Link;
struct LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class LinkEx;
struct LinkExDefaultTypeInternal;
extern LinkExDefaultTypeInternal _LinkEx_default_instance_;
class LinkIndexAdded;
struct LinkIndexAddedDefaultTypeInternal;
extern LinkIndexAddedDefaultTypeInternal _LinkIndexAdded_default_instance_;
class LinkStatInfo;
struct LinkStatInfoDefaultTypeInternal;
extern LinkStatInfoDefaultTypeInternal _LinkStatInfo_default_instance_;
class LocalTimePoint;
struct LocalTimePointDefaultTypeInternal;
extern LocalTimePointDefaultTypeInternal _LocalTimePoint_default_instance_;
class MAP;
struct MAPDefaultTypeInternal;
extern MAPDefaultTypeInternal _MAP_default_instance_;
class MapData;
struct MapDataDefaultTypeInternal;
extern MapDataDefaultTypeInternal _MapData_default_instance_;
class MapLocation;
struct MapLocationDefaultTypeInternal;
extern MapLocationDefaultTypeInternal _MapLocation_default_instance_;
class MonitorStatsData;
struct MonitorStatsDataDefaultTypeInternal;
extern MonitorStatsDataDefaultTypeInternal _MonitorStatsData_default_instance_;
class MotionConfidenceSet;
struct MotionConfidenceSetDefaultTypeInternal;
extern MotionConfidenceSetDefaultTypeInternal _MotionConfidenceSet_default_instance_;
class Movement;
struct MovementDefaultTypeInternal;
extern MovementDefaultTypeInternal _Movement_default_instance_;
class MovementEx;
struct MovementExDefaultTypeInternal;
extern MovementExDefaultTypeInternal _MovementEx_default_instance_;
class MovementIndexAdded;
struct MovementIndexAddedDefaultTypeInternal;
extern MovementIndexAddedDefaultTypeInternal _MovementIndexAdded_default_instance_;
class MovementStatInfo;
struct MovementStatInfoDefaultTypeInternal;
extern MovementStatInfoDefaultTypeInternal _MovementStatInfo_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class NodeIndexAdded;
struct NodeIndexAddedDefaultTypeInternal;
extern NodeIndexAddedDefaultTypeInternal _NodeIndexAdded_default_instance_;
class NodeReferenceId;
struct NodeReferenceIdDefaultTypeInternal;
extern NodeReferenceIdDefaultTypeInternal _NodeReferenceId_default_instance_;
class NodeStatInfo;
struct NodeStatInfoDefaultTypeInternal;
extern NodeStatInfoDefaultTypeInternal _NodeStatInfo_default_instance_;
class ObjIdValue;
struct ObjIdValueDefaultTypeInternal;
extern ObjIdValueDefaultTypeInternal _ObjIdValue_default_instance_;
class ObstacleData;
struct ObstacleDataDefaultTypeInternal;
extern ObstacleDataDefaultTypeInternal _ObstacleData_default_instance_;
class OptimData;
struct OptimDataDefaultTypeInternal;
extern OptimDataDefaultTypeInternal _OptimData_default_instance_;
class OptimPhase;
struct OptimPhaseDefaultTypeInternal;
extern OptimPhaseDefaultTypeInternal _OptimPhase_default_instance_;
class OptimTimeType;
struct OptimTimeTypeDefaultTypeInternal;
extern OptimTimeTypeDefaultTypeInternal _OptimTimeType_default_instance_;
class ParkingRequest;
struct ParkingRequestDefaultTypeInternal;
extern ParkingRequestDefaultTypeInternal _ParkingRequest_default_instance_;
class ParkingType;
struct ParkingTypeDefaultTypeInternal;
extern ParkingTypeDefaultTypeInternal _ParkingType_default_instance_;
class ParticipantData;
struct ParticipantDataDefaultTypeInternal;
extern ParticipantDataDefaultTypeInternal _ParticipantData_default_instance_;
class ParticipantSize;
struct ParticipantSizeDefaultTypeInternal;
extern ParticipantSizeDefaultTypeInternal _ParticipantSize_default_instance_;
class ParticipantSizeConfidence;
struct ParticipantSizeConfidenceDefaultTypeInternal;
extern ParticipantSizeConfidenceDefaultTypeInternal _ParticipantSizeConfidence_default_instance_;
class PathHistoryPoint;
struct PathHistoryPointDefaultTypeInternal;
extern PathHistoryPointDefaultTypeInternal _PathHistoryPoint_default_instance_;
class PathPlanning;
struct PathPlanningDefaultTypeInternal;
extern PathPlanningDefaultTypeInternal _PathPlanning_default_instance_;
class PathPlanningPoint;
struct PathPlanningPointDefaultTypeInternal;
extern PathPlanningPointDefaultTypeInternal _PathPlanningPoint_default_instance_;
class PeriodictimeSpan;
struct PeriodictimeSpanDefaultTypeInternal;
extern PeriodictimeSpanDefaultTypeInternal _PeriodictimeSpan_default_instance_;
class Phase;
struct PhaseDefaultTypeInternal;
extern PhaseDefaultTypeInternal _Phase_default_instance_;
class PhaseId;
struct PhaseIdDefaultTypeInternal;
extern PhaseIdDefaultTypeInternal _PhaseId_default_instance_;
class PhaseState;
struct PhaseStateDefaultTypeInternal;
extern PhaseStateDefaultTypeInternal _PhaseState_default_instance_;
class Polygon;
struct PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Position3D;
struct Position3DDefaultTypeInternal;
extern Position3DDefaultTypeInternal _Position3D_default_instance_;
class PositionAccuracy;
struct PositionAccuracyDefaultTypeInternal;
extern PositionAccuracyDefaultTypeInternal _PositionAccuracy_default_instance_;
class PositionConfidenceSet;
struct PositionConfidenceSetDefaultTypeInternal;
extern PositionConfidenceSetDefaultTypeInternal _PositionConfidenceSet_default_instance_;
class ProhibitedZone;
struct ProhibitedZoneDefaultTypeInternal;
extern ProhibitedZoneDefaultTypeInternal _ProhibitedZone_default_instance_;
class ReferenceLanes;
struct ReferenceLanesDefaultTypeInternal;
extern ReferenceLanesDefaultTypeInternal _ReferenceLanes_default_instance_;
class ReferenceLink;
struct ReferenceLinkDefaultTypeInternal;
extern ReferenceLinkDefaultTypeInternal _ReferenceLink_default_instance_;
class ReferencePath;
struct ReferencePathDefaultTypeInternal;
extern ReferencePathDefaultTypeInternal _ReferencePath_default_instance_;
class RegulatorySpeedLimit;
struct RegulatorySpeedLimitDefaultTypeInternal;
extern RegulatorySpeedLimitDefaultTypeInternal _RegulatorySpeedLimit_default_instance_;
class ReqClearTheWay;
struct ReqClearTheWayDefaultTypeInternal;
extern ReqClearTheWayDefaultTypeInternal _ReqClearTheWay_default_instance_;
class ReqInfo;
struct ReqInfoDefaultTypeInternal;
extern ReqInfoDefaultTypeInternal _ReqInfo_default_instance_;
class ReqLaneChange;
struct ReqLaneChangeDefaultTypeInternal;
extern ReqLaneChangeDefaultTypeInternal _ReqLaneChange_default_instance_;
class ReqParkingArea;
struct ReqParkingAreaDefaultTypeInternal;
extern ReqParkingAreaDefaultTypeInternal _ReqParkingArea_default_instance_;
class ReqSensorSharing;
struct ReqSensorSharingDefaultTypeInternal;
extern ReqSensorSharingDefaultTypeInternal _ReqSensorSharing_default_instance_;
class ReqSignalPriority;
struct ReqSignalPriorityDefaultTypeInternal;
extern ReqSignalPriorityDefaultTypeInternal _ReqSignalPriority_default_instance_;
class RscData;
struct RscDataDefaultTypeInternal;
extern RscDataDefaultTypeInternal _RscData_default_instance_;
class RsiReply;
struct RsiReplyDefaultTypeInternal;
extern RsiReplyDefaultTypeInternal _RsiReply_default_instance_;
class RsiTimeDetails;
struct RsiTimeDetailsDefaultTypeInternal;
extern RsiTimeDetailsDefaultTypeInternal _RsiTimeDetails_default_instance_;
class RsmReply;
struct RsmReplyDefaultTypeInternal;
extern RsmReplyDefaultTypeInternal _RsmReply_default_instance_;
class RsuRsmReply;
struct RsuRsmReplyDefaultTypeInternal;
extern RsuRsmReplyDefaultTypeInternal _RsuRsmReply_default_instance_;
class RteData;
struct RteDataDefaultTypeInternal;
extern RteDataDefaultTypeInternal _RteData_default_instance_;
class RtsData;
struct RtsDataDefaultTypeInternal;
extern RtsDataDefaultTypeInternal _RtsData_default_instance_;
class STPoint;
struct STPointDefaultTypeInternal;
extern STPointDefaultTypeInternal _STPoint_default_instance_;
class Section;
struct SectionDefaultTypeInternal;
extern SectionDefaultTypeInternal _Section_default_instance_;
class SectionStatInfo;
struct SectionStatInfoDefaultTypeInternal;
extern SectionStatInfoDefaultTypeInternal _SectionStatInfo_default_instance_;
class SignalControlIndexAdded;
struct SignalControlIndexAddedDefaultTypeInternal;
extern SignalControlIndexAddedDefaultTypeInternal _SignalControlIndexAdded_default_instance_;
class SignalScheme;
struct SignalSchemeDefaultTypeInternal;
extern SignalSchemeDefaultTypeInternal _SignalScheme_default_instance_;
class SignalWaitingLane;
struct SignalWaitingLaneDefaultTypeInternal;
extern SignalWaitingLaneDefaultTypeInternal _SignalWaitingLane_default_instance_;
class SingleTimeSpan;
struct SingleTimeSpanDefaultTypeInternal;
extern SingleTimeSpanDefaultTypeInternal _SingleTimeSpan_default_instance_;
class SpatData;
struct SpatDataDefaultTypeInternal;
extern SpatDataDefaultTypeInternal _SpatData_default_instance_;
class StatusData;
struct StatusDataDefaultTypeInternal;
extern StatusDataDefaultTypeInternal _StatusData_default_instance_;
class ThrottleSystemStatus;
struct ThrottleSystemStatusDefaultTypeInternal;
extern ThrottleSystemStatusDefaultTypeInternal _ThrottleSystemStatus_default_instance_;
class TimeCountingDown;
struct TimeCountingDownDefaultTypeInternal;
extern TimeCountingDownDefaultTypeInternal _TimeCountingDown_default_instance_;
class TrafficFlow;
struct TrafficFlowDefaultTypeInternal;
extern TrafficFlowDefaultTypeInternal _TrafficFlow_default_instance_;
class TrafficFlowExtension;
struct TrafficFlowExtensionDefaultTypeInternal;
extern TrafficFlowExtensionDefaultTypeInternal _TrafficFlowExtension_default_instance_;
class TrafficFlowStat;
struct TrafficFlowStatDefaultTypeInternal;
extern TrafficFlowStatDefaultTypeInternal _TrafficFlowStat_default_instance_;
class TrafficFlowStatByInterval;
struct TrafficFlowStatByIntervalDefaultTypeInternal;
extern TrafficFlowStatByIntervalDefaultTypeInternal _TrafficFlowStatByInterval_default_instance_;
class TrafficFlowStatBySignalCycle;
struct TrafficFlowStatBySignalCycleDefaultTypeInternal;
extern TrafficFlowStatBySignalCycleDefaultTypeInternal _TrafficFlowStatBySignalCycle_default_instance_;
class TrafficFlowStatMapElement;
struct TrafficFlowStatMapElementDefaultTypeInternal;
extern TrafficFlowStatMapElementDefaultTypeInternal _TrafficFlowStatMapElement_default_instance_;
class TrafficFlowStatType;
struct TrafficFlowStatTypeDefaultTypeInternal;
extern TrafficFlowStatTypeDefaultTypeInternal _TrafficFlowStatType_default_instance_;
class VehicleCoordination;
struct VehicleCoordinationDefaultTypeInternal;
extern VehicleCoordinationDefaultTypeInternal _VehicleCoordination_default_instance_;
class VehicleSize;
struct VehicleSizeDefaultTypeInternal;
extern VehicleSizeDefaultTypeInternal _VehicleSize_default_instance_;
class VirData;
struct VirDataDefaultTypeInternal;
extern VirDataDefaultTypeInternal _VirData_default_instance_;
}  // namespace pb
}  // namespace v2x
}  // namespace seisys
}  // namespace cn
PROTOBUF_NAMESPACE_OPEN
template<> ::cn::seisys::v2x::pb::AccelerationConfidence* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::AccelerationConfidence>(Arena*);
template<> ::cn::seisys::v2x::pb::AccelerationSet4Way* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::AccelerationSet4Way>(Arena*);
template<> ::cn::seisys::v2x::pb::AllowedManeuvers* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::AllowedManeuvers>(Arena*);
template<> ::cn::seisys::v2x::pb::BrakeSystemStatus* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::BrakeSystemStatus>(Arena*);
template<> ::cn::seisys::v2x::pb::BsmData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::BsmData>(Arena*);
template<> ::cn::seisys::v2x::pb::CamData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::CamData>(Arena*);
template<> ::cn::seisys::v2x::pb::ConnectingLane* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ConnectingLane>(Arena*);
template<> ::cn::seisys::v2x::pb::ConnectingLaneEx* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ConnectingLaneEx>(Arena*);
template<> ::cn::seisys::v2x::pb::Connection* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::Connection>(Arena*);
template<> ::cn::seisys::v2x::pb::ConnectionEx* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ConnectionEx>(Arena*);
template<> ::cn::seisys::v2x::pb::CoordinationInfo* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::CoordinationInfo>(Arena*);
template<> ::cn::seisys::v2x::pb::DenmData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::DenmData>(Arena*);
template<> ::cn::seisys::v2x::pb::DetectorArea* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::DetectorArea>(Arena*);
template<> ::cn::seisys::v2x::pb::DriveBehavior* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::DriveBehavior>(Arena*);
template<> ::cn::seisys::v2x::pb::DriveRequest* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::DriveRequest>(Arena*);
template<> ::cn::seisys::v2x::pb::DriveSuggestion* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::DriveSuggestion>(Arena*);
template<> ::cn::seisys::v2x::pb::IarData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::IarData>(Arena*);
template<> ::cn::seisys::v2x::pb::IntersectionState* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::IntersectionState>(Arena*);
template<> ::cn::seisys::v2x::pb::Lane* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::Lane>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneAttributes* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributes>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneAttributesBarrier* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributesBarrier>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneAttributesBike* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributesBike>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributesCrosswalk>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneAttributesParking* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributesParking>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneAttributesSidewalk* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributesSidewalk>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneAttributesStriping* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributesStriping>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneAttributesVehicle* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributesVehicle>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneBoundary* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneBoundary>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneCoordination* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneCoordination>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneEx* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneEx>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneIndexAdded* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneIndexAdded>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneSharing* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneSharing>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneStatInfo* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneStatInfo>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneType* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneType>(Arena*);
template<> ::cn::seisys::v2x::pb::LaneTypeAttributes* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LaneTypeAttributes>(Arena*);
template<> ::cn::seisys::v2x::pb::Link* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::Link>(Arena*);
template<> ::cn::seisys::v2x::pb::LinkEx* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LinkEx>(Arena*);
template<> ::cn::seisys::v2x::pb::LinkIndexAdded* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LinkIndexAdded>(Arena*);
template<> ::cn::seisys::v2x::pb::LinkStatInfo* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LinkStatInfo>(Arena*);
template<> ::cn::seisys::v2x::pb::LocalTimePoint* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::LocalTimePoint>(Arena*);
template<> ::cn::seisys::v2x::pb::MAP* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::MAP>(Arena*);
template<> ::cn::seisys::v2x::pb::MapData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::MapData>(Arena*);
template<> ::cn::seisys::v2x::pb::MapLocation* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::MapLocation>(Arena*);
template<> ::cn::seisys::v2x::pb::MonitorStatsData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::MonitorStatsData>(Arena*);
template<> ::cn::seisys::v2x::pb::MotionConfidenceSet* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::MotionConfidenceSet>(Arena*);
template<> ::cn::seisys::v2x::pb::Movement* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::Movement>(Arena*);
template<> ::cn::seisys::v2x::pb::MovementEx* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::MovementEx>(Arena*);
template<> ::cn::seisys::v2x::pb::MovementIndexAdded* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::MovementIndexAdded>(Arena*);
template<> ::cn::seisys::v2x::pb::MovementStatInfo* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::MovementStatInfo>(Arena*);
template<> ::cn::seisys::v2x::pb::Node* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::Node>(Arena*);
template<> ::cn::seisys::v2x::pb::NodeIndexAdded* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::NodeIndexAdded>(Arena*);
template<> ::cn::seisys::v2x::pb::NodeReferenceId* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(Arena*);
template<> ::cn::seisys::v2x::pb::NodeStatInfo* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::NodeStatInfo>(Arena*);
template<> ::cn::seisys::v2x::pb::ObjIdValue* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ObjIdValue>(Arena*);
template<> ::cn::seisys::v2x::pb::ObstacleData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ObstacleData>(Arena*);
template<> ::cn::seisys::v2x::pb::OptimData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::OptimData>(Arena*);
template<> ::cn::seisys::v2x::pb::OptimPhase* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::OptimPhase>(Arena*);
template<> ::cn::seisys::v2x::pb::OptimTimeType* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::OptimTimeType>(Arena*);
template<> ::cn::seisys::v2x::pb::ParkingRequest* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ParkingRequest>(Arena*);
template<> ::cn::seisys::v2x::pb::ParkingType* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ParkingType>(Arena*);
template<> ::cn::seisys::v2x::pb::ParticipantData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ParticipantData>(Arena*);
template<> ::cn::seisys::v2x::pb::ParticipantSize* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ParticipantSize>(Arena*);
template<> ::cn::seisys::v2x::pb::ParticipantSizeConfidence* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ParticipantSizeConfidence>(Arena*);
template<> ::cn::seisys::v2x::pb::PathHistoryPoint* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::PathHistoryPoint>(Arena*);
template<> ::cn::seisys::v2x::pb::PathPlanning* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::PathPlanning>(Arena*);
template<> ::cn::seisys::v2x::pb::PathPlanningPoint* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::PathPlanningPoint>(Arena*);
template<> ::cn::seisys::v2x::pb::PeriodictimeSpan* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::PeriodictimeSpan>(Arena*);
template<> ::cn::seisys::v2x::pb::Phase* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::Phase>(Arena*);
template<> ::cn::seisys::v2x::pb::PhaseId* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::PhaseId>(Arena*);
template<> ::cn::seisys::v2x::pb::PhaseState* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::PhaseState>(Arena*);
template<> ::cn::seisys::v2x::pb::Polygon* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::Polygon>(Arena*);
template<> ::cn::seisys::v2x::pb::Position3D* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(Arena*);
template<> ::cn::seisys::v2x::pb::PositionAccuracy* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::PositionAccuracy>(Arena*);
template<> ::cn::seisys::v2x::pb::PositionConfidenceSet* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::PositionConfidenceSet>(Arena*);
template<> ::cn::seisys::v2x::pb::ProhibitedZone* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ProhibitedZone>(Arena*);
template<> ::cn::seisys::v2x::pb::ReferenceLanes* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ReferenceLanes>(Arena*);
template<> ::cn::seisys::v2x::pb::ReferenceLink* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ReferenceLink>(Arena*);
template<> ::cn::seisys::v2x::pb::ReferencePath* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ReferencePath>(Arena*);
template<> ::cn::seisys::v2x::pb::RegulatorySpeedLimit* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::RegulatorySpeedLimit>(Arena*);
template<> ::cn::seisys::v2x::pb::ReqClearTheWay* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ReqClearTheWay>(Arena*);
template<> ::cn::seisys::v2x::pb::ReqInfo* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ReqInfo>(Arena*);
template<> ::cn::seisys::v2x::pb::ReqLaneChange* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ReqLaneChange>(Arena*);
template<> ::cn::seisys::v2x::pb::ReqParkingArea* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ReqParkingArea>(Arena*);
template<> ::cn::seisys::v2x::pb::ReqSensorSharing* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ReqSensorSharing>(Arena*);
template<> ::cn::seisys::v2x::pb::ReqSignalPriority* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ReqSignalPriority>(Arena*);
template<> ::cn::seisys::v2x::pb::RscData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::RscData>(Arena*);
template<> ::cn::seisys::v2x::pb::RsiReply* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::RsiReply>(Arena*);
template<> ::cn::seisys::v2x::pb::RsiTimeDetails* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::RsiTimeDetails>(Arena*);
template<> ::cn::seisys::v2x::pb::RsmReply* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::RsmReply>(Arena*);
template<> ::cn::seisys::v2x::pb::RsuRsmReply* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::RsuRsmReply>(Arena*);
template<> ::cn::seisys::v2x::pb::RteData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::RteData>(Arena*);
template<> ::cn::seisys::v2x::pb::RtsData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::RtsData>(Arena*);
template<> ::cn::seisys::v2x::pb::STPoint* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::STPoint>(Arena*);
template<> ::cn::seisys::v2x::pb::Section* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::Section>(Arena*);
template<> ::cn::seisys::v2x::pb::SectionStatInfo* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::SectionStatInfo>(Arena*);
template<> ::cn::seisys::v2x::pb::SignalControlIndexAdded* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::SignalControlIndexAdded>(Arena*);
template<> ::cn::seisys::v2x::pb::SignalScheme* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::SignalScheme>(Arena*);
template<> ::cn::seisys::v2x::pb::SignalWaitingLane* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::SignalWaitingLane>(Arena*);
template<> ::cn::seisys::v2x::pb::SingleTimeSpan* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::SingleTimeSpan>(Arena*);
template<> ::cn::seisys::v2x::pb::SpatData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::SpatData>(Arena*);
template<> ::cn::seisys::v2x::pb::StatusData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::StatusData>(Arena*);
template<> ::cn::seisys::v2x::pb::ThrottleSystemStatus* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::ThrottleSystemStatus>(Arena*);
template<> ::cn::seisys::v2x::pb::TimeCountingDown* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::TimeCountingDown>(Arena*);
template<> ::cn::seisys::v2x::pb::TrafficFlow* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlow>(Arena*);
template<> ::cn::seisys::v2x::pb::TrafficFlowExtension* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowExtension>(Arena*);
template<> ::cn::seisys::v2x::pb::TrafficFlowStat* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowStat>(Arena*);
template<> ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowStatByInterval>(Arena*);
template<> ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle>(Arena*);
template<> ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowStatMapElement>(Arena*);
template<> ::cn::seisys::v2x::pb::TrafficFlowStatType* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowStatType>(Arena*);
template<> ::cn::seisys::v2x::pb::VehicleCoordination* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::VehicleCoordination>(Arena*);
template<> ::cn::seisys::v2x::pb::VehicleSize* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::VehicleSize>(Arena*);
template<> ::cn::seisys::v2x::pb::VirData* Arena::CreateMaybeMessage<::cn::seisys::v2x::pb::VirData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cn {
namespace seisys {
namespace v2x {
namespace pb {

enum PositionConfidenceSet_PositionConfidence : int {
  PositionConfidenceSet_PositionConfidence_UNAVAILABLE_POS_CONFID = 0,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_500M = 1,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_200M = 2,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_100M = 3,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_50M = 4,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_20M = 5,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_10M = 6,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_5M = 7,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_2M = 8,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_1M = 9,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_50CM = 10,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_20CM = 11,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_10CM = 12,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_5CM = 13,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_2CM = 14,
  PositionConfidenceSet_PositionConfidence_POS_CONFID_1CM = 15,
  PositionConfidenceSet_PositionConfidence_PositionConfidenceSet_PositionConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PositionConfidenceSet_PositionConfidence_PositionConfidenceSet_PositionConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PositionConfidenceSet_PositionConfidence_IsValid(int value);
constexpr PositionConfidenceSet_PositionConfidence PositionConfidenceSet_PositionConfidence_PositionConfidence_MIN = PositionConfidenceSet_PositionConfidence_UNAVAILABLE_POS_CONFID;
constexpr PositionConfidenceSet_PositionConfidence PositionConfidenceSet_PositionConfidence_PositionConfidence_MAX = PositionConfidenceSet_PositionConfidence_POS_CONFID_1CM;
constexpr int PositionConfidenceSet_PositionConfidence_PositionConfidence_ARRAYSIZE = PositionConfidenceSet_PositionConfidence_PositionConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PositionConfidenceSet_PositionConfidence_descriptor();
template<typename T>
inline const std::string& PositionConfidenceSet_PositionConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PositionConfidenceSet_PositionConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PositionConfidenceSet_PositionConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PositionConfidenceSet_PositionConfidence_descriptor(), enum_t_value);
}
inline bool PositionConfidenceSet_PositionConfidence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PositionConfidenceSet_PositionConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PositionConfidenceSet_PositionConfidence>(
    PositionConfidenceSet_PositionConfidence_descriptor(), name, value);
}
enum PositionConfidenceSet_ElevationConfidence : int {
  PositionConfidenceSet_ElevationConfidence_UNAVAILABLE_ELE_CONFID = 0,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_500M = 1,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_200M = 2,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_100M = 3,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_50M = 4,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_20M = 5,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_10M = 6,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_5M = 7,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_2M = 8,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_1M = 9,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_50CM = 10,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_20CM = 11,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_10CM = 12,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_5CM = 13,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_2CM = 14,
  PositionConfidenceSet_ElevationConfidence_ELE_CONFID_1CM = 15,
  PositionConfidenceSet_ElevationConfidence_PositionConfidenceSet_ElevationConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PositionConfidenceSet_ElevationConfidence_PositionConfidenceSet_ElevationConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PositionConfidenceSet_ElevationConfidence_IsValid(int value);
constexpr PositionConfidenceSet_ElevationConfidence PositionConfidenceSet_ElevationConfidence_ElevationConfidence_MIN = PositionConfidenceSet_ElevationConfidence_UNAVAILABLE_ELE_CONFID;
constexpr PositionConfidenceSet_ElevationConfidence PositionConfidenceSet_ElevationConfidence_ElevationConfidence_MAX = PositionConfidenceSet_ElevationConfidence_ELE_CONFID_1CM;
constexpr int PositionConfidenceSet_ElevationConfidence_ElevationConfidence_ARRAYSIZE = PositionConfidenceSet_ElevationConfidence_ElevationConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PositionConfidenceSet_ElevationConfidence_descriptor();
template<typename T>
inline const std::string& PositionConfidenceSet_ElevationConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PositionConfidenceSet_ElevationConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PositionConfidenceSet_ElevationConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PositionConfidenceSet_ElevationConfidence_descriptor(), enum_t_value);
}
inline bool PositionConfidenceSet_ElevationConfidence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PositionConfidenceSet_ElevationConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PositionConfidenceSet_ElevationConfidence>(
    PositionConfidenceSet_ElevationConfidence_descriptor(), name, value);
}
enum ParticipantSizeConfidence_SizeValueConfidence : int {
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_UNAVAILABLE = 0,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_100_00 = 1,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_050_00 = 2,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_020_00 = 3,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_010_00 = 4,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_005_00 = 5,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_002_00 = 6,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_001_00 = 7,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_50 = 8,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_20 = 9,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_10 = 10,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_05 = 11,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_02 = 12,
  ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_01 = 13,
  ParticipantSizeConfidence_SizeValueConfidence_ParticipantSizeConfidence_SizeValueConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParticipantSizeConfidence_SizeValueConfidence_ParticipantSizeConfidence_SizeValueConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParticipantSizeConfidence_SizeValueConfidence_IsValid(int value);
constexpr ParticipantSizeConfidence_SizeValueConfidence ParticipantSizeConfidence_SizeValueConfidence_SizeValueConfidence_MIN = ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_UNAVAILABLE;
constexpr ParticipantSizeConfidence_SizeValueConfidence ParticipantSizeConfidence_SizeValueConfidence_SizeValueConfidence_MAX = ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_01;
constexpr int ParticipantSizeConfidence_SizeValueConfidence_SizeValueConfidence_ARRAYSIZE = ParticipantSizeConfidence_SizeValueConfidence_SizeValueConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParticipantSizeConfidence_SizeValueConfidence_descriptor();
template<typename T>
inline const std::string& ParticipantSizeConfidence_SizeValueConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParticipantSizeConfidence_SizeValueConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParticipantSizeConfidence_SizeValueConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParticipantSizeConfidence_SizeValueConfidence_descriptor(), enum_t_value);
}
inline bool ParticipantSizeConfidence_SizeValueConfidence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParticipantSizeConfidence_SizeValueConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParticipantSizeConfidence_SizeValueConfidence>(
    ParticipantSizeConfidence_SizeValueConfidence_descriptor(), name, value);
}
enum RegulatorySpeedLimit_SpeedLimitType : int {
  RegulatorySpeedLimit_SpeedLimitType_SPEED_LIMIT_UNKNOWN = 0,
  RegulatorySpeedLimit_SpeedLimitType_MAX_SPEED_IN_SCHOOL_ZONE = 1,
  RegulatorySpeedLimit_SpeedLimitType_MAX_SPEED_INSCHOOL_ZONE_WHEN_CHILDREN_ARE_PRESENT = 2,
  RegulatorySpeedLimit_SpeedLimitType_MAX_SPEED_INCONSTRUCTION_ZONE = 3,
  RegulatorySpeedLimit_SpeedLimitType_VEHICLE_MIN_SPEED = 4,
  RegulatorySpeedLimit_SpeedLimitType_VEHICLE_SPEED = 5,
  RegulatorySpeedLimit_SpeedLimitType_VEHICLE_NIGHT_MAX_SPEED = 6,
  RegulatorySpeedLimit_SpeedLimitType_TRUCK_MIN_SPEED = 7,
  RegulatorySpeedLimit_SpeedLimitType_TRUCK_MAX_SPEED = 8,
  RegulatorySpeedLimit_SpeedLimitType_TRUCK_NIGHT_MAX_SPEED = 9,
  RegulatorySpeedLimit_SpeedLimitType_VEHICLES_WITH_TRAILERS_MIN_SPEED = 10,
  RegulatorySpeedLimit_SpeedLimitType_VEHICLES_WITH_TRAILERS_MAX_SPEED = 11,
  RegulatorySpeedLimit_SpeedLimitType_VEHICLES_WITHTRAILERS_NIGHT_MAX_SPEED = 12,
  RegulatorySpeedLimit_SpeedLimitType_RegulatorySpeedLimit_SpeedLimitType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegulatorySpeedLimit_SpeedLimitType_RegulatorySpeedLimit_SpeedLimitType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegulatorySpeedLimit_SpeedLimitType_IsValid(int value);
constexpr RegulatorySpeedLimit_SpeedLimitType RegulatorySpeedLimit_SpeedLimitType_SpeedLimitType_MIN = RegulatorySpeedLimit_SpeedLimitType_SPEED_LIMIT_UNKNOWN;
constexpr RegulatorySpeedLimit_SpeedLimitType RegulatorySpeedLimit_SpeedLimitType_SpeedLimitType_MAX = RegulatorySpeedLimit_SpeedLimitType_VEHICLES_WITHTRAILERS_NIGHT_MAX_SPEED;
constexpr int RegulatorySpeedLimit_SpeedLimitType_SpeedLimitType_ARRAYSIZE = RegulatorySpeedLimit_SpeedLimitType_SpeedLimitType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegulatorySpeedLimit_SpeedLimitType_descriptor();
template<typename T>
inline const std::string& RegulatorySpeedLimit_SpeedLimitType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegulatorySpeedLimit_SpeedLimitType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegulatorySpeedLimit_SpeedLimitType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegulatorySpeedLimit_SpeedLimitType_descriptor(), enum_t_value);
}
inline bool RegulatorySpeedLimit_SpeedLimitType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegulatorySpeedLimit_SpeedLimitType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegulatorySpeedLimit_SpeedLimitType>(
    RegulatorySpeedLimit_SpeedLimitType_descriptor(), name, value);
}
enum AccelerationConfidence_AccConfidence : int {
  AccelerationConfidence_AccConfidence_ACC_CONFID_UNAVAILABLE = 0,
  AccelerationConfidence_AccConfidence_ACC_CONFID_PREC100DE = 1,
  AccelerationConfidence_AccConfidence_ACC_CONFID_PREC10DEG = 2,
  AccelerationConfidence_AccConfidence_ACC_CONFID_PREC5DEG = 3,
  AccelerationConfidence_AccConfidence_ACC_CONFID_PREC1DEG = 4,
  AccelerationConfidence_AccConfidence_ACC_CONFID_PREC0_1DEG = 5,
  AccelerationConfidence_AccConfidence_ACC_CONFID_PREC0_05DEG = 6,
  AccelerationConfidence_AccConfidence_ACC_CONFID_PREC0_01DEG = 7,
  AccelerationConfidence_AccConfidence_AccelerationConfidence_AccConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AccelerationConfidence_AccConfidence_AccelerationConfidence_AccConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AccelerationConfidence_AccConfidence_IsValid(int value);
constexpr AccelerationConfidence_AccConfidence AccelerationConfidence_AccConfidence_AccConfidence_MIN = AccelerationConfidence_AccConfidence_ACC_CONFID_UNAVAILABLE;
constexpr AccelerationConfidence_AccConfidence AccelerationConfidence_AccConfidence_AccConfidence_MAX = AccelerationConfidence_AccConfidence_ACC_CONFID_PREC0_01DEG;
constexpr int AccelerationConfidence_AccConfidence_AccConfidence_ARRAYSIZE = AccelerationConfidence_AccConfidence_AccConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccelerationConfidence_AccConfidence_descriptor();
template<typename T>
inline const std::string& AccelerationConfidence_AccConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccelerationConfidence_AccConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccelerationConfidence_AccConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccelerationConfidence_AccConfidence_descriptor(), enum_t_value);
}
inline bool AccelerationConfidence_AccConfidence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccelerationConfidence_AccConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccelerationConfidence_AccConfidence>(
    AccelerationConfidence_AccConfidence_descriptor(), name, value);
}
enum AccelerationConfidence_AngularVConfidence : int {
  AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_UNAVAILABLE = 0,
  AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC100DEG = 1,
  AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC10DEG = 2,
  AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC5DEG = 3,
  AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC1DEG = 4,
  AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC0_1DEG = 5,
  AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC0_05DEG = 6,
  AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC0_01DEG = 7,
  AccelerationConfidence_AngularVConfidence_AccelerationConfidence_AngularVConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AccelerationConfidence_AngularVConfidence_AccelerationConfidence_AngularVConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AccelerationConfidence_AngularVConfidence_IsValid(int value);
constexpr AccelerationConfidence_AngularVConfidence AccelerationConfidence_AngularVConfidence_AngularVConfidence_MIN = AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_UNAVAILABLE;
constexpr AccelerationConfidence_AngularVConfidence AccelerationConfidence_AngularVConfidence_AngularVConfidence_MAX = AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC0_01DEG;
constexpr int AccelerationConfidence_AngularVConfidence_AngularVConfidence_ARRAYSIZE = AccelerationConfidence_AngularVConfidence_AngularVConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccelerationConfidence_AngularVConfidence_descriptor();
template<typename T>
inline const std::string& AccelerationConfidence_AngularVConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccelerationConfidence_AngularVConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccelerationConfidence_AngularVConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccelerationConfidence_AngularVConfidence_descriptor(), enum_t_value);
}
inline bool AccelerationConfidence_AngularVConfidence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccelerationConfidence_AngularVConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccelerationConfidence_AngularVConfidence>(
    AccelerationConfidence_AngularVConfidence_descriptor(), name, value);
}
enum MotionConfidenceSet_SteeringWheelAngleConfidence : int {
  MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_UNAVAILABLE = 0,
  MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_PREC2DEG = 1,
  MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_PREC1DEG = 2,
  MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_PREC0_02DEG = 3,
  MotionConfidenceSet_SteeringWheelAngleConfidence_MotionConfidenceSet_SteeringWheelAngleConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MotionConfidenceSet_SteeringWheelAngleConfidence_MotionConfidenceSet_SteeringWheelAngleConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MotionConfidenceSet_SteeringWheelAngleConfidence_IsValid(int value);
constexpr MotionConfidenceSet_SteeringWheelAngleConfidence MotionConfidenceSet_SteeringWheelAngleConfidence_SteeringWheelAngleConfidence_MIN = MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_UNAVAILABLE;
constexpr MotionConfidenceSet_SteeringWheelAngleConfidence MotionConfidenceSet_SteeringWheelAngleConfidence_SteeringWheelAngleConfidence_MAX = MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_PREC0_02DEG;
constexpr int MotionConfidenceSet_SteeringWheelAngleConfidence_SteeringWheelAngleConfidence_ARRAYSIZE = MotionConfidenceSet_SteeringWheelAngleConfidence_SteeringWheelAngleConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionConfidenceSet_SteeringWheelAngleConfidence_descriptor();
template<typename T>
inline const std::string& MotionConfidenceSet_SteeringWheelAngleConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionConfidenceSet_SteeringWheelAngleConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionConfidenceSet_SteeringWheelAngleConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionConfidenceSet_SteeringWheelAngleConfidence_descriptor(), enum_t_value);
}
inline bool MotionConfidenceSet_SteeringWheelAngleConfidence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionConfidenceSet_SteeringWheelAngleConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionConfidenceSet_SteeringWheelAngleConfidence>(
    MotionConfidenceSet_SteeringWheelAngleConfidence_descriptor(), name, value);
}
enum PhaseState_LightState : int {
  PhaseState_LightState_LIGHT_STATE_UNKNOWN = 0,
  PhaseState_LightState_LIGHT_STATE_DARK = 1,
  PhaseState_LightState_LIGHT_STATE_FLASHING_RED = 2,
  PhaseState_LightState_LIGHT_STATE_RED = 3,
  PhaseState_LightState_LIGHT_STATE_FLASHING_GREEN = 4,
  PhaseState_LightState_LIGHT_STATE_PERMISSIVE_GREEN = 5,
  PhaseState_LightState_LIGHT_STATE_PROTETED_GREEN = 6,
  PhaseState_LightState_LIGHT_STATE_YELLOW = 7,
  PhaseState_LightState_LIGHT_STATE_FLASHING_YELLOW = 8,
  PhaseState_LightState_PhaseState_LightState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PhaseState_LightState_PhaseState_LightState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PhaseState_LightState_IsValid(int value);
constexpr PhaseState_LightState PhaseState_LightState_LightState_MIN = PhaseState_LightState_LIGHT_STATE_UNKNOWN;
constexpr PhaseState_LightState PhaseState_LightState_LightState_MAX = PhaseState_LightState_LIGHT_STATE_FLASHING_YELLOW;
constexpr int PhaseState_LightState_LightState_ARRAYSIZE = PhaseState_LightState_LightState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PhaseState_LightState_descriptor();
template<typename T>
inline const std::string& PhaseState_LightState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PhaseState_LightState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PhaseState_LightState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PhaseState_LightState_descriptor(), enum_t_value);
}
inline bool PhaseState_LightState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PhaseState_LightState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhaseState_LightState>(
    PhaseState_LightState_descriptor(), name, value);
}
enum BrakeSystemStatus_BrakePedalStatus : int {
  BrakeSystemStatus_BrakePedalStatus_UNAVAILABLE_PEDAL = 0,
  BrakeSystemStatus_BrakePedalStatus_OFF_PEDAL = 1,
  BrakeSystemStatus_BrakePedalStatus_ON_PEDAL = 2,
  BrakeSystemStatus_BrakePedalStatus_BrakeSystemStatus_BrakePedalStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BrakeSystemStatus_BrakePedalStatus_BrakeSystemStatus_BrakePedalStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BrakeSystemStatus_BrakePedalStatus_IsValid(int value);
constexpr BrakeSystemStatus_BrakePedalStatus BrakeSystemStatus_BrakePedalStatus_BrakePedalStatus_MIN = BrakeSystemStatus_BrakePedalStatus_UNAVAILABLE_PEDAL;
constexpr BrakeSystemStatus_BrakePedalStatus BrakeSystemStatus_BrakePedalStatus_BrakePedalStatus_MAX = BrakeSystemStatus_BrakePedalStatus_ON_PEDAL;
constexpr int BrakeSystemStatus_BrakePedalStatus_BrakePedalStatus_ARRAYSIZE = BrakeSystemStatus_BrakePedalStatus_BrakePedalStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrakeSystemStatus_BrakePedalStatus_descriptor();
template<typename T>
inline const std::string& BrakeSystemStatus_BrakePedalStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrakeSystemStatus_BrakePedalStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrakeSystemStatus_BrakePedalStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrakeSystemStatus_BrakePedalStatus_descriptor(), enum_t_value);
}
inline bool BrakeSystemStatus_BrakePedalStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrakeSystemStatus_BrakePedalStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrakeSystemStatus_BrakePedalStatus>(
    BrakeSystemStatus_BrakePedalStatus_descriptor(), name, value);
}
enum BrakeSystemStatus_TractionControlStatus : int {
  BrakeSystemStatus_TractionControlStatus_UNAVAILABLE_TRACTION = 0,
  BrakeSystemStatus_TractionControlStatus_OFF_TRACTION = 1,
  BrakeSystemStatus_TractionControlStatus_ON_TRACTION = 2,
  BrakeSystemStatus_TractionControlStatus_ENGAGED_TRACTION = 3,
  BrakeSystemStatus_TractionControlStatus_BrakeSystemStatus_TractionControlStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BrakeSystemStatus_TractionControlStatus_BrakeSystemStatus_TractionControlStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BrakeSystemStatus_TractionControlStatus_IsValid(int value);
constexpr BrakeSystemStatus_TractionControlStatus BrakeSystemStatus_TractionControlStatus_TractionControlStatus_MIN = BrakeSystemStatus_TractionControlStatus_UNAVAILABLE_TRACTION;
constexpr BrakeSystemStatus_TractionControlStatus BrakeSystemStatus_TractionControlStatus_TractionControlStatus_MAX = BrakeSystemStatus_TractionControlStatus_ENGAGED_TRACTION;
constexpr int BrakeSystemStatus_TractionControlStatus_TractionControlStatus_ARRAYSIZE = BrakeSystemStatus_TractionControlStatus_TractionControlStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrakeSystemStatus_TractionControlStatus_descriptor();
template<typename T>
inline const std::string& BrakeSystemStatus_TractionControlStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrakeSystemStatus_TractionControlStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrakeSystemStatus_TractionControlStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrakeSystemStatus_TractionControlStatus_descriptor(), enum_t_value);
}
inline bool BrakeSystemStatus_TractionControlStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrakeSystemStatus_TractionControlStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrakeSystemStatus_TractionControlStatus>(
    BrakeSystemStatus_TractionControlStatus_descriptor(), name, value);
}
enum BrakeSystemStatus_AntiLockBrakeStatus : int {
  BrakeSystemStatus_AntiLockBrakeStatus_UNAVAILABLE_ABS = 0,
  BrakeSystemStatus_AntiLockBrakeStatus_OFF_ABS = 1,
  BrakeSystemStatus_AntiLockBrakeStatus_ON_ABS = 2,
  BrakeSystemStatus_AntiLockBrakeStatus_ENGAGED_ABS = 3,
  BrakeSystemStatus_AntiLockBrakeStatus_BrakeSystemStatus_AntiLockBrakeStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BrakeSystemStatus_AntiLockBrakeStatus_BrakeSystemStatus_AntiLockBrakeStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BrakeSystemStatus_AntiLockBrakeStatus_IsValid(int value);
constexpr BrakeSystemStatus_AntiLockBrakeStatus BrakeSystemStatus_AntiLockBrakeStatus_AntiLockBrakeStatus_MIN = BrakeSystemStatus_AntiLockBrakeStatus_UNAVAILABLE_ABS;
constexpr BrakeSystemStatus_AntiLockBrakeStatus BrakeSystemStatus_AntiLockBrakeStatus_AntiLockBrakeStatus_MAX = BrakeSystemStatus_AntiLockBrakeStatus_ENGAGED_ABS;
constexpr int BrakeSystemStatus_AntiLockBrakeStatus_AntiLockBrakeStatus_ARRAYSIZE = BrakeSystemStatus_AntiLockBrakeStatus_AntiLockBrakeStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrakeSystemStatus_AntiLockBrakeStatus_descriptor();
template<typename T>
inline const std::string& BrakeSystemStatus_AntiLockBrakeStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrakeSystemStatus_AntiLockBrakeStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrakeSystemStatus_AntiLockBrakeStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrakeSystemStatus_AntiLockBrakeStatus_descriptor(), enum_t_value);
}
inline bool BrakeSystemStatus_AntiLockBrakeStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrakeSystemStatus_AntiLockBrakeStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrakeSystemStatus_AntiLockBrakeStatus>(
    BrakeSystemStatus_AntiLockBrakeStatus_descriptor(), name, value);
}
enum BrakeSystemStatus_StabilityControlStatus : int {
  BrakeSystemStatus_StabilityControlStatus_UNAVAILABLE_SCS = 0,
  BrakeSystemStatus_StabilityControlStatus_OFF_SCS = 1,
  BrakeSystemStatus_StabilityControlStatus_ON_SCS = 2,
  BrakeSystemStatus_StabilityControlStatus_ENGAGED_SCS = 3,
  BrakeSystemStatus_StabilityControlStatus_BrakeSystemStatus_StabilityControlStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BrakeSystemStatus_StabilityControlStatus_BrakeSystemStatus_StabilityControlStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BrakeSystemStatus_StabilityControlStatus_IsValid(int value);
constexpr BrakeSystemStatus_StabilityControlStatus BrakeSystemStatus_StabilityControlStatus_StabilityControlStatus_MIN = BrakeSystemStatus_StabilityControlStatus_UNAVAILABLE_SCS;
constexpr BrakeSystemStatus_StabilityControlStatus BrakeSystemStatus_StabilityControlStatus_StabilityControlStatus_MAX = BrakeSystemStatus_StabilityControlStatus_ENGAGED_SCS;
constexpr int BrakeSystemStatus_StabilityControlStatus_StabilityControlStatus_ARRAYSIZE = BrakeSystemStatus_StabilityControlStatus_StabilityControlStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrakeSystemStatus_StabilityControlStatus_descriptor();
template<typename T>
inline const std::string& BrakeSystemStatus_StabilityControlStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrakeSystemStatus_StabilityControlStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrakeSystemStatus_StabilityControlStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrakeSystemStatus_StabilityControlStatus_descriptor(), enum_t_value);
}
inline bool BrakeSystemStatus_StabilityControlStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrakeSystemStatus_StabilityControlStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrakeSystemStatus_StabilityControlStatus>(
    BrakeSystemStatus_StabilityControlStatus_descriptor(), name, value);
}
enum BrakeSystemStatus_BrakeBoostApplied : int {
  BrakeSystemStatus_BrakeBoostApplied_UNAVAILABLE_BBA = 0,
  BrakeSystemStatus_BrakeBoostApplied_OFF_BBA = 1,
  BrakeSystemStatus_BrakeBoostApplied_ON_BBA = 2,
  BrakeSystemStatus_BrakeBoostApplied_BrakeSystemStatus_BrakeBoostApplied_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BrakeSystemStatus_BrakeBoostApplied_BrakeSystemStatus_BrakeBoostApplied_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BrakeSystemStatus_BrakeBoostApplied_IsValid(int value);
constexpr BrakeSystemStatus_BrakeBoostApplied BrakeSystemStatus_BrakeBoostApplied_BrakeBoostApplied_MIN = BrakeSystemStatus_BrakeBoostApplied_UNAVAILABLE_BBA;
constexpr BrakeSystemStatus_BrakeBoostApplied BrakeSystemStatus_BrakeBoostApplied_BrakeBoostApplied_MAX = BrakeSystemStatus_BrakeBoostApplied_ON_BBA;
constexpr int BrakeSystemStatus_BrakeBoostApplied_BrakeBoostApplied_ARRAYSIZE = BrakeSystemStatus_BrakeBoostApplied_BrakeBoostApplied_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrakeSystemStatus_BrakeBoostApplied_descriptor();
template<typename T>
inline const std::string& BrakeSystemStatus_BrakeBoostApplied_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrakeSystemStatus_BrakeBoostApplied>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrakeSystemStatus_BrakeBoostApplied_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrakeSystemStatus_BrakeBoostApplied_descriptor(), enum_t_value);
}
inline bool BrakeSystemStatus_BrakeBoostApplied_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrakeSystemStatus_BrakeBoostApplied* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrakeSystemStatus_BrakeBoostApplied>(
    BrakeSystemStatus_BrakeBoostApplied_descriptor(), name, value);
}
enum BrakeSystemStatus_AuxiliaryBrakeStatus : int {
  BrakeSystemStatus_AuxiliaryBrakeStatus_UNAVAILABLE_AUX = 0,
  BrakeSystemStatus_AuxiliaryBrakeStatus_OFF_AUX = 1,
  BrakeSystemStatus_AuxiliaryBrakeStatus_ON_AUX = 2,
  BrakeSystemStatus_AuxiliaryBrakeStatus_ENGAGED_AUX = 3,
  BrakeSystemStatus_AuxiliaryBrakeStatus_BrakeSystemStatus_AuxiliaryBrakeStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BrakeSystemStatus_AuxiliaryBrakeStatus_BrakeSystemStatus_AuxiliaryBrakeStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BrakeSystemStatus_AuxiliaryBrakeStatus_IsValid(int value);
constexpr BrakeSystemStatus_AuxiliaryBrakeStatus BrakeSystemStatus_AuxiliaryBrakeStatus_AuxiliaryBrakeStatus_MIN = BrakeSystemStatus_AuxiliaryBrakeStatus_UNAVAILABLE_AUX;
constexpr BrakeSystemStatus_AuxiliaryBrakeStatus BrakeSystemStatus_AuxiliaryBrakeStatus_AuxiliaryBrakeStatus_MAX = BrakeSystemStatus_AuxiliaryBrakeStatus_ENGAGED_AUX;
constexpr int BrakeSystemStatus_AuxiliaryBrakeStatus_AuxiliaryBrakeStatus_ARRAYSIZE = BrakeSystemStatus_AuxiliaryBrakeStatus_AuxiliaryBrakeStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrakeSystemStatus_AuxiliaryBrakeStatus_descriptor();
template<typename T>
inline const std::string& BrakeSystemStatus_AuxiliaryBrakeStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrakeSystemStatus_AuxiliaryBrakeStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrakeSystemStatus_AuxiliaryBrakeStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrakeSystemStatus_AuxiliaryBrakeStatus_descriptor(), enum_t_value);
}
inline bool BrakeSystemStatus_AuxiliaryBrakeStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrakeSystemStatus_AuxiliaryBrakeStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrakeSystemStatus_AuxiliaryBrakeStatus>(
    BrakeSystemStatus_AuxiliaryBrakeStatus_descriptor(), name, value);
}
enum ThrottleSystemStatus_ThrottlePedalStauts : int {
  ThrottleSystemStatus_ThrottlePedalStauts_UNAVAILABLE_PEDAL = 0,
  ThrottleSystemStatus_ThrottlePedalStauts_OFF = 1,
  ThrottleSystemStatus_ThrottlePedalStauts_ON = 2,
  ThrottleSystemStatus_ThrottlePedalStauts_ThrottleSystemStatus_ThrottlePedalStauts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ThrottleSystemStatus_ThrottlePedalStauts_ThrottleSystemStatus_ThrottlePedalStauts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ThrottleSystemStatus_ThrottlePedalStauts_IsValid(int value);
constexpr ThrottleSystemStatus_ThrottlePedalStauts ThrottleSystemStatus_ThrottlePedalStauts_ThrottlePedalStauts_MIN = ThrottleSystemStatus_ThrottlePedalStauts_UNAVAILABLE_PEDAL;
constexpr ThrottleSystemStatus_ThrottlePedalStauts ThrottleSystemStatus_ThrottlePedalStauts_ThrottlePedalStauts_MAX = ThrottleSystemStatus_ThrottlePedalStauts_ON;
constexpr int ThrottleSystemStatus_ThrottlePedalStauts_ThrottlePedalStauts_ARRAYSIZE = ThrottleSystemStatus_ThrottlePedalStauts_ThrottlePedalStauts_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThrottleSystemStatus_ThrottlePedalStauts_descriptor();
template<typename T>
inline const std::string& ThrottleSystemStatus_ThrottlePedalStauts_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThrottleSystemStatus_ThrottlePedalStauts>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThrottleSystemStatus_ThrottlePedalStauts_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThrottleSystemStatus_ThrottlePedalStauts_descriptor(), enum_t_value);
}
inline bool ThrottleSystemStatus_ThrottlePedalStauts_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThrottleSystemStatus_ThrottlePedalStauts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThrottleSystemStatus_ThrottlePedalStauts>(
    ThrottleSystemStatus_ThrottlePedalStauts_descriptor(), name, value);
}
enum BsmData_TransmissionState : int {
  BsmData_TransmissionState_TRANSMISSION_NEUTRAL = 0,
  BsmData_TransmissionState_TRANSMISSION_PARK = 1,
  BsmData_TransmissionState_TRANSMISSION_FORWARD_GEARS = 2,
  BsmData_TransmissionState_TRANSMISSION_REVERSE_GEARS = 3,
  BsmData_TransmissionState_TRANSMISSION_RESERVED1 = 4,
  BsmData_TransmissionState_TRANSMISSION_RESERVED2 = 5,
  BsmData_TransmissionState_TRANSMISSION_RESERVED3 = 6,
  BsmData_TransmissionState_TRANSMISSION_UNAVAILABLE = 7,
  BsmData_TransmissionState_BsmData_TransmissionState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BsmData_TransmissionState_BsmData_TransmissionState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BsmData_TransmissionState_IsValid(int value);
constexpr BsmData_TransmissionState BsmData_TransmissionState_TransmissionState_MIN = BsmData_TransmissionState_TRANSMISSION_NEUTRAL;
constexpr BsmData_TransmissionState BsmData_TransmissionState_TransmissionState_MAX = BsmData_TransmissionState_TRANSMISSION_UNAVAILABLE;
constexpr int BsmData_TransmissionState_TransmissionState_ARRAYSIZE = BsmData_TransmissionState_TransmissionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BsmData_TransmissionState_descriptor();
template<typename T>
inline const std::string& BsmData_TransmissionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BsmData_TransmissionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BsmData_TransmissionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BsmData_TransmissionState_descriptor(), enum_t_value);
}
inline bool BsmData_TransmissionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BsmData_TransmissionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BsmData_TransmissionState>(
    BsmData_TransmissionState_descriptor(), name, value);
}
enum BsmData_VehicleFuelType : int {
  BsmData_VehicleFuelType_VEHICLE_TUEL_UNKNOWNFUEL = 0,
  BsmData_VehicleFuelType_GASOLINE = 1,
  BsmData_VehicleFuelType_ETHANOL = 2,
  BsmData_VehicleFuelType_DIESEL = 3,
  BsmData_VehicleFuelType_ELECTRIC = 4,
  BsmData_VehicleFuelType_HYBRID = 5,
  BsmData_VehicleFuelType_HYDROGEN = 6,
  BsmData_VehicleFuelType_NATGASLIQUID = 7,
  BsmData_VehicleFuelType_NATGASCOMP = 8,
  BsmData_VehicleFuelType_PROPANE = 9,
  BsmData_VehicleFuelType_BsmData_VehicleFuelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BsmData_VehicleFuelType_BsmData_VehicleFuelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BsmData_VehicleFuelType_IsValid(int value);
constexpr BsmData_VehicleFuelType BsmData_VehicleFuelType_VehicleFuelType_MIN = BsmData_VehicleFuelType_VEHICLE_TUEL_UNKNOWNFUEL;
constexpr BsmData_VehicleFuelType BsmData_VehicleFuelType_VehicleFuelType_MAX = BsmData_VehicleFuelType_PROPANE;
constexpr int BsmData_VehicleFuelType_VehicleFuelType_ARRAYSIZE = BsmData_VehicleFuelType_VehicleFuelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BsmData_VehicleFuelType_descriptor();
template<typename T>
inline const std::string& BsmData_VehicleFuelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BsmData_VehicleFuelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BsmData_VehicleFuelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BsmData_VehicleFuelType_descriptor(), enum_t_value);
}
inline bool BsmData_VehicleFuelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BsmData_VehicleFuelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BsmData_VehicleFuelType>(
    BsmData_VehicleFuelType_descriptor(), name, value);
}
enum BsmData_DriveStatus : int {
  BsmData_DriveStatus_AUTOPILOT = 0,
  BsmData_DriveStatus_MANUAL = 1,
  BsmData_DriveStatus_SECURITY = 2,
  BsmData_DriveStatus_BsmData_DriveStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BsmData_DriveStatus_BsmData_DriveStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BsmData_DriveStatus_IsValid(int value);
constexpr BsmData_DriveStatus BsmData_DriveStatus_DriveStatus_MIN = BsmData_DriveStatus_AUTOPILOT;
constexpr BsmData_DriveStatus BsmData_DriveStatus_DriveStatus_MAX = BsmData_DriveStatus_SECURITY;
constexpr int BsmData_DriveStatus_DriveStatus_ARRAYSIZE = BsmData_DriveStatus_DriveStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BsmData_DriveStatus_descriptor();
template<typename T>
inline const std::string& BsmData_DriveStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BsmData_DriveStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BsmData_DriveStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BsmData_DriveStatus_descriptor(), enum_t_value);
}
inline bool BsmData_DriveStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BsmData_DriveStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BsmData_DriveStatus>(
    BsmData_DriveStatus_descriptor(), name, value);
}
enum BsmData_EmergenyStatus : int {
  BsmData_EmergenyStatus_NO_EMER = 0,
  BsmData_EmergenyStatus_YES_EMER = 1,
  BsmData_EmergenyStatus_BsmData_EmergenyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BsmData_EmergenyStatus_BsmData_EmergenyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BsmData_EmergenyStatus_IsValid(int value);
constexpr BsmData_EmergenyStatus BsmData_EmergenyStatus_EmergenyStatus_MIN = BsmData_EmergenyStatus_NO_EMER;
constexpr BsmData_EmergenyStatus BsmData_EmergenyStatus_EmergenyStatus_MAX = BsmData_EmergenyStatus_YES_EMER;
constexpr int BsmData_EmergenyStatus_EmergenyStatus_ARRAYSIZE = BsmData_EmergenyStatus_EmergenyStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BsmData_EmergenyStatus_descriptor();
template<typename T>
inline const std::string& BsmData_EmergenyStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BsmData_EmergenyStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BsmData_EmergenyStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BsmData_EmergenyStatus_descriptor(), enum_t_value);
}
inline bool BsmData_EmergenyStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BsmData_EmergenyStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BsmData_EmergenyStatus>(
    BsmData_EmergenyStatus_descriptor(), name, value);
}
enum BsmData_Wiper : int {
  BsmData_Wiper_OFF = 0,
  BsmData_Wiper_INT = 1,
  BsmData_Wiper_LO = 2,
  BsmData_Wiper_HI = 3,
  BsmData_Wiper_BsmData_Wiper_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BsmData_Wiper_BsmData_Wiper_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BsmData_Wiper_IsValid(int value);
constexpr BsmData_Wiper BsmData_Wiper_Wiper_MIN = BsmData_Wiper_OFF;
constexpr BsmData_Wiper BsmData_Wiper_Wiper_MAX = BsmData_Wiper_HI;
constexpr int BsmData_Wiper_Wiper_ARRAYSIZE = BsmData_Wiper_Wiper_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BsmData_Wiper_descriptor();
template<typename T>
inline const std::string& BsmData_Wiper_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BsmData_Wiper>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BsmData_Wiper_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BsmData_Wiper_descriptor(), enum_t_value);
}
inline bool BsmData_Wiper_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BsmData_Wiper* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BsmData_Wiper>(
    BsmData_Wiper_descriptor(), name, value);
}
enum BsmData_OutofControl : int {
  BsmData_OutofControl_NO_OUTCON = 0,
  BsmData_OutofControl_YES_OUTCON = 1,
  BsmData_OutofControl_BsmData_OutofControl_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BsmData_OutofControl_BsmData_OutofControl_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BsmData_OutofControl_IsValid(int value);
constexpr BsmData_OutofControl BsmData_OutofControl_OutofControl_MIN = BsmData_OutofControl_NO_OUTCON;
constexpr BsmData_OutofControl BsmData_OutofControl_OutofControl_MAX = BsmData_OutofControl_YES_OUTCON;
constexpr int BsmData_OutofControl_OutofControl_ARRAYSIZE = BsmData_OutofControl_OutofControl_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BsmData_OutofControl_descriptor();
template<typename T>
inline const std::string& BsmData_OutofControl_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BsmData_OutofControl>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BsmData_OutofControl_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BsmData_OutofControl_descriptor(), enum_t_value);
}
inline bool BsmData_OutofControl_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BsmData_OutofControl* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BsmData_OutofControl>(
    BsmData_OutofControl_descriptor(), name, value);
}
enum ParticipantData_PlateColor : int {
  ParticipantData_PlateColor_UNKNOWN_PLATE_COLOR = 0,
  ParticipantData_PlateColor_BLUE_PLATE = 1,
  ParticipantData_PlateColor_YELLOW_PLATE = 2,
  ParticipantData_PlateColor_WHITE_PLATE = 3,
  ParticipantData_PlateColor_BLACK_PLATE = 4,
  ParticipantData_PlateColor_YELLOW_GREEN_PLATE = 5,
  ParticipantData_PlateColor_GRADIENT_GREEN_PLATE = 6,
  ParticipantData_PlateColor_ParticipantData_PlateColor_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParticipantData_PlateColor_ParticipantData_PlateColor_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParticipantData_PlateColor_IsValid(int value);
constexpr ParticipantData_PlateColor ParticipantData_PlateColor_PlateColor_MIN = ParticipantData_PlateColor_UNKNOWN_PLATE_COLOR;
constexpr ParticipantData_PlateColor ParticipantData_PlateColor_PlateColor_MAX = ParticipantData_PlateColor_GRADIENT_GREEN_PLATE;
constexpr int ParticipantData_PlateColor_PlateColor_ARRAYSIZE = ParticipantData_PlateColor_PlateColor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParticipantData_PlateColor_descriptor();
template<typename T>
inline const std::string& ParticipantData_PlateColor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParticipantData_PlateColor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParticipantData_PlateColor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParticipantData_PlateColor_descriptor(), enum_t_value);
}
inline bool ParticipantData_PlateColor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParticipantData_PlateColor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParticipantData_PlateColor>(
    ParticipantData_PlateColor_descriptor(), name, value);
}
enum ParticipantData_VehicleColor : int {
  ParticipantData_VehicleColor_UNKNOWN_VEHICEL_COLOR = 0,
  ParticipantData_VehicleColor_WHITE = 1,
  ParticipantData_VehicleColor_GRAY = 2,
  ParticipantData_VehicleColor_YELLOW = 3,
  ParticipantData_VehicleColor_PINK = 4,
  ParticipantData_VehicleColor_RED = 5,
  ParticipantData_VehicleColor_GREEN = 6,
  ParticipantData_VehicleColor_BLUE = 7,
  ParticipantData_VehicleColor_BROWN = 8,
  ParticipantData_VehicleColor_BLACK = 9,
  ParticipantData_VehicleColor_PURPLE = 10,
  ParticipantData_VehicleColor_OTHER = 11,
  ParticipantData_VehicleColor_ParticipantData_VehicleColor_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParticipantData_VehicleColor_ParticipantData_VehicleColor_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParticipantData_VehicleColor_IsValid(int value);
constexpr ParticipantData_VehicleColor ParticipantData_VehicleColor_VehicleColor_MIN = ParticipantData_VehicleColor_UNKNOWN_VEHICEL_COLOR;
constexpr ParticipantData_VehicleColor ParticipantData_VehicleColor_VehicleColor_MAX = ParticipantData_VehicleColor_OTHER;
constexpr int ParticipantData_VehicleColor_VehicleColor_ARRAYSIZE = ParticipantData_VehicleColor_VehicleColor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParticipantData_VehicleColor_descriptor();
template<typename T>
inline const std::string& ParticipantData_VehicleColor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParticipantData_VehicleColor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParticipantData_VehicleColor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParticipantData_VehicleColor_descriptor(), enum_t_value);
}
inline bool ParticipantData_VehicleColor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParticipantData_VehicleColor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParticipantData_VehicleColor>(
    ParticipantData_VehicleColor_descriptor(), name, value);
}
enum ParticipantData_ParticipantTypeExt : int {
  ParticipantData_ParticipantTypeExt_UNKNOWN_OBJECT_TYPE_EXT = 0,
  ParticipantData_ParticipantTypeExt_UNKNOWN_MOVABLE = 1,
  ParticipantData_ParticipantTypeExt_UNKNOWN_UNMOVABLE = 2,
  ParticipantData_ParticipantTypeExt_CAR = 3,
  ParticipantData_ParticipantTypeExt_VAN = 4,
  ParticipantData_ParticipantTypeExt_TRUCK = 5,
  ParticipantData_ParticipantTypeExt_BUS = 6,
  ParticipantData_ParticipantTypeExt_CYCLIST = 7,
  ParticipantData_ParticipantTypeExt_MOTORCYCLIST = 8,
  ParticipantData_ParticipantTypeExt_TRICYCLIST = 9,
  ParticipantData_ParticipantTypeExt_PEDESTRIAN = 10,
  ParticipantData_ParticipantTypeExt_ParticipantData_ParticipantTypeExt_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParticipantData_ParticipantTypeExt_ParticipantData_ParticipantTypeExt_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParticipantData_ParticipantTypeExt_IsValid(int value);
constexpr ParticipantData_ParticipantTypeExt ParticipantData_ParticipantTypeExt_ParticipantTypeExt_MIN = ParticipantData_ParticipantTypeExt_UNKNOWN_OBJECT_TYPE_EXT;
constexpr ParticipantData_ParticipantTypeExt ParticipantData_ParticipantTypeExt_ParticipantTypeExt_MAX = ParticipantData_ParticipantTypeExt_PEDESTRIAN;
constexpr int ParticipantData_ParticipantTypeExt_ParticipantTypeExt_ARRAYSIZE = ParticipantData_ParticipantTypeExt_ParticipantTypeExt_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParticipantData_ParticipantTypeExt_descriptor();
template<typename T>
inline const std::string& ParticipantData_ParticipantTypeExt_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParticipantData_ParticipantTypeExt>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParticipantData_ParticipantTypeExt_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParticipantData_ParticipantTypeExt_descriptor(), enum_t_value);
}
inline bool ParticipantData_ParticipantTypeExt_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParticipantData_ParticipantTypeExt* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParticipantData_ParticipantTypeExt>(
    ParticipantData_ParticipantTypeExt_descriptor(), name, value);
}
enum ObjIdValue_Role : int {
  ObjIdValue_Role_ACTIVE = 0,
  ObjIdValue_Role_PASSIVE = 1,
  ObjIdValue_Role_NOTCLEAR = 2,
  ObjIdValue_Role_ObjIdValue_Role_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ObjIdValue_Role_ObjIdValue_Role_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ObjIdValue_Role_IsValid(int value);
constexpr ObjIdValue_Role ObjIdValue_Role_Role_MIN = ObjIdValue_Role_ACTIVE;
constexpr ObjIdValue_Role ObjIdValue_Role_Role_MAX = ObjIdValue_Role_NOTCLEAR;
constexpr int ObjIdValue_Role_Role_ARRAYSIZE = ObjIdValue_Role_Role_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjIdValue_Role_descriptor();
template<typename T>
inline const std::string& ObjIdValue_Role_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjIdValue_Role>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjIdValue_Role_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjIdValue_Role_descriptor(), enum_t_value);
}
inline bool ObjIdValue_Role_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ObjIdValue_Role* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjIdValue_Role>(
    ObjIdValue_Role_descriptor(), name, value);
}
enum RteData_EventSource : int {
  RteData_EventSource_UNKNOWN_EVENT_SOURCE = 0,
  RteData_EventSource_TRAFFIC_POLICE = 1,
  RteData_EventSource_GOVENMENT = 2,
  RteData_EventSource_METEOROLOGICAL_DEPARTMENT = 3,
  RteData_EventSource_INTERNET_SERVICES = 4,
  RteData_EventSource_LOCAL_DETECTION = 5,
  RteData_EventSource_RteData_EventSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RteData_EventSource_RteData_EventSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RteData_EventSource_IsValid(int value);
constexpr RteData_EventSource RteData_EventSource_EventSource_MIN = RteData_EventSource_UNKNOWN_EVENT_SOURCE;
constexpr RteData_EventSource RteData_EventSource_EventSource_MAX = RteData_EventSource_LOCAL_DETECTION;
constexpr int RteData_EventSource_EventSource_ARRAYSIZE = RteData_EventSource_EventSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RteData_EventSource_descriptor();
template<typename T>
inline const std::string& RteData_EventSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RteData_EventSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RteData_EventSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RteData_EventSource_descriptor(), enum_t_value);
}
inline bool RteData_EventSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RteData_EventSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RteData_EventSource>(
    RteData_EventSource_descriptor(), name, value);
}
enum DriveRequest_ReqStatus : int {
  DriveRequest_ReqStatus_UNKNOWN = 0,
  DriveRequest_ReqStatus_REQUEST = 1,
  DriveRequest_ReqStatus_COMFIRMED = 2,
  DriveRequest_ReqStatus_CANCEL = 3,
  DriveRequest_ReqStatus_COMPLETE = 4,
  DriveRequest_ReqStatus_DriveRequest_ReqStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DriveRequest_ReqStatus_DriveRequest_ReqStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DriveRequest_ReqStatus_IsValid(int value);
constexpr DriveRequest_ReqStatus DriveRequest_ReqStatus_ReqStatus_MIN = DriveRequest_ReqStatus_UNKNOWN;
constexpr DriveRequest_ReqStatus DriveRequest_ReqStatus_ReqStatus_MAX = DriveRequest_ReqStatus_COMPLETE;
constexpr int DriveRequest_ReqStatus_ReqStatus_ARRAYSIZE = DriveRequest_ReqStatus_ReqStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DriveRequest_ReqStatus_descriptor();
template<typename T>
inline const std::string& DriveRequest_ReqStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DriveRequest_ReqStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DriveRequest_ReqStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DriveRequest_ReqStatus_descriptor(), enum_t_value);
}
inline bool DriveRequest_ReqStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriveRequest_ReqStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DriveRequest_ReqStatus>(
    DriveRequest_ReqStatus_descriptor(), name, value);
}
enum StatusData_StatusType : int {
  StatusData_StatusType_DEV_STATUS_UNKNOWN = 0,
  StatusData_StatusType_DEV_STATUS_OK = 1,
  StatusData_StatusType_DEV_STATUS_ABNORMAL = 2,
  StatusData_StatusType_DEV_STATUS_OFF = 3,
  StatusData_StatusType_DEV_STATUS_REBOOT = 4,
  StatusData_StatusType_DEV_STATUS_MAINTAIN = 5,
  StatusData_StatusType_DEV_STATUS_SCRAP = 6,
  StatusData_StatusType_StatusData_StatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StatusData_StatusType_StatusData_StatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StatusData_StatusType_IsValid(int value);
constexpr StatusData_StatusType StatusData_StatusType_StatusType_MIN = StatusData_StatusType_DEV_STATUS_UNKNOWN;
constexpr StatusData_StatusType StatusData_StatusType_StatusType_MAX = StatusData_StatusType_DEV_STATUS_SCRAP;
constexpr int StatusData_StatusType_StatusType_ARRAYSIZE = StatusData_StatusType_StatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusData_StatusType_descriptor();
template<typename T>
inline const std::string& StatusData_StatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusData_StatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusData_StatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusData_StatusType_descriptor(), enum_t_value);
}
inline bool StatusData_StatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusData_StatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusData_StatusType>(
    StatusData_StatusType_descriptor(), name, value);
}
enum Message_Type : int {
  UKNOWN_MSG = 0,
  OBJECT_MSG = 1,
  EVENT_MSG = 2,
  OBSTACLE_MSG = 3,
  STATUS_MSG = 4,
  RTE_MSG = 5,
  RTS_MSG = 6,
  SPAT_MSG = 7,
  MAP_MSG = 8,
  VIR_MSG = 9,
  RSC_MSG = 10,
  CAM_MSG = 11,
  DENM_MSG = 12,
  Message_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Message_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Message_Type_IsValid(int value);
constexpr Message_Type Message_Type_MIN = UKNOWN_MSG;
constexpr Message_Type Message_Type_MAX = DENM_MSG;
constexpr int Message_Type_ARRAYSIZE = Message_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Message_Type_descriptor();
template<typename T>
inline const std::string& Message_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Message_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Message_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Message_Type_descriptor(), enum_t_value);
}
inline bool Message_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Message_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
enum DataSource : int {
  DATA_SOURCE_UNKNOWN = 0,
  SELFINFO = 1,
  V2X = 2,
  VIDEO = 3,
  MICROWAVE_RADAR = 4,
  LOOP = 5,
  LIDAR = 6,
  INTEGRATED = 7,
  DATA_SOURCE_RESERVE = 8,
  CLOUD_FORWARDING = 9,
  MEC_TO_MEC = 10,
  CLOUD_TO_CLOUD = 11,
  CLOUD_MANUAL = 12,
  DataSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataSource_IsValid(int value);
constexpr DataSource DataSource_MIN = DATA_SOURCE_UNKNOWN;
constexpr DataSource DataSource_MAX = CLOUD_MANUAL;
constexpr int DataSource_ARRAYSIZE = DataSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataSource_descriptor();
template<typename T>
inline const std::string& DataSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataSource_descriptor(), enum_t_value);
}
inline bool DataSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataSource>(
    DataSource_descriptor(), name, value);
}
enum TimeConfidence : int {
  UNAVAILABLE = 0,
  TIME_100_000 = 1,
  TIME_050_000 = 2,
  TIME_020_000 = 3,
  TIME_010_000 = 4,
  TIME_002_000 = 5,
  TIME_001_000 = 6,
  TIME_000_500 = 7,
  TIME_000_200 = 8,
  TIME_000_100 = 9,
  TIME_000_050 = 10,
  TIME_000_020 = 11,
  TIME_000_010 = 12,
  TIME_000_005 = 13,
  TIME_000_002 = 14,
  TIME_000_001 = 15,
  TIME_000_000_5 = 16,
  TIME_000_000_2 = 17,
  TIME_000_000_1 = 18,
  TIME_000_000_05 = 19,
  TIME_000_000_02 = 20,
  TIME_000_000_01 = 21,
  TIME_000_000_005 = 22,
  TIME_000_000_002 = 23,
  TIME_000_000_001 = 24,
  TIME_000_000_000_5 = 25,
  TIME_000_000_000_2 = 26,
  TIME_000_000_000_1 = 27,
  TIME_000_000_000_05 = 28,
  TIME_000_000_000_02 = 29,
  TIME_000_000_000_01 = 30,
  TIME_000_000_000_005 = 31,
  TIME_000_000_000_002 = 32,
  TIME_000_000_000_001 = 33,
  TIME_000_000_000_000_5 = 34,
  TIME_000_000_000_000_2 = 35,
  TIME_000_000_000_000_1 = 36,
  TIME_000_000_000_000_05 = 37,
  TIME_000_000_000_000_02 = 38,
  TIME_000_000_000_000_01 = 39,
  TimeConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TimeConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TimeConfidence_IsValid(int value);
constexpr TimeConfidence TimeConfidence_MIN = UNAVAILABLE;
constexpr TimeConfidence TimeConfidence_MAX = TIME_000_000_000_000_01;
constexpr int TimeConfidence_ARRAYSIZE = TimeConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeConfidence_descriptor();
template<typename T>
inline const std::string& TimeConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeConfidence_descriptor(), enum_t_value);
}
inline bool TimeConfidence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeConfidence>(
    TimeConfidence_descriptor(), name, value);
}
enum ParticipantType : int {
  OBJECTTYPE_UNKNOWN = 0,
  OBJECTTYPE_MOTOR = 1,
  OBJECTTYPE_NON_MOTOR = 2,
  OBJECTTYPE_PEDESTRIAN = 3,
  OBJECTTYPE_RSU = 4,
  ParticipantType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParticipantType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParticipantType_IsValid(int value);
constexpr ParticipantType ParticipantType_MIN = OBJECTTYPE_UNKNOWN;
constexpr ParticipantType ParticipantType_MAX = OBJECTTYPE_RSU;
constexpr int ParticipantType_ARRAYSIZE = ParticipantType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParticipantType_descriptor();
template<typename T>
inline const std::string& ParticipantType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParticipantType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParticipantType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParticipantType_descriptor(), enum_t_value);
}
inline bool ParticipantType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParticipantType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParticipantType>(
    ParticipantType_descriptor(), name, value);
}
enum SpeedConfidence : int {
  SPEED_CONFID_UNAVAILABLE = 0,
  SPEED_CONFID_100MS = 1,
  SPEED_CONFID_10MS = 2,
  SPEED_CONFID_5MS = 3,
  SPEED_CONFID_1MS = 4,
  SPEED_CONFID_0_1MS = 5,
  SPEED_CONFID_0_05MS = 6,
  SPEED_CONFID_0_01MS = 7,
  SpeedConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpeedConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpeedConfidence_IsValid(int value);
constexpr SpeedConfidence SpeedConfidence_MIN = SPEED_CONFID_UNAVAILABLE;
constexpr SpeedConfidence SpeedConfidence_MAX = SPEED_CONFID_0_01MS;
constexpr int SpeedConfidence_ARRAYSIZE = SpeedConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeedConfidence_descriptor();
template<typename T>
inline const std::string& SpeedConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpeedConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpeedConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpeedConfidence_descriptor(), enum_t_value);
}
inline bool SpeedConfidence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpeedConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpeedConfidence>(
    SpeedConfidence_descriptor(), name, value);
}
enum HeadingConfidence : int {
  HEADING_CONFID_UNAVAILABLE = 0,
  HEADING_CONFID_PREC10DEG = 1,
  HEADING_CONFIDE_PREC05DEG = 2,
  HEADING_CONFIDE_PREC01DEG = 3,
  HEADING_CONFID_PREC_1DEG = 4,
  HEADING_CONFID_PREC0_05DEG = 5,
  HEADING_CONFID_PREC0_01DEG = 6,
  HEADING_CONFID_PREC0_0125DEG = 7,
  HeadingConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HeadingConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HeadingConfidence_IsValid(int value);
constexpr HeadingConfidence HeadingConfidence_MIN = HEADING_CONFID_UNAVAILABLE;
constexpr HeadingConfidence HeadingConfidence_MAX = HEADING_CONFID_PREC0_0125DEG;
constexpr int HeadingConfidence_ARRAYSIZE = HeadingConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HeadingConfidence_descriptor();
template<typename T>
inline const std::string& HeadingConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HeadingConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HeadingConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HeadingConfidence_descriptor(), enum_t_value);
}
inline bool HeadingConfidence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HeadingConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HeadingConfidence>(
    HeadingConfidence_descriptor(), name, value);
}
enum VehicleType : int {
  UNKNOWN_VEHICLE_CLASS = 0,
  PASSENGER_VEHICLE_TYPE_UNKNOWN = 10,
  MOTOR_LIGHTTRUNK = 20,
  TRUCK_VEHICLE_TYPE_UNKNOWN = 25,
  MOTORCYCLE_TYPE_UNKNOWN = 40,
  TRANSIT_TYPE_UNKNOWN = 50,
  EMERGENCY_TYPE_UNKNOWN = 60,
  SPECIAL_VEHICLE_CLASS = 1,
  PASSENGER_VEHICLE_TYPE_OTHER = 11,
  LIGHT_TRUCK_VEHICLE_TYPE_OTHER = 21,
  TRUCK_VEHICLE_TYPE_OTHER = 26,
  TRUCK_AXLE_CNT2 = 27,
  TRUCK_AXLE_CNT3 = 28,
  TRUCK_AXLE_CNT4 = 29,
  TRUCK_AXLE_CNT4_TRAILER = 30,
  TRUCK_AXLE_CNT5_TRAILER = 31,
  TRUCK_AXLE_CNT6_TRAILER = 32,
  TRUCK_AXLECNT5MULTITRAILER = 33,
  TRUCK_AXLE_CNT6_MULTI_TRAILER = 34,
  TRUCK_AXLE_CNT7_MULTI_TRAILER = 35,
  MOTORCYCLE_TYPE_OTHER = 41,
  MOTORCYCLE_CRUISER_STANDARD = 42,
  SPORT_UNCLAD_MOTORCYCLE_SPORT_UNCLAD = 43,
  MOTORCYCLE_SPORT_TOURING = 44,
  MOTORCYCLE_SUPER_SPORT = 45,
  MOTORCYCLE_TOURING = 46,
  MOTORCYCLE_TRIKE = 47,
  MOTORCYCLE_WPASSENGERS = 48,
  TRANSIT_TYPE_OTHER = 51,
  TRANSIT_BRT = 52,
  TRANSIT_EXPRESS_BUS = 53,
  TRANSIT_LOCAL_BUS = 54,
  TRANSIT_SCHOOL_BUS = 55,
  TRANSIT_FIXED_GUIdEWAY = 56,
  TRANSIT_PARATRANSIT = 57,
  TRANSIT_PARATRANSIT_AMBULANCE = 58,
  EMERGENCY_TYPE_OTHER = 61,
  EMERGENCY_FIRE_LIGHT_VEHICLE = 62,
  EMERGENCY_FIRE_HEAVY_VEHICLE = 63,
  EMERGENCY_FIRE_PARAMEDIC_VEHICLE = 64,
  EMERGENCY_FIRE_AMBULANCE_VEHICLE = 65,
  EMERGENCY_POLICE_LIGHT_VEHICLE = 66,
  EMERGENCY_POLICE_HEAVY_VEHICLE = 67,
  EMERGENCY_OTHER_RESPONDER = 68,
  EMERGENCY_OTHER_AMBULANCE = 69,
  OTHER_TRAVELER_TYPE_UNKNOWN = 80,
  OTHER_TRAVELER_TYPE_OTHER = 81,
  OTHER_TRAVELER_PEDESTRIAN = 82,
  OTHER_TRAVELER_VISUALLY_DISABLED = 83,
  OTHER_TRAVELER_PHYSICALLY_DISABLED = 84,
  OTHER_TRAVELER_BICYCLE = 85,
  OTHER_TRAVELER_VULNERABLE_ROAD_WORKER = 86,
  INFRASTRUCTURE_TYPE_UNKNOWN = 90,
  INFRASTRUCTURE_FIXED = 91,
  INFRASTRUCTURE_MOVABLE = 92,
  EQUIPPED_CARGO_TRAILER = 93,
  VehicleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VehicleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VehicleType_IsValid(int value);
constexpr VehicleType VehicleType_MIN = UNKNOWN_VEHICLE_CLASS;
constexpr VehicleType VehicleType_MAX = EQUIPPED_CARGO_TRAILER;
constexpr int VehicleType_ARRAYSIZE = VehicleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleType_descriptor();
template<typename T>
inline const std::string& VehicleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VehicleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VehicleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VehicleType_descriptor(), enum_t_value);
}
inline bool VehicleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VehicleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VehicleType>(
    VehicleType_descriptor(), name, value);
}
enum Maneuver : int {
  MANEUVER_STRAIGHT = 0,
  MANEUVER_LEFT_TURN = 1,
  MANEUVER_RIGHT_TURN = 2,
  MANEUVER_UTURN = 3,
  Maneuver_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Maneuver_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Maneuver_IsValid(int value);
constexpr Maneuver Maneuver_MIN = MANEUVER_STRAIGHT;
constexpr Maneuver Maneuver_MAX = MANEUVER_UTURN;
constexpr int Maneuver_ARRAYSIZE = Maneuver_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Maneuver_descriptor();
template<typename T>
inline const std::string& Maneuver_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Maneuver>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Maneuver_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Maneuver_descriptor(), enum_t_value);
}
inline bool Maneuver_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Maneuver* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Maneuver>(
    Maneuver_descriptor(), name, value);
}
enum MapElementType : int {
  MAP_ELEMENT_TYPE_UNKNOWN = 0,
  MAP_ELEMENT_TYPE_DETECTOR_AREA = 1,
  MAP_ELEMENT_TYPE_LANE = 2,
  MAP_ELEMENT_TYPE_SECTION = 3,
  MAP_ELEMENT_TYPE_LINK = 4,
  MAP_ELEMENT_TYPE_NODE = 5,
  MAP_ELEMENT_TYPE_MOVEMENT = 6,
  MapElementType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MapElementType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MapElementType_IsValid(int value);
constexpr MapElementType MapElementType_MIN = MAP_ELEMENT_TYPE_UNKNOWN;
constexpr MapElementType MapElementType_MAX = MAP_ELEMENT_TYPE_MOVEMENT;
constexpr int MapElementType_ARRAYSIZE = MapElementType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MapElementType_descriptor();
template<typename T>
inline const std::string& MapElementType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MapElementType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MapElementType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MapElementType_descriptor(), enum_t_value);
}
inline bool MapElementType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MapElementType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MapElementType>(
    MapElementType_descriptor(), name, value);
}
enum PlateType : int {
  UNKNOWN_PLATE = 0,
  LARGE_CAR_PLATE = 1,
  SMALL_CAR_PLATE = 2,
  EMBASSY_CAR_PLATE = 3,
  CONSULATE_CAR_PLATE = 4,
  OVERSEAS_CAR_PLATE = 5,
  FOREIGN_CAR_PLATE = 6,
  ORDINARY_MOTORCYCLE_PLATE = 7,
  MOPED_PLATE = 8,
  EMBASSY_MOTORCYCLE_PLATE = 9,
  CONSULATE_MOTORCYCLE_PLATE = 10,
  OVERSEAS_MOTORCYCLE_PLATE = 11,
  FOREIGN_MOTORCYCLE_PLATE = 12,
  LOW_SPEED_PLATE = 13,
  TRACTOR_PLATE = 14,
  TRAILER_PLATE = 15,
  COACH_CAR_PLATE = 16,
  COACH_MOTORCYCLE_PLATE = 17,
  TEMPORARY_ENTRY_PLATE = 20,
  TEMPORARY_ENTRY_MOTORCYCLE_PLATE = 21,
  TEMPORARY_DRIVING_PLATE = 22,
  POLICE_CAR_PLATE = 23,
  POLICE_MOTORCYCLE_PLATE = 24,
  ORIGINAL_AGRICULTURAL_MACHINERY_PLATE = 25,
  HONGKONG_PLATE = 26,
  MACAU_PLATE = 27,
  ARMED_POLICE_PLATE = 31,
  ARMY_PLATE = 32,
  NO_NUMBER_PLATE = 41,
  FAKE_PLATE = 42,
  MISAPPROPRIATION_PLATE = 43,
  UNRECOGNIZED_PLATE = 44,
  LARGE_NEW_ENERGY_YELLOW_GREEN_PLATE = 51,
  SMALL_NEW_ENERGY_GREEN_PLATE = 52,
  OTHER_PLATE = 99,
  PlateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlateType_IsValid(int value);
constexpr PlateType PlateType_MIN = UNKNOWN_PLATE;
constexpr PlateType PlateType_MAX = OTHER_PLATE;
constexpr int PlateType_ARRAYSIZE = PlateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlateType_descriptor();
template<typename T>
inline const std::string& PlateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlateType_descriptor(), enum_t_value);
}
inline bool PlateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlateType>(
    PlateType_descriptor(), name, value);
}
enum ObstaclesType : int {
  UNKNOWN_OBSTACLES_TYPE = 0,
  ROCKFALL = 1,
  LANDSLIDE = 2,
  ANIMAL_INTRUSION = 3,
  LIQUID_SPILL = 4,
  GOODS_SCATTERED = 5,
  TRAFFICCONE = 6,
  SAFETY_TRIANGLE = 7,
  TRAFFIC_ROADBLOCK = 8,
  INSPECTION_SHAFT_WITHOUT_COVER = 9,
  UNKNOWN_FRAGMENTS = 10,
  UNKNOWN_HARD_OBJECT = 11,
  UNKNOWN_SOFT_OBJECT = 12,
  ObstaclesType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ObstaclesType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ObstaclesType_IsValid(int value);
constexpr ObstaclesType ObstaclesType_MIN = UNKNOWN_OBSTACLES_TYPE;
constexpr ObstaclesType ObstaclesType_MAX = UNKNOWN_SOFT_OBJECT;
constexpr int ObstaclesType_ARRAYSIZE = ObstaclesType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObstaclesType_descriptor();
template<typename T>
inline const std::string& ObstaclesType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObstaclesType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObstaclesType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObstaclesType_descriptor(), enum_t_value);
}
inline bool ObstaclesType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ObstaclesType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObstaclesType>(
    ObstaclesType_descriptor(), name, value);
}
enum SceneType : int {
  SCENE_TYPE_URBAN = 0,
  SCENE_TYPE_HIGHSPEED = 1,
  SCENE_TYPE_CLOSEDPARK = 2,
  SCENE_TYPE_RESERVED = 3,
  SceneType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SceneType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SceneType_IsValid(int value);
constexpr SceneType SceneType_MIN = SCENE_TYPE_URBAN;
constexpr SceneType SceneType_MAX = SCENE_TYPE_RESERVED;
constexpr int SceneType_ARRAYSIZE = SceneType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SceneType_descriptor();
template<typename T>
inline const std::string& SceneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SceneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SceneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SceneType_descriptor(), enum_t_value);
}
inline bool SceneType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SceneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SceneType>(
    SceneType_descriptor(), name, value);
}
enum DeviceType : int {
  DEVICE_TYPE_UNKONWN = 0,
  OBU = 1,
  RSU = 2,
  OTHER = 100,
  CAMERA = 200,
  MICRO_RADAR = 202,
  LASER_RADAR = 203,
  MEC = 204,
  SIBOX = 205,
  WEATHER_SENSOR = 206,
  VMS = 207,
  MMW_RADAR = 208,
  CLOUD = 209,
  ELECTRONIC_TAGS = 210,
  WISDOM_LIGHTPOLE = 211,
  WISDOM_MANHOLECOVER = 212,
  WISDOM_PLATFORM = 213,
  CARRIER = 214,
  INTEGRATED_CABINET = 216,
  CORE_SW = 217,
  GATHER_SW = 218,
  ACCESS_SW = 219,
  POLE_BOX = 220,
  DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeviceType_IsValid(int value);
constexpr DeviceType DeviceType_MIN = DEVICE_TYPE_UNKONWN;
constexpr DeviceType DeviceType_MAX = POLE_BOX;
constexpr int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceType_descriptor();
template<typename T>
inline const std::string& DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceType_descriptor(), enum_t_value);
}
inline bool DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
// ===================================================================

class RsiTimeDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.RsiTimeDetails) */ {
 public:
  inline RsiTimeDetails() : RsiTimeDetails(nullptr) {}
  ~RsiTimeDetails() override;
  explicit PROTOBUF_CONSTEXPR RsiTimeDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RsiTimeDetails(const RsiTimeDetails& from);
  RsiTimeDetails(RsiTimeDetails&& from) noexcept
    : RsiTimeDetails() {
    *this = ::std::move(from);
  }

  inline RsiTimeDetails& operator=(const RsiTimeDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline RsiTimeDetails& operator=(RsiTimeDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RsiTimeDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const RsiTimeDetails* internal_default_instance() {
    return reinterpret_cast<const RsiTimeDetails*>(
               &_RsiTimeDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RsiTimeDetails& a, RsiTimeDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(RsiTimeDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RsiTimeDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RsiTimeDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RsiTimeDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RsiTimeDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RsiTimeDetails& from) {
    RsiTimeDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RsiTimeDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.RsiTimeDetails";
  }
  protected:
  explicit RsiTimeDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kEndTimeConfidenceFieldNumber = 3,
  };
  // uint64 startTime = 1;
  void clear_starttime();
  uint64_t starttime() const;
  void set_starttime(uint64_t value);
  private:
  uint64_t _internal_starttime() const;
  void _internal_set_starttime(uint64_t value);
  public:

  // uint64 endTime = 2;
  void clear_endtime();
  uint64_t endtime() const;
  void set_endtime(uint64_t value);
  private:
  uint64_t _internal_endtime() const;
  void _internal_set_endtime(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.TimeConfidence endTimeConfidence = 3;
  void clear_endtimeconfidence();
  ::cn::seisys::v2x::pb::TimeConfidence endtimeconfidence() const;
  void set_endtimeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  private:
  ::cn::seisys::v2x::pb::TimeConfidence _internal_endtimeconfidence() const;
  void _internal_set_endtimeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.RsiTimeDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t starttime_;
    uint64_t endtime_;
    int endtimeconfidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class Position3D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.Position3D) */ {
 public:
  inline Position3D() : Position3D(nullptr) {}
  ~Position3D() override;
  explicit PROTOBUF_CONSTEXPR Position3D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position3D(const Position3D& from);
  Position3D(Position3D&& from) noexcept
    : Position3D() {
    *this = ::std::move(from);
  }

  inline Position3D& operator=(const Position3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position3D& operator=(Position3D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position3D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position3D* internal_default_instance() {
    return reinterpret_cast<const Position3D*>(
               &_Position3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Position3D& a, Position3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Position3D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position3D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position3D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position3D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position3D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position3D& from) {
    Position3D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position3D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.Position3D";
  }
  protected:
  explicit Position3D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
    kEleFieldNumber = 3,
  };
  // int32 lat = 1;
  void clear_lat();
  int32_t lat() const;
  void set_lat(int32_t value);
  private:
  int32_t _internal_lat() const;
  void _internal_set_lat(int32_t value);
  public:

  // int32 lon = 2;
  void clear_lon();
  int32_t lon() const;
  void set_lon(int32_t value);
  private:
  int32_t _internal_lon() const;
  void _internal_set_lon(int32_t value);
  public:

  // int32 ele = 3;
  void clear_ele();
  int32_t ele() const;
  void set_ele(int32_t value);
  private:
  int32_t _internal_ele() const;
  void _internal_set_ele(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.Position3D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t lat_;
    int32_t lon_;
    int32_t ele_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class PositionConfidenceSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.PositionConfidenceSet) */ {
 public:
  inline PositionConfidenceSet() : PositionConfidenceSet(nullptr) {}
  ~PositionConfidenceSet() override;
  explicit PROTOBUF_CONSTEXPR PositionConfidenceSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionConfidenceSet(const PositionConfidenceSet& from);
  PositionConfidenceSet(PositionConfidenceSet&& from) noexcept
    : PositionConfidenceSet() {
    *this = ::std::move(from);
  }

  inline PositionConfidenceSet& operator=(const PositionConfidenceSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionConfidenceSet& operator=(PositionConfidenceSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionConfidenceSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionConfidenceSet* internal_default_instance() {
    return reinterpret_cast<const PositionConfidenceSet*>(
               &_PositionConfidenceSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PositionConfidenceSet& a, PositionConfidenceSet& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionConfidenceSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionConfidenceSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionConfidenceSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionConfidenceSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionConfidenceSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PositionConfidenceSet& from) {
    PositionConfidenceSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionConfidenceSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.PositionConfidenceSet";
  }
  protected:
  explicit PositionConfidenceSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PositionConfidenceSet_PositionConfidence PositionConfidence;
  static constexpr PositionConfidence UNAVAILABLE_POS_CONFID =
    PositionConfidenceSet_PositionConfidence_UNAVAILABLE_POS_CONFID;
  static constexpr PositionConfidence POS_CONFID_500M =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_500M;
  static constexpr PositionConfidence POS_CONFID_200M =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_200M;
  static constexpr PositionConfidence POS_CONFID_100M =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_100M;
  static constexpr PositionConfidence POS_CONFID_50M =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_50M;
  static constexpr PositionConfidence POS_CONFID_20M =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_20M;
  static constexpr PositionConfidence POS_CONFID_10M =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_10M;
  static constexpr PositionConfidence POS_CONFID_5M =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_5M;
  static constexpr PositionConfidence POS_CONFID_2M =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_2M;
  static constexpr PositionConfidence POS_CONFID_1M =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_1M;
  static constexpr PositionConfidence POS_CONFID_50CM =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_50CM;
  static constexpr PositionConfidence POS_CONFID_20CM =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_20CM;
  static constexpr PositionConfidence POS_CONFID_10CM =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_10CM;
  static constexpr PositionConfidence POS_CONFID_5CM =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_5CM;
  static constexpr PositionConfidence POS_CONFID_2CM =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_2CM;
  static constexpr PositionConfidence POS_CONFID_1CM =
    PositionConfidenceSet_PositionConfidence_POS_CONFID_1CM;
  static inline bool PositionConfidence_IsValid(int value) {
    return PositionConfidenceSet_PositionConfidence_IsValid(value);
  }
  static constexpr PositionConfidence PositionConfidence_MIN =
    PositionConfidenceSet_PositionConfidence_PositionConfidence_MIN;
  static constexpr PositionConfidence PositionConfidence_MAX =
    PositionConfidenceSet_PositionConfidence_PositionConfidence_MAX;
  static constexpr int PositionConfidence_ARRAYSIZE =
    PositionConfidenceSet_PositionConfidence_PositionConfidence_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PositionConfidence_descriptor() {
    return PositionConfidenceSet_PositionConfidence_descriptor();
  }
  template<typename T>
  static inline const std::string& PositionConfidence_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PositionConfidence>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PositionConfidence_Name.");
    return PositionConfidenceSet_PositionConfidence_Name(enum_t_value);
  }
  static inline bool PositionConfidence_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PositionConfidence* value) {
    return PositionConfidenceSet_PositionConfidence_Parse(name, value);
  }

  typedef PositionConfidenceSet_ElevationConfidence ElevationConfidence;
  static constexpr ElevationConfidence UNAVAILABLE_ELE_CONFID =
    PositionConfidenceSet_ElevationConfidence_UNAVAILABLE_ELE_CONFID;
  static constexpr ElevationConfidence ELE_CONFID_500M =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_500M;
  static constexpr ElevationConfidence ELE_CONFID_200M =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_200M;
  static constexpr ElevationConfidence ELE_CONFID_100M =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_100M;
  static constexpr ElevationConfidence ELE_CONFID_50M =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_50M;
  static constexpr ElevationConfidence ELE_CONFID_20M =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_20M;
  static constexpr ElevationConfidence ELE_CONFID_10M =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_10M;
  static constexpr ElevationConfidence ELE_CONFID_5M =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_5M;
  static constexpr ElevationConfidence ELE_CONFID_2M =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_2M;
  static constexpr ElevationConfidence ELE_CONFID_1M =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_1M;
  static constexpr ElevationConfidence ELE_CONFID_50CM =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_50CM;
  static constexpr ElevationConfidence ELE_CONFID_20CM =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_20CM;
  static constexpr ElevationConfidence ELE_CONFID_10CM =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_10CM;
  static constexpr ElevationConfidence ELE_CONFID_5CM =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_5CM;
  static constexpr ElevationConfidence ELE_CONFID_2CM =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_2CM;
  static constexpr ElevationConfidence ELE_CONFID_1CM =
    PositionConfidenceSet_ElevationConfidence_ELE_CONFID_1CM;
  static inline bool ElevationConfidence_IsValid(int value) {
    return PositionConfidenceSet_ElevationConfidence_IsValid(value);
  }
  static constexpr ElevationConfidence ElevationConfidence_MIN =
    PositionConfidenceSet_ElevationConfidence_ElevationConfidence_MIN;
  static constexpr ElevationConfidence ElevationConfidence_MAX =
    PositionConfidenceSet_ElevationConfidence_ElevationConfidence_MAX;
  static constexpr int ElevationConfidence_ARRAYSIZE =
    PositionConfidenceSet_ElevationConfidence_ElevationConfidence_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ElevationConfidence_descriptor() {
    return PositionConfidenceSet_ElevationConfidence_descriptor();
  }
  template<typename T>
  static inline const std::string& ElevationConfidence_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ElevationConfidence>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ElevationConfidence_Name.");
    return PositionConfidenceSet_ElevationConfidence_Name(enum_t_value);
  }
  static inline bool ElevationConfidence_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ElevationConfidence* value) {
    return PositionConfidenceSet_ElevationConfidence_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPosConfidFieldNumber = 1,
    kEleConfidFieldNumber = 2,
  };
  // .cn.seisys.v2x.pb.PositionConfidenceSet.PositionConfidence posConfid = 1;
  void clear_posconfid();
  ::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence posconfid() const;
  void set_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence value);
  private:
  ::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence _internal_posconfid() const;
  void _internal_set_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence value);
  public:

  // .cn.seisys.v2x.pb.PositionConfidenceSet.ElevationConfidence eleConfid = 2;
  void clear_eleconfid();
  ::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence eleconfid() const;
  void set_eleconfid(::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence value);
  private:
  ::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence _internal_eleconfid() const;
  void _internal_set_eleconfid(::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.PositionConfidenceSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int posconfid_;
    int eleconfid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ParticipantSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ParticipantSize) */ {
 public:
  inline ParticipantSize() : ParticipantSize(nullptr) {}
  ~ParticipantSize() override;
  explicit PROTOBUF_CONSTEXPR ParticipantSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantSize(const ParticipantSize& from);
  ParticipantSize(ParticipantSize&& from) noexcept
    : ParticipantSize() {
    *this = ::std::move(from);
  }

  inline ParticipantSize& operator=(const ParticipantSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantSize& operator=(ParticipantSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantSize* internal_default_instance() {
    return reinterpret_cast<const ParticipantSize*>(
               &_ParticipantSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ParticipantSize& a, ParticipantSize& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantSize& from) {
    ParticipantSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ParticipantSize";
  }
  protected:
  explicit ParticipantSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kLengthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // uint32 width = 1;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 length = 2;
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // uint32 height = 3;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ParticipantSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t width_;
    uint32_t length_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ParticipantSizeConfidence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ParticipantSizeConfidence) */ {
 public:
  inline ParticipantSizeConfidence() : ParticipantSizeConfidence(nullptr) {}
  ~ParticipantSizeConfidence() override;
  explicit PROTOBUF_CONSTEXPR ParticipantSizeConfidence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantSizeConfidence(const ParticipantSizeConfidence& from);
  ParticipantSizeConfidence(ParticipantSizeConfidence&& from) noexcept
    : ParticipantSizeConfidence() {
    *this = ::std::move(from);
  }

  inline ParticipantSizeConfidence& operator=(const ParticipantSizeConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantSizeConfidence& operator=(ParticipantSizeConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantSizeConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantSizeConfidence* internal_default_instance() {
    return reinterpret_cast<const ParticipantSizeConfidence*>(
               &_ParticipantSizeConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ParticipantSizeConfidence& a, ParticipantSizeConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantSizeConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantSizeConfidence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantSizeConfidence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantSizeConfidence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantSizeConfidence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantSizeConfidence& from) {
    ParticipantSizeConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantSizeConfidence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ParticipantSizeConfidence";
  }
  protected:
  explicit ParticipantSizeConfidence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ParticipantSizeConfidence_SizeValueConfidence SizeValueConfidence;
  static constexpr SizeValueConfidence SIZE_CONFID_UNAVAILABLE =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_UNAVAILABLE;
  static constexpr SizeValueConfidence SIZE_CONFID_100_00 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_100_00;
  static constexpr SizeValueConfidence SIZE_CONFID_050_00 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_050_00;
  static constexpr SizeValueConfidence SIZE_CONFID_020_00 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_020_00;
  static constexpr SizeValueConfidence SIZE_CONFID_010_00 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_010_00;
  static constexpr SizeValueConfidence SIZE_CONFID_005_00 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_005_00;
  static constexpr SizeValueConfidence SIZE_CONFID_002_00 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_002_00;
  static constexpr SizeValueConfidence SIZE_CONFID_001_00 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_001_00;
  static constexpr SizeValueConfidence SIZE_CONFID_000_50 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_50;
  static constexpr SizeValueConfidence SIZE_CONFID_000_20 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_20;
  static constexpr SizeValueConfidence SIZE_CONFID_000_10 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_10;
  static constexpr SizeValueConfidence SIZE_CONFID_000_05 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_05;
  static constexpr SizeValueConfidence SIZE_CONFID_000_02 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_02;
  static constexpr SizeValueConfidence SIZE_CONFID_000_01 =
    ParticipantSizeConfidence_SizeValueConfidence_SIZE_CONFID_000_01;
  static inline bool SizeValueConfidence_IsValid(int value) {
    return ParticipantSizeConfidence_SizeValueConfidence_IsValid(value);
  }
  static constexpr SizeValueConfidence SizeValueConfidence_MIN =
    ParticipantSizeConfidence_SizeValueConfidence_SizeValueConfidence_MIN;
  static constexpr SizeValueConfidence SizeValueConfidence_MAX =
    ParticipantSizeConfidence_SizeValueConfidence_SizeValueConfidence_MAX;
  static constexpr int SizeValueConfidence_ARRAYSIZE =
    ParticipantSizeConfidence_SizeValueConfidence_SizeValueConfidence_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SizeValueConfidence_descriptor() {
    return ParticipantSizeConfidence_SizeValueConfidence_descriptor();
  }
  template<typename T>
  static inline const std::string& SizeValueConfidence_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SizeValueConfidence>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SizeValueConfidence_Name.");
    return ParticipantSizeConfidence_SizeValueConfidence_Name(enum_t_value);
  }
  static inline bool SizeValueConfidence_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SizeValueConfidence* value) {
    return ParticipantSizeConfidence_SizeValueConfidence_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWidthConfidFieldNumber = 1,
    kLengthConfidFieldNumber = 2,
    kHeightConfidFieldNumber = 3,
  };
  // .cn.seisys.v2x.pb.ParticipantSizeConfidence.SizeValueConfidence widthConfid = 1;
  void clear_widthconfid();
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence widthconfid() const;
  void set_widthconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value);
  private:
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence _internal_widthconfid() const;
  void _internal_set_widthconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value);
  public:

  // .cn.seisys.v2x.pb.ParticipantSizeConfidence.SizeValueConfidence lengthConfid = 2;
  void clear_lengthconfid();
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence lengthconfid() const;
  void set_lengthconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value);
  private:
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence _internal_lengthconfid() const;
  void _internal_set_lengthconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value);
  public:

  // .cn.seisys.v2x.pb.ParticipantSizeConfidence.SizeValueConfidence heightConfid = 3;
  void clear_heightconfid();
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence heightconfid() const;
  void set_heightconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value);
  private:
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence _internal_heightconfid() const;
  void _internal_set_heightconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ParticipantSizeConfidence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int widthconfid_;
    int lengthconfid_;
    int heightconfid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class Polygon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {}
  ~Polygon() override;
  explicit PROTOBUF_CONSTEXPR Polygon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Polygon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Polygon& from) {
    Polygon::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
  };
  // repeated .cn.seisys.v2x.pb.Position3D pos = 1;
  int pos_size() const;
  private:
  int _internal_pos_size() const;
  public:
  void clear_pos();
  ::cn::seisys::v2x::pb::Position3D* mutable_pos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
      mutable_pos();
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_pos(int index) const;
  ::cn::seisys::v2x::pb::Position3D* _internal_add_pos();
  public:
  const ::cn::seisys::v2x::pb::Position3D& pos(int index) const;
  ::cn::seisys::v2x::pb::Position3D* add_pos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
      pos() const;

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D > pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class DetectorArea final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.DetectorArea) */ {
 public:
  inline DetectorArea() : DetectorArea(nullptr) {}
  ~DetectorArea() override;
  explicit PROTOBUF_CONSTEXPR DetectorArea(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectorArea(const DetectorArea& from);
  DetectorArea(DetectorArea&& from) noexcept
    : DetectorArea() {
    *this = ::std::move(from);
  }

  inline DetectorArea& operator=(const DetectorArea& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectorArea& operator=(DetectorArea&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectorArea& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectorArea* internal_default_instance() {
    return reinterpret_cast<const DetectorArea*>(
               &_DetectorArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DetectorArea& a, DetectorArea& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectorArea* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectorArea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectorArea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectorArea>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectorArea& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DetectorArea& from) {
    DetectorArea::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectorArea* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.DetectorArea";
  }
  protected:
  explicit DetectorArea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonFieldNumber = 3,
    kNodeIdFieldNumber = 4,
    kSetTimeFieldNumber = 2,
    kAreaIdFieldNumber = 1,
    kLaneIdFieldNumber = 5,
  };
  // .cn.seisys.v2x.pb.Polygon polygon = 3;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::cn::seisys::v2x::pb::Polygon& polygon() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Polygon* release_polygon();
  ::cn::seisys::v2x::pb::Polygon* mutable_polygon();
  void set_allocated_polygon(::cn::seisys::v2x::pb::Polygon* polygon);
  private:
  const ::cn::seisys::v2x::pb::Polygon& _internal_polygon() const;
  ::cn::seisys::v2x::pb::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::cn::seisys::v2x::pb::Polygon* polygon);
  ::cn::seisys::v2x::pb::Polygon* unsafe_arena_release_polygon();

  // .cn.seisys.v2x.pb.NodeReferenceId nodeId = 4;
  bool has_nodeid() const;
  private:
  bool _internal_has_nodeid() const;
  public:
  void clear_nodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& nodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_nodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_nodeid();
  void set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_nodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_nodeid();
  public:
  void unsafe_arena_set_allocated_nodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_nodeid();

  // int64 setTime = 2;
  void clear_settime();
  int64_t settime() const;
  void set_settime(int64_t value);
  private:
  int64_t _internal_settime() const;
  void _internal_set_settime(int64_t value);
  public:

  // int32 areaId = 1;
  void clear_areaid();
  int32_t areaid() const;
  void set_areaid(int32_t value);
  private:
  int32_t _internal_areaid() const;
  void _internal_set_areaid(int32_t value);
  public:

  // int32 laneId = 5;
  void clear_laneid();
  int32_t laneid() const;
  void set_laneid(int32_t value);
  private:
  int32_t _internal_laneid() const;
  void _internal_set_laneid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.DetectorArea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::Polygon* polygon_;
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid_;
    int64_t settime_;
    int32_t areaid_;
    int32_t laneid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class RegulatorySpeedLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.RegulatorySpeedLimit) */ {
 public:
  inline RegulatorySpeedLimit() : RegulatorySpeedLimit(nullptr) {}
  ~RegulatorySpeedLimit() override;
  explicit PROTOBUF_CONSTEXPR RegulatorySpeedLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegulatorySpeedLimit(const RegulatorySpeedLimit& from);
  RegulatorySpeedLimit(RegulatorySpeedLimit&& from) noexcept
    : RegulatorySpeedLimit() {
    *this = ::std::move(from);
  }

  inline RegulatorySpeedLimit& operator=(const RegulatorySpeedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegulatorySpeedLimit& operator=(RegulatorySpeedLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegulatorySpeedLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegulatorySpeedLimit* internal_default_instance() {
    return reinterpret_cast<const RegulatorySpeedLimit*>(
               &_RegulatorySpeedLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegulatorySpeedLimit& a, RegulatorySpeedLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(RegulatorySpeedLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegulatorySpeedLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegulatorySpeedLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegulatorySpeedLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegulatorySpeedLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegulatorySpeedLimit& from) {
    RegulatorySpeedLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegulatorySpeedLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.RegulatorySpeedLimit";
  }
  protected:
  explicit RegulatorySpeedLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RegulatorySpeedLimit_SpeedLimitType SpeedLimitType;
  static constexpr SpeedLimitType SPEED_LIMIT_UNKNOWN =
    RegulatorySpeedLimit_SpeedLimitType_SPEED_LIMIT_UNKNOWN;
  static constexpr SpeedLimitType MAX_SPEED_IN_SCHOOL_ZONE =
    RegulatorySpeedLimit_SpeedLimitType_MAX_SPEED_IN_SCHOOL_ZONE;
  static constexpr SpeedLimitType MAX_SPEED_INSCHOOL_ZONE_WHEN_CHILDREN_ARE_PRESENT =
    RegulatorySpeedLimit_SpeedLimitType_MAX_SPEED_INSCHOOL_ZONE_WHEN_CHILDREN_ARE_PRESENT;
  static constexpr SpeedLimitType MAX_SPEED_INCONSTRUCTION_ZONE =
    RegulatorySpeedLimit_SpeedLimitType_MAX_SPEED_INCONSTRUCTION_ZONE;
  static constexpr SpeedLimitType VEHICLE_MIN_SPEED =
    RegulatorySpeedLimit_SpeedLimitType_VEHICLE_MIN_SPEED;
  static constexpr SpeedLimitType VEHICLE_SPEED =
    RegulatorySpeedLimit_SpeedLimitType_VEHICLE_SPEED;
  static constexpr SpeedLimitType VEHICLE_NIGHT_MAX_SPEED =
    RegulatorySpeedLimit_SpeedLimitType_VEHICLE_NIGHT_MAX_SPEED;
  static constexpr SpeedLimitType TRUCK_MIN_SPEED =
    RegulatorySpeedLimit_SpeedLimitType_TRUCK_MIN_SPEED;
  static constexpr SpeedLimitType TRUCK_MAX_SPEED =
    RegulatorySpeedLimit_SpeedLimitType_TRUCK_MAX_SPEED;
  static constexpr SpeedLimitType TRUCK_NIGHT_MAX_SPEED =
    RegulatorySpeedLimit_SpeedLimitType_TRUCK_NIGHT_MAX_SPEED;
  static constexpr SpeedLimitType VEHICLES_WITH_TRAILERS_MIN_SPEED =
    RegulatorySpeedLimit_SpeedLimitType_VEHICLES_WITH_TRAILERS_MIN_SPEED;
  static constexpr SpeedLimitType VEHICLES_WITH_TRAILERS_MAX_SPEED =
    RegulatorySpeedLimit_SpeedLimitType_VEHICLES_WITH_TRAILERS_MAX_SPEED;
  static constexpr SpeedLimitType VEHICLES_WITHTRAILERS_NIGHT_MAX_SPEED =
    RegulatorySpeedLimit_SpeedLimitType_VEHICLES_WITHTRAILERS_NIGHT_MAX_SPEED;
  static inline bool SpeedLimitType_IsValid(int value) {
    return RegulatorySpeedLimit_SpeedLimitType_IsValid(value);
  }
  static constexpr SpeedLimitType SpeedLimitType_MIN =
    RegulatorySpeedLimit_SpeedLimitType_SpeedLimitType_MIN;
  static constexpr SpeedLimitType SpeedLimitType_MAX =
    RegulatorySpeedLimit_SpeedLimitType_SpeedLimitType_MAX;
  static constexpr int SpeedLimitType_ARRAYSIZE =
    RegulatorySpeedLimit_SpeedLimitType_SpeedLimitType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpeedLimitType_descriptor() {
    return RegulatorySpeedLimit_SpeedLimitType_descriptor();
  }
  template<typename T>
  static inline const std::string& SpeedLimitType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpeedLimitType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpeedLimitType_Name.");
    return RegulatorySpeedLimit_SpeedLimitType_Name(enum_t_value);
  }
  static inline bool SpeedLimitType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SpeedLimitType* value) {
    return RegulatorySpeedLimit_SpeedLimitType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedLimitTypeFieldNumber = 1,
    kSpeedFieldNumber = 2,
  };
  // .cn.seisys.v2x.pb.RegulatorySpeedLimit.SpeedLimitType speedLimitType = 1;
  void clear_speedlimittype();
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType speedlimittype() const;
  void set_speedlimittype(::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType value);
  private:
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType _internal_speedlimittype() const;
  void _internal_set_speedlimittype(::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType value);
  public:

  // int32 speed = 2;
  void clear_speed();
  int32_t speed() const;
  void set_speed(int32_t value);
  private:
  int32_t _internal_speed() const;
  void _internal_set_speed(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.RegulatorySpeedLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int speedlimittype_;
    int32_t speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class AccelerationSet4Way final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.AccelerationSet4Way) */ {
 public:
  inline AccelerationSet4Way() : AccelerationSet4Way(nullptr) {}
  ~AccelerationSet4Way() override;
  explicit PROTOBUF_CONSTEXPR AccelerationSet4Way(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccelerationSet4Way(const AccelerationSet4Way& from);
  AccelerationSet4Way(AccelerationSet4Way&& from) noexcept
    : AccelerationSet4Way() {
    *this = ::std::move(from);
  }

  inline AccelerationSet4Way& operator=(const AccelerationSet4Way& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelerationSet4Way& operator=(AccelerationSet4Way&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelerationSet4Way& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelerationSet4Way* internal_default_instance() {
    return reinterpret_cast<const AccelerationSet4Way*>(
               &_AccelerationSet4Way_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AccelerationSet4Way& a, AccelerationSet4Way& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelerationSet4Way* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelerationSet4Way* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelerationSet4Way* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelerationSet4Way>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccelerationSet4Way& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccelerationSet4Way& from) {
    AccelerationSet4Way::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerationSet4Way* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.AccelerationSet4Way";
  }
  protected:
  explicit AccelerationSet4Way(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
    kVertFieldNumber = 3,
    kYawFieldNumber = 4,
  };
  // int32 lat = 1;
  void clear_lat();
  int32_t lat() const;
  void set_lat(int32_t value);
  private:
  int32_t _internal_lat() const;
  void _internal_set_lat(int32_t value);
  public:

  // int32 lon = 2;
  void clear_lon();
  int32_t lon() const;
  void set_lon(int32_t value);
  private:
  int32_t _internal_lon() const;
  void _internal_set_lon(int32_t value);
  public:

  // int32 vert = 3;
  void clear_vert();
  int32_t vert() const;
  void set_vert(int32_t value);
  private:
  int32_t _internal_vert() const;
  void _internal_set_vert(int32_t value);
  public:

  // int32 yaw = 4;
  void clear_yaw();
  int32_t yaw() const;
  void set_yaw(int32_t value);
  private:
  int32_t _internal_yaw() const;
  void _internal_set_yaw(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.AccelerationSet4Way)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t lat_;
    int32_t lon_;
    int32_t vert_;
    int32_t yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class AccelerationConfidence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.AccelerationConfidence) */ {
 public:
  inline AccelerationConfidence() : AccelerationConfidence(nullptr) {}
  ~AccelerationConfidence() override;
  explicit PROTOBUF_CONSTEXPR AccelerationConfidence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccelerationConfidence(const AccelerationConfidence& from);
  AccelerationConfidence(AccelerationConfidence&& from) noexcept
    : AccelerationConfidence() {
    *this = ::std::move(from);
  }

  inline AccelerationConfidence& operator=(const AccelerationConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelerationConfidence& operator=(AccelerationConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelerationConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelerationConfidence* internal_default_instance() {
    return reinterpret_cast<const AccelerationConfidence*>(
               &_AccelerationConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AccelerationConfidence& a, AccelerationConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelerationConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelerationConfidence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelerationConfidence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelerationConfidence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccelerationConfidence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccelerationConfidence& from) {
    AccelerationConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerationConfidence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.AccelerationConfidence";
  }
  protected:
  explicit AccelerationConfidence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccelerationConfidence_AccConfidence AccConfidence;
  static constexpr AccConfidence ACC_CONFID_UNAVAILABLE =
    AccelerationConfidence_AccConfidence_ACC_CONFID_UNAVAILABLE;
  static constexpr AccConfidence ACC_CONFID_PREC100DE =
    AccelerationConfidence_AccConfidence_ACC_CONFID_PREC100DE;
  static constexpr AccConfidence ACC_CONFID_PREC10DEG =
    AccelerationConfidence_AccConfidence_ACC_CONFID_PREC10DEG;
  static constexpr AccConfidence ACC_CONFID_PREC5DEG =
    AccelerationConfidence_AccConfidence_ACC_CONFID_PREC5DEG;
  static constexpr AccConfidence ACC_CONFID_PREC1DEG =
    AccelerationConfidence_AccConfidence_ACC_CONFID_PREC1DEG;
  static constexpr AccConfidence ACC_CONFID_PREC0_1DEG =
    AccelerationConfidence_AccConfidence_ACC_CONFID_PREC0_1DEG;
  static constexpr AccConfidence ACC_CONFID_PREC0_05DEG =
    AccelerationConfidence_AccConfidence_ACC_CONFID_PREC0_05DEG;
  static constexpr AccConfidence ACC_CONFID_PREC0_01DEG =
    AccelerationConfidence_AccConfidence_ACC_CONFID_PREC0_01DEG;
  static inline bool AccConfidence_IsValid(int value) {
    return AccelerationConfidence_AccConfidence_IsValid(value);
  }
  static constexpr AccConfidence AccConfidence_MIN =
    AccelerationConfidence_AccConfidence_AccConfidence_MIN;
  static constexpr AccConfidence AccConfidence_MAX =
    AccelerationConfidence_AccConfidence_AccConfidence_MAX;
  static constexpr int AccConfidence_ARRAYSIZE =
    AccelerationConfidence_AccConfidence_AccConfidence_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AccConfidence_descriptor() {
    return AccelerationConfidence_AccConfidence_descriptor();
  }
  template<typename T>
  static inline const std::string& AccConfidence_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AccConfidence>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AccConfidence_Name.");
    return AccelerationConfidence_AccConfidence_Name(enum_t_value);
  }
  static inline bool AccConfidence_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AccConfidence* value) {
    return AccelerationConfidence_AccConfidence_Parse(name, value);
  }

  typedef AccelerationConfidence_AngularVConfidence AngularVConfidence;
  static constexpr AngularVConfidence ANGULARV_CONFID_UNAVAILABLE =
    AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_UNAVAILABLE;
  static constexpr AngularVConfidence ANGULARV_CONFID_PREC100DEG =
    AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC100DEG;
  static constexpr AngularVConfidence ANGULARV_CONFID_PREC10DEG =
    AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC10DEG;
  static constexpr AngularVConfidence ANGULARV_CONFID_PREC5DEG =
    AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC5DEG;
  static constexpr AngularVConfidence ANGULARV_CONFID_PREC1DEG =
    AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC1DEG;
  static constexpr AngularVConfidence ANGULARV_CONFID_PREC0_1DEG =
    AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC0_1DEG;
  static constexpr AngularVConfidence ANGULARV_CONFID_PREC0_05DEG =
    AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC0_05DEG;
  static constexpr AngularVConfidence ANGULARV_CONFID_PREC0_01DEG =
    AccelerationConfidence_AngularVConfidence_ANGULARV_CONFID_PREC0_01DEG;
  static inline bool AngularVConfidence_IsValid(int value) {
    return AccelerationConfidence_AngularVConfidence_IsValid(value);
  }
  static constexpr AngularVConfidence AngularVConfidence_MIN =
    AccelerationConfidence_AngularVConfidence_AngularVConfidence_MIN;
  static constexpr AngularVConfidence AngularVConfidence_MAX =
    AccelerationConfidence_AngularVConfidence_AngularVConfidence_MAX;
  static constexpr int AngularVConfidence_ARRAYSIZE =
    AccelerationConfidence_AngularVConfidence_AngularVConfidence_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AngularVConfidence_descriptor() {
    return AccelerationConfidence_AngularVConfidence_descriptor();
  }
  template<typename T>
  static inline const std::string& AngularVConfidence_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AngularVConfidence>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AngularVConfidence_Name.");
    return AccelerationConfidence_AngularVConfidence_Name(enum_t_value);
  }
  static inline bool AngularVConfidence_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AngularVConfidence* value) {
    return AccelerationConfidence_AngularVConfidence_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLonAccelConfidFieldNumber = 1,
    kLatAccelConfidFieldNumber = 2,
    kVerticalAccelConfidFieldNumber = 3,
    kYawRateConfidFieldNumber = 4,
  };
  // .cn.seisys.v2x.pb.AccelerationConfidence.AccConfidence lonAccelConfid = 1;
  void clear_lonaccelconfid();
  ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence lonaccelconfid() const;
  void set_lonaccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value);
  private:
  ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence _internal_lonaccelconfid() const;
  void _internal_set_lonaccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value);
  public:

  // .cn.seisys.v2x.pb.AccelerationConfidence.AccConfidence latAccelConfid = 2;
  void clear_lataccelconfid();
  ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence lataccelconfid() const;
  void set_lataccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value);
  private:
  ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence _internal_lataccelconfid() const;
  void _internal_set_lataccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value);
  public:

  // .cn.seisys.v2x.pb.AccelerationConfidence.AccConfidence verticalAccelConfid = 3;
  void clear_verticalaccelconfid();
  ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence verticalaccelconfid() const;
  void set_verticalaccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value);
  private:
  ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence _internal_verticalaccelconfid() const;
  void _internal_set_verticalaccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value);
  public:

  // .cn.seisys.v2x.pb.AccelerationConfidence.AngularVConfidence yawRateConfid = 4;
  void clear_yawrateconfid();
  ::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence yawrateconfid() const;
  void set_yawrateconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence value);
  private:
  ::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence _internal_yawrateconfid() const;
  void _internal_set_yawrateconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.AccelerationConfidence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int lonaccelconfid_;
    int lataccelconfid_;
    int verticalaccelconfid_;
    int yawrateconfid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class MotionConfidenceSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.MotionConfidenceSet) */ {
 public:
  inline MotionConfidenceSet() : MotionConfidenceSet(nullptr) {}
  ~MotionConfidenceSet() override;
  explicit PROTOBUF_CONSTEXPR MotionConfidenceSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionConfidenceSet(const MotionConfidenceSet& from);
  MotionConfidenceSet(MotionConfidenceSet&& from) noexcept
    : MotionConfidenceSet() {
    *this = ::std::move(from);
  }

  inline MotionConfidenceSet& operator=(const MotionConfidenceSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionConfidenceSet& operator=(MotionConfidenceSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionConfidenceSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionConfidenceSet* internal_default_instance() {
    return reinterpret_cast<const MotionConfidenceSet*>(
               &_MotionConfidenceSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MotionConfidenceSet& a, MotionConfidenceSet& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionConfidenceSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionConfidenceSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotionConfidenceSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotionConfidenceSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotionConfidenceSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MotionConfidenceSet& from) {
    MotionConfidenceSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionConfidenceSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.MotionConfidenceSet";
  }
  protected:
  explicit MotionConfidenceSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MotionConfidenceSet_SteeringWheelAngleConfidence SteeringWheelAngleConfidence;
  static constexpr SteeringWheelAngleConfidence STEERING_WHEEL_ANGLE_CONFID_UNAVAILABLE =
    MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_UNAVAILABLE;
  static constexpr SteeringWheelAngleConfidence STEERING_WHEEL_ANGLE_CONFID_PREC2DEG =
    MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_PREC2DEG;
  static constexpr SteeringWheelAngleConfidence STEERING_WHEEL_ANGLE_CONFID_PREC1DEG =
    MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_PREC1DEG;
  static constexpr SteeringWheelAngleConfidence STEERING_WHEEL_ANGLE_CONFID_PREC0_02DEG =
    MotionConfidenceSet_SteeringWheelAngleConfidence_STEERING_WHEEL_ANGLE_CONFID_PREC0_02DEG;
  static inline bool SteeringWheelAngleConfidence_IsValid(int value) {
    return MotionConfidenceSet_SteeringWheelAngleConfidence_IsValid(value);
  }
  static constexpr SteeringWheelAngleConfidence SteeringWheelAngleConfidence_MIN =
    MotionConfidenceSet_SteeringWheelAngleConfidence_SteeringWheelAngleConfidence_MIN;
  static constexpr SteeringWheelAngleConfidence SteeringWheelAngleConfidence_MAX =
    MotionConfidenceSet_SteeringWheelAngleConfidence_SteeringWheelAngleConfidence_MAX;
  static constexpr int SteeringWheelAngleConfidence_ARRAYSIZE =
    MotionConfidenceSet_SteeringWheelAngleConfidence_SteeringWheelAngleConfidence_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SteeringWheelAngleConfidence_descriptor() {
    return MotionConfidenceSet_SteeringWheelAngleConfidence_descriptor();
  }
  template<typename T>
  static inline const std::string& SteeringWheelAngleConfidence_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SteeringWheelAngleConfidence>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SteeringWheelAngleConfidence_Name.");
    return MotionConfidenceSet_SteeringWheelAngleConfidence_Name(enum_t_value);
  }
  static inline bool SteeringWheelAngleConfidence_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SteeringWheelAngleConfidence* value) {
    return MotionConfidenceSet_SteeringWheelAngleConfidence_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedCfdFieldNumber = 1,
    kHeadingCfdFieldNumber = 2,
    kSteerCfdFieldNumber = 3,
  };
  // .cn.seisys.v2x.pb.SpeedConfidence speedCfd = 1;
  void clear_speedcfd();
  ::cn::seisys::v2x::pb::SpeedConfidence speedcfd() const;
  void set_speedcfd(::cn::seisys::v2x::pb::SpeedConfidence value);
  private:
  ::cn::seisys::v2x::pb::SpeedConfidence _internal_speedcfd() const;
  void _internal_set_speedcfd(::cn::seisys::v2x::pb::SpeedConfidence value);
  public:

  // .cn.seisys.v2x.pb.HeadingConfidence headingCfd = 2;
  void clear_headingcfd();
  ::cn::seisys::v2x::pb::HeadingConfidence headingcfd() const;
  void set_headingcfd(::cn::seisys::v2x::pb::HeadingConfidence value);
  private:
  ::cn::seisys::v2x::pb::HeadingConfidence _internal_headingcfd() const;
  void _internal_set_headingcfd(::cn::seisys::v2x::pb::HeadingConfidence value);
  public:

  // .cn.seisys.v2x.pb.MotionConfidenceSet.SteeringWheelAngleConfidence steerCfd = 3;
  void clear_steercfd();
  ::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence steercfd() const;
  void set_steercfd(::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence value);
  private:
  ::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence _internal_steercfd() const;
  void _internal_set_steercfd(::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.MotionConfidenceSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int speedcfd_;
    int headingcfd_;
    int steercfd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class VehicleSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.VehicleSize) */ {
 public:
  inline VehicleSize() : VehicleSize(nullptr) {}
  ~VehicleSize() override;
  explicit PROTOBUF_CONSTEXPR VehicleSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehicleSize(const VehicleSize& from);
  VehicleSize(VehicleSize&& from) noexcept
    : VehicleSize() {
    *this = ::std::move(from);
  }

  inline VehicleSize& operator=(const VehicleSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleSize& operator=(VehicleSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleSize* internal_default_instance() {
    return reinterpret_cast<const VehicleSize*>(
               &_VehicleSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VehicleSize& a, VehicleSize& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehicleSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehicleSize& from) {
    VehicleSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.VehicleSize";
  }
  protected:
  explicit VehicleSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kLengthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 length = 2;
  void clear_length();
  int32_t length() const;
  void set_length(int32_t value);
  private:
  int32_t _internal_length() const;
  void _internal_set_length(int32_t value);
  public:

  // int32 height = 3;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.VehicleSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t width_;
    int32_t length_;
    int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class NodeReferenceId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.NodeReferenceId) */ {
 public:
  inline NodeReferenceId() : NodeReferenceId(nullptr) {}
  ~NodeReferenceId() override;
  explicit PROTOBUF_CONSTEXPR NodeReferenceId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeReferenceId(const NodeReferenceId& from);
  NodeReferenceId(NodeReferenceId&& from) noexcept
    : NodeReferenceId() {
    *this = ::std::move(from);
  }

  inline NodeReferenceId& operator=(const NodeReferenceId& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeReferenceId& operator=(NodeReferenceId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeReferenceId& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeReferenceId* internal_default_instance() {
    return reinterpret_cast<const NodeReferenceId*>(
               &_NodeReferenceId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NodeReferenceId& a, NodeReferenceId& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeReferenceId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeReferenceId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeReferenceId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeReferenceId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeReferenceId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeReferenceId& from) {
    NodeReferenceId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeReferenceId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.NodeReferenceId";
  }
  protected:
  explicit NodeReferenceId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // uint32 region = 1;
  void clear_region();
  uint32_t region() const;
  void set_region(uint32_t value);
  private:
  uint32_t _internal_region() const;
  void _internal_set_region(uint32_t value);
  public:

  // uint32 nodeId = 2;
  void clear_nodeid();
  uint32_t nodeid() const;
  void set_nodeid(uint32_t value);
  private:
  uint32_t _internal_nodeid() const;
  void _internal_set_nodeid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.NodeReferenceId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t region_;
    uint32_t nodeid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class MapLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.MapLocation) */ {
 public:
  inline MapLocation() : MapLocation(nullptr) {}
  ~MapLocation() override;
  explicit PROTOBUF_CONSTEXPR MapLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapLocation(const MapLocation& from);
  MapLocation(MapLocation&& from) noexcept
    : MapLocation() {
    *this = ::std::move(from);
  }

  inline MapLocation& operator=(const MapLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapLocation& operator=(MapLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapLocation* internal_default_instance() {
    return reinterpret_cast<const MapLocation*>(
               &_MapLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MapLocation& a, MapLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(MapLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapLocation& from) {
    MapLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.MapLocation";
  }
  protected:
  explicit MapLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkNameFieldNumber = 2,
    kNodeIdFieldNumber = 1,
    kUpstreamNodeIdFieldNumber = 3,
    kSectionIdFieldNumber = 4,
    kLaneIdFieldNumber = 5,
  };
  // string linkName = 2;
  void clear_linkname();
  const std::string& linkname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_linkname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_linkname();
  PROTOBUF_NODISCARD std::string* release_linkname();
  void set_allocated_linkname(std::string* linkname);
  private:
  const std::string& _internal_linkname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_linkname(const std::string& value);
  std::string* _internal_mutable_linkname();
  public:

  // .cn.seisys.v2x.pb.NodeReferenceId nodeId = 1;
  bool has_nodeid() const;
  private:
  bool _internal_has_nodeid() const;
  public:
  void clear_nodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& nodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_nodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_nodeid();
  void set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_nodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_nodeid();
  public:
  void unsafe_arena_set_allocated_nodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_nodeid();

  // .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 3;
  bool has_upstreamnodeid() const;
  private:
  bool _internal_has_upstreamnodeid() const;
  public:
  void clear_upstreamnodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& upstreamnodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_upstreamnodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_upstreamnodeid();
  void set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_upstreamnodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_upstreamnodeid();
  public:
  void unsafe_arena_set_allocated_upstreamnodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_upstreamnodeid();

  // uint32 sectionId = 4;
  void clear_sectionid();
  uint32_t sectionid() const;
  void set_sectionid(uint32_t value);
  private:
  uint32_t _internal_sectionid() const;
  void _internal_set_sectionid(uint32_t value);
  public:

  // uint32 laneId = 5;
  void clear_laneid();
  uint32_t laneid() const;
  void set_laneid(uint32_t value);
  private:
  uint32_t _internal_laneid() const;
  void _internal_set_laneid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.MapLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr linkname_;
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid_;
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid_;
    uint32_t sectionid_;
    uint32_t laneid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class PhaseId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.PhaseId) */ {
 public:
  inline PhaseId() : PhaseId(nullptr) {}
  ~PhaseId() override;
  explicit PROTOBUF_CONSTEXPR PhaseId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseId(const PhaseId& from);
  PhaseId(PhaseId&& from) noexcept
    : PhaseId() {
    *this = ::std::move(from);
  }

  inline PhaseId& operator=(const PhaseId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseId& operator=(PhaseId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseId& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseId* internal_default_instance() {
    return reinterpret_cast<const PhaseId*>(
               &_PhaseId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PhaseId& a, PhaseId& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseId& from) {
    PhaseId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.PhaseId";
  }
  protected:
  explicit PhaseId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhaseIdFieldNumber = 1,
  };
  // uint32 phaseId = 1;
  void clear_phaseid();
  uint32_t phaseid() const;
  void set_phaseid(uint32_t value);
  private:
  uint32_t _internal_phaseid() const;
  void _internal_set_phaseid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.PhaseId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t phaseid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ReferenceLanes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ReferenceLanes) */ {
 public:
  inline ReferenceLanes() : ReferenceLanes(nullptr) {}
  ~ReferenceLanes() override;
  explicit PROTOBUF_CONSTEXPR ReferenceLanes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceLanes(const ReferenceLanes& from);
  ReferenceLanes(ReferenceLanes&& from) noexcept
    : ReferenceLanes() {
    *this = ::std::move(from);
  }

  inline ReferenceLanes& operator=(const ReferenceLanes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceLanes& operator=(ReferenceLanes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceLanes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceLanes* internal_default_instance() {
    return reinterpret_cast<const ReferenceLanes*>(
               &_ReferenceLanes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReferenceLanes& a, ReferenceLanes& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceLanes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceLanes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferenceLanes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReferenceLanes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReferenceLanes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReferenceLanes& from) {
    ReferenceLanes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceLanes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ReferenceLanes";
  }
  protected:
  explicit ReferenceLanes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceLanesFieldNumber = 1,
  };
  // uint32 referenceLanes = 1;
  void clear_referencelanes();
  uint32_t referencelanes() const;
  void set_referencelanes(uint32_t value);
  private:
  uint32_t _internal_referencelanes() const;
  void _internal_set_referencelanes(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ReferenceLanes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t referencelanes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ReferencePath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ReferencePath) */ {
 public:
  inline ReferencePath() : ReferencePath(nullptr) {}
  ~ReferencePath() override;
  explicit PROTOBUF_CONSTEXPR ReferencePath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferencePath(const ReferencePath& from);
  ReferencePath(ReferencePath&& from) noexcept
    : ReferencePath() {
    *this = ::std::move(from);
  }

  inline ReferencePath& operator=(const ReferencePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferencePath& operator=(ReferencePath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferencePath& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferencePath* internal_default_instance() {
    return reinterpret_cast<const ReferencePath*>(
               &_ReferencePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ReferencePath& a, ReferencePath& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferencePath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferencePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferencePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReferencePath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReferencePath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReferencePath& from) {
    ReferencePath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferencePath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ReferencePath";
  }
  protected:
  explicit ReferencePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivePathFieldNumber = 1,
    kPathRadiusFieldNumber = 2,
  };
  // repeated .cn.seisys.v2x.pb.Position3D activePath = 1;
  int activepath_size() const;
  private:
  int _internal_activepath_size() const;
  public:
  void clear_activepath();
  ::cn::seisys::v2x::pb::Position3D* mutable_activepath(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
      mutable_activepath();
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_activepath(int index) const;
  ::cn::seisys::v2x::pb::Position3D* _internal_add_activepath();
  public:
  const ::cn::seisys::v2x::pb::Position3D& activepath(int index) const;
  ::cn::seisys::v2x::pb::Position3D* add_activepath();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
      activepath() const;

  // uint32 pathRadius = 2;
  void clear_pathradius();
  uint32_t pathradius() const;
  void set_pathradius(uint32_t value);
  private:
  uint32_t _internal_pathradius() const;
  void _internal_set_pathradius(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ReferencePath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D > activepath_;
    uint32_t pathradius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ReferenceLink final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ReferenceLink) */ {
 public:
  inline ReferenceLink() : ReferenceLink(nullptr) {}
  ~ReferenceLink() override;
  explicit PROTOBUF_CONSTEXPR ReferenceLink(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceLink(const ReferenceLink& from);
  ReferenceLink(ReferenceLink&& from) noexcept
    : ReferenceLink() {
    *this = ::std::move(from);
  }

  inline ReferenceLink& operator=(const ReferenceLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceLink& operator=(ReferenceLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceLink* internal_default_instance() {
    return reinterpret_cast<const ReferenceLink*>(
               &_ReferenceLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ReferenceLink& a, ReferenceLink& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceLink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceLink* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferenceLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReferenceLink>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReferenceLink& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReferenceLink& from) {
    ReferenceLink::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceLink* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ReferenceLink";
  }
  protected:
  explicit ReferenceLink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpstreamNodeIdFieldNumber = 1,
    kDownstreamNodeIdFieldNumber = 2,
    kReferenceLanesFieldNumber = 3,
  };
  // .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 1;
  bool has_upstreamnodeid() const;
  private:
  bool _internal_has_upstreamnodeid() const;
  public:
  void clear_upstreamnodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& upstreamnodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_upstreamnodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_upstreamnodeid();
  void set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_upstreamnodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_upstreamnodeid();
  public:
  void unsafe_arena_set_allocated_upstreamnodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_upstreamnodeid();

  // .cn.seisys.v2x.pb.NodeReferenceId downstreamNodeId = 2;
  bool has_downstreamnodeid() const;
  private:
  bool _internal_has_downstreamnodeid() const;
  public:
  void clear_downstreamnodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& downstreamnodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_downstreamnodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_downstreamnodeid();
  void set_allocated_downstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* downstreamnodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_downstreamnodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_downstreamnodeid();
  public:
  void unsafe_arena_set_allocated_downstreamnodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* downstreamnodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_downstreamnodeid();

  // .cn.seisys.v2x.pb.ReferenceLanes referenceLanes = 3;
  bool has_referencelanes() const;
  private:
  bool _internal_has_referencelanes() const;
  public:
  void clear_referencelanes();
  const ::cn::seisys::v2x::pb::ReferenceLanes& referencelanes() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReferenceLanes* release_referencelanes();
  ::cn::seisys::v2x::pb::ReferenceLanes* mutable_referencelanes();
  void set_allocated_referencelanes(::cn::seisys::v2x::pb::ReferenceLanes* referencelanes);
  private:
  const ::cn::seisys::v2x::pb::ReferenceLanes& _internal_referencelanes() const;
  ::cn::seisys::v2x::pb::ReferenceLanes* _internal_mutable_referencelanes();
  public:
  void unsafe_arena_set_allocated_referencelanes(
      ::cn::seisys::v2x::pb::ReferenceLanes* referencelanes);
  ::cn::seisys::v2x::pb::ReferenceLanes* unsafe_arena_release_referencelanes();

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ReferenceLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid_;
    ::cn::seisys::v2x::pb::NodeReferenceId* downstreamnodeid_;
    ::cn::seisys::v2x::pb::ReferenceLanes* referencelanes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class AllowedManeuvers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.AllowedManeuvers) */ {
 public:
  inline AllowedManeuvers() : AllowedManeuvers(nullptr) {}
  ~AllowedManeuvers() override;
  explicit PROTOBUF_CONSTEXPR AllowedManeuvers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowedManeuvers(const AllowedManeuvers& from);
  AllowedManeuvers(AllowedManeuvers&& from) noexcept
    : AllowedManeuvers() {
    *this = ::std::move(from);
  }

  inline AllowedManeuvers& operator=(const AllowedManeuvers& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowedManeuvers& operator=(AllowedManeuvers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllowedManeuvers& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowedManeuvers* internal_default_instance() {
    return reinterpret_cast<const AllowedManeuvers*>(
               &_AllowedManeuvers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AllowedManeuvers& a, AllowedManeuvers& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowedManeuvers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowedManeuvers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowedManeuvers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllowedManeuvers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllowedManeuvers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllowedManeuvers& from) {
    AllowedManeuvers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllowedManeuvers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.AllowedManeuvers";
  }
  protected:
  explicit AllowedManeuvers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManeuversFieldNumber = 1,
  };
  // uint32 maneuvers = 1;
  void clear_maneuvers();
  uint32_t maneuvers() const;
  void set_maneuvers(uint32_t value);
  private:
  uint32_t _internal_maneuvers() const;
  void _internal_set_maneuvers(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.AllowedManeuvers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t maneuvers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneStatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneStatInfo) */ {
 public:
  inline LaneStatInfo() : LaneStatInfo(nullptr) {}
  ~LaneStatInfo() override;
  explicit PROTOBUF_CONSTEXPR LaneStatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneStatInfo(const LaneStatInfo& from);
  LaneStatInfo(LaneStatInfo&& from) noexcept
    : LaneStatInfo() {
    *this = ::std::move(from);
  }

  inline LaneStatInfo& operator=(const LaneStatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneStatInfo& operator=(LaneStatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneStatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneStatInfo* internal_default_instance() {
    return reinterpret_cast<const LaneStatInfo*>(
               &_LaneStatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LaneStatInfo& a, LaneStatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneStatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneStatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneStatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneStatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneStatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneStatInfo& from) {
    LaneStatInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneStatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneStatInfo";
  }
  protected:
  explicit LaneStatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtIdFieldNumber = 4,
    kLinkStatInfoFieldNumber = 2,
    kSectionStatInfoFieldNumber = 3,
    kLaneIdFieldNumber = 1,
  };
  // string extId = 4;
  void clear_extid();
  const std::string& extid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extid();
  PROTOBUF_NODISCARD std::string* release_extid();
  void set_allocated_extid(std::string* extid);
  private:
  const std::string& _internal_extid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extid(const std::string& value);
  std::string* _internal_mutable_extid();
  public:

  // .cn.seisys.v2x.pb.LinkStatInfo linkStatInfo = 2;
  bool has_linkstatinfo() const;
  private:
  bool _internal_has_linkstatinfo() const;
  public:
  void clear_linkstatinfo();
  const ::cn::seisys::v2x::pb::LinkStatInfo& linkstatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LinkStatInfo* release_linkstatinfo();
  ::cn::seisys::v2x::pb::LinkStatInfo* mutable_linkstatinfo();
  void set_allocated_linkstatinfo(::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo);
  private:
  const ::cn::seisys::v2x::pb::LinkStatInfo& _internal_linkstatinfo() const;
  ::cn::seisys::v2x::pb::LinkStatInfo* _internal_mutable_linkstatinfo();
  public:
  void unsafe_arena_set_allocated_linkstatinfo(
      ::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo);
  ::cn::seisys::v2x::pb::LinkStatInfo* unsafe_arena_release_linkstatinfo();

  // .cn.seisys.v2x.pb.SectionStatInfo sectionStatInfo = 3;
  bool has_sectionstatinfo() const;
  private:
  bool _internal_has_sectionstatinfo() const;
  public:
  void clear_sectionstatinfo();
  const ::cn::seisys::v2x::pb::SectionStatInfo& sectionstatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::SectionStatInfo* release_sectionstatinfo();
  ::cn::seisys::v2x::pb::SectionStatInfo* mutable_sectionstatinfo();
  void set_allocated_sectionstatinfo(::cn::seisys::v2x::pb::SectionStatInfo* sectionstatinfo);
  private:
  const ::cn::seisys::v2x::pb::SectionStatInfo& _internal_sectionstatinfo() const;
  ::cn::seisys::v2x::pb::SectionStatInfo* _internal_mutable_sectionstatinfo();
  public:
  void unsafe_arena_set_allocated_sectionstatinfo(
      ::cn::seisys::v2x::pb::SectionStatInfo* sectionstatinfo);
  ::cn::seisys::v2x::pb::SectionStatInfo* unsafe_arena_release_sectionstatinfo();

  // uint32 laneId = 1;
  void clear_laneid();
  uint32_t laneid() const;
  void set_laneid(uint32_t value);
  private:
  uint32_t _internal_laneid() const;
  void _internal_set_laneid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneStatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extid_;
    ::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo_;
    ::cn::seisys::v2x::pb::SectionStatInfo* sectionstatinfo_;
    uint32_t laneid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class SectionStatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.SectionStatInfo) */ {
 public:
  inline SectionStatInfo() : SectionStatInfo(nullptr) {}
  ~SectionStatInfo() override;
  explicit PROTOBUF_CONSTEXPR SectionStatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SectionStatInfo(const SectionStatInfo& from);
  SectionStatInfo(SectionStatInfo&& from) noexcept
    : SectionStatInfo() {
    *this = ::std::move(from);
  }

  inline SectionStatInfo& operator=(const SectionStatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SectionStatInfo& operator=(SectionStatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SectionStatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SectionStatInfo* internal_default_instance() {
    return reinterpret_cast<const SectionStatInfo*>(
               &_SectionStatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SectionStatInfo& a, SectionStatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SectionStatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SectionStatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SectionStatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SectionStatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SectionStatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SectionStatInfo& from) {
    SectionStatInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SectionStatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.SectionStatInfo";
  }
  protected:
  explicit SectionStatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtIdFieldNumber = 3,
    kLinkStatInfoFieldNumber = 2,
    kSectionIdFieldNumber = 1,
  };
  // string extId = 3;
  void clear_extid();
  const std::string& extid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extid();
  PROTOBUF_NODISCARD std::string* release_extid();
  void set_allocated_extid(std::string* extid);
  private:
  const std::string& _internal_extid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extid(const std::string& value);
  std::string* _internal_mutable_extid();
  public:

  // .cn.seisys.v2x.pb.LinkStatInfo linkStatInfo = 2;
  bool has_linkstatinfo() const;
  private:
  bool _internal_has_linkstatinfo() const;
  public:
  void clear_linkstatinfo();
  const ::cn::seisys::v2x::pb::LinkStatInfo& linkstatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LinkStatInfo* release_linkstatinfo();
  ::cn::seisys::v2x::pb::LinkStatInfo* mutable_linkstatinfo();
  void set_allocated_linkstatinfo(::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo);
  private:
  const ::cn::seisys::v2x::pb::LinkStatInfo& _internal_linkstatinfo() const;
  ::cn::seisys::v2x::pb::LinkStatInfo* _internal_mutable_linkstatinfo();
  public:
  void unsafe_arena_set_allocated_linkstatinfo(
      ::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo);
  ::cn::seisys::v2x::pb::LinkStatInfo* unsafe_arena_release_linkstatinfo();

  // uint32 sectionId = 1;
  void clear_sectionid();
  uint32_t sectionid() const;
  void set_sectionid(uint32_t value);
  private:
  uint32_t _internal_sectionid() const;
  void _internal_set_sectionid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.SectionStatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extid_;
    ::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo_;
    uint32_t sectionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LinkStatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LinkStatInfo) */ {
 public:
  inline LinkStatInfo() : LinkStatInfo(nullptr) {}
  ~LinkStatInfo() override;
  explicit PROTOBUF_CONSTEXPR LinkStatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinkStatInfo(const LinkStatInfo& from);
  LinkStatInfo(LinkStatInfo&& from) noexcept
    : LinkStatInfo() {
    *this = ::std::move(from);
  }

  inline LinkStatInfo& operator=(const LinkStatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkStatInfo& operator=(LinkStatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinkStatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinkStatInfo* internal_default_instance() {
    return reinterpret_cast<const LinkStatInfo*>(
               &_LinkStatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(LinkStatInfo& a, LinkStatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkStatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkStatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinkStatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinkStatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinkStatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LinkStatInfo& from) {
    LinkStatInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkStatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LinkStatInfo";
  }
  protected:
  explicit LinkStatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kExtIdFieldNumber = 4,
    kUpstreamNodeIdFieldNumber = 1,
    kNodeStatInfoFieldNumber = 3,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string extId = 4;
  void clear_extid();
  const std::string& extid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extid();
  PROTOBUF_NODISCARD std::string* release_extid();
  void set_allocated_extid(std::string* extid);
  private:
  const std::string& _internal_extid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extid(const std::string& value);
  std::string* _internal_mutable_extid();
  public:

  // .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 1;
  bool has_upstreamnodeid() const;
  private:
  bool _internal_has_upstreamnodeid() const;
  public:
  void clear_upstreamnodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& upstreamnodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_upstreamnodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_upstreamnodeid();
  void set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_upstreamnodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_upstreamnodeid();
  public:
  void unsafe_arena_set_allocated_upstreamnodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_upstreamnodeid();

  // .cn.seisys.v2x.pb.NodeStatInfo nodeStatInfo = 3;
  bool has_nodestatinfo() const;
  private:
  bool _internal_has_nodestatinfo() const;
  public:
  void clear_nodestatinfo();
  const ::cn::seisys::v2x::pb::NodeStatInfo& nodestatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeStatInfo* release_nodestatinfo();
  ::cn::seisys::v2x::pb::NodeStatInfo* mutable_nodestatinfo();
  void set_allocated_nodestatinfo(::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo);
  private:
  const ::cn::seisys::v2x::pb::NodeStatInfo& _internal_nodestatinfo() const;
  ::cn::seisys::v2x::pb::NodeStatInfo* _internal_mutable_nodestatinfo();
  public:
  void unsafe_arena_set_allocated_nodestatinfo(
      ::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo);
  ::cn::seisys::v2x::pb::NodeStatInfo* unsafe_arena_release_nodestatinfo();

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LinkStatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extid_;
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid_;
    ::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class NodeStatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.NodeStatInfo) */ {
 public:
  inline NodeStatInfo() : NodeStatInfo(nullptr) {}
  ~NodeStatInfo() override;
  explicit PROTOBUF_CONSTEXPR NodeStatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeStatInfo(const NodeStatInfo& from);
  NodeStatInfo(NodeStatInfo&& from) noexcept
    : NodeStatInfo() {
    *this = ::std::move(from);
  }

  inline NodeStatInfo& operator=(const NodeStatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStatInfo& operator=(NodeStatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeStatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeStatInfo* internal_default_instance() {
    return reinterpret_cast<const NodeStatInfo*>(
               &_NodeStatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(NodeStatInfo& a, NodeStatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeStatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeStatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeStatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeStatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeStatInfo& from) {
    NodeStatInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeStatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.NodeStatInfo";
  }
  protected:
  explicit NodeStatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
  };
  // .cn.seisys.v2x.pb.NodeReferenceId nodeId = 1;
  bool has_nodeid() const;
  private:
  bool _internal_has_nodeid() const;
  public:
  void clear_nodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& nodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_nodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_nodeid();
  void set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_nodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_nodeid();
  public:
  void unsafe_arena_set_allocated_nodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_nodeid();

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.NodeStatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class MovementStatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.MovementStatInfo) */ {
 public:
  inline MovementStatInfo() : MovementStatInfo(nullptr) {}
  ~MovementStatInfo() override;
  explicit PROTOBUF_CONSTEXPR MovementStatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovementStatInfo(const MovementStatInfo& from);
  MovementStatInfo(MovementStatInfo&& from) noexcept
    : MovementStatInfo() {
    *this = ::std::move(from);
  }

  inline MovementStatInfo& operator=(const MovementStatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovementStatInfo& operator=(MovementStatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovementStatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovementStatInfo* internal_default_instance() {
    return reinterpret_cast<const MovementStatInfo*>(
               &_MovementStatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MovementStatInfo& a, MovementStatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MovementStatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovementStatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovementStatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MovementStatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MovementStatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MovementStatInfo& from) {
    MovementStatInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovementStatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.MovementStatInfo";
  }
  protected:
  explicit MovementStatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtIdFieldNumber = 4,
    kRemoteIntersectionFieldNumber = 1,
    kNodeStatInfoFieldNumber = 3,
    kTurnDirectionFieldNumber = 2,
  };
  // string extId = 4;
  void clear_extid();
  const std::string& extid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extid();
  PROTOBUF_NODISCARD std::string* release_extid();
  void set_allocated_extid(std::string* extid);
  private:
  const std::string& _internal_extid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extid(const std::string& value);
  std::string* _internal_mutable_extid();
  public:

  // .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
  bool has_remoteintersection() const;
  private:
  bool _internal_has_remoteintersection() const;
  public:
  void clear_remoteintersection();
  const ::cn::seisys::v2x::pb::NodeReferenceId& remoteintersection() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_remoteintersection();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_remoteintersection();
  void set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_remoteintersection() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_remoteintersection();
  public:
  void unsafe_arena_set_allocated_remoteintersection(
      ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_remoteintersection();

  // .cn.seisys.v2x.pb.NodeStatInfo nodeStatInfo = 3;
  bool has_nodestatinfo() const;
  private:
  bool _internal_has_nodestatinfo() const;
  public:
  void clear_nodestatinfo();
  const ::cn::seisys::v2x::pb::NodeStatInfo& nodestatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeStatInfo* release_nodestatinfo();
  ::cn::seisys::v2x::pb::NodeStatInfo* mutable_nodestatinfo();
  void set_allocated_nodestatinfo(::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo);
  private:
  const ::cn::seisys::v2x::pb::NodeStatInfo& _internal_nodestatinfo() const;
  ::cn::seisys::v2x::pb::NodeStatInfo* _internal_mutable_nodestatinfo();
  public:
  void unsafe_arena_set_allocated_nodestatinfo(
      ::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo);
  ::cn::seisys::v2x::pb::NodeStatInfo* unsafe_arena_release_nodestatinfo();

  // .cn.seisys.v2x.pb.Maneuver turnDirection = 2;
  void clear_turndirection();
  ::cn::seisys::v2x::pb::Maneuver turndirection() const;
  void set_turndirection(::cn::seisys::v2x::pb::Maneuver value);
  private:
  ::cn::seisys::v2x::pb::Maneuver _internal_turndirection() const;
  void _internal_set_turndirection(::cn::seisys::v2x::pb::Maneuver value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.MovementStatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extid_;
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection_;
    ::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo_;
    int turndirection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class TrafficFlowStatByInterval final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.TrafficFlowStatByInterval) */ {
 public:
  inline TrafficFlowStatByInterval() : TrafficFlowStatByInterval(nullptr) {}
  ~TrafficFlowStatByInterval() override;
  explicit PROTOBUF_CONSTEXPR TrafficFlowStatByInterval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficFlowStatByInterval(const TrafficFlowStatByInterval& from);
  TrafficFlowStatByInterval(TrafficFlowStatByInterval&& from) noexcept
    : TrafficFlowStatByInterval() {
    *this = ::std::move(from);
  }

  inline TrafficFlowStatByInterval& operator=(const TrafficFlowStatByInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficFlowStatByInterval& operator=(TrafficFlowStatByInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficFlowStatByInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficFlowStatByInterval* internal_default_instance() {
    return reinterpret_cast<const TrafficFlowStatByInterval*>(
               &_TrafficFlowStatByInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TrafficFlowStatByInterval& a, TrafficFlowStatByInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficFlowStatByInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficFlowStatByInterval* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficFlowStatByInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficFlowStatByInterval>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficFlowStatByInterval& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrafficFlowStatByInterval& from) {
    TrafficFlowStatByInterval::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlowStatByInterval* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.TrafficFlowStatByInterval";
  }
  protected:
  explicit TrafficFlowStatByInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 1,
  };
  // uint32 interval = 1;
  void clear_interval();
  uint32_t interval() const;
  void set_interval(uint32_t value);
  private:
  uint32_t _internal_interval() const;
  void _internal_set_interval(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.TrafficFlowStatByInterval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t interval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class TrafficFlowStatBySignalCycle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle) */ {
 public:
  inline TrafficFlowStatBySignalCycle() : TrafficFlowStatBySignalCycle(nullptr) {}
  ~TrafficFlowStatBySignalCycle() override;
  explicit PROTOBUF_CONSTEXPR TrafficFlowStatBySignalCycle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficFlowStatBySignalCycle(const TrafficFlowStatBySignalCycle& from);
  TrafficFlowStatBySignalCycle(TrafficFlowStatBySignalCycle&& from) noexcept
    : TrafficFlowStatBySignalCycle() {
    *this = ::std::move(from);
  }

  inline TrafficFlowStatBySignalCycle& operator=(const TrafficFlowStatBySignalCycle& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficFlowStatBySignalCycle& operator=(TrafficFlowStatBySignalCycle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficFlowStatBySignalCycle& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficFlowStatBySignalCycle* internal_default_instance() {
    return reinterpret_cast<const TrafficFlowStatBySignalCycle*>(
               &_TrafficFlowStatBySignalCycle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TrafficFlowStatBySignalCycle& a, TrafficFlowStatBySignalCycle& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficFlowStatBySignalCycle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficFlowStatBySignalCycle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficFlowStatBySignalCycle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficFlowStatBySignalCycle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficFlowStatBySignalCycle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrafficFlowStatBySignalCycle& from) {
    TrafficFlowStatBySignalCycle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlowStatBySignalCycle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle";
  }
  protected:
  explicit TrafficFlowStatBySignalCycle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCycleStartTimeFieldNumber = 1,
    kCycleEndTimeFieldNumber = 2,
    kCycleTimeFieldNumber = 3,
  };
  // uint64 cycleStartTime = 1;
  void clear_cyclestarttime();
  uint64_t cyclestarttime() const;
  void set_cyclestarttime(uint64_t value);
  private:
  uint64_t _internal_cyclestarttime() const;
  void _internal_set_cyclestarttime(uint64_t value);
  public:

  // uint64 cycleEndTime = 2;
  void clear_cycleendtime();
  uint64_t cycleendtime() const;
  void set_cycleendtime(uint64_t value);
  private:
  uint64_t _internal_cycleendtime() const;
  void _internal_set_cycleendtime(uint64_t value);
  public:

  // uint32 cycleTime = 3;
  void clear_cycletime();
  uint32_t cycletime() const;
  void set_cycletime(uint32_t value);
  private:
  uint32_t _internal_cycletime() const;
  void _internal_set_cycletime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t cyclestarttime_;
    uint64_t cycleendtime_;
    uint32_t cycletime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class TrafficFlowStatType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.TrafficFlowStatType) */ {
 public:
  inline TrafficFlowStatType() : TrafficFlowStatType(nullptr) {}
  ~TrafficFlowStatType() override;
  explicit PROTOBUF_CONSTEXPR TrafficFlowStatType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficFlowStatType(const TrafficFlowStatType& from);
  TrafficFlowStatType(TrafficFlowStatType&& from) noexcept
    : TrafficFlowStatType() {
    *this = ::std::move(from);
  }

  inline TrafficFlowStatType& operator=(const TrafficFlowStatType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficFlowStatType& operator=(TrafficFlowStatType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficFlowStatType& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficFlowStatType* internal_default_instance() {
    return reinterpret_cast<const TrafficFlowStatType*>(
               &_TrafficFlowStatType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TrafficFlowStatType& a, TrafficFlowStatType& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficFlowStatType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficFlowStatType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficFlowStatType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficFlowStatType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficFlowStatType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrafficFlowStatType& from) {
    TrafficFlowStatType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlowStatType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.TrafficFlowStatType";
  }
  protected:
  explicit TrafficFlowStatType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalFieldNumber = 1,
    kSequenceFieldNumber = 2,
  };
  // .cn.seisys.v2x.pb.TrafficFlowStatByInterval interval = 1;
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const ::cn::seisys::v2x::pb::TrafficFlowStatByInterval& interval() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* release_interval();
  ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* mutable_interval();
  void set_allocated_interval(::cn::seisys::v2x::pb::TrafficFlowStatByInterval* interval);
  private:
  const ::cn::seisys::v2x::pb::TrafficFlowStatByInterval& _internal_interval() const;
  ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* interval);
  ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* unsafe_arena_release_interval();

  // .cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle sequence = 2;
  bool has_sequence() const;
  private:
  bool _internal_has_sequence() const;
  public:
  void clear_sequence();
  const ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle& sequence() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* release_sequence();
  ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* mutable_sequence();
  void set_allocated_sequence(::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* sequence);
  private:
  const ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle& _internal_sequence() const;
  ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* _internal_mutable_sequence();
  public:
  void unsafe_arena_set_allocated_sequence(
      ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* sequence);
  ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* unsafe_arena_release_sequence();

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.TrafficFlowStatType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* interval_;
    ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class TrafficFlowStatMapElement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.TrafficFlowStatMapElement) */ {
 public:
  inline TrafficFlowStatMapElement() : TrafficFlowStatMapElement(nullptr) {}
  ~TrafficFlowStatMapElement() override;
  explicit PROTOBUF_CONSTEXPR TrafficFlowStatMapElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficFlowStatMapElement(const TrafficFlowStatMapElement& from);
  TrafficFlowStatMapElement(TrafficFlowStatMapElement&& from) noexcept
    : TrafficFlowStatMapElement() {
    *this = ::std::move(from);
  }

  inline TrafficFlowStatMapElement& operator=(const TrafficFlowStatMapElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficFlowStatMapElement& operator=(TrafficFlowStatMapElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficFlowStatMapElement& default_instance() {
    return *internal_default_instance();
  }
  enum TrafficFlowStatMapElementOneOfCase {
    kDetectorArea = 1,
    kLaneStatInfo = 2,
    kSectionStatInfo = 3,
    kLinkStatInfo = 4,
    kNodeStatInfo = 5,
    kMovementStatInfo = 6,
    TRAFFICFLOWSTATMAPELEMENTONEOF_NOT_SET = 0,
  };

  static inline const TrafficFlowStatMapElement* internal_default_instance() {
    return reinterpret_cast<const TrafficFlowStatMapElement*>(
               &_TrafficFlowStatMapElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TrafficFlowStatMapElement& a, TrafficFlowStatMapElement& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficFlowStatMapElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficFlowStatMapElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficFlowStatMapElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficFlowStatMapElement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficFlowStatMapElement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrafficFlowStatMapElement& from) {
    TrafficFlowStatMapElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlowStatMapElement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.TrafficFlowStatMapElement";
  }
  protected:
  explicit TrafficFlowStatMapElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectorAreaFieldNumber = 1,
    kLaneStatInfoFieldNumber = 2,
    kSectionStatInfoFieldNumber = 3,
    kLinkStatInfoFieldNumber = 4,
    kNodeStatInfoFieldNumber = 5,
    kMovementStatInfoFieldNumber = 6,
  };
  // .cn.seisys.v2x.pb.DetectorArea detectorArea = 1;
  bool has_detectorarea() const;
  private:
  bool _internal_has_detectorarea() const;
  public:
  void clear_detectorarea();
  const ::cn::seisys::v2x::pb::DetectorArea& detectorarea() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::DetectorArea* release_detectorarea();
  ::cn::seisys::v2x::pb::DetectorArea* mutable_detectorarea();
  void set_allocated_detectorarea(::cn::seisys::v2x::pb::DetectorArea* detectorarea);
  private:
  const ::cn::seisys::v2x::pb::DetectorArea& _internal_detectorarea() const;
  ::cn::seisys::v2x::pb::DetectorArea* _internal_mutable_detectorarea();
  public:
  void unsafe_arena_set_allocated_detectorarea(
      ::cn::seisys::v2x::pb::DetectorArea* detectorarea);
  ::cn::seisys::v2x::pb::DetectorArea* unsafe_arena_release_detectorarea();

  // .cn.seisys.v2x.pb.LaneStatInfo laneStatInfo = 2;
  bool has_lanestatinfo() const;
  private:
  bool _internal_has_lanestatinfo() const;
  public:
  void clear_lanestatinfo();
  const ::cn::seisys::v2x::pb::LaneStatInfo& lanestatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneStatInfo* release_lanestatinfo();
  ::cn::seisys::v2x::pb::LaneStatInfo* mutable_lanestatinfo();
  void set_allocated_lanestatinfo(::cn::seisys::v2x::pb::LaneStatInfo* lanestatinfo);
  private:
  const ::cn::seisys::v2x::pb::LaneStatInfo& _internal_lanestatinfo() const;
  ::cn::seisys::v2x::pb::LaneStatInfo* _internal_mutable_lanestatinfo();
  public:
  void unsafe_arena_set_allocated_lanestatinfo(
      ::cn::seisys::v2x::pb::LaneStatInfo* lanestatinfo);
  ::cn::seisys::v2x::pb::LaneStatInfo* unsafe_arena_release_lanestatinfo();

  // .cn.seisys.v2x.pb.SectionStatInfo sectionStatInfo = 3;
  bool has_sectionstatinfo() const;
  private:
  bool _internal_has_sectionstatinfo() const;
  public:
  void clear_sectionstatinfo();
  const ::cn::seisys::v2x::pb::SectionStatInfo& sectionstatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::SectionStatInfo* release_sectionstatinfo();
  ::cn::seisys::v2x::pb::SectionStatInfo* mutable_sectionstatinfo();
  void set_allocated_sectionstatinfo(::cn::seisys::v2x::pb::SectionStatInfo* sectionstatinfo);
  private:
  const ::cn::seisys::v2x::pb::SectionStatInfo& _internal_sectionstatinfo() const;
  ::cn::seisys::v2x::pb::SectionStatInfo* _internal_mutable_sectionstatinfo();
  public:
  void unsafe_arena_set_allocated_sectionstatinfo(
      ::cn::seisys::v2x::pb::SectionStatInfo* sectionstatinfo);
  ::cn::seisys::v2x::pb::SectionStatInfo* unsafe_arena_release_sectionstatinfo();

  // .cn.seisys.v2x.pb.LinkStatInfo linkStatInfo = 4;
  bool has_linkstatinfo() const;
  private:
  bool _internal_has_linkstatinfo() const;
  public:
  void clear_linkstatinfo();
  const ::cn::seisys::v2x::pb::LinkStatInfo& linkstatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LinkStatInfo* release_linkstatinfo();
  ::cn::seisys::v2x::pb::LinkStatInfo* mutable_linkstatinfo();
  void set_allocated_linkstatinfo(::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo);
  private:
  const ::cn::seisys::v2x::pb::LinkStatInfo& _internal_linkstatinfo() const;
  ::cn::seisys::v2x::pb::LinkStatInfo* _internal_mutable_linkstatinfo();
  public:
  void unsafe_arena_set_allocated_linkstatinfo(
      ::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo);
  ::cn::seisys::v2x::pb::LinkStatInfo* unsafe_arena_release_linkstatinfo();

  // .cn.seisys.v2x.pb.NodeStatInfo nodeStatInfo = 5;
  bool has_nodestatinfo() const;
  private:
  bool _internal_has_nodestatinfo() const;
  public:
  void clear_nodestatinfo();
  const ::cn::seisys::v2x::pb::NodeStatInfo& nodestatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeStatInfo* release_nodestatinfo();
  ::cn::seisys::v2x::pb::NodeStatInfo* mutable_nodestatinfo();
  void set_allocated_nodestatinfo(::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo);
  private:
  const ::cn::seisys::v2x::pb::NodeStatInfo& _internal_nodestatinfo() const;
  ::cn::seisys::v2x::pb::NodeStatInfo* _internal_mutable_nodestatinfo();
  public:
  void unsafe_arena_set_allocated_nodestatinfo(
      ::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo);
  ::cn::seisys::v2x::pb::NodeStatInfo* unsafe_arena_release_nodestatinfo();

  // .cn.seisys.v2x.pb.MovementStatInfo movementStatInfo = 6;
  bool has_movementstatinfo() const;
  private:
  bool _internal_has_movementstatinfo() const;
  public:
  void clear_movementstatinfo();
  const ::cn::seisys::v2x::pb::MovementStatInfo& movementstatinfo() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::MovementStatInfo* release_movementstatinfo();
  ::cn::seisys::v2x::pb::MovementStatInfo* mutable_movementstatinfo();
  void set_allocated_movementstatinfo(::cn::seisys::v2x::pb::MovementStatInfo* movementstatinfo);
  private:
  const ::cn::seisys::v2x::pb::MovementStatInfo& _internal_movementstatinfo() const;
  ::cn::seisys::v2x::pb::MovementStatInfo* _internal_mutable_movementstatinfo();
  public:
  void unsafe_arena_set_allocated_movementstatinfo(
      ::cn::seisys::v2x::pb::MovementStatInfo* movementstatinfo);
  ::cn::seisys::v2x::pb::MovementStatInfo* unsafe_arena_release_movementstatinfo();

  void clear_TrafficFlowStatMapElementOneOf();
  TrafficFlowStatMapElementOneOfCase TrafficFlowStatMapElementOneOf_case() const;
  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.TrafficFlowStatMapElement)
 private:
  class _Internal;
  void set_has_detectorarea();
  void set_has_lanestatinfo();
  void set_has_sectionstatinfo();
  void set_has_linkstatinfo();
  void set_has_nodestatinfo();
  void set_has_movementstatinfo();

  inline bool has_TrafficFlowStatMapElementOneOf() const;
  inline void clear_has_TrafficFlowStatMapElementOneOf();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TrafficFlowStatMapElementOneOfUnion {
      constexpr TrafficFlowStatMapElementOneOfUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::cn::seisys::v2x::pb::DetectorArea* detectorarea_;
      ::cn::seisys::v2x::pb::LaneStatInfo* lanestatinfo_;
      ::cn::seisys::v2x::pb::SectionStatInfo* sectionstatinfo_;
      ::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo_;
      ::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo_;
      ::cn::seisys::v2x::pb::MovementStatInfo* movementstatinfo_;
    } TrafficFlowStatMapElementOneOf_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneIndexAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneIndexAdded) */ {
 public:
  inline LaneIndexAdded() : LaneIndexAdded(nullptr) {}
  ~LaneIndexAdded() override;
  explicit PROTOBUF_CONSTEXPR LaneIndexAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneIndexAdded(const LaneIndexAdded& from);
  LaneIndexAdded(LaneIndexAdded&& from) noexcept
    : LaneIndexAdded() {
    *this = ::std::move(from);
  }

  inline LaneIndexAdded& operator=(const LaneIndexAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneIndexAdded& operator=(LaneIndexAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneIndexAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneIndexAdded* internal_default_instance() {
    return reinterpret_cast<const LaneIndexAdded*>(
               &_LaneIndexAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(LaneIndexAdded& a, LaneIndexAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneIndexAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneIndexAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneIndexAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneIndexAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneIndexAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneIndexAdded& from) {
    LaneIndexAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneIndexAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneIndexAdded";
  }
  protected:
  explicit LaneIndexAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kLaneCapacityFieldNumber = 2,
    kLaneSaturationFieldNumber = 3,
    kLaneSpaceOccupyFieldNumber = 4,
    kLaneTimeOccupyFieldNumber = 5,
    kLaneAvgGrnQueueFieldNumber = 6,
    kLaneGrnUtilizationFieldNumber = 7,
  };
  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 laneCapacity = 2;
  void clear_lanecapacity();
  uint32_t lanecapacity() const;
  void set_lanecapacity(uint32_t value);
  private:
  uint32_t _internal_lanecapacity() const;
  void _internal_set_lanecapacity(uint32_t value);
  public:

  // uint32 laneSaturation = 3;
  void clear_lanesaturation();
  uint32_t lanesaturation() const;
  void set_lanesaturation(uint32_t value);
  private:
  uint32_t _internal_lanesaturation() const;
  void _internal_set_lanesaturation(uint32_t value);
  public:

  // uint32 laneSpaceOccupy = 4;
  void clear_lanespaceoccupy();
  uint32_t lanespaceoccupy() const;
  void set_lanespaceoccupy(uint32_t value);
  private:
  uint32_t _internal_lanespaceoccupy() const;
  void _internal_set_lanespaceoccupy(uint32_t value);
  public:

  // uint32 laneTimeOccupy = 5;
  void clear_lanetimeoccupy();
  uint32_t lanetimeoccupy() const;
  void set_lanetimeoccupy(uint32_t value);
  private:
  uint32_t _internal_lanetimeoccupy() const;
  void _internal_set_lanetimeoccupy(uint32_t value);
  public:

  // uint32 laneAvgGrnQueue = 6;
  void clear_laneavggrnqueue();
  uint32_t laneavggrnqueue() const;
  void set_laneavggrnqueue(uint32_t value);
  private:
  uint32_t _internal_laneavggrnqueue() const;
  void _internal_set_laneavggrnqueue(uint32_t value);
  public:

  // uint32 laneGrnUtilization = 7;
  void clear_lanegrnutilization();
  uint32_t lanegrnutilization() const;
  void set_lanegrnutilization(uint32_t value);
  private:
  uint32_t _internal_lanegrnutilization() const;
  void _internal_set_lanegrnutilization(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneIndexAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t timestamp_;
    uint32_t lanecapacity_;
    uint32_t lanesaturation_;
    uint32_t lanespaceoccupy_;
    uint32_t lanetimeoccupy_;
    uint32_t laneavggrnqueue_;
    uint32_t lanegrnutilization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LinkIndexAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LinkIndexAdded) */ {
 public:
  inline LinkIndexAdded() : LinkIndexAdded(nullptr) {}
  ~LinkIndexAdded() override;
  explicit PROTOBUF_CONSTEXPR LinkIndexAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinkIndexAdded(const LinkIndexAdded& from);
  LinkIndexAdded(LinkIndexAdded&& from) noexcept
    : LinkIndexAdded() {
    *this = ::std::move(from);
  }

  inline LinkIndexAdded& operator=(const LinkIndexAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkIndexAdded& operator=(LinkIndexAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinkIndexAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinkIndexAdded* internal_default_instance() {
    return reinterpret_cast<const LinkIndexAdded*>(
               &_LinkIndexAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(LinkIndexAdded& a, LinkIndexAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkIndexAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkIndexAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinkIndexAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinkIndexAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinkIndexAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LinkIndexAdded& from) {
    LinkIndexAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkIndexAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LinkIndexAdded";
  }
  protected:
  explicit LinkIndexAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kLinkCapacityFieldNumber = 2,
    kLinkSaturationFieldNumber = 3,
    kLinkSpaceOccupyFieldNumber = 4,
    kLinkTimeOccupyFieldNumber = 5,
    kLinkAvgGrnQueueFieldNumber = 6,
    kLinkGrnUtilizationFieldNumber = 7,
  };
  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 linkCapacity = 2;
  void clear_linkcapacity();
  uint32_t linkcapacity() const;
  void set_linkcapacity(uint32_t value);
  private:
  uint32_t _internal_linkcapacity() const;
  void _internal_set_linkcapacity(uint32_t value);
  public:

  // uint32 linkSaturation = 3;
  void clear_linksaturation();
  uint32_t linksaturation() const;
  void set_linksaturation(uint32_t value);
  private:
  uint32_t _internal_linksaturation() const;
  void _internal_set_linksaturation(uint32_t value);
  public:

  // uint32 linkSpaceOccupy = 4;
  void clear_linkspaceoccupy();
  uint32_t linkspaceoccupy() const;
  void set_linkspaceoccupy(uint32_t value);
  private:
  uint32_t _internal_linkspaceoccupy() const;
  void _internal_set_linkspaceoccupy(uint32_t value);
  public:

  // uint32 linkTimeOccupy = 5;
  void clear_linktimeoccupy();
  uint32_t linktimeoccupy() const;
  void set_linktimeoccupy(uint32_t value);
  private:
  uint32_t _internal_linktimeoccupy() const;
  void _internal_set_linktimeoccupy(uint32_t value);
  public:

  // uint32 linkAvgGrnQueue = 6;
  void clear_linkavggrnqueue();
  uint32_t linkavggrnqueue() const;
  void set_linkavggrnqueue(uint32_t value);
  private:
  uint32_t _internal_linkavggrnqueue() const;
  void _internal_set_linkavggrnqueue(uint32_t value);
  public:

  // uint32 linkGrnUtilization = 7;
  void clear_linkgrnutilization();
  uint32_t linkgrnutilization() const;
  void set_linkgrnutilization(uint32_t value);
  private:
  uint32_t _internal_linkgrnutilization() const;
  void _internal_set_linkgrnutilization(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LinkIndexAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t timestamp_;
    uint32_t linkcapacity_;
    uint32_t linksaturation_;
    uint32_t linkspaceoccupy_;
    uint32_t linktimeoccupy_;
    uint32_t linkavggrnqueue_;
    uint32_t linkgrnutilization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class MovementIndexAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.MovementIndexAdded) */ {
 public:
  inline MovementIndexAdded() : MovementIndexAdded(nullptr) {}
  ~MovementIndexAdded() override;
  explicit PROTOBUF_CONSTEXPR MovementIndexAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovementIndexAdded(const MovementIndexAdded& from);
  MovementIndexAdded(MovementIndexAdded&& from) noexcept
    : MovementIndexAdded() {
    *this = ::std::move(from);
  }

  inline MovementIndexAdded& operator=(const MovementIndexAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovementIndexAdded& operator=(MovementIndexAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovementIndexAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovementIndexAdded* internal_default_instance() {
    return reinterpret_cast<const MovementIndexAdded*>(
               &_MovementIndexAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MovementIndexAdded& a, MovementIndexAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(MovementIndexAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovementIndexAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovementIndexAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MovementIndexAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MovementIndexAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MovementIndexAdded& from) {
    MovementIndexAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovementIndexAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.MovementIndexAdded";
  }
  protected:
  explicit MovementIndexAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kMovementCapacityFieldNumber = 2,
    kMovementSaturationFieldNumber = 3,
    kMovementSpaceOccupyFieldNumber = 4,
    kMovementTimeOccupyFieldNumber = 5,
    kMovementAvgGrnQueueFieldNumber = 6,
    kMovementGrnUtilizationFieldNumber = 7,
  };
  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 movementCapacity = 2;
  void clear_movementcapacity();
  uint32_t movementcapacity() const;
  void set_movementcapacity(uint32_t value);
  private:
  uint32_t _internal_movementcapacity() const;
  void _internal_set_movementcapacity(uint32_t value);
  public:

  // uint32 movementSaturation = 3;
  void clear_movementsaturation();
  uint32_t movementsaturation() const;
  void set_movementsaturation(uint32_t value);
  private:
  uint32_t _internal_movementsaturation() const;
  void _internal_set_movementsaturation(uint32_t value);
  public:

  // uint32 movementSpaceOccupy = 4;
  void clear_movementspaceoccupy();
  uint32_t movementspaceoccupy() const;
  void set_movementspaceoccupy(uint32_t value);
  private:
  uint32_t _internal_movementspaceoccupy() const;
  void _internal_set_movementspaceoccupy(uint32_t value);
  public:

  // uint32 movementTimeOccupy = 5;
  void clear_movementtimeoccupy();
  uint32_t movementtimeoccupy() const;
  void set_movementtimeoccupy(uint32_t value);
  private:
  uint32_t _internal_movementtimeoccupy() const;
  void _internal_set_movementtimeoccupy(uint32_t value);
  public:

  // uint32 movementAvgGrnQueue = 6;
  void clear_movementavggrnqueue();
  uint32_t movementavggrnqueue() const;
  void set_movementavggrnqueue(uint32_t value);
  private:
  uint32_t _internal_movementavggrnqueue() const;
  void _internal_set_movementavggrnqueue(uint32_t value);
  public:

  // uint32 movementGrnUtilization = 7;
  void clear_movementgrnutilization();
  uint32_t movementgrnutilization() const;
  void set_movementgrnutilization(uint32_t value);
  private:
  uint32_t _internal_movementgrnutilization() const;
  void _internal_set_movementgrnutilization(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.MovementIndexAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t timestamp_;
    uint32_t movementcapacity_;
    uint32_t movementsaturation_;
    uint32_t movementspaceoccupy_;
    uint32_t movementtimeoccupy_;
    uint32_t movementavggrnqueue_;
    uint32_t movementgrnutilization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class NodeIndexAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.NodeIndexAdded) */ {
 public:
  inline NodeIndexAdded() : NodeIndexAdded(nullptr) {}
  ~NodeIndexAdded() override;
  explicit PROTOBUF_CONSTEXPR NodeIndexAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeIndexAdded(const NodeIndexAdded& from);
  NodeIndexAdded(NodeIndexAdded&& from) noexcept
    : NodeIndexAdded() {
    *this = ::std::move(from);
  }

  inline NodeIndexAdded& operator=(const NodeIndexAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeIndexAdded& operator=(NodeIndexAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeIndexAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeIndexAdded* internal_default_instance() {
    return reinterpret_cast<const NodeIndexAdded*>(
               &_NodeIndexAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(NodeIndexAdded& a, NodeIndexAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeIndexAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeIndexAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeIndexAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeIndexAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeIndexAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeIndexAdded& from) {
    NodeIndexAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeIndexAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.NodeIndexAdded";
  }
  protected:
  explicit NodeIndexAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kNodeSpaceOccupyFieldNumber = 2,
    kNodeTimeOccupyFieldNumber = 3,
    kNodeCapacityFieldNumber = 4,
    kNodeSaturationFieldNumber = 5,
    kNodeGrnUtilizationFieldNumber = 6,
    kNodeAvgGrnQueueFieldNumber = 7,
    kDemandIndexFieldNumber = 8,
    kSupplyIndexFieldNumber = 9,
    kTheoryIndexFieldNumber = 10,
  };
  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 nodeSpaceOccupy = 2;
  void clear_nodespaceoccupy();
  uint32_t nodespaceoccupy() const;
  void set_nodespaceoccupy(uint32_t value);
  private:
  uint32_t _internal_nodespaceoccupy() const;
  void _internal_set_nodespaceoccupy(uint32_t value);
  public:

  // uint32 nodeTimeOccupy = 3;
  void clear_nodetimeoccupy();
  uint32_t nodetimeoccupy() const;
  void set_nodetimeoccupy(uint32_t value);
  private:
  uint32_t _internal_nodetimeoccupy() const;
  void _internal_set_nodetimeoccupy(uint32_t value);
  public:

  // uint64 nodeCapacity = 4;
  void clear_nodecapacity();
  uint64_t nodecapacity() const;
  void set_nodecapacity(uint64_t value);
  private:
  uint64_t _internal_nodecapacity() const;
  void _internal_set_nodecapacity(uint64_t value);
  public:

  // uint32 nodeSaturation = 5;
  void clear_nodesaturation();
  uint32_t nodesaturation() const;
  void set_nodesaturation(uint32_t value);
  private:
  uint32_t _internal_nodesaturation() const;
  void _internal_set_nodesaturation(uint32_t value);
  public:

  // uint32 nodeGrnUtilization = 6;
  void clear_nodegrnutilization();
  uint32_t nodegrnutilization() const;
  void set_nodegrnutilization(uint32_t value);
  private:
  uint32_t _internal_nodegrnutilization() const;
  void _internal_set_nodegrnutilization(uint32_t value);
  public:

  // uint32 nodeAvgGrnQueue = 7;
  void clear_nodeavggrnqueue();
  uint32_t nodeavggrnqueue() const;
  void set_nodeavggrnqueue(uint32_t value);
  private:
  uint32_t _internal_nodeavggrnqueue() const;
  void _internal_set_nodeavggrnqueue(uint32_t value);
  public:

  // uint32 demandIndex = 8;
  void clear_demandindex();
  uint32_t demandindex() const;
  void set_demandindex(uint32_t value);
  private:
  uint32_t _internal_demandindex() const;
  void _internal_set_demandindex(uint32_t value);
  public:

  // uint32 supplyIndex = 9;
  void clear_supplyindex();
  uint32_t supplyindex() const;
  void set_supplyindex(uint32_t value);
  private:
  uint32_t _internal_supplyindex() const;
  void _internal_set_supplyindex(uint32_t value);
  public:

  // uint32 theoryIndex = 10;
  void clear_theoryindex();
  uint32_t theoryindex() const;
  void set_theoryindex(uint32_t value);
  private:
  uint32_t _internal_theoryindex() const;
  void _internal_set_theoryindex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.NodeIndexAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t timestamp_;
    uint32_t nodespaceoccupy_;
    uint32_t nodetimeoccupy_;
    uint64_t nodecapacity_;
    uint32_t nodesaturation_;
    uint32_t nodegrnutilization_;
    uint32_t nodeavggrnqueue_;
    uint32_t demandindex_;
    uint32_t supplyindex_;
    uint32_t theoryindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class SignalControlIndexAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.SignalControlIndexAdded) */ {
 public:
  inline SignalControlIndexAdded() : SignalControlIndexAdded(nullptr) {}
  ~SignalControlIndexAdded() override;
  explicit PROTOBUF_CONSTEXPR SignalControlIndexAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalControlIndexAdded(const SignalControlIndexAdded& from);
  SignalControlIndexAdded(SignalControlIndexAdded&& from) noexcept
    : SignalControlIndexAdded() {
    *this = ::std::move(from);
  }

  inline SignalControlIndexAdded& operator=(const SignalControlIndexAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalControlIndexAdded& operator=(SignalControlIndexAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalControlIndexAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalControlIndexAdded* internal_default_instance() {
    return reinterpret_cast<const SignalControlIndexAdded*>(
               &_SignalControlIndexAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SignalControlIndexAdded& a, SignalControlIndexAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalControlIndexAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalControlIndexAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalControlIndexAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalControlIndexAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalControlIndexAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalControlIndexAdded& from) {
    SignalControlIndexAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalControlIndexAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.SignalControlIndexAdded";
  }
  protected:
  explicit SignalControlIndexAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhaseIdFieldNumber = 1,
    kGreenStartQueueFieldNumber = 2,
    kRedStartQueueFieldNumber = 3,
    kGreenUtilizationFieldNumber = 4,
  };
  // uint32 phaseId = 1;
  void clear_phaseid();
  uint32_t phaseid() const;
  void set_phaseid(uint32_t value);
  private:
  uint32_t _internal_phaseid() const;
  void _internal_set_phaseid(uint32_t value);
  public:

  // uint32 greenStartQueue = 2;
  void clear_greenstartqueue();
  uint32_t greenstartqueue() const;
  void set_greenstartqueue(uint32_t value);
  private:
  uint32_t _internal_greenstartqueue() const;
  void _internal_set_greenstartqueue(uint32_t value);
  public:

  // uint32 redStartQueue = 3;
  void clear_redstartqueue();
  uint32_t redstartqueue() const;
  void set_redstartqueue(uint32_t value);
  private:
  uint32_t _internal_redstartqueue() const;
  void _internal_set_redstartqueue(uint32_t value);
  public:

  // uint32 greenUtilization = 4;
  void clear_greenutilization();
  uint32_t greenutilization() const;
  void set_greenutilization(uint32_t value);
  private:
  uint32_t _internal_greenutilization() const;
  void _internal_set_greenutilization(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.SignalControlIndexAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t phaseid_;
    uint32_t greenstartqueue_;
    uint32_t redstartqueue_;
    uint32_t greenutilization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class TrafficFlowExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.TrafficFlowExtension) */ {
 public:
  inline TrafficFlowExtension() : TrafficFlowExtension(nullptr) {}
  ~TrafficFlowExtension() override;
  explicit PROTOBUF_CONSTEXPR TrafficFlowExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficFlowExtension(const TrafficFlowExtension& from);
  TrafficFlowExtension(TrafficFlowExtension&& from) noexcept
    : TrafficFlowExtension() {
    *this = ::std::move(from);
  }

  inline TrafficFlowExtension& operator=(const TrafficFlowExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficFlowExtension& operator=(TrafficFlowExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficFlowExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficFlowExtension* internal_default_instance() {
    return reinterpret_cast<const TrafficFlowExtension*>(
               &_TrafficFlowExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(TrafficFlowExtension& a, TrafficFlowExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficFlowExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficFlowExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficFlowExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficFlowExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficFlowExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrafficFlowExtension& from) {
    TrafficFlowExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlowExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.TrafficFlowExtension";
  }
  protected:
  explicit TrafficFlowExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneIndexFieldNumber = 1,
    kLinkIndexFieldNumber = 2,
    kMovementIndexFieldNumber = 3,
    kNodeIndexFieldNumber = 4,
    kSignalIndexFieldNumber = 5,
  };
  // repeated .cn.seisys.v2x.pb.LaneIndexAdded laneIndex = 1;
  int laneindex_size() const;
  private:
  int _internal_laneindex_size() const;
  public:
  void clear_laneindex();
  ::cn::seisys::v2x::pb::LaneIndexAdded* mutable_laneindex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneIndexAdded >*
      mutable_laneindex();
  private:
  const ::cn::seisys::v2x::pb::LaneIndexAdded& _internal_laneindex(int index) const;
  ::cn::seisys::v2x::pb::LaneIndexAdded* _internal_add_laneindex();
  public:
  const ::cn::seisys::v2x::pb::LaneIndexAdded& laneindex(int index) const;
  ::cn::seisys::v2x::pb::LaneIndexAdded* add_laneindex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneIndexAdded >&
      laneindex() const;

  // repeated .cn.seisys.v2x.pb.LinkIndexAdded linkIndex = 2;
  int linkindex_size() const;
  private:
  int _internal_linkindex_size() const;
  public:
  void clear_linkindex();
  ::cn::seisys::v2x::pb::LinkIndexAdded* mutable_linkindex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkIndexAdded >*
      mutable_linkindex();
  private:
  const ::cn::seisys::v2x::pb::LinkIndexAdded& _internal_linkindex(int index) const;
  ::cn::seisys::v2x::pb::LinkIndexAdded* _internal_add_linkindex();
  public:
  const ::cn::seisys::v2x::pb::LinkIndexAdded& linkindex(int index) const;
  ::cn::seisys::v2x::pb::LinkIndexAdded* add_linkindex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkIndexAdded >&
      linkindex() const;

  // repeated .cn.seisys.v2x.pb.MovementIndexAdded movementIndex = 3;
  int movementindex_size() const;
  private:
  int _internal_movementindex_size() const;
  public:
  void clear_movementindex();
  ::cn::seisys::v2x::pb::MovementIndexAdded* mutable_movementindex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementIndexAdded >*
      mutable_movementindex();
  private:
  const ::cn::seisys::v2x::pb::MovementIndexAdded& _internal_movementindex(int index) const;
  ::cn::seisys::v2x::pb::MovementIndexAdded* _internal_add_movementindex();
  public:
  const ::cn::seisys::v2x::pb::MovementIndexAdded& movementindex(int index) const;
  ::cn::seisys::v2x::pb::MovementIndexAdded* add_movementindex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementIndexAdded >&
      movementindex() const;

  // repeated .cn.seisys.v2x.pb.NodeIndexAdded nodeIndex = 4;
  int nodeindex_size() const;
  private:
  int _internal_nodeindex_size() const;
  public:
  void clear_nodeindex();
  ::cn::seisys::v2x::pb::NodeIndexAdded* mutable_nodeindex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::NodeIndexAdded >*
      mutable_nodeindex();
  private:
  const ::cn::seisys::v2x::pb::NodeIndexAdded& _internal_nodeindex(int index) const;
  ::cn::seisys::v2x::pb::NodeIndexAdded* _internal_add_nodeindex();
  public:
  const ::cn::seisys::v2x::pb::NodeIndexAdded& nodeindex(int index) const;
  ::cn::seisys::v2x::pb::NodeIndexAdded* add_nodeindex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::NodeIndexAdded >&
      nodeindex() const;

  // repeated .cn.seisys.v2x.pb.SignalControlIndexAdded signalIndex = 5;
  int signalindex_size() const;
  private:
  int _internal_signalindex_size() const;
  public:
  void clear_signalindex();
  ::cn::seisys::v2x::pb::SignalControlIndexAdded* mutable_signalindex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalControlIndexAdded >*
      mutable_signalindex();
  private:
  const ::cn::seisys::v2x::pb::SignalControlIndexAdded& _internal_signalindex(int index) const;
  ::cn::seisys::v2x::pb::SignalControlIndexAdded* _internal_add_signalindex();
  public:
  const ::cn::seisys::v2x::pb::SignalControlIndexAdded& signalindex(int index) const;
  ::cn::seisys::v2x::pb::SignalControlIndexAdded* add_signalindex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalControlIndexAdded >&
      signalindex() const;

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.TrafficFlowExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneIndexAdded > laneindex_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkIndexAdded > linkindex_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementIndexAdded > movementindex_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::NodeIndexAdded > nodeindex_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalControlIndexAdded > signalindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class TrafficFlowStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.TrafficFlowStat) */ {
 public:
  inline TrafficFlowStat() : TrafficFlowStat(nullptr) {}
  ~TrafficFlowStat() override;
  explicit PROTOBUF_CONSTEXPR TrafficFlowStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficFlowStat(const TrafficFlowStat& from);
  TrafficFlowStat(TrafficFlowStat&& from) noexcept
    : TrafficFlowStat() {
    *this = ::std::move(from);
  }

  inline TrafficFlowStat& operator=(const TrafficFlowStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficFlowStat& operator=(TrafficFlowStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficFlowStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficFlowStat* internal_default_instance() {
    return reinterpret_cast<const TrafficFlowStat*>(
               &_TrafficFlowStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TrafficFlowStat& a, TrafficFlowStat& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficFlowStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficFlowStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficFlowStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficFlowStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficFlowStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrafficFlowStat& from) {
    TrafficFlowStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlowStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.TrafficFlowStat";
  }
  protected:
  explicit TrafficFlowStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapElementFieldNumber = 1,
    kTrafficFlowExtensionFieldNumber = 15,
    kMapElementTypeFieldNumber = 2,
    kPtcTypeFieldNumber = 3,
    kTimestampFieldNumber = 5,
    kVehicleTypeFieldNumber = 4,
    kVolumeFieldNumber = 6,
    kSpeedPointFieldNumber = 7,
    kSpeedAreaFieldNumber = 8,
    kDensityFieldNumber = 9,
    kTravelTimeFieldNumber = 10,
    kDelayFieldNumber = 11,
    kQueueLengthFieldNumber = 12,
    kQueueIntFieldNumber = 13,
    kCongestionFieldNumber = 14,
    kTimeHeadwayFieldNumber = 16,
    kSpaceHeadwayFieldNumber = 17,
    kStopNumsFieldNumber = 18,
  };
  // .cn.seisys.v2x.pb.TrafficFlowStatMapElement mapElement = 1;
  bool has_mapelement() const;
  private:
  bool _internal_has_mapelement() const;
  public:
  void clear_mapelement();
  const ::cn::seisys::v2x::pb::TrafficFlowStatMapElement& mapelement() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* release_mapelement();
  ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* mutable_mapelement();
  void set_allocated_mapelement(::cn::seisys::v2x::pb::TrafficFlowStatMapElement* mapelement);
  private:
  const ::cn::seisys::v2x::pb::TrafficFlowStatMapElement& _internal_mapelement() const;
  ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* _internal_mutable_mapelement();
  public:
  void unsafe_arena_set_allocated_mapelement(
      ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* mapelement);
  ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* unsafe_arena_release_mapelement();

  // .cn.seisys.v2x.pb.TrafficFlowExtension trafficFlowExtension = 15;
  bool has_trafficflowextension() const;
  private:
  bool _internal_has_trafficflowextension() const;
  public:
  void clear_trafficflowextension();
  const ::cn::seisys::v2x::pb::TrafficFlowExtension& trafficflowextension() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::TrafficFlowExtension* release_trafficflowextension();
  ::cn::seisys::v2x::pb::TrafficFlowExtension* mutable_trafficflowextension();
  void set_allocated_trafficflowextension(::cn::seisys::v2x::pb::TrafficFlowExtension* trafficflowextension);
  private:
  const ::cn::seisys::v2x::pb::TrafficFlowExtension& _internal_trafficflowextension() const;
  ::cn::seisys::v2x::pb::TrafficFlowExtension* _internal_mutable_trafficflowextension();
  public:
  void unsafe_arena_set_allocated_trafficflowextension(
      ::cn::seisys::v2x::pb::TrafficFlowExtension* trafficflowextension);
  ::cn::seisys::v2x::pb::TrafficFlowExtension* unsafe_arena_release_trafficflowextension();

  // .cn.seisys.v2x.pb.MapElementType mapElementType = 2;
  void clear_mapelementtype();
  ::cn::seisys::v2x::pb::MapElementType mapelementtype() const;
  void set_mapelementtype(::cn::seisys::v2x::pb::MapElementType value);
  private:
  ::cn::seisys::v2x::pb::MapElementType _internal_mapelementtype() const;
  void _internal_set_mapelementtype(::cn::seisys::v2x::pb::MapElementType value);
  public:

  // .cn.seisys.v2x.pb.ParticipantType ptcType = 3;
  void clear_ptctype();
  ::cn::seisys::v2x::pb::ParticipantType ptctype() const;
  void set_ptctype(::cn::seisys::v2x::pb::ParticipantType value);
  private:
  ::cn::seisys::v2x::pb::ParticipantType _internal_ptctype() const;
  void _internal_set_ptctype(::cn::seisys::v2x::pb::ParticipantType value);
  public:

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.VehicleType vehicleType = 4;
  void clear_vehicletype();
  ::cn::seisys::v2x::pb::VehicleType vehicletype() const;
  void set_vehicletype(::cn::seisys::v2x::pb::VehicleType value);
  private:
  ::cn::seisys::v2x::pb::VehicleType _internal_vehicletype() const;
  void _internal_set_vehicletype(::cn::seisys::v2x::pb::VehicleType value);
  public:

  // uint32 volume = 6;
  void clear_volume();
  uint32_t volume() const;
  void set_volume(uint32_t value);
  private:
  uint32_t _internal_volume() const;
  void _internal_set_volume(uint32_t value);
  public:

  // uint32 speedPoint = 7;
  void clear_speedpoint();
  uint32_t speedpoint() const;
  void set_speedpoint(uint32_t value);
  private:
  uint32_t _internal_speedpoint() const;
  void _internal_set_speedpoint(uint32_t value);
  public:

  // uint32 speedArea = 8;
  void clear_speedarea();
  uint32_t speedarea() const;
  void set_speedarea(uint32_t value);
  private:
  uint32_t _internal_speedarea() const;
  void _internal_set_speedarea(uint32_t value);
  public:

  // uint32 density = 9;
  void clear_density();
  uint32_t density() const;
  void set_density(uint32_t value);
  private:
  uint32_t _internal_density() const;
  void _internal_set_density(uint32_t value);
  public:

  // uint32 travelTime = 10;
  void clear_traveltime();
  uint32_t traveltime() const;
  void set_traveltime(uint32_t value);
  private:
  uint32_t _internal_traveltime() const;
  void _internal_set_traveltime(uint32_t value);
  public:

  // uint32 delay = 11;
  void clear_delay();
  uint32_t delay() const;
  void set_delay(uint32_t value);
  private:
  uint32_t _internal_delay() const;
  void _internal_set_delay(uint32_t value);
  public:

  // uint32 queueLength = 12;
  void clear_queuelength();
  uint32_t queuelength() const;
  void set_queuelength(uint32_t value);
  private:
  uint32_t _internal_queuelength() const;
  void _internal_set_queuelength(uint32_t value);
  public:

  // uint32 queueInt = 13;
  void clear_queueint();
  uint32_t queueint() const;
  void set_queueint(uint32_t value);
  private:
  uint32_t _internal_queueint() const;
  void _internal_set_queueint(uint32_t value);
  public:

  // uint32 congestion = 14;
  void clear_congestion();
  uint32_t congestion() const;
  void set_congestion(uint32_t value);
  private:
  uint32_t _internal_congestion() const;
  void _internal_set_congestion(uint32_t value);
  public:

  // uint32 timeHeadway = 16;
  void clear_timeheadway();
  uint32_t timeheadway() const;
  void set_timeheadway(uint32_t value);
  private:
  uint32_t _internal_timeheadway() const;
  void _internal_set_timeheadway(uint32_t value);
  public:

  // uint32 spaceHeadway = 17;
  void clear_spaceheadway();
  uint32_t spaceheadway() const;
  void set_spaceheadway(uint32_t value);
  private:
  uint32_t _internal_spaceheadway() const;
  void _internal_set_spaceheadway(uint32_t value);
  public:

  // uint32 stopNums = 18;
  void clear_stopnums();
  uint32_t stopnums() const;
  void set_stopnums(uint32_t value);
  private:
  uint32_t _internal_stopnums() const;
  void _internal_set_stopnums(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.TrafficFlowStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* mapelement_;
    ::cn::seisys::v2x::pb::TrafficFlowExtension* trafficflowextension_;
    int mapelementtype_;
    int ptctype_;
    uint64_t timestamp_;
    int vehicletype_;
    uint32_t volume_;
    uint32_t speedpoint_;
    uint32_t speedarea_;
    uint32_t density_;
    uint32_t traveltime_;
    uint32_t delay_;
    uint32_t queuelength_;
    uint32_t queueint_;
    uint32_t congestion_;
    uint32_t timeheadway_;
    uint32_t spaceheadway_;
    uint32_t stopnums_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class TrafficFlow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.TrafficFlow) */ {
 public:
  inline TrafficFlow() : TrafficFlow(nullptr) {}
  ~TrafficFlow() override;
  explicit PROTOBUF_CONSTEXPR TrafficFlow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficFlow(const TrafficFlow& from);
  TrafficFlow(TrafficFlow&& from) noexcept
    : TrafficFlow() {
    *this = ::std::move(from);
  }

  inline TrafficFlow& operator=(const TrafficFlow& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficFlow& operator=(TrafficFlow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficFlow& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficFlow* internal_default_instance() {
    return reinterpret_cast<const TrafficFlow*>(
               &_TrafficFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(TrafficFlow& a, TrafficFlow& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficFlow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficFlow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficFlow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficFlow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficFlow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrafficFlow& from) {
    TrafficFlow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.TrafficFlow";
  }
  protected:
  explicit TrafficFlow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 4,
    kNodeIdFieldNumber = 1,
    kStatTypeFieldNumber = 3,
    kGenTimeFieldNumber = 2,
  };
  // repeated .cn.seisys.v2x.pb.TrafficFlowStat stats = 4;
  int stats_size() const;
  private:
  int _internal_stats_size() const;
  public:
  void clear_stats();
  ::cn::seisys::v2x::pb::TrafficFlowStat* mutable_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlowStat >*
      mutable_stats();
  private:
  const ::cn::seisys::v2x::pb::TrafficFlowStat& _internal_stats(int index) const;
  ::cn::seisys::v2x::pb::TrafficFlowStat* _internal_add_stats();
  public:
  const ::cn::seisys::v2x::pb::TrafficFlowStat& stats(int index) const;
  ::cn::seisys::v2x::pb::TrafficFlowStat* add_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlowStat >&
      stats() const;

  // .cn.seisys.v2x.pb.NodeReferenceId nodeId = 1;
  bool has_nodeid() const;
  private:
  bool _internal_has_nodeid() const;
  public:
  void clear_nodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& nodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_nodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_nodeid();
  void set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_nodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_nodeid();
  public:
  void unsafe_arena_set_allocated_nodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_nodeid();

  // .cn.seisys.v2x.pb.TrafficFlowStatType statType = 3;
  bool has_stattype() const;
  private:
  bool _internal_has_stattype() const;
  public:
  void clear_stattype();
  const ::cn::seisys::v2x::pb::TrafficFlowStatType& stattype() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::TrafficFlowStatType* release_stattype();
  ::cn::seisys::v2x::pb::TrafficFlowStatType* mutable_stattype();
  void set_allocated_stattype(::cn::seisys::v2x::pb::TrafficFlowStatType* stattype);
  private:
  const ::cn::seisys::v2x::pb::TrafficFlowStatType& _internal_stattype() const;
  ::cn::seisys::v2x::pb::TrafficFlowStatType* _internal_mutable_stattype();
  public:
  void unsafe_arena_set_allocated_stattype(
      ::cn::seisys::v2x::pb::TrafficFlowStatType* stattype);
  ::cn::seisys::v2x::pb::TrafficFlowStatType* unsafe_arena_release_stattype();

  // uint64 genTime = 2;
  void clear_gentime();
  uint64_t gentime() const;
  void set_gentime(uint64_t value);
  private:
  uint64_t _internal_gentime() const;
  void _internal_set_gentime(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.TrafficFlow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlowStat > stats_;
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid_;
    ::cn::seisys::v2x::pb::TrafficFlowStatType* stattype_;
    uint64_t gentime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class TimeCountingDown final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.TimeCountingDown) */ {
 public:
  inline TimeCountingDown() : TimeCountingDown(nullptr) {}
  ~TimeCountingDown() override;
  explicit PROTOBUF_CONSTEXPR TimeCountingDown(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeCountingDown(const TimeCountingDown& from);
  TimeCountingDown(TimeCountingDown&& from) noexcept
    : TimeCountingDown() {
    *this = ::std::move(from);
  }

  inline TimeCountingDown& operator=(const TimeCountingDown& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeCountingDown& operator=(TimeCountingDown&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeCountingDown& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeCountingDown* internal_default_instance() {
    return reinterpret_cast<const TimeCountingDown*>(
               &_TimeCountingDown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(TimeCountingDown& a, TimeCountingDown& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeCountingDown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeCountingDown* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeCountingDown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeCountingDown>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeCountingDown& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeCountingDown& from) {
    TimeCountingDown::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeCountingDown* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.TimeCountingDown";
  }
  protected:
  explicit TimeCountingDown(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kMinEndTimeFieldNumber = 2,
    kMaxEndTimeFieldNumber = 3,
    kLikelyEndTimeFieldNumber = 4,
    kTimeConfidenceFieldNumber = 5,
    kNextStartTimeFieldNumber = 6,
    kNextDurationFieldNumber = 7,
  };
  // uint32 startTime = 1;
  void clear_starttime();
  uint32_t starttime() const;
  void set_starttime(uint32_t value);
  private:
  uint32_t _internal_starttime() const;
  void _internal_set_starttime(uint32_t value);
  public:

  // uint32 minEndTime = 2;
  void clear_minendtime();
  uint32_t minendtime() const;
  void set_minendtime(uint32_t value);
  private:
  uint32_t _internal_minendtime() const;
  void _internal_set_minendtime(uint32_t value);
  public:

  // uint32 maxEndTime = 3;
  void clear_maxendtime();
  uint32_t maxendtime() const;
  void set_maxendtime(uint32_t value);
  private:
  uint32_t _internal_maxendtime() const;
  void _internal_set_maxendtime(uint32_t value);
  public:

  // uint32 likelyEndTime = 4;
  void clear_likelyendtime();
  uint32_t likelyendtime() const;
  void set_likelyendtime(uint32_t value);
  private:
  uint32_t _internal_likelyendtime() const;
  void _internal_set_likelyendtime(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.TimeConfidence timeConfidence = 5;
  void clear_timeconfidence();
  ::cn::seisys::v2x::pb::TimeConfidence timeconfidence() const;
  void set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  private:
  ::cn::seisys::v2x::pb::TimeConfidence _internal_timeconfidence() const;
  void _internal_set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  public:

  // uint32 nextStartTime = 6;
  void clear_nextstarttime();
  uint32_t nextstarttime() const;
  void set_nextstarttime(uint32_t value);
  private:
  uint32_t _internal_nextstarttime() const;
  void _internal_set_nextstarttime(uint32_t value);
  public:

  // uint32 nextDuration = 7;
  void clear_nextduration();
  uint32_t nextduration() const;
  void set_nextduration(uint32_t value);
  private:
  uint32_t _internal_nextduration() const;
  void _internal_set_nextduration(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.TimeCountingDown)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t starttime_;
    uint32_t minendtime_;
    uint32_t maxendtime_;
    uint32_t likelyendtime_;
    int timeconfidence_;
    uint32_t nextstarttime_;
    uint32_t nextduration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class PhaseState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.PhaseState) */ {
 public:
  inline PhaseState() : PhaseState(nullptr) {}
  ~PhaseState() override;
  explicit PROTOBUF_CONSTEXPR PhaseState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhaseState(const PhaseState& from);
  PhaseState(PhaseState&& from) noexcept
    : PhaseState() {
    *this = ::std::move(from);
  }

  inline PhaseState& operator=(const PhaseState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhaseState& operator=(PhaseState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhaseState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhaseState* internal_default_instance() {
    return reinterpret_cast<const PhaseState*>(
               &_PhaseState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(PhaseState& a, PhaseState& b) {
    a.Swap(&b);
  }
  inline void Swap(PhaseState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhaseState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhaseState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhaseState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhaseState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhaseState& from) {
    PhaseState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhaseState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.PhaseState";
  }
  protected:
  explicit PhaseState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PhaseState_LightState LightState;
  static constexpr LightState LIGHT_STATE_UNKNOWN =
    PhaseState_LightState_LIGHT_STATE_UNKNOWN;
  static constexpr LightState LIGHT_STATE_DARK =
    PhaseState_LightState_LIGHT_STATE_DARK;
  static constexpr LightState LIGHT_STATE_FLASHING_RED =
    PhaseState_LightState_LIGHT_STATE_FLASHING_RED;
  static constexpr LightState LIGHT_STATE_RED =
    PhaseState_LightState_LIGHT_STATE_RED;
  static constexpr LightState LIGHT_STATE_FLASHING_GREEN =
    PhaseState_LightState_LIGHT_STATE_FLASHING_GREEN;
  static constexpr LightState LIGHT_STATE_PERMISSIVE_GREEN =
    PhaseState_LightState_LIGHT_STATE_PERMISSIVE_GREEN;
  static constexpr LightState LIGHT_STATE_PROTETED_GREEN =
    PhaseState_LightState_LIGHT_STATE_PROTETED_GREEN;
  static constexpr LightState LIGHT_STATE_YELLOW =
    PhaseState_LightState_LIGHT_STATE_YELLOW;
  static constexpr LightState LIGHT_STATE_FLASHING_YELLOW =
    PhaseState_LightState_LIGHT_STATE_FLASHING_YELLOW;
  static inline bool LightState_IsValid(int value) {
    return PhaseState_LightState_IsValid(value);
  }
  static constexpr LightState LightState_MIN =
    PhaseState_LightState_LightState_MIN;
  static constexpr LightState LightState_MAX =
    PhaseState_LightState_LightState_MAX;
  static constexpr int LightState_ARRAYSIZE =
    PhaseState_LightState_LightState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LightState_descriptor() {
    return PhaseState_LightState_descriptor();
  }
  template<typename T>
  static inline const std::string& LightState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LightState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LightState_Name.");
    return PhaseState_LightState_Name(enum_t_value);
  }
  static inline bool LightState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LightState* value) {
    return PhaseState_LightState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimingFieldNumber = 2,
    kLightFieldNumber = 1,
  };
  // .cn.seisys.v2x.pb.TimeCountingDown timing = 2;
  bool has_timing() const;
  private:
  bool _internal_has_timing() const;
  public:
  void clear_timing();
  const ::cn::seisys::v2x::pb::TimeCountingDown& timing() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::TimeCountingDown* release_timing();
  ::cn::seisys::v2x::pb::TimeCountingDown* mutable_timing();
  void set_allocated_timing(::cn::seisys::v2x::pb::TimeCountingDown* timing);
  private:
  const ::cn::seisys::v2x::pb::TimeCountingDown& _internal_timing() const;
  ::cn::seisys::v2x::pb::TimeCountingDown* _internal_mutable_timing();
  public:
  void unsafe_arena_set_allocated_timing(
      ::cn::seisys::v2x::pb::TimeCountingDown* timing);
  ::cn::seisys::v2x::pb::TimeCountingDown* unsafe_arena_release_timing();

  // .cn.seisys.v2x.pb.PhaseState.LightState light = 1;
  void clear_light();
  ::cn::seisys::v2x::pb::PhaseState_LightState light() const;
  void set_light(::cn::seisys::v2x::pb::PhaseState_LightState value);
  private:
  ::cn::seisys::v2x::pb::PhaseState_LightState _internal_light() const;
  void _internal_set_light(::cn::seisys::v2x::pb::PhaseState_LightState value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.PhaseState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::TimeCountingDown* timing_;
    int light_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class Phase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.Phase) */ {
 public:
  inline Phase() : Phase(nullptr) {}
  ~Phase() override;
  explicit PROTOBUF_CONSTEXPR Phase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Phase(const Phase& from);
  Phase(Phase&& from) noexcept
    : Phase() {
    *this = ::std::move(from);
  }

  inline Phase& operator=(const Phase& from) {
    CopyFrom(from);
    return *this;
  }
  inline Phase& operator=(Phase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Phase& default_instance() {
    return *internal_default_instance();
  }
  static inline const Phase* internal_default_instance() {
    return reinterpret_cast<const Phase*>(
               &_Phase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Phase& a, Phase& b) {
    a.Swap(&b);
  }
  inline void Swap(Phase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Phase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Phase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Phase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Phase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Phase& from) {
    Phase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Phase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.Phase";
  }
  protected:
  explicit Phase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhaseStatesFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .cn.seisys.v2x.pb.PhaseState phaseStates = 2;
  int phasestates_size() const;
  private:
  int _internal_phasestates_size() const;
  public:
  void clear_phasestates();
  ::cn::seisys::v2x::pb::PhaseState* mutable_phasestates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseState >*
      mutable_phasestates();
  private:
  const ::cn::seisys::v2x::pb::PhaseState& _internal_phasestates(int index) const;
  ::cn::seisys::v2x::pb::PhaseState* _internal_add_phasestates();
  public:
  const ::cn::seisys::v2x::pb::PhaseState& phasestates(int index) const;
  ::cn::seisys::v2x::pb::PhaseState* add_phasestates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseState >&
      phasestates() const;

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.Phase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseState > phasestates_;
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class IntersectionState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.IntersectionState) */ {
 public:
  inline IntersectionState() : IntersectionState(nullptr) {}
  ~IntersectionState() override;
  explicit PROTOBUF_CONSTEXPR IntersectionState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntersectionState(const IntersectionState& from);
  IntersectionState(IntersectionState&& from) noexcept
    : IntersectionState() {
    *this = ::std::move(from);
  }

  inline IntersectionState& operator=(const IntersectionState& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntersectionState& operator=(IntersectionState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntersectionState& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntersectionState* internal_default_instance() {
    return reinterpret_cast<const IntersectionState*>(
               &_IntersectionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(IntersectionState& a, IntersectionState& b) {
    a.Swap(&b);
  }
  inline void Swap(IntersectionState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntersectionState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntersectionState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntersectionState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntersectionState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntersectionState& from) {
    IntersectionState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntersectionState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.IntersectionState";
  }
  protected:
  explicit IntersectionState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhasesFieldNumber = 5,
    kStatusFieldNumber = 2,
    kIntersectionIdFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kTimeConfidenceFieldNumber = 4,
  };
  // repeated .cn.seisys.v2x.pb.Phase phases = 5;
  int phases_size() const;
  private:
  int _internal_phases_size() const;
  public:
  void clear_phases();
  ::cn::seisys::v2x::pb::Phase* mutable_phases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Phase >*
      mutable_phases();
  private:
  const ::cn::seisys::v2x::pb::Phase& _internal_phases(int index) const;
  ::cn::seisys::v2x::pb::Phase* _internal_add_phases();
  public:
  const ::cn::seisys::v2x::pb::Phase& phases(int index) const;
  ::cn::seisys::v2x::pb::Phase* add_phases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Phase >&
      phases() const;

  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .cn.seisys.v2x.pb.NodeReferenceId intersectionId = 1;
  bool has_intersectionid() const;
  private:
  bool _internal_has_intersectionid() const;
  public:
  void clear_intersectionid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& intersectionid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_intersectionid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_intersectionid();
  void set_allocated_intersectionid(::cn::seisys::v2x::pb::NodeReferenceId* intersectionid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_intersectionid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_intersectionid();
  public:
  void unsafe_arena_set_allocated_intersectionid(
      ::cn::seisys::v2x::pb::NodeReferenceId* intersectionid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_intersectionid();

  // uint64 timestamp = 3;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.TimeConfidence timeConfidence = 4;
  void clear_timeconfidence();
  ::cn::seisys::v2x::pb::TimeConfidence timeconfidence() const;
  void set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  private:
  ::cn::seisys::v2x::pb::TimeConfidence _internal_timeconfidence() const;
  void _internal_set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.IntersectionState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Phase > phases_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::cn::seisys::v2x::pb::NodeReferenceId* intersectionid_;
    uint64_t timestamp_;
    int timeconfidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class SpatData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.SpatData) */ {
 public:
  inline SpatData() : SpatData(nullptr) {}
  ~SpatData() override;
  explicit PROTOBUF_CONSTEXPR SpatData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpatData(const SpatData& from);
  SpatData(SpatData&& from) noexcept
    : SpatData() {
    *this = ::std::move(from);
  }

  inline SpatData& operator=(const SpatData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpatData& operator=(SpatData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpatData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpatData* internal_default_instance() {
    return reinterpret_cast<const SpatData*>(
               &_SpatData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SpatData& a, SpatData& b) {
    a.Swap(&b);
  }
  inline void Swap(SpatData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpatData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpatData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpatData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpatData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpatData& from) {
    SpatData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpatData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.SpatData";
  }
  protected:
  explicit SpatData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntersectionsFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kMsgCntFieldNumber = 1,
  };
  // repeated .cn.seisys.v2x.pb.IntersectionState intersections = 3;
  int intersections_size() const;
  private:
  int _internal_intersections_size() const;
  public:
  void clear_intersections();
  ::cn::seisys::v2x::pb::IntersectionState* mutable_intersections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::IntersectionState >*
      mutable_intersections();
  private:
  const ::cn::seisys::v2x::pb::IntersectionState& _internal_intersections(int index) const;
  ::cn::seisys::v2x::pb::IntersectionState* _internal_add_intersections();
  public:
  const ::cn::seisys::v2x::pb::IntersectionState& intersections(int index) const;
  ::cn::seisys::v2x::pb::IntersectionState* add_intersections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::IntersectionState >&
      intersections() const;

  // uint64 timestamp = 2;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 msgCnt = 1;
  void clear_msgcnt();
  uint32_t msgcnt() const;
  void set_msgcnt(uint32_t value);
  private:
  uint32_t _internal_msgcnt() const;
  void _internal_set_msgcnt(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.SpatData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::IntersectionState > intersections_;
    uint64_t timestamp_;
    uint32_t msgcnt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LocalTimePoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LocalTimePoint) */ {
 public:
  inline LocalTimePoint() : LocalTimePoint(nullptr) {}
  ~LocalTimePoint() override;
  explicit PROTOBUF_CONSTEXPR LocalTimePoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalTimePoint(const LocalTimePoint& from);
  LocalTimePoint(LocalTimePoint&& from) noexcept
    : LocalTimePoint() {
    *this = ::std::move(from);
  }

  inline LocalTimePoint& operator=(const LocalTimePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalTimePoint& operator=(LocalTimePoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalTimePoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalTimePoint* internal_default_instance() {
    return reinterpret_cast<const LocalTimePoint*>(
               &_LocalTimePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(LocalTimePoint& a, LocalTimePoint& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalTimePoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalTimePoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalTimePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalTimePoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalTimePoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalTimePoint& from) {
    LocalTimePoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalTimePoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LocalTimePoint";
  }
  protected:
  explicit LocalTimePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHhFieldNumber = 1,
    kMmFieldNumber = 2,
    kSsFieldNumber = 3,
  };
  // int32 hh = 1;
  void clear_hh();
  int32_t hh() const;
  void set_hh(int32_t value);
  private:
  int32_t _internal_hh() const;
  void _internal_set_hh(int32_t value);
  public:

  // int32 mm = 2;
  void clear_mm();
  int32_t mm() const;
  void set_mm(int32_t value);
  private:
  int32_t _internal_mm() const;
  void _internal_set_mm(int32_t value);
  public:

  // int32 ss = 3;
  void clear_ss();
  int32_t ss() const;
  void set_ss(int32_t value);
  private:
  int32_t _internal_ss() const;
  void _internal_set_ss(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LocalTimePoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t hh_;
    int32_t mm_;
    int32_t ss_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class PeriodictimeSpan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.PeriodictimeSpan) */ {
 public:
  inline PeriodictimeSpan() : PeriodictimeSpan(nullptr) {}
  ~PeriodictimeSpan() override;
  explicit PROTOBUF_CONSTEXPR PeriodictimeSpan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeriodictimeSpan(const PeriodictimeSpan& from);
  PeriodictimeSpan(PeriodictimeSpan&& from) noexcept
    : PeriodictimeSpan() {
    *this = ::std::move(from);
  }

  inline PeriodictimeSpan& operator=(const PeriodictimeSpan& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeriodictimeSpan& operator=(PeriodictimeSpan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeriodictimeSpan& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeriodictimeSpan* internal_default_instance() {
    return reinterpret_cast<const PeriodictimeSpan*>(
               &_PeriodictimeSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PeriodictimeSpan& a, PeriodictimeSpan& b) {
    a.Swap(&b);
  }
  inline void Swap(PeriodictimeSpan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeriodictimeSpan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeriodictimeSpan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeriodictimeSpan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeriodictimeSpan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeriodictimeSpan& from) {
    PeriodictimeSpan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeriodictimeSpan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.PeriodictimeSpan";
  }
  protected:
  explicit PeriodictimeSpan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromTimePointFieldNumber = 4,
    kToTimePointFieldNumber = 5,
    kMonthFilterFieldNumber = 1,
    kDayFilterFieldNumber = 2,
    kWeekdayFilterFieldNumber = 3,
  };
  // .cn.seisys.v2x.pb.LocalTimePoint fromTimePoint = 4;
  bool has_fromtimepoint() const;
  private:
  bool _internal_has_fromtimepoint() const;
  public:
  void clear_fromtimepoint();
  const ::cn::seisys::v2x::pb::LocalTimePoint& fromtimepoint() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LocalTimePoint* release_fromtimepoint();
  ::cn::seisys::v2x::pb::LocalTimePoint* mutable_fromtimepoint();
  void set_allocated_fromtimepoint(::cn::seisys::v2x::pb::LocalTimePoint* fromtimepoint);
  private:
  const ::cn::seisys::v2x::pb::LocalTimePoint& _internal_fromtimepoint() const;
  ::cn::seisys::v2x::pb::LocalTimePoint* _internal_mutable_fromtimepoint();
  public:
  void unsafe_arena_set_allocated_fromtimepoint(
      ::cn::seisys::v2x::pb::LocalTimePoint* fromtimepoint);
  ::cn::seisys::v2x::pb::LocalTimePoint* unsafe_arena_release_fromtimepoint();

  // .cn.seisys.v2x.pb.LocalTimePoint toTimePoint = 5;
  bool has_totimepoint() const;
  private:
  bool _internal_has_totimepoint() const;
  public:
  void clear_totimepoint();
  const ::cn::seisys::v2x::pb::LocalTimePoint& totimepoint() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LocalTimePoint* release_totimepoint();
  ::cn::seisys::v2x::pb::LocalTimePoint* mutable_totimepoint();
  void set_allocated_totimepoint(::cn::seisys::v2x::pb::LocalTimePoint* totimepoint);
  private:
  const ::cn::seisys::v2x::pb::LocalTimePoint& _internal_totimepoint() const;
  ::cn::seisys::v2x::pb::LocalTimePoint* _internal_mutable_totimepoint();
  public:
  void unsafe_arena_set_allocated_totimepoint(
      ::cn::seisys::v2x::pb::LocalTimePoint* totimepoint);
  ::cn::seisys::v2x::pb::LocalTimePoint* unsafe_arena_release_totimepoint();

  // int32 monthFilter = 1;
  void clear_monthfilter();
  int32_t monthfilter() const;
  void set_monthfilter(int32_t value);
  private:
  int32_t _internal_monthfilter() const;
  void _internal_set_monthfilter(int32_t value);
  public:

  // int32 dayFilter = 2;
  void clear_dayfilter();
  int32_t dayfilter() const;
  void set_dayfilter(int32_t value);
  private:
  int32_t _internal_dayfilter() const;
  void _internal_set_dayfilter(int32_t value);
  public:

  // int32 weekdayFilter = 3;
  void clear_weekdayfilter();
  int32_t weekdayfilter() const;
  void set_weekdayfilter(int32_t value);
  private:
  int32_t _internal_weekdayfilter() const;
  void _internal_set_weekdayfilter(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.PeriodictimeSpan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::LocalTimePoint* fromtimepoint_;
    ::cn::seisys::v2x::pb::LocalTimePoint* totimepoint_;
    int32_t monthfilter_;
    int32_t dayfilter_;
    int32_t weekdayfilter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class SingleTimeSpan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.SingleTimeSpan) */ {
 public:
  inline SingleTimeSpan() : SingleTimeSpan(nullptr) {}
  ~SingleTimeSpan() override;
  explicit PROTOBUF_CONSTEXPR SingleTimeSpan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleTimeSpan(const SingleTimeSpan& from);
  SingleTimeSpan(SingleTimeSpan&& from) noexcept
    : SingleTimeSpan() {
    *this = ::std::move(from);
  }

  inline SingleTimeSpan& operator=(const SingleTimeSpan& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleTimeSpan& operator=(SingleTimeSpan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleTimeSpan& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleTimeSpan* internal_default_instance() {
    return reinterpret_cast<const SingleTimeSpan*>(
               &_SingleTimeSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SingleTimeSpan& a, SingleTimeSpan& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleTimeSpan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleTimeSpan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleTimeSpan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleTimeSpan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleTimeSpan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleTimeSpan& from) {
    SingleTimeSpan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleTimeSpan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.SingleTimeSpan";
  }
  protected:
  explicit SingleTimeSpan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
  };
  // uint64 startTime = 1;
  void clear_starttime();
  uint64_t starttime() const;
  void set_starttime(uint64_t value);
  private:
  uint64_t _internal_starttime() const;
  void _internal_set_starttime(uint64_t value);
  public:

  // uint64 endTime = 2;
  void clear_endtime();
  uint64_t endtime() const;
  void set_endtime(uint64_t value);
  private:
  uint64_t _internal_endtime() const;
  void _internal_set_endtime(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.SingleTimeSpan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t starttime_;
    uint64_t endtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class OptimTimeType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.OptimTimeType) */ {
 public:
  inline OptimTimeType() : OptimTimeType(nullptr) {}
  ~OptimTimeType() override;
  explicit PROTOBUF_CONSTEXPR OptimTimeType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptimTimeType(const OptimTimeType& from);
  OptimTimeType(OptimTimeType&& from) noexcept
    : OptimTimeType() {
    *this = ::std::move(from);
  }

  inline OptimTimeType& operator=(const OptimTimeType& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimTimeType& operator=(OptimTimeType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimTimeType& default_instance() {
    return *internal_default_instance();
  }
  enum OptimTimeTypeOneOfCase {
    kSingle = 1,
    kPeriodic = 2,
    OPTIMTIMETYPEONEOF_NOT_SET = 0,
  };

  static inline const OptimTimeType* internal_default_instance() {
    return reinterpret_cast<const OptimTimeType*>(
               &_OptimTimeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(OptimTimeType& a, OptimTimeType& b) {
    a.Swap(&b);
  }
  inline void Swap(OptimTimeType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimTimeType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimTimeType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptimTimeType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OptimTimeType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OptimTimeType& from) {
    OptimTimeType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptimTimeType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.OptimTimeType";
  }
  protected:
  explicit OptimTimeType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSingleFieldNumber = 1,
    kPeriodicFieldNumber = 2,
  };
  // .cn.seisys.v2x.pb.SingleTimeSpan single = 1;
  bool has_single() const;
  private:
  bool _internal_has_single() const;
  public:
  void clear_single();
  const ::cn::seisys::v2x::pb::SingleTimeSpan& single() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::SingleTimeSpan* release_single();
  ::cn::seisys::v2x::pb::SingleTimeSpan* mutable_single();
  void set_allocated_single(::cn::seisys::v2x::pb::SingleTimeSpan* single);
  private:
  const ::cn::seisys::v2x::pb::SingleTimeSpan& _internal_single() const;
  ::cn::seisys::v2x::pb::SingleTimeSpan* _internal_mutable_single();
  public:
  void unsafe_arena_set_allocated_single(
      ::cn::seisys::v2x::pb::SingleTimeSpan* single);
  ::cn::seisys::v2x::pb::SingleTimeSpan* unsafe_arena_release_single();

  // .cn.seisys.v2x.pb.PeriodictimeSpan periodic = 2;
  bool has_periodic() const;
  private:
  bool _internal_has_periodic() const;
  public:
  void clear_periodic();
  const ::cn::seisys::v2x::pb::PeriodictimeSpan& periodic() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PeriodictimeSpan* release_periodic();
  ::cn::seisys::v2x::pb::PeriodictimeSpan* mutable_periodic();
  void set_allocated_periodic(::cn::seisys::v2x::pb::PeriodictimeSpan* periodic);
  private:
  const ::cn::seisys::v2x::pb::PeriodictimeSpan& _internal_periodic() const;
  ::cn::seisys::v2x::pb::PeriodictimeSpan* _internal_mutable_periodic();
  public:
  void unsafe_arena_set_allocated_periodic(
      ::cn::seisys::v2x::pb::PeriodictimeSpan* periodic);
  ::cn::seisys::v2x::pb::PeriodictimeSpan* unsafe_arena_release_periodic();

  void clear_OptimTimeTypeOneOf();
  OptimTimeTypeOneOfCase OptimTimeTypeOneOf_case() const;
  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.OptimTimeType)
 private:
  class _Internal;
  void set_has_single();
  void set_has_periodic();

  inline bool has_OptimTimeTypeOneOf() const;
  inline void clear_has_OptimTimeTypeOneOf();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OptimTimeTypeOneOfUnion {
      constexpr OptimTimeTypeOneOfUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::cn::seisys::v2x::pb::SingleTimeSpan* single_;
      ::cn::seisys::v2x::pb::PeriodictimeSpan* periodic_;
    } OptimTimeTypeOneOf_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class MovementEx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.MovementEx) */ {
 public:
  inline MovementEx() : MovementEx(nullptr) {}
  ~MovementEx() override;
  explicit PROTOBUF_CONSTEXPR MovementEx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovementEx(const MovementEx& from);
  MovementEx(MovementEx&& from) noexcept
    : MovementEx() {
    *this = ::std::move(from);
  }

  inline MovementEx& operator=(const MovementEx& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovementEx& operator=(MovementEx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovementEx& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovementEx* internal_default_instance() {
    return reinterpret_cast<const MovementEx*>(
               &_MovementEx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MovementEx& a, MovementEx& b) {
    a.Swap(&b);
  }
  inline void Swap(MovementEx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovementEx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovementEx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MovementEx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MovementEx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MovementEx& from) {
    MovementEx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovementEx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.MovementEx";
  }
  protected:
  explicit MovementEx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteIntersectionFieldNumber = 1,
    kPhaseIdFieldNumber = 2,
    kTurnDirectionFieldNumber = 3,
  };
  // .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
  bool has_remoteintersection() const;
  private:
  bool _internal_has_remoteintersection() const;
  public:
  void clear_remoteintersection();
  const ::cn::seisys::v2x::pb::NodeReferenceId& remoteintersection() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_remoteintersection();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_remoteintersection();
  void set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_remoteintersection() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_remoteintersection();
  public:
  void unsafe_arena_set_allocated_remoteintersection(
      ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_remoteintersection();

  // uint32 phaseId = 2;
  void clear_phaseid();
  uint32_t phaseid() const;
  void set_phaseid(uint32_t value);
  private:
  uint32_t _internal_phaseid() const;
  void _internal_set_phaseid(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.Maneuver turnDirection = 3;
  void clear_turndirection();
  ::cn::seisys::v2x::pb::Maneuver turndirection() const;
  void set_turndirection(::cn::seisys::v2x::pb::Maneuver value);
  private:
  ::cn::seisys::v2x::pb::Maneuver _internal_turndirection() const;
  void _internal_set_turndirection(::cn::seisys::v2x::pb::Maneuver value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.MovementEx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection_;
    uint32_t phaseid_;
    int turndirection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class OptimPhase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.OptimPhase) */ {
 public:
  inline OptimPhase() : OptimPhase(nullptr) {}
  ~OptimPhase() override;
  explicit PROTOBUF_CONSTEXPR OptimPhase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptimPhase(const OptimPhase& from);
  OptimPhase(OptimPhase&& from) noexcept
    : OptimPhase() {
    *this = ::std::move(from);
  }

  inline OptimPhase& operator=(const OptimPhase& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimPhase& operator=(OptimPhase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimPhase& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptimPhase* internal_default_instance() {
    return reinterpret_cast<const OptimPhase*>(
               &_OptimPhase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(OptimPhase& a, OptimPhase& b) {
    a.Swap(&b);
  }
  inline void Swap(OptimPhase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimPhase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimPhase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptimPhase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OptimPhase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OptimPhase& from) {
    OptimPhase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptimPhase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.OptimPhase";
  }
  protected:
  explicit OptimPhase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMovementIdFieldNumber = 3,
    kPhaseIdFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPhaseTimeFieldNumber = 4,
    kGreenFieldNumber = 5,
    kPhaseYellowTimeFieldNumber = 6,
    kPhaseAllRedTimeFieldNumber = 7,
    kMinGreenFieldNumber = 8,
    kMaxGreenFieldNumber = 9,
  };
  // repeated .cn.seisys.v2x.pb.MovementEx movementId = 3;
  int movementid_size() const;
  private:
  int _internal_movementid_size() const;
  public:
  void clear_movementid();
  ::cn::seisys::v2x::pb::MovementEx* mutable_movementid(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx >*
      mutable_movementid();
  private:
  const ::cn::seisys::v2x::pb::MovementEx& _internal_movementid(int index) const;
  ::cn::seisys::v2x::pb::MovementEx* _internal_add_movementid();
  public:
  const ::cn::seisys::v2x::pb::MovementEx& movementid(int index) const;
  ::cn::seisys::v2x::pb::MovementEx* add_movementid();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx >&
      movementid() const;

  // uint32 phaseId = 1;
  void clear_phaseid();
  uint32_t phaseid() const;
  void set_phaseid(uint32_t value);
  private:
  uint32_t _internal_phaseid() const;
  void _internal_set_phaseid(uint32_t value);
  public:

  // uint32 order = 2;
  void clear_order();
  uint32_t order() const;
  void set_order(uint32_t value);
  private:
  uint32_t _internal_order() const;
  void _internal_set_order(uint32_t value);
  public:

  // uint32 phaseTime = 4;
  void clear_phasetime();
  uint32_t phasetime() const;
  void set_phasetime(uint32_t value);
  private:
  uint32_t _internal_phasetime() const;
  void _internal_set_phasetime(uint32_t value);
  public:

  // uint32 green = 5;
  void clear_green();
  uint32_t green() const;
  void set_green(uint32_t value);
  private:
  uint32_t _internal_green() const;
  void _internal_set_green(uint32_t value);
  public:

  // uint32 phaseYellowTime = 6;
  void clear_phaseyellowtime();
  uint32_t phaseyellowtime() const;
  void set_phaseyellowtime(uint32_t value);
  private:
  uint32_t _internal_phaseyellowtime() const;
  void _internal_set_phaseyellowtime(uint32_t value);
  public:

  // uint32 phaseAllRedTime = 7;
  void clear_phaseallredtime();
  uint32_t phaseallredtime() const;
  void set_phaseallredtime(uint32_t value);
  private:
  uint32_t _internal_phaseallredtime() const;
  void _internal_set_phaseallredtime(uint32_t value);
  public:

  // uint32 minGreen = 8;
  void clear_mingreen();
  uint32_t mingreen() const;
  void set_mingreen(uint32_t value);
  private:
  uint32_t _internal_mingreen() const;
  void _internal_set_mingreen(uint32_t value);
  public:

  // uint32 maxGreen = 9;
  void clear_maxgreen();
  uint32_t maxgreen() const;
  void set_maxgreen(uint32_t value);
  private:
  uint32_t _internal_maxgreen() const;
  void _internal_set_maxgreen(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.OptimPhase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx > movementid_;
    uint32_t phaseid_;
    uint32_t order_;
    uint32_t phasetime_;
    uint32_t green_;
    uint32_t phaseyellowtime_;
    uint32_t phaseallredtime_;
    uint32_t mingreen_;
    uint32_t maxgreen_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class OptimData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.OptimData) */ {
 public:
  inline OptimData() : OptimData(nullptr) {}
  ~OptimData() override;
  explicit PROTOBUF_CONSTEXPR OptimData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptimData(const OptimData& from);
  OptimData(OptimData&& from) noexcept
    : OptimData() {
    *this = ::std::move(from);
  }

  inline OptimData& operator=(const OptimData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimData& operator=(OptimData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimData& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptimData* internal_default_instance() {
    return reinterpret_cast<const OptimData*>(
               &_OptimData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(OptimData& a, OptimData& b) {
    a.Swap(&b);
  }
  inline void Swap(OptimData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptimData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OptimData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OptimData& from) {
    OptimData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptimData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.OptimData";
  }
  protected:
  explicit OptimData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptimPhaseListFieldNumber = 5,
    kCoorPhaseFieldNumber = 6,
    kOptimTimeTypeFieldNumber = 1,
    kOptimCycleTimeFieldNumber = 2,
    kMinCycleTimeFieldNumber = 3,
    kMaxCycleTimeFieldNumber = 4,
    kOffsetFieldNumber = 7,
  };
  // repeated .cn.seisys.v2x.pb.OptimPhase optimPhaseList = 5;
  int optimphaselist_size() const;
  private:
  int _internal_optimphaselist_size() const;
  public:
  void clear_optimphaselist();
  ::cn::seisys::v2x::pb::OptimPhase* mutable_optimphaselist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimPhase >*
      mutable_optimphaselist();
  private:
  const ::cn::seisys::v2x::pb::OptimPhase& _internal_optimphaselist(int index) const;
  ::cn::seisys::v2x::pb::OptimPhase* _internal_add_optimphaselist();
  public:
  const ::cn::seisys::v2x::pb::OptimPhase& optimphaselist(int index) const;
  ::cn::seisys::v2x::pb::OptimPhase* add_optimphaselist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimPhase >&
      optimphaselist() const;

  // string coorPhase = 6;
  void clear_coorphase();
  const std::string& coorphase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coorphase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coorphase();
  PROTOBUF_NODISCARD std::string* release_coorphase();
  void set_allocated_coorphase(std::string* coorphase);
  private:
  const std::string& _internal_coorphase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coorphase(const std::string& value);
  std::string* _internal_mutable_coorphase();
  public:

  // .cn.seisys.v2x.pb.OptimTimeType optimTimeType = 1;
  bool has_optimtimetype() const;
  private:
  bool _internal_has_optimtimetype() const;
  public:
  void clear_optimtimetype();
  const ::cn::seisys::v2x::pb::OptimTimeType& optimtimetype() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::OptimTimeType* release_optimtimetype();
  ::cn::seisys::v2x::pb::OptimTimeType* mutable_optimtimetype();
  void set_allocated_optimtimetype(::cn::seisys::v2x::pb::OptimTimeType* optimtimetype);
  private:
  const ::cn::seisys::v2x::pb::OptimTimeType& _internal_optimtimetype() const;
  ::cn::seisys::v2x::pb::OptimTimeType* _internal_mutable_optimtimetype();
  public:
  void unsafe_arena_set_allocated_optimtimetype(
      ::cn::seisys::v2x::pb::OptimTimeType* optimtimetype);
  ::cn::seisys::v2x::pb::OptimTimeType* unsafe_arena_release_optimtimetype();

  // uint32 optimCycleTime = 2;
  void clear_optimcycletime();
  uint32_t optimcycletime() const;
  void set_optimcycletime(uint32_t value);
  private:
  uint32_t _internal_optimcycletime() const;
  void _internal_set_optimcycletime(uint32_t value);
  public:

  // uint32 minCycleTime = 3;
  void clear_mincycletime();
  uint32_t mincycletime() const;
  void set_mincycletime(uint32_t value);
  private:
  uint32_t _internal_mincycletime() const;
  void _internal_set_mincycletime(uint32_t value);
  public:

  // uint32 maxCycleTime = 4;
  void clear_maxcycletime();
  uint32_t maxcycletime() const;
  void set_maxcycletime(uint32_t value);
  private:
  uint32_t _internal_maxcycletime() const;
  void _internal_set_maxcycletime(uint32_t value);
  public:

  // uint32 offset = 7;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.OptimData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimPhase > optimphaselist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coorphase_;
    ::cn::seisys::v2x::pb::OptimTimeType* optimtimetype_;
    uint32_t optimcycletime_;
    uint32_t mincycletime_;
    uint32_t maxcycletime_;
    uint32_t offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class SignalScheme final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.SignalScheme) */ {
 public:
  inline SignalScheme() : SignalScheme(nullptr) {}
  ~SignalScheme() override;
  explicit PROTOBUF_CONSTEXPR SignalScheme(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalScheme(const SignalScheme& from);
  SignalScheme(SignalScheme&& from) noexcept
    : SignalScheme() {
    *this = ::std::move(from);
  }

  inline SignalScheme& operator=(const SignalScheme& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalScheme& operator=(SignalScheme&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalScheme& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalScheme* internal_default_instance() {
    return reinterpret_cast<const SignalScheme*>(
               &_SignalScheme_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(SignalScheme& a, SignalScheme& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalScheme* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalScheme* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalScheme* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalScheme>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalScheme& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalScheme& from) {
    SignalScheme::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalScheme* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.SignalScheme";
  }
  protected:
  explicit SignalScheme(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptimDataListFieldNumber = 4,
    kNodeIdFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kOptimTypeFieldNumber = 2,
  };
  // repeated .cn.seisys.v2x.pb.OptimData optimDataList = 4;
  int optimdatalist_size() const;
  private:
  int _internal_optimdatalist_size() const;
  public:
  void clear_optimdatalist();
  ::cn::seisys::v2x::pb::OptimData* mutable_optimdatalist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimData >*
      mutable_optimdatalist();
  private:
  const ::cn::seisys::v2x::pb::OptimData& _internal_optimdatalist(int index) const;
  ::cn::seisys::v2x::pb::OptimData* _internal_add_optimdatalist();
  public:
  const ::cn::seisys::v2x::pb::OptimData& optimdatalist(int index) const;
  ::cn::seisys::v2x::pb::OptimData* add_optimdatalist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimData >&
      optimdatalist() const;

  // .cn.seisys.v2x.pb.NodeReferenceId nodeId = 1;
  bool has_nodeid() const;
  private:
  bool _internal_has_nodeid() const;
  public:
  void clear_nodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& nodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_nodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_nodeid();
  void set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_nodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_nodeid();
  public:
  void unsafe_arena_set_allocated_nodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* nodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_nodeid();

  // uint64 timestamp = 3;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 optimType = 2;
  void clear_optimtype();
  uint32_t optimtype() const;
  void set_optimtype(uint32_t value);
  private:
  uint32_t _internal_optimtype() const;
  void _internal_set_optimtype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.SignalScheme)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimData > optimdatalist_;
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid_;
    uint64_t timestamp_;
    uint32_t optimtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class BrakeSystemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.BrakeSystemStatus) */ {
 public:
  inline BrakeSystemStatus() : BrakeSystemStatus(nullptr) {}
  ~BrakeSystemStatus() override;
  explicit PROTOBUF_CONSTEXPR BrakeSystemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrakeSystemStatus(const BrakeSystemStatus& from);
  BrakeSystemStatus(BrakeSystemStatus&& from) noexcept
    : BrakeSystemStatus() {
    *this = ::std::move(from);
  }

  inline BrakeSystemStatus& operator=(const BrakeSystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrakeSystemStatus& operator=(BrakeSystemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrakeSystemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrakeSystemStatus* internal_default_instance() {
    return reinterpret_cast<const BrakeSystemStatus*>(
               &_BrakeSystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(BrakeSystemStatus& a, BrakeSystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BrakeSystemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrakeSystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrakeSystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrakeSystemStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BrakeSystemStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BrakeSystemStatus& from) {
    BrakeSystemStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrakeSystemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.BrakeSystemStatus";
  }
  protected:
  explicit BrakeSystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BrakeSystemStatus_BrakePedalStatus BrakePedalStatus;
  static constexpr BrakePedalStatus UNAVAILABLE_PEDAL =
    BrakeSystemStatus_BrakePedalStatus_UNAVAILABLE_PEDAL;
  static constexpr BrakePedalStatus OFF_PEDAL =
    BrakeSystemStatus_BrakePedalStatus_OFF_PEDAL;
  static constexpr BrakePedalStatus ON_PEDAL =
    BrakeSystemStatus_BrakePedalStatus_ON_PEDAL;
  static inline bool BrakePedalStatus_IsValid(int value) {
    return BrakeSystemStatus_BrakePedalStatus_IsValid(value);
  }
  static constexpr BrakePedalStatus BrakePedalStatus_MIN =
    BrakeSystemStatus_BrakePedalStatus_BrakePedalStatus_MIN;
  static constexpr BrakePedalStatus BrakePedalStatus_MAX =
    BrakeSystemStatus_BrakePedalStatus_BrakePedalStatus_MAX;
  static constexpr int BrakePedalStatus_ARRAYSIZE =
    BrakeSystemStatus_BrakePedalStatus_BrakePedalStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BrakePedalStatus_descriptor() {
    return BrakeSystemStatus_BrakePedalStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& BrakePedalStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BrakePedalStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BrakePedalStatus_Name.");
    return BrakeSystemStatus_BrakePedalStatus_Name(enum_t_value);
  }
  static inline bool BrakePedalStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BrakePedalStatus* value) {
    return BrakeSystemStatus_BrakePedalStatus_Parse(name, value);
  }

  typedef BrakeSystemStatus_TractionControlStatus TractionControlStatus;
  static constexpr TractionControlStatus UNAVAILABLE_TRACTION =
    BrakeSystemStatus_TractionControlStatus_UNAVAILABLE_TRACTION;
  static constexpr TractionControlStatus OFF_TRACTION =
    BrakeSystemStatus_TractionControlStatus_OFF_TRACTION;
  static constexpr TractionControlStatus ON_TRACTION =
    BrakeSystemStatus_TractionControlStatus_ON_TRACTION;
  static constexpr TractionControlStatus ENGAGED_TRACTION =
    BrakeSystemStatus_TractionControlStatus_ENGAGED_TRACTION;
  static inline bool TractionControlStatus_IsValid(int value) {
    return BrakeSystemStatus_TractionControlStatus_IsValid(value);
  }
  static constexpr TractionControlStatus TractionControlStatus_MIN =
    BrakeSystemStatus_TractionControlStatus_TractionControlStatus_MIN;
  static constexpr TractionControlStatus TractionControlStatus_MAX =
    BrakeSystemStatus_TractionControlStatus_TractionControlStatus_MAX;
  static constexpr int TractionControlStatus_ARRAYSIZE =
    BrakeSystemStatus_TractionControlStatus_TractionControlStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TractionControlStatus_descriptor() {
    return BrakeSystemStatus_TractionControlStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& TractionControlStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TractionControlStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TractionControlStatus_Name.");
    return BrakeSystemStatus_TractionControlStatus_Name(enum_t_value);
  }
  static inline bool TractionControlStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TractionControlStatus* value) {
    return BrakeSystemStatus_TractionControlStatus_Parse(name, value);
  }

  typedef BrakeSystemStatus_AntiLockBrakeStatus AntiLockBrakeStatus;
  static constexpr AntiLockBrakeStatus UNAVAILABLE_ABS =
    BrakeSystemStatus_AntiLockBrakeStatus_UNAVAILABLE_ABS;
  static constexpr AntiLockBrakeStatus OFF_ABS =
    BrakeSystemStatus_AntiLockBrakeStatus_OFF_ABS;
  static constexpr AntiLockBrakeStatus ON_ABS =
    BrakeSystemStatus_AntiLockBrakeStatus_ON_ABS;
  static constexpr AntiLockBrakeStatus ENGAGED_ABS =
    BrakeSystemStatus_AntiLockBrakeStatus_ENGAGED_ABS;
  static inline bool AntiLockBrakeStatus_IsValid(int value) {
    return BrakeSystemStatus_AntiLockBrakeStatus_IsValid(value);
  }
  static constexpr AntiLockBrakeStatus AntiLockBrakeStatus_MIN =
    BrakeSystemStatus_AntiLockBrakeStatus_AntiLockBrakeStatus_MIN;
  static constexpr AntiLockBrakeStatus AntiLockBrakeStatus_MAX =
    BrakeSystemStatus_AntiLockBrakeStatus_AntiLockBrakeStatus_MAX;
  static constexpr int AntiLockBrakeStatus_ARRAYSIZE =
    BrakeSystemStatus_AntiLockBrakeStatus_AntiLockBrakeStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AntiLockBrakeStatus_descriptor() {
    return BrakeSystemStatus_AntiLockBrakeStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& AntiLockBrakeStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AntiLockBrakeStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AntiLockBrakeStatus_Name.");
    return BrakeSystemStatus_AntiLockBrakeStatus_Name(enum_t_value);
  }
  static inline bool AntiLockBrakeStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AntiLockBrakeStatus* value) {
    return BrakeSystemStatus_AntiLockBrakeStatus_Parse(name, value);
  }

  typedef BrakeSystemStatus_StabilityControlStatus StabilityControlStatus;
  static constexpr StabilityControlStatus UNAVAILABLE_SCS =
    BrakeSystemStatus_StabilityControlStatus_UNAVAILABLE_SCS;
  static constexpr StabilityControlStatus OFF_SCS =
    BrakeSystemStatus_StabilityControlStatus_OFF_SCS;
  static constexpr StabilityControlStatus ON_SCS =
    BrakeSystemStatus_StabilityControlStatus_ON_SCS;
  static constexpr StabilityControlStatus ENGAGED_SCS =
    BrakeSystemStatus_StabilityControlStatus_ENGAGED_SCS;
  static inline bool StabilityControlStatus_IsValid(int value) {
    return BrakeSystemStatus_StabilityControlStatus_IsValid(value);
  }
  static constexpr StabilityControlStatus StabilityControlStatus_MIN =
    BrakeSystemStatus_StabilityControlStatus_StabilityControlStatus_MIN;
  static constexpr StabilityControlStatus StabilityControlStatus_MAX =
    BrakeSystemStatus_StabilityControlStatus_StabilityControlStatus_MAX;
  static constexpr int StabilityControlStatus_ARRAYSIZE =
    BrakeSystemStatus_StabilityControlStatus_StabilityControlStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StabilityControlStatus_descriptor() {
    return BrakeSystemStatus_StabilityControlStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& StabilityControlStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StabilityControlStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StabilityControlStatus_Name.");
    return BrakeSystemStatus_StabilityControlStatus_Name(enum_t_value);
  }
  static inline bool StabilityControlStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StabilityControlStatus* value) {
    return BrakeSystemStatus_StabilityControlStatus_Parse(name, value);
  }

  typedef BrakeSystemStatus_BrakeBoostApplied BrakeBoostApplied;
  static constexpr BrakeBoostApplied UNAVAILABLE_BBA =
    BrakeSystemStatus_BrakeBoostApplied_UNAVAILABLE_BBA;
  static constexpr BrakeBoostApplied OFF_BBA =
    BrakeSystemStatus_BrakeBoostApplied_OFF_BBA;
  static constexpr BrakeBoostApplied ON_BBA =
    BrakeSystemStatus_BrakeBoostApplied_ON_BBA;
  static inline bool BrakeBoostApplied_IsValid(int value) {
    return BrakeSystemStatus_BrakeBoostApplied_IsValid(value);
  }
  static constexpr BrakeBoostApplied BrakeBoostApplied_MIN =
    BrakeSystemStatus_BrakeBoostApplied_BrakeBoostApplied_MIN;
  static constexpr BrakeBoostApplied BrakeBoostApplied_MAX =
    BrakeSystemStatus_BrakeBoostApplied_BrakeBoostApplied_MAX;
  static constexpr int BrakeBoostApplied_ARRAYSIZE =
    BrakeSystemStatus_BrakeBoostApplied_BrakeBoostApplied_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BrakeBoostApplied_descriptor() {
    return BrakeSystemStatus_BrakeBoostApplied_descriptor();
  }
  template<typename T>
  static inline const std::string& BrakeBoostApplied_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BrakeBoostApplied>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BrakeBoostApplied_Name.");
    return BrakeSystemStatus_BrakeBoostApplied_Name(enum_t_value);
  }
  static inline bool BrakeBoostApplied_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BrakeBoostApplied* value) {
    return BrakeSystemStatus_BrakeBoostApplied_Parse(name, value);
  }

  typedef BrakeSystemStatus_AuxiliaryBrakeStatus AuxiliaryBrakeStatus;
  static constexpr AuxiliaryBrakeStatus UNAVAILABLE_AUX =
    BrakeSystemStatus_AuxiliaryBrakeStatus_UNAVAILABLE_AUX;
  static constexpr AuxiliaryBrakeStatus OFF_AUX =
    BrakeSystemStatus_AuxiliaryBrakeStatus_OFF_AUX;
  static constexpr AuxiliaryBrakeStatus ON_AUX =
    BrakeSystemStatus_AuxiliaryBrakeStatus_ON_AUX;
  static constexpr AuxiliaryBrakeStatus ENGAGED_AUX =
    BrakeSystemStatus_AuxiliaryBrakeStatus_ENGAGED_AUX;
  static inline bool AuxiliaryBrakeStatus_IsValid(int value) {
    return BrakeSystemStatus_AuxiliaryBrakeStatus_IsValid(value);
  }
  static constexpr AuxiliaryBrakeStatus AuxiliaryBrakeStatus_MIN =
    BrakeSystemStatus_AuxiliaryBrakeStatus_AuxiliaryBrakeStatus_MIN;
  static constexpr AuxiliaryBrakeStatus AuxiliaryBrakeStatus_MAX =
    BrakeSystemStatus_AuxiliaryBrakeStatus_AuxiliaryBrakeStatus_MAX;
  static constexpr int AuxiliaryBrakeStatus_ARRAYSIZE =
    BrakeSystemStatus_AuxiliaryBrakeStatus_AuxiliaryBrakeStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AuxiliaryBrakeStatus_descriptor() {
    return BrakeSystemStatus_AuxiliaryBrakeStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& AuxiliaryBrakeStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AuxiliaryBrakeStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AuxiliaryBrakeStatus_Name.");
    return BrakeSystemStatus_AuxiliaryBrakeStatus_Name(enum_t_value);
  }
  static inline bool AuxiliaryBrakeStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AuxiliaryBrakeStatus* value) {
    return BrakeSystemStatus_AuxiliaryBrakeStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBrakePadelFieldNumber = 1,
    kWheelBrakesFieldNumber = 2,
    kTractionFieldNumber = 3,
    kAbsFieldNumber = 4,
    kScsFieldNumber = 5,
    kBrakeBoostFieldNumber = 6,
    kAuxBrakesFieldNumber = 7,
    kBrakeControlFieldNumber = 8,
  };
  // .cn.seisys.v2x.pb.BrakeSystemStatus.BrakePedalStatus brakePadel = 1;
  void clear_brakepadel();
  ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus brakepadel() const;
  void set_brakepadel(::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus value);
  private:
  ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus _internal_brakepadel() const;
  void _internal_set_brakepadel(::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus value);
  public:

  // uint32 wheelBrakes = 2;
  void clear_wheelbrakes();
  uint32_t wheelbrakes() const;
  void set_wheelbrakes(uint32_t value);
  private:
  uint32_t _internal_wheelbrakes() const;
  void _internal_set_wheelbrakes(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.BrakeSystemStatus.TractionControlStatus traction = 3;
  void clear_traction();
  ::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus traction() const;
  void set_traction(::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus value);
  private:
  ::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus _internal_traction() const;
  void _internal_set_traction(::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus value);
  public:

  // .cn.seisys.v2x.pb.BrakeSystemStatus.AntiLockBrakeStatus abs = 4;
  void clear_abs();
  ::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus abs() const;
  void set_abs(::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus value);
  private:
  ::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus _internal_abs() const;
  void _internal_set_abs(::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus value);
  public:

  // .cn.seisys.v2x.pb.BrakeSystemStatus.StabilityControlStatus scs = 5;
  void clear_scs();
  ::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus scs() const;
  void set_scs(::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus value);
  private:
  ::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus _internal_scs() const;
  void _internal_set_scs(::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus value);
  public:

  // .cn.seisys.v2x.pb.BrakeSystemStatus.BrakeBoostApplied brakeBoost = 6;
  void clear_brakeboost();
  ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied brakeboost() const;
  void set_brakeboost(::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied value);
  private:
  ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied _internal_brakeboost() const;
  void _internal_set_brakeboost(::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied value);
  public:

  // .cn.seisys.v2x.pb.BrakeSystemStatus.AuxiliaryBrakeStatus auxBrakes = 7;
  void clear_auxbrakes();
  ::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus auxbrakes() const;
  void set_auxbrakes(::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus value);
  private:
  ::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus _internal_auxbrakes() const;
  void _internal_set_auxbrakes(::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus value);
  public:

  // uint32 brakeControl = 8;
  void clear_brakecontrol();
  uint32_t brakecontrol() const;
  void set_brakecontrol(uint32_t value);
  private:
  uint32_t _internal_brakecontrol() const;
  void _internal_set_brakecontrol(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.BrakeSystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int brakepadel_;
    uint32_t wheelbrakes_;
    int traction_;
    int abs_;
    int scs_;
    int brakeboost_;
    int auxbrakes_;
    uint32_t brakecontrol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class PositionAccuracy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.PositionAccuracy) */ {
 public:
  inline PositionAccuracy() : PositionAccuracy(nullptr) {}
  ~PositionAccuracy() override;
  explicit PROTOBUF_CONSTEXPR PositionAccuracy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionAccuracy(const PositionAccuracy& from);
  PositionAccuracy(PositionAccuracy&& from) noexcept
    : PositionAccuracy() {
    *this = ::std::move(from);
  }

  inline PositionAccuracy& operator=(const PositionAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAccuracy& operator=(PositionAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAccuracy& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionAccuracy* internal_default_instance() {
    return reinterpret_cast<const PositionAccuracy*>(
               &_PositionAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(PositionAccuracy& a, PositionAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAccuracy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAccuracy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionAccuracy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionAccuracy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PositionAccuracy& from) {
    PositionAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionAccuracy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.PositionAccuracy";
  }
  protected:
  explicit PositionAccuracy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSemiMajorFieldNumber = 1,
    kSemiMinorFieldNumber = 2,
    kOrientationFieldNumber = 3,
  };
  // int32 semiMajor = 1;
  void clear_semimajor();
  int32_t semimajor() const;
  void set_semimajor(int32_t value);
  private:
  int32_t _internal_semimajor() const;
  void _internal_set_semimajor(int32_t value);
  public:

  // int32 semiMinor = 2;
  void clear_semiminor();
  int32_t semiminor() const;
  void set_semiminor(int32_t value);
  private:
  int32_t _internal_semiminor() const;
  void _internal_set_semiminor(int32_t value);
  public:

  // int32 orientation = 3;
  void clear_orientation();
  int32_t orientation() const;
  void set_orientation(int32_t value);
  private:
  int32_t _internal_orientation() const;
  void _internal_set_orientation(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.PositionAccuracy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t semimajor_;
    int32_t semiminor_;
    int32_t orientation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ThrottleSystemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ThrottleSystemStatus) */ {
 public:
  inline ThrottleSystemStatus() : ThrottleSystemStatus(nullptr) {}
  ~ThrottleSystemStatus() override;
  explicit PROTOBUF_CONSTEXPR ThrottleSystemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThrottleSystemStatus(const ThrottleSystemStatus& from);
  ThrottleSystemStatus(ThrottleSystemStatus&& from) noexcept
    : ThrottleSystemStatus() {
    *this = ::std::move(from);
  }

  inline ThrottleSystemStatus& operator=(const ThrottleSystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThrottleSystemStatus& operator=(ThrottleSystemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThrottleSystemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThrottleSystemStatus* internal_default_instance() {
    return reinterpret_cast<const ThrottleSystemStatus*>(
               &_ThrottleSystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ThrottleSystemStatus& a, ThrottleSystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ThrottleSystemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThrottleSystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThrottleSystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThrottleSystemStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThrottleSystemStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThrottleSystemStatus& from) {
    ThrottleSystemStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThrottleSystemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ThrottleSystemStatus";
  }
  protected:
  explicit ThrottleSystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ThrottleSystemStatus_ThrottlePedalStauts ThrottlePedalStauts;
  static constexpr ThrottlePedalStauts UNAVAILABLE_PEDAL =
    ThrottleSystemStatus_ThrottlePedalStauts_UNAVAILABLE_PEDAL;
  static constexpr ThrottlePedalStauts OFF =
    ThrottleSystemStatus_ThrottlePedalStauts_OFF;
  static constexpr ThrottlePedalStauts ON =
    ThrottleSystemStatus_ThrottlePedalStauts_ON;
  static inline bool ThrottlePedalStauts_IsValid(int value) {
    return ThrottleSystemStatus_ThrottlePedalStauts_IsValid(value);
  }
  static constexpr ThrottlePedalStauts ThrottlePedalStauts_MIN =
    ThrottleSystemStatus_ThrottlePedalStauts_ThrottlePedalStauts_MIN;
  static constexpr ThrottlePedalStauts ThrottlePedalStauts_MAX =
    ThrottleSystemStatus_ThrottlePedalStauts_ThrottlePedalStauts_MAX;
  static constexpr int ThrottlePedalStauts_ARRAYSIZE =
    ThrottleSystemStatus_ThrottlePedalStauts_ThrottlePedalStauts_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ThrottlePedalStauts_descriptor() {
    return ThrottleSystemStatus_ThrottlePedalStauts_descriptor();
  }
  template<typename T>
  static inline const std::string& ThrottlePedalStauts_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ThrottlePedalStauts>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ThrottlePedalStauts_Name.");
    return ThrottleSystemStatus_ThrottlePedalStauts_Name(enum_t_value);
  }
  static inline bool ThrottlePedalStauts_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ThrottlePedalStauts* value) {
    return ThrottleSystemStatus_ThrottlePedalStauts_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kThorttleControlFieldNumber = 1,
    kThrottlePadelFieldNumber = 2,
    kWheelThrottlesFieldNumber = 3,
  };
  // uint32 thorttleControl = 1;
  void clear_thorttlecontrol();
  uint32_t thorttlecontrol() const;
  void set_thorttlecontrol(uint32_t value);
  private:
  uint32_t _internal_thorttlecontrol() const;
  void _internal_set_thorttlecontrol(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.ThrottleSystemStatus.ThrottlePedalStauts throttlePadel = 2;
  void clear_throttlepadel();
  ::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts throttlepadel() const;
  void set_throttlepadel(::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts value);
  private:
  ::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts _internal_throttlepadel() const;
  void _internal_set_throttlepadel(::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts value);
  public:

  // int32 wheelThrottles = 3;
  void clear_wheelthrottles();
  int32_t wheelthrottles() const;
  void set_wheelthrottles(int32_t value);
  private:
  int32_t _internal_wheelthrottles() const;
  void _internal_set_wheelthrottles(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ThrottleSystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t thorttlecontrol_;
    int throttlepadel_;
    int32_t wheelthrottles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class BsmData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.BsmData) */ {
 public:
  inline BsmData() : BsmData(nullptr) {}
  ~BsmData() override;
  explicit PROTOBUF_CONSTEXPR BsmData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BsmData(const BsmData& from);
  BsmData(BsmData&& from) noexcept
    : BsmData() {
    *this = ::std::move(from);
  }

  inline BsmData& operator=(const BsmData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BsmData& operator=(BsmData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BsmData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BsmData* internal_default_instance() {
    return reinterpret_cast<const BsmData*>(
               &_BsmData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(BsmData& a, BsmData& b) {
    a.Swap(&b);
  }
  inline void Swap(BsmData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BsmData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BsmData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BsmData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BsmData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BsmData& from) {
    BsmData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BsmData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.BsmData";
  }
  protected:
  explicit BsmData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BsmData_TransmissionState TransmissionState;
  static constexpr TransmissionState TRANSMISSION_NEUTRAL =
    BsmData_TransmissionState_TRANSMISSION_NEUTRAL;
  static constexpr TransmissionState TRANSMISSION_PARK =
    BsmData_TransmissionState_TRANSMISSION_PARK;
  static constexpr TransmissionState TRANSMISSION_FORWARD_GEARS =
    BsmData_TransmissionState_TRANSMISSION_FORWARD_GEARS;
  static constexpr TransmissionState TRANSMISSION_REVERSE_GEARS =
    BsmData_TransmissionState_TRANSMISSION_REVERSE_GEARS;
  static constexpr TransmissionState TRANSMISSION_RESERVED1 =
    BsmData_TransmissionState_TRANSMISSION_RESERVED1;
  static constexpr TransmissionState TRANSMISSION_RESERVED2 =
    BsmData_TransmissionState_TRANSMISSION_RESERVED2;
  static constexpr TransmissionState TRANSMISSION_RESERVED3 =
    BsmData_TransmissionState_TRANSMISSION_RESERVED3;
  static constexpr TransmissionState TRANSMISSION_UNAVAILABLE =
    BsmData_TransmissionState_TRANSMISSION_UNAVAILABLE;
  static inline bool TransmissionState_IsValid(int value) {
    return BsmData_TransmissionState_IsValid(value);
  }
  static constexpr TransmissionState TransmissionState_MIN =
    BsmData_TransmissionState_TransmissionState_MIN;
  static constexpr TransmissionState TransmissionState_MAX =
    BsmData_TransmissionState_TransmissionState_MAX;
  static constexpr int TransmissionState_ARRAYSIZE =
    BsmData_TransmissionState_TransmissionState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TransmissionState_descriptor() {
    return BsmData_TransmissionState_descriptor();
  }
  template<typename T>
  static inline const std::string& TransmissionState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TransmissionState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TransmissionState_Name.");
    return BsmData_TransmissionState_Name(enum_t_value);
  }
  static inline bool TransmissionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TransmissionState* value) {
    return BsmData_TransmissionState_Parse(name, value);
  }

  typedef BsmData_VehicleFuelType VehicleFuelType;
  static constexpr VehicleFuelType VEHICLE_TUEL_UNKNOWNFUEL =
    BsmData_VehicleFuelType_VEHICLE_TUEL_UNKNOWNFUEL;
  static constexpr VehicleFuelType GASOLINE =
    BsmData_VehicleFuelType_GASOLINE;
  static constexpr VehicleFuelType ETHANOL =
    BsmData_VehicleFuelType_ETHANOL;
  static constexpr VehicleFuelType DIESEL =
    BsmData_VehicleFuelType_DIESEL;
  static constexpr VehicleFuelType ELECTRIC =
    BsmData_VehicleFuelType_ELECTRIC;
  static constexpr VehicleFuelType HYBRID =
    BsmData_VehicleFuelType_HYBRID;
  static constexpr VehicleFuelType HYDROGEN =
    BsmData_VehicleFuelType_HYDROGEN;
  static constexpr VehicleFuelType NATGASLIQUID =
    BsmData_VehicleFuelType_NATGASLIQUID;
  static constexpr VehicleFuelType NATGASCOMP =
    BsmData_VehicleFuelType_NATGASCOMP;
  static constexpr VehicleFuelType PROPANE =
    BsmData_VehicleFuelType_PROPANE;
  static inline bool VehicleFuelType_IsValid(int value) {
    return BsmData_VehicleFuelType_IsValid(value);
  }
  static constexpr VehicleFuelType VehicleFuelType_MIN =
    BsmData_VehicleFuelType_VehicleFuelType_MIN;
  static constexpr VehicleFuelType VehicleFuelType_MAX =
    BsmData_VehicleFuelType_VehicleFuelType_MAX;
  static constexpr int VehicleFuelType_ARRAYSIZE =
    BsmData_VehicleFuelType_VehicleFuelType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VehicleFuelType_descriptor() {
    return BsmData_VehicleFuelType_descriptor();
  }
  template<typename T>
  static inline const std::string& VehicleFuelType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehicleFuelType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehicleFuelType_Name.");
    return BsmData_VehicleFuelType_Name(enum_t_value);
  }
  static inline bool VehicleFuelType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VehicleFuelType* value) {
    return BsmData_VehicleFuelType_Parse(name, value);
  }

  typedef BsmData_DriveStatus DriveStatus;
  static constexpr DriveStatus AUTOPILOT =
    BsmData_DriveStatus_AUTOPILOT;
  static constexpr DriveStatus MANUAL =
    BsmData_DriveStatus_MANUAL;
  static constexpr DriveStatus SECURITY =
    BsmData_DriveStatus_SECURITY;
  static inline bool DriveStatus_IsValid(int value) {
    return BsmData_DriveStatus_IsValid(value);
  }
  static constexpr DriveStatus DriveStatus_MIN =
    BsmData_DriveStatus_DriveStatus_MIN;
  static constexpr DriveStatus DriveStatus_MAX =
    BsmData_DriveStatus_DriveStatus_MAX;
  static constexpr int DriveStatus_ARRAYSIZE =
    BsmData_DriveStatus_DriveStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DriveStatus_descriptor() {
    return BsmData_DriveStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& DriveStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DriveStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DriveStatus_Name.");
    return BsmData_DriveStatus_Name(enum_t_value);
  }
  static inline bool DriveStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DriveStatus* value) {
    return BsmData_DriveStatus_Parse(name, value);
  }

  typedef BsmData_EmergenyStatus EmergenyStatus;
  static constexpr EmergenyStatus NO_EMER =
    BsmData_EmergenyStatus_NO_EMER;
  static constexpr EmergenyStatus YES_EMER =
    BsmData_EmergenyStatus_YES_EMER;
  static inline bool EmergenyStatus_IsValid(int value) {
    return BsmData_EmergenyStatus_IsValid(value);
  }
  static constexpr EmergenyStatus EmergenyStatus_MIN =
    BsmData_EmergenyStatus_EmergenyStatus_MIN;
  static constexpr EmergenyStatus EmergenyStatus_MAX =
    BsmData_EmergenyStatus_EmergenyStatus_MAX;
  static constexpr int EmergenyStatus_ARRAYSIZE =
    BsmData_EmergenyStatus_EmergenyStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EmergenyStatus_descriptor() {
    return BsmData_EmergenyStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& EmergenyStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EmergenyStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EmergenyStatus_Name.");
    return BsmData_EmergenyStatus_Name(enum_t_value);
  }
  static inline bool EmergenyStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EmergenyStatus* value) {
    return BsmData_EmergenyStatus_Parse(name, value);
  }

  typedef BsmData_Wiper Wiper;
  static constexpr Wiper OFF =
    BsmData_Wiper_OFF;
  static constexpr Wiper INT =
    BsmData_Wiper_INT;
  static constexpr Wiper LO =
    BsmData_Wiper_LO;
  static constexpr Wiper HI =
    BsmData_Wiper_HI;
  static inline bool Wiper_IsValid(int value) {
    return BsmData_Wiper_IsValid(value);
  }
  static constexpr Wiper Wiper_MIN =
    BsmData_Wiper_Wiper_MIN;
  static constexpr Wiper Wiper_MAX =
    BsmData_Wiper_Wiper_MAX;
  static constexpr int Wiper_ARRAYSIZE =
    BsmData_Wiper_Wiper_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Wiper_descriptor() {
    return BsmData_Wiper_descriptor();
  }
  template<typename T>
  static inline const std::string& Wiper_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Wiper>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Wiper_Name.");
    return BsmData_Wiper_Name(enum_t_value);
  }
  static inline bool Wiper_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Wiper* value) {
    return BsmData_Wiper_Parse(name, value);
  }

  typedef BsmData_OutofControl OutofControl;
  static constexpr OutofControl NO_OUTCON =
    BsmData_OutofControl_NO_OUTCON;
  static constexpr OutofControl YES_OUTCON =
    BsmData_OutofControl_YES_OUTCON;
  static inline bool OutofControl_IsValid(int value) {
    return BsmData_OutofControl_IsValid(value);
  }
  static constexpr OutofControl OutofControl_MIN =
    BsmData_OutofControl_OutofControl_MIN;
  static constexpr OutofControl OutofControl_MAX =
    BsmData_OutofControl_OutofControl_MAX;
  static constexpr int OutofControl_ARRAYSIZE =
    BsmData_OutofControl_OutofControl_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OutofControl_descriptor() {
    return BsmData_OutofControl_descriptor();
  }
  template<typename T>
  static inline const std::string& OutofControl_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OutofControl>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OutofControl_Name.");
    return BsmData_OutofControl_Name(enum_t_value);
  }
  static inline bool OutofControl_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OutofControl* value) {
    return BsmData_OutofControl_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kObuIdFieldNumber = 1,
    kPlateNoFieldNumber = 2,
    kPosFieldNumber = 4,
    kPosConfidFieldNumber = 5,
    kPosAccuracyFieldNumber = 6,
    kAccelerationFieldNumber = 7,
    kMotionConfidFieldNumber = 12,
    kBrakesFieldNumber = 13,
    kThrottleFieldNumber = 14,
    kSizeFieldNumber = 15,
    kTimestampFieldNumber = 3,
    kTransmissionFieldNumber = 8,
    kSpeedFieldNumber = 9,
    kHeadingFieldNumber = 10,
    kSteeringWheelAngleFieldNumber = 11,
    kVehicleTypeFieldNumber = 16,
    kFuelTypeFieldNumber = 17,
    kDriveModedriveStatusFieldNumber = 18,
    kEmergencyStatusFieldNumber = 19,
    kLightFieldNumber = 20,
    kWiperFieldNumber = 21,
    kOutofControlFieldNumber = 22,
    kEnduranceFieldNumber = 23,
  };
  // string obuId = 1;
  void clear_obuid();
  const std::string& obuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obuid();
  PROTOBUF_NODISCARD std::string* release_obuid();
  void set_allocated_obuid(std::string* obuid);
  private:
  const std::string& _internal_obuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obuid(const std::string& value);
  std::string* _internal_mutable_obuid();
  public:

  // string plateNo = 2;
  void clear_plateno();
  const std::string& plateno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plateno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plateno();
  PROTOBUF_NODISCARD std::string* release_plateno();
  void set_allocated_plateno(std::string* plateno);
  private:
  const std::string& _internal_plateno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plateno(const std::string& value);
  std::string* _internal_mutable_plateno();
  public:

  // .cn.seisys.v2x.pb.Position3D pos = 4;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::cn::seisys::v2x::pb::Position3D& pos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_pos();
  ::cn::seisys::v2x::pb::Position3D* mutable_pos();
  void set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_pos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::cn::seisys::v2x::pb::Position3D* pos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_pos();

  // .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 5;
  bool has_posconfid() const;
  private:
  bool _internal_has_posconfid() const;
  public:
  void clear_posconfid();
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& posconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PositionConfidenceSet* release_posconfid();
  ::cn::seisys::v2x::pb::PositionConfidenceSet* mutable_posconfid();
  void set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  private:
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& _internal_posconfid() const;
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _internal_mutable_posconfid();
  public:
  void unsafe_arena_set_allocated_posconfid(
      ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  ::cn::seisys::v2x::pb::PositionConfidenceSet* unsafe_arena_release_posconfid();

  // .cn.seisys.v2x.pb.PositionAccuracy posAccuracy = 6;
  bool has_posaccuracy() const;
  private:
  bool _internal_has_posaccuracy() const;
  public:
  void clear_posaccuracy();
  const ::cn::seisys::v2x::pb::PositionAccuracy& posaccuracy() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PositionAccuracy* release_posaccuracy();
  ::cn::seisys::v2x::pb::PositionAccuracy* mutable_posaccuracy();
  void set_allocated_posaccuracy(::cn::seisys::v2x::pb::PositionAccuracy* posaccuracy);
  private:
  const ::cn::seisys::v2x::pb::PositionAccuracy& _internal_posaccuracy() const;
  ::cn::seisys::v2x::pb::PositionAccuracy* _internal_mutable_posaccuracy();
  public:
  void unsafe_arena_set_allocated_posaccuracy(
      ::cn::seisys::v2x::pb::PositionAccuracy* posaccuracy);
  ::cn::seisys::v2x::pb::PositionAccuracy* unsafe_arena_release_posaccuracy();

  // .cn.seisys.v2x.pb.AccelerationSet4Way acceleration = 7;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::cn::seisys::v2x::pb::AccelerationSet4Way& acceleration() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::AccelerationSet4Way* release_acceleration();
  ::cn::seisys::v2x::pb::AccelerationSet4Way* mutable_acceleration();
  void set_allocated_acceleration(::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration);
  private:
  const ::cn::seisys::v2x::pb::AccelerationSet4Way& _internal_acceleration() const;
  ::cn::seisys::v2x::pb::AccelerationSet4Way* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration);
  ::cn::seisys::v2x::pb::AccelerationSet4Way* unsafe_arena_release_acceleration();

  // .cn.seisys.v2x.pb.MotionConfidenceSet motionConfid = 12;
  bool has_motionconfid() const;
  private:
  bool _internal_has_motionconfid() const;
  public:
  void clear_motionconfid();
  const ::cn::seisys::v2x::pb::MotionConfidenceSet& motionconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::MotionConfidenceSet* release_motionconfid();
  ::cn::seisys::v2x::pb::MotionConfidenceSet* mutable_motionconfid();
  void set_allocated_motionconfid(::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid);
  private:
  const ::cn::seisys::v2x::pb::MotionConfidenceSet& _internal_motionconfid() const;
  ::cn::seisys::v2x::pb::MotionConfidenceSet* _internal_mutable_motionconfid();
  public:
  void unsafe_arena_set_allocated_motionconfid(
      ::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid);
  ::cn::seisys::v2x::pb::MotionConfidenceSet* unsafe_arena_release_motionconfid();

  // .cn.seisys.v2x.pb.BrakeSystemStatus brakes = 13;
  bool has_brakes() const;
  private:
  bool _internal_has_brakes() const;
  public:
  void clear_brakes();
  const ::cn::seisys::v2x::pb::BrakeSystemStatus& brakes() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::BrakeSystemStatus* release_brakes();
  ::cn::seisys::v2x::pb::BrakeSystemStatus* mutable_brakes();
  void set_allocated_brakes(::cn::seisys::v2x::pb::BrakeSystemStatus* brakes);
  private:
  const ::cn::seisys::v2x::pb::BrakeSystemStatus& _internal_brakes() const;
  ::cn::seisys::v2x::pb::BrakeSystemStatus* _internal_mutable_brakes();
  public:
  void unsafe_arena_set_allocated_brakes(
      ::cn::seisys::v2x::pb::BrakeSystemStatus* brakes);
  ::cn::seisys::v2x::pb::BrakeSystemStatus* unsafe_arena_release_brakes();

  // .cn.seisys.v2x.pb.ThrottleSystemStatus throttle = 14;
  bool has_throttle() const;
  private:
  bool _internal_has_throttle() const;
  public:
  void clear_throttle();
  const ::cn::seisys::v2x::pb::ThrottleSystemStatus& throttle() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ThrottleSystemStatus* release_throttle();
  ::cn::seisys::v2x::pb::ThrottleSystemStatus* mutable_throttle();
  void set_allocated_throttle(::cn::seisys::v2x::pb::ThrottleSystemStatus* throttle);
  private:
  const ::cn::seisys::v2x::pb::ThrottleSystemStatus& _internal_throttle() const;
  ::cn::seisys::v2x::pb::ThrottleSystemStatus* _internal_mutable_throttle();
  public:
  void unsafe_arena_set_allocated_throttle(
      ::cn::seisys::v2x::pb::ThrottleSystemStatus* throttle);
  ::cn::seisys::v2x::pb::ThrottleSystemStatus* unsafe_arena_release_throttle();

  // .cn.seisys.v2x.pb.VehicleSize size = 15;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::cn::seisys::v2x::pb::VehicleSize& size() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::VehicleSize* release_size();
  ::cn::seisys::v2x::pb::VehicleSize* mutable_size();
  void set_allocated_size(::cn::seisys::v2x::pb::VehicleSize* size);
  private:
  const ::cn::seisys::v2x::pb::VehicleSize& _internal_size() const;
  ::cn::seisys::v2x::pb::VehicleSize* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::cn::seisys::v2x::pb::VehicleSize* size);
  ::cn::seisys::v2x::pb::VehicleSize* unsafe_arena_release_size();

  // uint64 timestamp = 3;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.BsmData.TransmissionState transmission = 8;
  void clear_transmission();
  ::cn::seisys::v2x::pb::BsmData_TransmissionState transmission() const;
  void set_transmission(::cn::seisys::v2x::pb::BsmData_TransmissionState value);
  private:
  ::cn::seisys::v2x::pb::BsmData_TransmissionState _internal_transmission() const;
  void _internal_set_transmission(::cn::seisys::v2x::pb::BsmData_TransmissionState value);
  public:

  // uint32 speed = 9;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // uint32 heading = 10;
  void clear_heading();
  uint32_t heading() const;
  void set_heading(uint32_t value);
  private:
  uint32_t _internal_heading() const;
  void _internal_set_heading(uint32_t value);
  public:

  // int32 steeringWheelAngle = 11;
  void clear_steeringwheelangle();
  int32_t steeringwheelangle() const;
  void set_steeringwheelangle(int32_t value);
  private:
  int32_t _internal_steeringwheelangle() const;
  void _internal_set_steeringwheelangle(int32_t value);
  public:

  // .cn.seisys.v2x.pb.VehicleType vehicleType = 16;
  void clear_vehicletype();
  ::cn::seisys::v2x::pb::VehicleType vehicletype() const;
  void set_vehicletype(::cn::seisys::v2x::pb::VehicleType value);
  private:
  ::cn::seisys::v2x::pb::VehicleType _internal_vehicletype() const;
  void _internal_set_vehicletype(::cn::seisys::v2x::pb::VehicleType value);
  public:

  // .cn.seisys.v2x.pb.BsmData.VehicleFuelType fuelType = 17;
  void clear_fueltype();
  ::cn::seisys::v2x::pb::BsmData_VehicleFuelType fueltype() const;
  void set_fueltype(::cn::seisys::v2x::pb::BsmData_VehicleFuelType value);
  private:
  ::cn::seisys::v2x::pb::BsmData_VehicleFuelType _internal_fueltype() const;
  void _internal_set_fueltype(::cn::seisys::v2x::pb::BsmData_VehicleFuelType value);
  public:

  // .cn.seisys.v2x.pb.BsmData.DriveStatus driveModedriveStatus = 18;
  void clear_drivemodedrivestatus();
  ::cn::seisys::v2x::pb::BsmData_DriveStatus drivemodedrivestatus() const;
  void set_drivemodedrivestatus(::cn::seisys::v2x::pb::BsmData_DriveStatus value);
  private:
  ::cn::seisys::v2x::pb::BsmData_DriveStatus _internal_drivemodedrivestatus() const;
  void _internal_set_drivemodedrivestatus(::cn::seisys::v2x::pb::BsmData_DriveStatus value);
  public:

  // .cn.seisys.v2x.pb.BsmData.EmergenyStatus emergencyStatus = 19;
  void clear_emergencystatus();
  ::cn::seisys::v2x::pb::BsmData_EmergenyStatus emergencystatus() const;
  void set_emergencystatus(::cn::seisys::v2x::pb::BsmData_EmergenyStatus value);
  private:
  ::cn::seisys::v2x::pb::BsmData_EmergenyStatus _internal_emergencystatus() const;
  void _internal_set_emergencystatus(::cn::seisys::v2x::pb::BsmData_EmergenyStatus value);
  public:

  // uint32 light = 20;
  void clear_light();
  uint32_t light() const;
  void set_light(uint32_t value);
  private:
  uint32_t _internal_light() const;
  void _internal_set_light(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.BsmData.Wiper wiper = 21;
  void clear_wiper();
  ::cn::seisys::v2x::pb::BsmData_Wiper wiper() const;
  void set_wiper(::cn::seisys::v2x::pb::BsmData_Wiper value);
  private:
  ::cn::seisys::v2x::pb::BsmData_Wiper _internal_wiper() const;
  void _internal_set_wiper(::cn::seisys::v2x::pb::BsmData_Wiper value);
  public:

  // .cn.seisys.v2x.pb.BsmData.OutofControl outofControl = 22;
  void clear_outofcontrol();
  ::cn::seisys::v2x::pb::BsmData_OutofControl outofcontrol() const;
  void set_outofcontrol(::cn::seisys::v2x::pb::BsmData_OutofControl value);
  private:
  ::cn::seisys::v2x::pb::BsmData_OutofControl _internal_outofcontrol() const;
  void _internal_set_outofcontrol(::cn::seisys::v2x::pb::BsmData_OutofControl value);
  public:

  // uint32 endurance = 23;
  void clear_endurance();
  uint32_t endurance() const;
  void set_endurance(uint32_t value);
  private:
  uint32_t _internal_endurance() const;
  void _internal_set_endurance(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.BsmData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plateno_;
    ::cn::seisys::v2x::pb::Position3D* pos_;
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid_;
    ::cn::seisys::v2x::pb::PositionAccuracy* posaccuracy_;
    ::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration_;
    ::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid_;
    ::cn::seisys::v2x::pb::BrakeSystemStatus* brakes_;
    ::cn::seisys::v2x::pb::ThrottleSystemStatus* throttle_;
    ::cn::seisys::v2x::pb::VehicleSize* size_;
    uint64_t timestamp_;
    int transmission_;
    uint32_t speed_;
    uint32_t heading_;
    int32_t steeringwheelangle_;
    int vehicletype_;
    int fueltype_;
    int drivemodedrivestatus_;
    int emergencystatus_;
    uint32_t light_;
    int wiper_;
    int outofcontrol_;
    uint32_t endurance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class PathHistoryPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.PathHistoryPoint) */ {
 public:
  inline PathHistoryPoint() : PathHistoryPoint(nullptr) {}
  ~PathHistoryPoint() override;
  explicit PROTOBUF_CONSTEXPR PathHistoryPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathHistoryPoint(const PathHistoryPoint& from);
  PathHistoryPoint(PathHistoryPoint&& from) noexcept
    : PathHistoryPoint() {
    *this = ::std::move(from);
  }

  inline PathHistoryPoint& operator=(const PathHistoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathHistoryPoint& operator=(PathHistoryPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathHistoryPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathHistoryPoint* internal_default_instance() {
    return reinterpret_cast<const PathHistoryPoint*>(
               &_PathHistoryPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(PathHistoryPoint& a, PathHistoryPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(PathHistoryPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathHistoryPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathHistoryPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathHistoryPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathHistoryPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathHistoryPoint& from) {
    PathHistoryPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathHistoryPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.PathHistoryPoint";
  }
  protected:
  explicit PathHistoryPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kPosConfidFieldNumber = 4,
    kTimeOffsetFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kHeadingFieldNumber = 5,
  };
  // .cn.seisys.v2x.pb.Position3D pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::cn::seisys::v2x::pb::Position3D& pos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_pos();
  ::cn::seisys::v2x::pb::Position3D* mutable_pos();
  void set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_pos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::cn::seisys::v2x::pb::Position3D* pos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_pos();

  // .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 4;
  bool has_posconfid() const;
  private:
  bool _internal_has_posconfid() const;
  public:
  void clear_posconfid();
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& posconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PositionConfidenceSet* release_posconfid();
  ::cn::seisys::v2x::pb::PositionConfidenceSet* mutable_posconfid();
  void set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  private:
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& _internal_posconfid() const;
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _internal_mutable_posconfid();
  public:
  void unsafe_arena_set_allocated_posconfid(
      ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  ::cn::seisys::v2x::pb::PositionConfidenceSet* unsafe_arena_release_posconfid();

  // uint32 timeOffset = 2;
  void clear_timeoffset();
  uint32_t timeoffset() const;
  void set_timeoffset(uint32_t value);
  private:
  uint32_t _internal_timeoffset() const;
  void _internal_set_timeoffset(uint32_t value);
  public:

  // uint32 speed = 3;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // uint32 heading = 5;
  void clear_heading();
  uint32_t heading() const;
  void set_heading(uint32_t value);
  private:
  uint32_t _internal_heading() const;
  void _internal_set_heading(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.PathHistoryPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::Position3D* pos_;
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid_;
    uint32_t timeoffset_;
    uint32_t speed_;
    uint32_t heading_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ParticipantData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ParticipantData) */ {
 public:
  inline ParticipantData() : ParticipantData(nullptr) {}
  ~ParticipantData() override;
  explicit PROTOBUF_CONSTEXPR ParticipantData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantData(const ParticipantData& from);
  ParticipantData(ParticipantData&& from) noexcept
    : ParticipantData() {
    *this = ::std::move(from);
  }

  inline ParticipantData& operator=(const ParticipantData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantData& operator=(ParticipantData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantData* internal_default_instance() {
    return reinterpret_cast<const ParticipantData*>(
               &_ParticipantData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ParticipantData& a, ParticipantData& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantData& from) {
    ParticipantData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ParticipantData";
  }
  protected:
  explicit ParticipantData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ParticipantData_PlateColor PlateColor;
  static constexpr PlateColor UNKNOWN_PLATE_COLOR =
    ParticipantData_PlateColor_UNKNOWN_PLATE_COLOR;
  static constexpr PlateColor BLUE_PLATE =
    ParticipantData_PlateColor_BLUE_PLATE;
  static constexpr PlateColor YELLOW_PLATE =
    ParticipantData_PlateColor_YELLOW_PLATE;
  static constexpr PlateColor WHITE_PLATE =
    ParticipantData_PlateColor_WHITE_PLATE;
  static constexpr PlateColor BLACK_PLATE =
    ParticipantData_PlateColor_BLACK_PLATE;
  static constexpr PlateColor YELLOW_GREEN_PLATE =
    ParticipantData_PlateColor_YELLOW_GREEN_PLATE;
  static constexpr PlateColor GRADIENT_GREEN_PLATE =
    ParticipantData_PlateColor_GRADIENT_GREEN_PLATE;
  static inline bool PlateColor_IsValid(int value) {
    return ParticipantData_PlateColor_IsValid(value);
  }
  static constexpr PlateColor PlateColor_MIN =
    ParticipantData_PlateColor_PlateColor_MIN;
  static constexpr PlateColor PlateColor_MAX =
    ParticipantData_PlateColor_PlateColor_MAX;
  static constexpr int PlateColor_ARRAYSIZE =
    ParticipantData_PlateColor_PlateColor_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PlateColor_descriptor() {
    return ParticipantData_PlateColor_descriptor();
  }
  template<typename T>
  static inline const std::string& PlateColor_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PlateColor>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PlateColor_Name.");
    return ParticipantData_PlateColor_Name(enum_t_value);
  }
  static inline bool PlateColor_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PlateColor* value) {
    return ParticipantData_PlateColor_Parse(name, value);
  }

  typedef ParticipantData_VehicleColor VehicleColor;
  static constexpr VehicleColor UNKNOWN_VEHICEL_COLOR =
    ParticipantData_VehicleColor_UNKNOWN_VEHICEL_COLOR;
  static constexpr VehicleColor WHITE =
    ParticipantData_VehicleColor_WHITE;
  static constexpr VehicleColor GRAY =
    ParticipantData_VehicleColor_GRAY;
  static constexpr VehicleColor YELLOW =
    ParticipantData_VehicleColor_YELLOW;
  static constexpr VehicleColor PINK =
    ParticipantData_VehicleColor_PINK;
  static constexpr VehicleColor RED =
    ParticipantData_VehicleColor_RED;
  static constexpr VehicleColor GREEN =
    ParticipantData_VehicleColor_GREEN;
  static constexpr VehicleColor BLUE =
    ParticipantData_VehicleColor_BLUE;
  static constexpr VehicleColor BROWN =
    ParticipantData_VehicleColor_BROWN;
  static constexpr VehicleColor BLACK =
    ParticipantData_VehicleColor_BLACK;
  static constexpr VehicleColor PURPLE =
    ParticipantData_VehicleColor_PURPLE;
  static constexpr VehicleColor OTHER =
    ParticipantData_VehicleColor_OTHER;
  static inline bool VehicleColor_IsValid(int value) {
    return ParticipantData_VehicleColor_IsValid(value);
  }
  static constexpr VehicleColor VehicleColor_MIN =
    ParticipantData_VehicleColor_VehicleColor_MIN;
  static constexpr VehicleColor VehicleColor_MAX =
    ParticipantData_VehicleColor_VehicleColor_MAX;
  static constexpr int VehicleColor_ARRAYSIZE =
    ParticipantData_VehicleColor_VehicleColor_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VehicleColor_descriptor() {
    return ParticipantData_VehicleColor_descriptor();
  }
  template<typename T>
  static inline const std::string& VehicleColor_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehicleColor>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehicleColor_Name.");
    return ParticipantData_VehicleColor_Name(enum_t_value);
  }
  static inline bool VehicleColor_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VehicleColor* value) {
    return ParticipantData_VehicleColor_Parse(name, value);
  }

  typedef ParticipantData_ParticipantTypeExt ParticipantTypeExt;
  static constexpr ParticipantTypeExt UNKNOWN_OBJECT_TYPE_EXT =
    ParticipantData_ParticipantTypeExt_UNKNOWN_OBJECT_TYPE_EXT;
  static constexpr ParticipantTypeExt UNKNOWN_MOVABLE =
    ParticipantData_ParticipantTypeExt_UNKNOWN_MOVABLE;
  static constexpr ParticipantTypeExt UNKNOWN_UNMOVABLE =
    ParticipantData_ParticipantTypeExt_UNKNOWN_UNMOVABLE;
  static constexpr ParticipantTypeExt CAR =
    ParticipantData_ParticipantTypeExt_CAR;
  static constexpr ParticipantTypeExt VAN =
    ParticipantData_ParticipantTypeExt_VAN;
  static constexpr ParticipantTypeExt TRUCK =
    ParticipantData_ParticipantTypeExt_TRUCK;
  static constexpr ParticipantTypeExt BUS =
    ParticipantData_ParticipantTypeExt_BUS;
  static constexpr ParticipantTypeExt CYCLIST =
    ParticipantData_ParticipantTypeExt_CYCLIST;
  static constexpr ParticipantTypeExt MOTORCYCLIST =
    ParticipantData_ParticipantTypeExt_MOTORCYCLIST;
  static constexpr ParticipantTypeExt TRICYCLIST =
    ParticipantData_ParticipantTypeExt_TRICYCLIST;
  static constexpr ParticipantTypeExt PEDESTRIAN =
    ParticipantData_ParticipantTypeExt_PEDESTRIAN;
  static inline bool ParticipantTypeExt_IsValid(int value) {
    return ParticipantData_ParticipantTypeExt_IsValid(value);
  }
  static constexpr ParticipantTypeExt ParticipantTypeExt_MIN =
    ParticipantData_ParticipantTypeExt_ParticipantTypeExt_MIN;
  static constexpr ParticipantTypeExt ParticipantTypeExt_MAX =
    ParticipantData_ParticipantTypeExt_ParticipantTypeExt_MAX;
  static constexpr int ParticipantTypeExt_ARRAYSIZE =
    ParticipantData_ParticipantTypeExt_ParticipantTypeExt_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ParticipantTypeExt_descriptor() {
    return ParticipantData_ParticipantTypeExt_descriptor();
  }
  template<typename T>
  static inline const std::string& ParticipantTypeExt_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ParticipantTypeExt>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ParticipantTypeExt_Name.");
    return ParticipantData_ParticipantTypeExt_Name(enum_t_value);
  }
  static inline bool ParticipantTypeExt_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ParticipantTypeExt* value) {
    return ParticipantData_ParticipantTypeExt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathHistoryFieldNumber = 26,
    kDeviceIdListFieldNumber = 4,
    kVehicleBandFieldNumber = 16,
    kPlateNoFieldNumber = 18,
    kPtcPosFieldNumber = 7,
    kMapLocationFieldNumber = 8,
    kPosConfidFieldNumber = 9,
    kMotionConfidFieldNumber = 12,
    kAccelSetFieldNumber = 13,
    kAccelerationConfidFieldNumber = 14,
    kPtcSizeFieldNumber = 15,
    kPtcSizeConfidFieldNumber = 22,
    kPolygonFieldNumber = 28,
    kPtcIdFieldNumber = 1,
    kPtcTypeFieldNumber = 2,
    kDataSourceFieldNumber = 3,
    kTimestampFieldNumber = 5,
    kTimeConfidenceFieldNumber = 6,
    kSpeedFieldNumber = 10,
    kHeadingFieldNumber = 11,
    kVehicleTypeFieldNumber = 17,
    kPlateTypeFieldNumber = 19,
    kPlateColorFieldNumber = 20,
    kVehicleColorFieldNumber = 21,
    kPtcTypeExtFieldNumber = 23,
    kPtcTypeExtConfidFieldNumber = 24,
    kStatusDurationFieldNumber = 25,
    kIdFieldNumber = 29,
    kTrackingFieldNumber = 27,
  };
  // repeated .cn.seisys.v2x.pb.PathHistoryPoint pathHistory = 26;
  int pathhistory_size() const;
  private:
  int _internal_pathhistory_size() const;
  public:
  void clear_pathhistory();
  ::cn::seisys::v2x::pb::PathHistoryPoint* mutable_pathhistory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathHistoryPoint >*
      mutable_pathhistory();
  private:
  const ::cn::seisys::v2x::pb::PathHistoryPoint& _internal_pathhistory(int index) const;
  ::cn::seisys::v2x::pb::PathHistoryPoint* _internal_add_pathhistory();
  public:
  const ::cn::seisys::v2x::pb::PathHistoryPoint& pathhistory(int index) const;
  ::cn::seisys::v2x::pb::PathHistoryPoint* add_pathhistory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathHistoryPoint >&
      pathhistory() const;

  // string deviceIdList = 4;
  void clear_deviceidlist();
  const std::string& deviceidlist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceidlist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceidlist();
  PROTOBUF_NODISCARD std::string* release_deviceidlist();
  void set_allocated_deviceidlist(std::string* deviceidlist);
  private:
  const std::string& _internal_deviceidlist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceidlist(const std::string& value);
  std::string* _internal_mutable_deviceidlist();
  public:

  // string vehicleBand = 16;
  void clear_vehicleband();
  const std::string& vehicleband() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vehicleband(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vehicleband();
  PROTOBUF_NODISCARD std::string* release_vehicleband();
  void set_allocated_vehicleband(std::string* vehicleband);
  private:
  const std::string& _internal_vehicleband() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleband(const std::string& value);
  std::string* _internal_mutable_vehicleband();
  public:

  // string plateNo = 18;
  void clear_plateno();
  const std::string& plateno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plateno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plateno();
  PROTOBUF_NODISCARD std::string* release_plateno();
  void set_allocated_plateno(std::string* plateno);
  private:
  const std::string& _internal_plateno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plateno(const std::string& value);
  std::string* _internal_mutable_plateno();
  public:

  // .cn.seisys.v2x.pb.Position3D ptcPos = 7;
  bool has_ptcpos() const;
  private:
  bool _internal_has_ptcpos() const;
  public:
  void clear_ptcpos();
  const ::cn::seisys::v2x::pb::Position3D& ptcpos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_ptcpos();
  ::cn::seisys::v2x::pb::Position3D* mutable_ptcpos();
  void set_allocated_ptcpos(::cn::seisys::v2x::pb::Position3D* ptcpos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_ptcpos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_ptcpos();
  public:
  void unsafe_arena_set_allocated_ptcpos(
      ::cn::seisys::v2x::pb::Position3D* ptcpos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_ptcpos();

  // .cn.seisys.v2x.pb.MapLocation mapLocation = 8;
  bool has_maplocation() const;
  private:
  bool _internal_has_maplocation() const;
  public:
  void clear_maplocation();
  const ::cn::seisys::v2x::pb::MapLocation& maplocation() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::MapLocation* release_maplocation();
  ::cn::seisys::v2x::pb::MapLocation* mutable_maplocation();
  void set_allocated_maplocation(::cn::seisys::v2x::pb::MapLocation* maplocation);
  private:
  const ::cn::seisys::v2x::pb::MapLocation& _internal_maplocation() const;
  ::cn::seisys::v2x::pb::MapLocation* _internal_mutable_maplocation();
  public:
  void unsafe_arena_set_allocated_maplocation(
      ::cn::seisys::v2x::pb::MapLocation* maplocation);
  ::cn::seisys::v2x::pb::MapLocation* unsafe_arena_release_maplocation();

  // .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 9;
  bool has_posconfid() const;
  private:
  bool _internal_has_posconfid() const;
  public:
  void clear_posconfid();
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& posconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PositionConfidenceSet* release_posconfid();
  ::cn::seisys::v2x::pb::PositionConfidenceSet* mutable_posconfid();
  void set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  private:
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& _internal_posconfid() const;
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _internal_mutable_posconfid();
  public:
  void unsafe_arena_set_allocated_posconfid(
      ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  ::cn::seisys::v2x::pb::PositionConfidenceSet* unsafe_arena_release_posconfid();

  // .cn.seisys.v2x.pb.MotionConfidenceSet motionConfid = 12;
  bool has_motionconfid() const;
  private:
  bool _internal_has_motionconfid() const;
  public:
  void clear_motionconfid();
  const ::cn::seisys::v2x::pb::MotionConfidenceSet& motionconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::MotionConfidenceSet* release_motionconfid();
  ::cn::seisys::v2x::pb::MotionConfidenceSet* mutable_motionconfid();
  void set_allocated_motionconfid(::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid);
  private:
  const ::cn::seisys::v2x::pb::MotionConfidenceSet& _internal_motionconfid() const;
  ::cn::seisys::v2x::pb::MotionConfidenceSet* _internal_mutable_motionconfid();
  public:
  void unsafe_arena_set_allocated_motionconfid(
      ::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid);
  ::cn::seisys::v2x::pb::MotionConfidenceSet* unsafe_arena_release_motionconfid();

  // .cn.seisys.v2x.pb.AccelerationSet4Way accelSet = 13;
  bool has_accelset() const;
  private:
  bool _internal_has_accelset() const;
  public:
  void clear_accelset();
  const ::cn::seisys::v2x::pb::AccelerationSet4Way& accelset() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::AccelerationSet4Way* release_accelset();
  ::cn::seisys::v2x::pb::AccelerationSet4Way* mutable_accelset();
  void set_allocated_accelset(::cn::seisys::v2x::pb::AccelerationSet4Way* accelset);
  private:
  const ::cn::seisys::v2x::pb::AccelerationSet4Way& _internal_accelset() const;
  ::cn::seisys::v2x::pb::AccelerationSet4Way* _internal_mutable_accelset();
  public:
  void unsafe_arena_set_allocated_accelset(
      ::cn::seisys::v2x::pb::AccelerationSet4Way* accelset);
  ::cn::seisys::v2x::pb::AccelerationSet4Way* unsafe_arena_release_accelset();

  // .cn.seisys.v2x.pb.AccelerationConfidence accelerationConfid = 14;
  bool has_accelerationconfid() const;
  private:
  bool _internal_has_accelerationconfid() const;
  public:
  void clear_accelerationconfid();
  const ::cn::seisys::v2x::pb::AccelerationConfidence& accelerationconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::AccelerationConfidence* release_accelerationconfid();
  ::cn::seisys::v2x::pb::AccelerationConfidence* mutable_accelerationconfid();
  void set_allocated_accelerationconfid(::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid);
  private:
  const ::cn::seisys::v2x::pb::AccelerationConfidence& _internal_accelerationconfid() const;
  ::cn::seisys::v2x::pb::AccelerationConfidence* _internal_mutable_accelerationconfid();
  public:
  void unsafe_arena_set_allocated_accelerationconfid(
      ::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid);
  ::cn::seisys::v2x::pb::AccelerationConfidence* unsafe_arena_release_accelerationconfid();

  // .cn.seisys.v2x.pb.ParticipantSize ptcSize = 15;
  bool has_ptcsize() const;
  private:
  bool _internal_has_ptcsize() const;
  public:
  void clear_ptcsize();
  const ::cn::seisys::v2x::pb::ParticipantSize& ptcsize() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ParticipantSize* release_ptcsize();
  ::cn::seisys::v2x::pb::ParticipantSize* mutable_ptcsize();
  void set_allocated_ptcsize(::cn::seisys::v2x::pb::ParticipantSize* ptcsize);
  private:
  const ::cn::seisys::v2x::pb::ParticipantSize& _internal_ptcsize() const;
  ::cn::seisys::v2x::pb::ParticipantSize* _internal_mutable_ptcsize();
  public:
  void unsafe_arena_set_allocated_ptcsize(
      ::cn::seisys::v2x::pb::ParticipantSize* ptcsize);
  ::cn::seisys::v2x::pb::ParticipantSize* unsafe_arena_release_ptcsize();

  // .cn.seisys.v2x.pb.ParticipantSizeConfidence ptcSizeConfid = 22;
  bool has_ptcsizeconfid() const;
  private:
  bool _internal_has_ptcsizeconfid() const;
  public:
  void clear_ptcsizeconfid();
  const ::cn::seisys::v2x::pb::ParticipantSizeConfidence& ptcsizeconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ParticipantSizeConfidence* release_ptcsizeconfid();
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* mutable_ptcsizeconfid();
  void set_allocated_ptcsizeconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence* ptcsizeconfid);
  private:
  const ::cn::seisys::v2x::pb::ParticipantSizeConfidence& _internal_ptcsizeconfid() const;
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* _internal_mutable_ptcsizeconfid();
  public:
  void unsafe_arena_set_allocated_ptcsizeconfid(
      ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ptcsizeconfid);
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* unsafe_arena_release_ptcsizeconfid();

  // .cn.seisys.v2x.pb.Polygon polygon = 28;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::cn::seisys::v2x::pb::Polygon& polygon() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Polygon* release_polygon();
  ::cn::seisys::v2x::pb::Polygon* mutable_polygon();
  void set_allocated_polygon(::cn::seisys::v2x::pb::Polygon* polygon);
  private:
  const ::cn::seisys::v2x::pb::Polygon& _internal_polygon() const;
  ::cn::seisys::v2x::pb::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::cn::seisys::v2x::pb::Polygon* polygon);
  ::cn::seisys::v2x::pb::Polygon* unsafe_arena_release_polygon();

  // uint64 ptcId = 1;
  void clear_ptcid();
  uint64_t ptcid() const;
  void set_ptcid(uint64_t value);
  private:
  uint64_t _internal_ptcid() const;
  void _internal_set_ptcid(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.ParticipantType ptcType = 2;
  void clear_ptctype();
  ::cn::seisys::v2x::pb::ParticipantType ptctype() const;
  void set_ptctype(::cn::seisys::v2x::pb::ParticipantType value);
  private:
  ::cn::seisys::v2x::pb::ParticipantType _internal_ptctype() const;
  void _internal_set_ptctype(::cn::seisys::v2x::pb::ParticipantType value);
  public:

  // .cn.seisys.v2x.pb.DataSource dataSource = 3;
  void clear_datasource();
  ::cn::seisys::v2x::pb::DataSource datasource() const;
  void set_datasource(::cn::seisys::v2x::pb::DataSource value);
  private:
  ::cn::seisys::v2x::pb::DataSource _internal_datasource() const;
  void _internal_set_datasource(::cn::seisys::v2x::pb::DataSource value);
  public:

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.TimeConfidence timeConfidence = 6;
  void clear_timeconfidence();
  ::cn::seisys::v2x::pb::TimeConfidence timeconfidence() const;
  void set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  private:
  ::cn::seisys::v2x::pb::TimeConfidence _internal_timeconfidence() const;
  void _internal_set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  public:

  // uint32 speed = 10;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // uint32 heading = 11;
  void clear_heading();
  uint32_t heading() const;
  void set_heading(uint32_t value);
  private:
  uint32_t _internal_heading() const;
  void _internal_set_heading(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.VehicleType vehicleType = 17;
  void clear_vehicletype();
  ::cn::seisys::v2x::pb::VehicleType vehicletype() const;
  void set_vehicletype(::cn::seisys::v2x::pb::VehicleType value);
  private:
  ::cn::seisys::v2x::pb::VehicleType _internal_vehicletype() const;
  void _internal_set_vehicletype(::cn::seisys::v2x::pb::VehicleType value);
  public:

  // .cn.seisys.v2x.pb.PlateType plateType = 19;
  void clear_platetype();
  ::cn::seisys::v2x::pb::PlateType platetype() const;
  void set_platetype(::cn::seisys::v2x::pb::PlateType value);
  private:
  ::cn::seisys::v2x::pb::PlateType _internal_platetype() const;
  void _internal_set_platetype(::cn::seisys::v2x::pb::PlateType value);
  public:

  // .cn.seisys.v2x.pb.ParticipantData.PlateColor plateColor = 20;
  void clear_platecolor();
  ::cn::seisys::v2x::pb::ParticipantData_PlateColor platecolor() const;
  void set_platecolor(::cn::seisys::v2x::pb::ParticipantData_PlateColor value);
  private:
  ::cn::seisys::v2x::pb::ParticipantData_PlateColor _internal_platecolor() const;
  void _internal_set_platecolor(::cn::seisys::v2x::pb::ParticipantData_PlateColor value);
  public:

  // .cn.seisys.v2x.pb.ParticipantData.VehicleColor vehicleColor = 21;
  void clear_vehiclecolor();
  ::cn::seisys::v2x::pb::ParticipantData_VehicleColor vehiclecolor() const;
  void set_vehiclecolor(::cn::seisys::v2x::pb::ParticipantData_VehicleColor value);
  private:
  ::cn::seisys::v2x::pb::ParticipantData_VehicleColor _internal_vehiclecolor() const;
  void _internal_set_vehiclecolor(::cn::seisys::v2x::pb::ParticipantData_VehicleColor value);
  public:

  // .cn.seisys.v2x.pb.ParticipantData.ParticipantTypeExt ptcTypeExt = 23;
  void clear_ptctypeext();
  ::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt ptctypeext() const;
  void set_ptctypeext(::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt value);
  private:
  ::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt _internal_ptctypeext() const;
  void _internal_set_ptctypeext(::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt value);
  public:

  // uint32 ptcTypeExtConfid = 24;
  void clear_ptctypeextconfid();
  uint32_t ptctypeextconfid() const;
  void set_ptctypeextconfid(uint32_t value);
  private:
  uint32_t _internal_ptctypeextconfid() const;
  void _internal_set_ptctypeextconfid(uint32_t value);
  public:

  // uint32 statusDuration = 25;
  void clear_statusduration();
  uint32_t statusduration() const;
  void set_statusduration(uint32_t value);
  private:
  uint32_t _internal_statusduration() const;
  void _internal_set_statusduration(uint32_t value);
  public:

  // uint64 id = 29;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint32 tracking = 27;
  void clear_tracking();
  uint32_t tracking() const;
  void set_tracking(uint32_t value);
  private:
  uint32_t _internal_tracking() const;
  void _internal_set_tracking(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ParticipantData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathHistoryPoint > pathhistory_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceidlist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicleband_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plateno_;
    ::cn::seisys::v2x::pb::Position3D* ptcpos_;
    ::cn::seisys::v2x::pb::MapLocation* maplocation_;
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid_;
    ::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid_;
    ::cn::seisys::v2x::pb::AccelerationSet4Way* accelset_;
    ::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid_;
    ::cn::seisys::v2x::pb::ParticipantSize* ptcsize_;
    ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ptcsizeconfid_;
    ::cn::seisys::v2x::pb::Polygon* polygon_;
    uint64_t ptcid_;
    int ptctype_;
    int datasource_;
    uint64_t timestamp_;
    int timeconfidence_;
    uint32_t speed_;
    uint32_t heading_;
    int vehicletype_;
    int platetype_;
    int platecolor_;
    int vehiclecolor_;
    int ptctypeext_;
    uint32_t ptctypeextconfid_;
    uint32_t statusduration_;
    uint64_t id_;
    uint32_t tracking_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ObstacleData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ObstacleData) */ {
 public:
  inline ObstacleData() : ObstacleData(nullptr) {}
  ~ObstacleData() override;
  explicit PROTOBUF_CONSTEXPR ObstacleData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleData(const ObstacleData& from);
  ObstacleData(ObstacleData&& from) noexcept
    : ObstacleData() {
    *this = ::std::move(from);
  }

  inline ObstacleData& operator=(const ObstacleData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleData& operator=(ObstacleData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleData* internal_default_instance() {
    return reinterpret_cast<const ObstacleData*>(
               &_ObstacleData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ObstacleData& a, ObstacleData& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObstacleData& from) {
    ObstacleData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ObstacleData";
  }
  protected:
  explicit ObstacleData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdListFieldNumber = 6,
    kObsPosFieldNumber = 7,
    kPosConfidFieldNumber = 8,
    kMapLocationFieldNumber = 9,
    kMotionConfidFieldNumber = 12,
    kAccelerationFieldNumber = 15,
    kSizeFieldNumber = 16,
    kObsSizeConfidFieldNumber = 17,
    kPolygonFieldNumber = 19,
    kObsIdFieldNumber = 1,
    kObsTypeFieldNumber = 2,
    kObstypeCfdFieldNumber = 3,
    kTimestampFieldNumber = 5,
    kObsSourceFieldNumber = 4,
    kSpeedFieldNumber = 10,
    kHeadingFieldNumber = 11,
    kVerSpeedFieldNumber = 13,
    kVerSpeedConfidFieldNumber = 14,
    kTrackingFieldNumber = 18,
  };
  // string deviceIdList = 6;
  void clear_deviceidlist();
  const std::string& deviceidlist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceidlist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceidlist();
  PROTOBUF_NODISCARD std::string* release_deviceidlist();
  void set_allocated_deviceidlist(std::string* deviceidlist);
  private:
  const std::string& _internal_deviceidlist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceidlist(const std::string& value);
  std::string* _internal_mutable_deviceidlist();
  public:

  // .cn.seisys.v2x.pb.Position3D obsPos = 7;
  bool has_obspos() const;
  private:
  bool _internal_has_obspos() const;
  public:
  void clear_obspos();
  const ::cn::seisys::v2x::pb::Position3D& obspos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_obspos();
  ::cn::seisys::v2x::pb::Position3D* mutable_obspos();
  void set_allocated_obspos(::cn::seisys::v2x::pb::Position3D* obspos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_obspos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_obspos();
  public:
  void unsafe_arena_set_allocated_obspos(
      ::cn::seisys::v2x::pb::Position3D* obspos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_obspos();

  // .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 8;
  bool has_posconfid() const;
  private:
  bool _internal_has_posconfid() const;
  public:
  void clear_posconfid();
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& posconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PositionConfidenceSet* release_posconfid();
  ::cn::seisys::v2x::pb::PositionConfidenceSet* mutable_posconfid();
  void set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  private:
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& _internal_posconfid() const;
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _internal_mutable_posconfid();
  public:
  void unsafe_arena_set_allocated_posconfid(
      ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  ::cn::seisys::v2x::pb::PositionConfidenceSet* unsafe_arena_release_posconfid();

  // .cn.seisys.v2x.pb.MapLocation mapLocation = 9;
  bool has_maplocation() const;
  private:
  bool _internal_has_maplocation() const;
  public:
  void clear_maplocation();
  const ::cn::seisys::v2x::pb::MapLocation& maplocation() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::MapLocation* release_maplocation();
  ::cn::seisys::v2x::pb::MapLocation* mutable_maplocation();
  void set_allocated_maplocation(::cn::seisys::v2x::pb::MapLocation* maplocation);
  private:
  const ::cn::seisys::v2x::pb::MapLocation& _internal_maplocation() const;
  ::cn::seisys::v2x::pb::MapLocation* _internal_mutable_maplocation();
  public:
  void unsafe_arena_set_allocated_maplocation(
      ::cn::seisys::v2x::pb::MapLocation* maplocation);
  ::cn::seisys::v2x::pb::MapLocation* unsafe_arena_release_maplocation();

  // .cn.seisys.v2x.pb.MotionConfidenceSet motionConfid = 12;
  bool has_motionconfid() const;
  private:
  bool _internal_has_motionconfid() const;
  public:
  void clear_motionconfid();
  const ::cn::seisys::v2x::pb::MotionConfidenceSet& motionconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::MotionConfidenceSet* release_motionconfid();
  ::cn::seisys::v2x::pb::MotionConfidenceSet* mutable_motionconfid();
  void set_allocated_motionconfid(::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid);
  private:
  const ::cn::seisys::v2x::pb::MotionConfidenceSet& _internal_motionconfid() const;
  ::cn::seisys::v2x::pb::MotionConfidenceSet* _internal_mutable_motionconfid();
  public:
  void unsafe_arena_set_allocated_motionconfid(
      ::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid);
  ::cn::seisys::v2x::pb::MotionConfidenceSet* unsafe_arena_release_motionconfid();

  // .cn.seisys.v2x.pb.AccelerationSet4Way acceleration = 15;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::cn::seisys::v2x::pb::AccelerationSet4Way& acceleration() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::AccelerationSet4Way* release_acceleration();
  ::cn::seisys::v2x::pb::AccelerationSet4Way* mutable_acceleration();
  void set_allocated_acceleration(::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration);
  private:
  const ::cn::seisys::v2x::pb::AccelerationSet4Way& _internal_acceleration() const;
  ::cn::seisys::v2x::pb::AccelerationSet4Way* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration);
  ::cn::seisys::v2x::pb::AccelerationSet4Way* unsafe_arena_release_acceleration();

  // .cn.seisys.v2x.pb.ParticipantSize size = 16;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::cn::seisys::v2x::pb::ParticipantSize& size() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ParticipantSize* release_size();
  ::cn::seisys::v2x::pb::ParticipantSize* mutable_size();
  void set_allocated_size(::cn::seisys::v2x::pb::ParticipantSize* size);
  private:
  const ::cn::seisys::v2x::pb::ParticipantSize& _internal_size() const;
  ::cn::seisys::v2x::pb::ParticipantSize* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::cn::seisys::v2x::pb::ParticipantSize* size);
  ::cn::seisys::v2x::pb::ParticipantSize* unsafe_arena_release_size();

  // .cn.seisys.v2x.pb.ParticipantSizeConfidence obsSizeConfid = 17;
  bool has_obssizeconfid() const;
  private:
  bool _internal_has_obssizeconfid() const;
  public:
  void clear_obssizeconfid();
  const ::cn::seisys::v2x::pb::ParticipantSizeConfidence& obssizeconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ParticipantSizeConfidence* release_obssizeconfid();
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* mutable_obssizeconfid();
  void set_allocated_obssizeconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence* obssizeconfid);
  private:
  const ::cn::seisys::v2x::pb::ParticipantSizeConfidence& _internal_obssizeconfid() const;
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* _internal_mutable_obssizeconfid();
  public:
  void unsafe_arena_set_allocated_obssizeconfid(
      ::cn::seisys::v2x::pb::ParticipantSizeConfidence* obssizeconfid);
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* unsafe_arena_release_obssizeconfid();

  // .cn.seisys.v2x.pb.Polygon polygon = 19;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::cn::seisys::v2x::pb::Polygon& polygon() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Polygon* release_polygon();
  ::cn::seisys::v2x::pb::Polygon* mutable_polygon();
  void set_allocated_polygon(::cn::seisys::v2x::pb::Polygon* polygon);
  private:
  const ::cn::seisys::v2x::pb::Polygon& _internal_polygon() const;
  ::cn::seisys::v2x::pb::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::cn::seisys::v2x::pb::Polygon* polygon);
  ::cn::seisys::v2x::pb::Polygon* unsafe_arena_release_polygon();

  // uint64 obsId = 1;
  void clear_obsid();
  uint64_t obsid() const;
  void set_obsid(uint64_t value);
  private:
  uint64_t _internal_obsid() const;
  void _internal_set_obsid(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.ObstaclesType obsType = 2;
  void clear_obstype();
  ::cn::seisys::v2x::pb::ObstaclesType obstype() const;
  void set_obstype(::cn::seisys::v2x::pb::ObstaclesType value);
  private:
  ::cn::seisys::v2x::pb::ObstaclesType _internal_obstype() const;
  void _internal_set_obstype(::cn::seisys::v2x::pb::ObstaclesType value);
  public:

  // uint32 obstypeCfd = 3;
  void clear_obstypecfd();
  uint32_t obstypecfd() const;
  void set_obstypecfd(uint32_t value);
  private:
  uint32_t _internal_obstypecfd() const;
  void _internal_set_obstypecfd(uint32_t value);
  public:

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.DataSource obsSource = 4;
  void clear_obssource();
  ::cn::seisys::v2x::pb::DataSource obssource() const;
  void set_obssource(::cn::seisys::v2x::pb::DataSource value);
  private:
  ::cn::seisys::v2x::pb::DataSource _internal_obssource() const;
  void _internal_set_obssource(::cn::seisys::v2x::pb::DataSource value);
  public:

  // uint32 speed = 10;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // uint32 heading = 11;
  void clear_heading();
  uint32_t heading() const;
  void set_heading(uint32_t value);
  private:
  uint32_t _internal_heading() const;
  void _internal_set_heading(uint32_t value);
  public:

  // uint32 verSpeed = 13;
  void clear_verspeed();
  uint32_t verspeed() const;
  void set_verspeed(uint32_t value);
  private:
  uint32_t _internal_verspeed() const;
  void _internal_set_verspeed(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.SpeedConfidence verSpeedConfid = 14;
  void clear_verspeedconfid();
  ::cn::seisys::v2x::pb::SpeedConfidence verspeedconfid() const;
  void set_verspeedconfid(::cn::seisys::v2x::pb::SpeedConfidence value);
  private:
  ::cn::seisys::v2x::pb::SpeedConfidence _internal_verspeedconfid() const;
  void _internal_set_verspeedconfid(::cn::seisys::v2x::pb::SpeedConfidence value);
  public:

  // uint32 tracking = 18;
  void clear_tracking();
  uint32_t tracking() const;
  void set_tracking(uint32_t value);
  private:
  uint32_t _internal_tracking() const;
  void _internal_set_tracking(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ObstacleData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceidlist_;
    ::cn::seisys::v2x::pb::Position3D* obspos_;
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid_;
    ::cn::seisys::v2x::pb::MapLocation* maplocation_;
    ::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid_;
    ::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration_;
    ::cn::seisys::v2x::pb::ParticipantSize* size_;
    ::cn::seisys::v2x::pb::ParticipantSizeConfidence* obssizeconfid_;
    ::cn::seisys::v2x::pb::Polygon* polygon_;
    uint64_t obsid_;
    int obstype_;
    uint32_t obstypecfd_;
    uint64_t timestamp_;
    int obssource_;
    uint32_t speed_;
    uint32_t heading_;
    uint32_t verspeed_;
    int verspeedconfid_;
    uint32_t tracking_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ObjIdValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ObjIdValue) */ {
 public:
  inline ObjIdValue() : ObjIdValue(nullptr) {}
  ~ObjIdValue() override;
  explicit PROTOBUF_CONSTEXPR ObjIdValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjIdValue(const ObjIdValue& from);
  ObjIdValue(ObjIdValue&& from) noexcept
    : ObjIdValue() {
    *this = ::std::move(from);
  }

  inline ObjIdValue& operator=(const ObjIdValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjIdValue& operator=(ObjIdValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjIdValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjIdValue* internal_default_instance() {
    return reinterpret_cast<const ObjIdValue*>(
               &_ObjIdValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ObjIdValue& a, ObjIdValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjIdValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjIdValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjIdValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjIdValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjIdValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjIdValue& from) {
    ObjIdValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjIdValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ObjIdValue";
  }
  protected:
  explicit ObjIdValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObjIdValue_Role Role;
  static constexpr Role ACTIVE =
    ObjIdValue_Role_ACTIVE;
  static constexpr Role PASSIVE =
    ObjIdValue_Role_PASSIVE;
  static constexpr Role NOTCLEAR =
    ObjIdValue_Role_NOTCLEAR;
  static inline bool Role_IsValid(int value) {
    return ObjIdValue_Role_IsValid(value);
  }
  static constexpr Role Role_MIN =
    ObjIdValue_Role_Role_MIN;
  static constexpr Role Role_MAX =
    ObjIdValue_Role_Role_MAX;
  static constexpr int Role_ARRAYSIZE =
    ObjIdValue_Role_Role_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Role_descriptor() {
    return ObjIdValue_Role_descriptor();
  }
  template<typename T>
  static inline const std::string& Role_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Role>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Role_Name.");
    return ObjIdValue_Role_Name(enum_t_value);
  }
  static inline bool Role_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Role* value) {
    return ObjIdValue_Role_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPtcIdFieldNumber = 1,
    kObsIdFieldNumber = 2,
    kRoleFieldNumber = 3,
  };
  // uint64 ptcId = 1;
  void clear_ptcid();
  uint64_t ptcid() const;
  void set_ptcid(uint64_t value);
  private:
  uint64_t _internal_ptcid() const;
  void _internal_set_ptcid(uint64_t value);
  public:

  // uint64 obsId = 2;
  void clear_obsid();
  uint64_t obsid() const;
  void set_obsid(uint64_t value);
  private:
  uint64_t _internal_obsid() const;
  void _internal_set_obsid(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.ObjIdValue.Role role = 3;
  void clear_role();
  ::cn::seisys::v2x::pb::ObjIdValue_Role role() const;
  void set_role(::cn::seisys::v2x::pb::ObjIdValue_Role value);
  private:
  ::cn::seisys::v2x::pb::ObjIdValue_Role _internal_role() const;
  void _internal_set_role(::cn::seisys::v2x::pb::ObjIdValue_Role value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ObjIdValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t ptcid_;
    uint64_t obsid_;
    int role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class RteData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.RteData) */ {
 public:
  inline RteData() : RteData(nullptr) {}
  ~RteData() override;
  explicit PROTOBUF_CONSTEXPR RteData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RteData(const RteData& from);
  RteData(RteData&& from) noexcept
    : RteData() {
    *this = ::std::move(from);
  }

  inline RteData& operator=(const RteData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RteData& operator=(RteData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RteData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RteData* internal_default_instance() {
    return reinterpret_cast<const RteData*>(
               &_RteData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(RteData& a, RteData& b) {
    a.Swap(&b);
  }
  inline void Swap(RteData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RteData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RteData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RteData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RteData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RteData& from) {
    RteData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RteData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.RteData";
  }
  protected:
  explicit RteData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RteData_EventSource EventSource;
  static constexpr EventSource UNKNOWN_EVENT_SOURCE =
    RteData_EventSource_UNKNOWN_EVENT_SOURCE;
  static constexpr EventSource TRAFFIC_POLICE =
    RteData_EventSource_TRAFFIC_POLICE;
  static constexpr EventSource GOVENMENT =
    RteData_EventSource_GOVENMENT;
  static constexpr EventSource METEOROLOGICAL_DEPARTMENT =
    RteData_EventSource_METEOROLOGICAL_DEPARTMENT;
  static constexpr EventSource INTERNET_SERVICES =
    RteData_EventSource_INTERNET_SERVICES;
  static constexpr EventSource LOCAL_DETECTION =
    RteData_EventSource_LOCAL_DETECTION;
  static inline bool EventSource_IsValid(int value) {
    return RteData_EventSource_IsValid(value);
  }
  static constexpr EventSource EventSource_MIN =
    RteData_EventSource_EventSource_MIN;
  static constexpr EventSource EventSource_MAX =
    RteData_EventSource_EventSource_MAX;
  static constexpr int EventSource_ARRAYSIZE =
    RteData_EventSource_EventSource_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EventSource_descriptor() {
    return RteData_EventSource_descriptor();
  }
  template<typename T>
  static inline const std::string& EventSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventSource_Name.");
    return RteData_EventSource_Name(enum_t_value);
  }
  static inline bool EventSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventSource* value) {
    return RteData_EventSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReferencePathFieldNumber = 12,
    kReferenceLinksFieldNumber = 13,
    kEventObjIdFieldNumber = 14,
    kDescriptionFieldNumber = 3,
    kDeviceIdListFieldNumber = 6,
    kPriorityFieldNumber = 11,
    kEventImagesFieldNumber = 16,
    kEventVideosFieldNumber = 17,
    kRtePosFieldNumber = 7,
    kMapLocationFieldNumber = 8,
    kTimeDetailsFieldNumber = 10,
    kRteIdFieldNumber = 1,
    kRteTypeFieldNumber = 2,
    kEventSourceFieldNumber = 4,
    kDataSourceFieldNumber = 5,
    kEventRadiusFieldNumber = 9,
    kEventConfidFieldNumber = 15,
    kSessionIdFieldNumber = 18,
    kIdFieldNumber = 19,
  };
  // repeated .cn.seisys.v2x.pb.ReferencePath referencePath = 12;
  int referencepath_size() const;
  private:
  int _internal_referencepath_size() const;
  public:
  void clear_referencepath();
  ::cn::seisys::v2x::pb::ReferencePath* mutable_referencepath(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >*
      mutable_referencepath();
  private:
  const ::cn::seisys::v2x::pb::ReferencePath& _internal_referencepath(int index) const;
  ::cn::seisys::v2x::pb::ReferencePath* _internal_add_referencepath();
  public:
  const ::cn::seisys::v2x::pb::ReferencePath& referencepath(int index) const;
  ::cn::seisys::v2x::pb::ReferencePath* add_referencepath();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >&
      referencepath() const;

  // repeated .cn.seisys.v2x.pb.ReferenceLink referenceLinks = 13;
  int referencelinks_size() const;
  private:
  int _internal_referencelinks_size() const;
  public:
  void clear_referencelinks();
  ::cn::seisys::v2x::pb::ReferenceLink* mutable_referencelinks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink >*
      mutable_referencelinks();
  private:
  const ::cn::seisys::v2x::pb::ReferenceLink& _internal_referencelinks(int index) const;
  ::cn::seisys::v2x::pb::ReferenceLink* _internal_add_referencelinks();
  public:
  const ::cn::seisys::v2x::pb::ReferenceLink& referencelinks(int index) const;
  ::cn::seisys::v2x::pb::ReferenceLink* add_referencelinks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink >&
      referencelinks() const;

  // repeated .cn.seisys.v2x.pb.ObjIdValue eventObjId = 14;
  int eventobjid_size() const;
  private:
  int _internal_eventobjid_size() const;
  public:
  void clear_eventobjid();
  ::cn::seisys::v2x::pb::ObjIdValue* mutable_eventobjid(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObjIdValue >*
      mutable_eventobjid();
  private:
  const ::cn::seisys::v2x::pb::ObjIdValue& _internal_eventobjid(int index) const;
  ::cn::seisys::v2x::pb::ObjIdValue* _internal_add_eventobjid();
  public:
  const ::cn::seisys::v2x::pb::ObjIdValue& eventobjid(int index) const;
  ::cn::seisys::v2x::pb::ObjIdValue* add_eventobjid();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObjIdValue >&
      eventobjid() const;

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string deviceIdList = 6;
  void clear_deviceidlist();
  const std::string& deviceidlist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceidlist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceidlist();
  PROTOBUF_NODISCARD std::string* release_deviceidlist();
  void set_allocated_deviceidlist(std::string* deviceidlist);
  private:
  const std::string& _internal_deviceidlist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceidlist(const std::string& value);
  std::string* _internal_mutable_deviceidlist();
  public:

  // string priority = 11;
  void clear_priority();
  const std::string& priority() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_priority(ArgT0&& arg0, ArgT... args);
  std::string* mutable_priority();
  PROTOBUF_NODISCARD std::string* release_priority();
  void set_allocated_priority(std::string* priority);
  private:
  const std::string& _internal_priority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_priority(const std::string& value);
  std::string* _internal_mutable_priority();
  public:

  // string eventImages = 16;
  void clear_eventimages();
  const std::string& eventimages() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eventimages(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eventimages();
  PROTOBUF_NODISCARD std::string* release_eventimages();
  void set_allocated_eventimages(std::string* eventimages);
  private:
  const std::string& _internal_eventimages() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eventimages(const std::string& value);
  std::string* _internal_mutable_eventimages();
  public:

  // string eventVideos = 17;
  void clear_eventvideos();
  const std::string& eventvideos() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_eventvideos(ArgT0&& arg0, ArgT... args);
  std::string* mutable_eventvideos();
  PROTOBUF_NODISCARD std::string* release_eventvideos();
  void set_allocated_eventvideos(std::string* eventvideos);
  private:
  const std::string& _internal_eventvideos() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_eventvideos(const std::string& value);
  std::string* _internal_mutable_eventvideos();
  public:

  // .cn.seisys.v2x.pb.Position3D rtePos = 7;
  bool has_rtepos() const;
  private:
  bool _internal_has_rtepos() const;
  public:
  void clear_rtepos();
  const ::cn::seisys::v2x::pb::Position3D& rtepos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_rtepos();
  ::cn::seisys::v2x::pb::Position3D* mutable_rtepos();
  void set_allocated_rtepos(::cn::seisys::v2x::pb::Position3D* rtepos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_rtepos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_rtepos();
  public:
  void unsafe_arena_set_allocated_rtepos(
      ::cn::seisys::v2x::pb::Position3D* rtepos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_rtepos();

  // .cn.seisys.v2x.pb.MapLocation mapLocation = 8;
  bool has_maplocation() const;
  private:
  bool _internal_has_maplocation() const;
  public:
  void clear_maplocation();
  const ::cn::seisys::v2x::pb::MapLocation& maplocation() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::MapLocation* release_maplocation();
  ::cn::seisys::v2x::pb::MapLocation* mutable_maplocation();
  void set_allocated_maplocation(::cn::seisys::v2x::pb::MapLocation* maplocation);
  private:
  const ::cn::seisys::v2x::pb::MapLocation& _internal_maplocation() const;
  ::cn::seisys::v2x::pb::MapLocation* _internal_mutable_maplocation();
  public:
  void unsafe_arena_set_allocated_maplocation(
      ::cn::seisys::v2x::pb::MapLocation* maplocation);
  ::cn::seisys::v2x::pb::MapLocation* unsafe_arena_release_maplocation();

  // .cn.seisys.v2x.pb.RsiTimeDetails timeDetails = 10;
  bool has_timedetails() const;
  private:
  bool _internal_has_timedetails() const;
  public:
  void clear_timedetails();
  const ::cn::seisys::v2x::pb::RsiTimeDetails& timedetails() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::RsiTimeDetails* release_timedetails();
  ::cn::seisys::v2x::pb::RsiTimeDetails* mutable_timedetails();
  void set_allocated_timedetails(::cn::seisys::v2x::pb::RsiTimeDetails* timedetails);
  private:
  const ::cn::seisys::v2x::pb::RsiTimeDetails& _internal_timedetails() const;
  ::cn::seisys::v2x::pb::RsiTimeDetails* _internal_mutable_timedetails();
  public:
  void unsafe_arena_set_allocated_timedetails(
      ::cn::seisys::v2x::pb::RsiTimeDetails* timedetails);
  ::cn::seisys::v2x::pb::RsiTimeDetails* unsafe_arena_release_timedetails();

  // uint32 rteId = 1;
  void clear_rteid();
  uint32_t rteid() const;
  void set_rteid(uint32_t value);
  private:
  uint32_t _internal_rteid() const;
  void _internal_set_rteid(uint32_t value);
  public:

  // uint32 rteType = 2;
  void clear_rtetype();
  uint32_t rtetype() const;
  void set_rtetype(uint32_t value);
  private:
  uint32_t _internal_rtetype() const;
  void _internal_set_rtetype(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.RteData.EventSource eventSource = 4;
  void clear_eventsource();
  ::cn::seisys::v2x::pb::RteData_EventSource eventsource() const;
  void set_eventsource(::cn::seisys::v2x::pb::RteData_EventSource value);
  private:
  ::cn::seisys::v2x::pb::RteData_EventSource _internal_eventsource() const;
  void _internal_set_eventsource(::cn::seisys::v2x::pb::RteData_EventSource value);
  public:

  // .cn.seisys.v2x.pb.DataSource dataSource = 5;
  void clear_datasource();
  ::cn::seisys::v2x::pb::DataSource datasource() const;
  void set_datasource(::cn::seisys::v2x::pb::DataSource value);
  private:
  ::cn::seisys::v2x::pb::DataSource _internal_datasource() const;
  void _internal_set_datasource(::cn::seisys::v2x::pb::DataSource value);
  public:

  // uint32 eventRadius = 9;
  void clear_eventradius();
  uint32_t eventradius() const;
  void set_eventradius(uint32_t value);
  private:
  uint32_t _internal_eventradius() const;
  void _internal_set_eventradius(uint32_t value);
  public:

  // int32 eventConfid = 15;
  void clear_eventconfid();
  int32_t eventconfid() const;
  void set_eventconfid(int32_t value);
  private:
  int32_t _internal_eventconfid() const;
  void _internal_set_eventconfid(int32_t value);
  public:

  // uint64 sessionId = 18;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // uint64 id = 19;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.RteData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath > referencepath_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink > referencelinks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObjIdValue > eventobjid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceidlist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr priority_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eventimages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr eventvideos_;
    ::cn::seisys::v2x::pb::Position3D* rtepos_;
    ::cn::seisys::v2x::pb::MapLocation* maplocation_;
    ::cn::seisys::v2x::pb::RsiTimeDetails* timedetails_;
    uint32_t rteid_;
    uint32_t rtetype_;
    int eventsource_;
    int datasource_;
    uint32_t eventradius_;
    int32_t eventconfid_;
    uint64_t sessionid_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class RtsData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.RtsData) */ {
 public:
  inline RtsData() : RtsData(nullptr) {}
  ~RtsData() override;
  explicit PROTOBUF_CONSTEXPR RtsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtsData(const RtsData& from);
  RtsData(RtsData&& from) noexcept
    : RtsData() {
    *this = ::std::move(from);
  }

  inline RtsData& operator=(const RtsData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtsData& operator=(RtsData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtsData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtsData* internal_default_instance() {
    return reinterpret_cast<const RtsData*>(
               &_RtsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(RtsData& a, RtsData& b) {
    a.Swap(&b);
  }
  inline void Swap(RtsData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtsData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtsData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtsData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtsData& from) {
    RtsData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtsData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.RtsData";
  }
  protected:
  explicit RtsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefPathListFieldNumber = 8,
    kRefLinkListFieldNumber = 9,
    kPriorityFieldNumber = 4,
    kDescriptionFieldNumber = 7,
    kRtsPosFieldNumber = 5,
    kTimeDetailsFieldNumber = 6,
    kRtsIdFieldNumber = 1,
    kRtsTypeFieldNumber = 2,
    kDataSourceFieldNumber = 3,
    kPathRadiusFieldNumber = 10,
    kSessionIdFieldNumber = 11,
    kIdFieldNumber = 12,
  };
  // repeated .cn.seisys.v2x.pb.ReferencePath refPathList = 8;
  int refpathlist_size() const;
  private:
  int _internal_refpathlist_size() const;
  public:
  void clear_refpathlist();
  ::cn::seisys::v2x::pb::ReferencePath* mutable_refpathlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >*
      mutable_refpathlist();
  private:
  const ::cn::seisys::v2x::pb::ReferencePath& _internal_refpathlist(int index) const;
  ::cn::seisys::v2x::pb::ReferencePath* _internal_add_refpathlist();
  public:
  const ::cn::seisys::v2x::pb::ReferencePath& refpathlist(int index) const;
  ::cn::seisys::v2x::pb::ReferencePath* add_refpathlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >&
      refpathlist() const;

  // repeated .cn.seisys.v2x.pb.ReferenceLink refLinkList = 9;
  int reflinklist_size() const;
  private:
  int _internal_reflinklist_size() const;
  public:
  void clear_reflinklist();
  ::cn::seisys::v2x::pb::ReferenceLink* mutable_reflinklist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink >*
      mutable_reflinklist();
  private:
  const ::cn::seisys::v2x::pb::ReferenceLink& _internal_reflinklist(int index) const;
  ::cn::seisys::v2x::pb::ReferenceLink* _internal_add_reflinklist();
  public:
  const ::cn::seisys::v2x::pb::ReferenceLink& reflinklist(int index) const;
  ::cn::seisys::v2x::pb::ReferenceLink* add_reflinklist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink >&
      reflinklist() const;

  // string priority = 4;
  void clear_priority();
  const std::string& priority() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_priority(ArgT0&& arg0, ArgT... args);
  std::string* mutable_priority();
  PROTOBUF_NODISCARD std::string* release_priority();
  void set_allocated_priority(std::string* priority);
  private:
  const std::string& _internal_priority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_priority(const std::string& value);
  std::string* _internal_mutable_priority();
  public:

  // string description = 7;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .cn.seisys.v2x.pb.Position3D rtsPos = 5;
  bool has_rtspos() const;
  private:
  bool _internal_has_rtspos() const;
  public:
  void clear_rtspos();
  const ::cn::seisys::v2x::pb::Position3D& rtspos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_rtspos();
  ::cn::seisys::v2x::pb::Position3D* mutable_rtspos();
  void set_allocated_rtspos(::cn::seisys::v2x::pb::Position3D* rtspos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_rtspos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_rtspos();
  public:
  void unsafe_arena_set_allocated_rtspos(
      ::cn::seisys::v2x::pb::Position3D* rtspos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_rtspos();

  // .cn.seisys.v2x.pb.RsiTimeDetails timeDetails = 6;
  bool has_timedetails() const;
  private:
  bool _internal_has_timedetails() const;
  public:
  void clear_timedetails();
  const ::cn::seisys::v2x::pb::RsiTimeDetails& timedetails() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::RsiTimeDetails* release_timedetails();
  ::cn::seisys::v2x::pb::RsiTimeDetails* mutable_timedetails();
  void set_allocated_timedetails(::cn::seisys::v2x::pb::RsiTimeDetails* timedetails);
  private:
  const ::cn::seisys::v2x::pb::RsiTimeDetails& _internal_timedetails() const;
  ::cn::seisys::v2x::pb::RsiTimeDetails* _internal_mutable_timedetails();
  public:
  void unsafe_arena_set_allocated_timedetails(
      ::cn::seisys::v2x::pb::RsiTimeDetails* timedetails);
  ::cn::seisys::v2x::pb::RsiTimeDetails* unsafe_arena_release_timedetails();

  // int32 rtsId = 1;
  void clear_rtsid();
  int32_t rtsid() const;
  void set_rtsid(int32_t value);
  private:
  int32_t _internal_rtsid() const;
  void _internal_set_rtsid(int32_t value);
  public:

  // int32 rtsType = 2;
  void clear_rtstype();
  int32_t rtstype() const;
  void set_rtstype(int32_t value);
  private:
  int32_t _internal_rtstype() const;
  void _internal_set_rtstype(int32_t value);
  public:

  // .cn.seisys.v2x.pb.DataSource dataSource = 3;
  void clear_datasource();
  ::cn::seisys::v2x::pb::DataSource datasource() const;
  void set_datasource(::cn::seisys::v2x::pb::DataSource value);
  private:
  ::cn::seisys::v2x::pb::DataSource _internal_datasource() const;
  void _internal_set_datasource(::cn::seisys::v2x::pb::DataSource value);
  public:

  // uint32 pathRadius = 10;
  void clear_pathradius();
  uint32_t pathradius() const;
  void set_pathradius(uint32_t value);
  private:
  uint32_t _internal_pathradius() const;
  void _internal_set_pathradius(uint32_t value);
  public:

  // uint64 sessionId = 11;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // uint64 id = 12;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.RtsData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath > refpathlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink > reflinklist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr priority_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::cn::seisys::v2x::pb::Position3D* rtspos_;
    ::cn::seisys::v2x::pb::RsiTimeDetails* timedetails_;
    int32_t rtsid_;
    int32_t rtstype_;
    int datasource_;
    uint32_t pathradius_;
    uint64_t sessionid_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ConnectingLane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ConnectingLane) */ {
 public:
  inline ConnectingLane() : ConnectingLane(nullptr) {}
  ~ConnectingLane() override;
  explicit PROTOBUF_CONSTEXPR ConnectingLane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectingLane(const ConnectingLane& from);
  ConnectingLane(ConnectingLane&& from) noexcept
    : ConnectingLane() {
    *this = ::std::move(from);
  }

  inline ConnectingLane& operator=(const ConnectingLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectingLane& operator=(ConnectingLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectingLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectingLane* internal_default_instance() {
    return reinterpret_cast<const ConnectingLane*>(
               &_ConnectingLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ConnectingLane& a, ConnectingLane& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectingLane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectingLane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectingLane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectingLane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectingLane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectingLane& from) {
    ConnectingLane::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectingLane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ConnectingLane";
  }
  protected:
  explicit ConnectingLane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManeuversFieldNumber = 2,
    kLaneFieldNumber = 1,
  };
  // .cn.seisys.v2x.pb.AllowedManeuvers maneuvers = 2;
  bool has_maneuvers() const;
  private:
  bool _internal_has_maneuvers() const;
  public:
  void clear_maneuvers();
  const ::cn::seisys::v2x::pb::AllowedManeuvers& maneuvers() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::AllowedManeuvers* release_maneuvers();
  ::cn::seisys::v2x::pb::AllowedManeuvers* mutable_maneuvers();
  void set_allocated_maneuvers(::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers);
  private:
  const ::cn::seisys::v2x::pb::AllowedManeuvers& _internal_maneuvers() const;
  ::cn::seisys::v2x::pb::AllowedManeuvers* _internal_mutable_maneuvers();
  public:
  void unsafe_arena_set_allocated_maneuvers(
      ::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers);
  ::cn::seisys::v2x::pb::AllowedManeuvers* unsafe_arena_release_maneuvers();

  // uint32 lane = 1;
  void clear_lane();
  uint32_t lane() const;
  void set_lane(uint32_t value);
  private:
  uint32_t _internal_lane() const;
  void _internal_set_lane(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ConnectingLane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers_;
    uint32_t lane_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class Connection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.Connection) */ {
 public:
  inline Connection() : Connection(nullptr) {}
  ~Connection() override;
  explicit PROTOBUF_CONSTEXPR Connection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connection(const Connection& from);
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connection& operator=(Connection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }
  inline void Swap(Connection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Connection& from) {
    Connection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.Connection";
  }
  protected:
  explicit Connection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteIntersectionFieldNumber = 1,
    kConnectingLaneFieldNumber = 2,
    kPhaseIdFieldNumber = 3,
  };
  // .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
  bool has_remoteintersection() const;
  private:
  bool _internal_has_remoteintersection() const;
  public:
  void clear_remoteintersection();
  const ::cn::seisys::v2x::pb::NodeReferenceId& remoteintersection() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_remoteintersection();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_remoteintersection();
  void set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_remoteintersection() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_remoteintersection();
  public:
  void unsafe_arena_set_allocated_remoteintersection(
      ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_remoteintersection();

  // .cn.seisys.v2x.pb.ConnectingLane connectingLane = 2;
  bool has_connectinglane() const;
  private:
  bool _internal_has_connectinglane() const;
  public:
  void clear_connectinglane();
  const ::cn::seisys::v2x::pb::ConnectingLane& connectinglane() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ConnectingLane* release_connectinglane();
  ::cn::seisys::v2x::pb::ConnectingLane* mutable_connectinglane();
  void set_allocated_connectinglane(::cn::seisys::v2x::pb::ConnectingLane* connectinglane);
  private:
  const ::cn::seisys::v2x::pb::ConnectingLane& _internal_connectinglane() const;
  ::cn::seisys::v2x::pb::ConnectingLane* _internal_mutable_connectinglane();
  public:
  void unsafe_arena_set_allocated_connectinglane(
      ::cn::seisys::v2x::pb::ConnectingLane* connectinglane);
  ::cn::seisys::v2x::pb::ConnectingLane* unsafe_arena_release_connectinglane();

  // uint32 phaseId = 3;
  void clear_phaseid();
  uint32_t phaseid() const;
  void set_phaseid(uint32_t value);
  private:
  uint32_t _internal_phaseid() const;
  void _internal_set_phaseid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.Connection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection_;
    ::cn::seisys::v2x::pb::ConnectingLane* connectinglane_;
    uint32_t phaseid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneAttributesParking final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneAttributesParking) */ {
 public:
  inline LaneAttributesParking() : LaneAttributesParking(nullptr) {}
  ~LaneAttributesParking() override;
  explicit PROTOBUF_CONSTEXPR LaneAttributesParking(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttributesParking(const LaneAttributesParking& from);
  LaneAttributesParking(LaneAttributesParking&& from) noexcept
    : LaneAttributesParking() {
    *this = ::std::move(from);
  }

  inline LaneAttributesParking& operator=(const LaneAttributesParking& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttributesParking& operator=(LaneAttributesParking&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttributesParking& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttributesParking* internal_default_instance() {
    return reinterpret_cast<const LaneAttributesParking*>(
               &_LaneAttributesParking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(LaneAttributesParking& a, LaneAttributesParking& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttributesParking* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttributesParking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttributesParking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttributesParking>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttributesParking& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneAttributesParking& from) {
    LaneAttributesParking::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttributesParking* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneAttributesParking";
  }
  protected:
  explicit LaneAttributesParking(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParkingAndStoppingLanesFieldNumber = 1,
  };
  // uint32 parkingAndStoppingLanes = 1;
  void clear_parkingandstoppinglanes();
  uint32_t parkingandstoppinglanes() const;
  void set_parkingandstoppinglanes(uint32_t value);
  private:
  uint32_t _internal_parkingandstoppinglanes() const;
  void _internal_set_parkingandstoppinglanes(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneAttributesParking)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t parkingandstoppinglanes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneAttributesCrosswalk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneAttributesCrosswalk) */ {
 public:
  inline LaneAttributesCrosswalk() : LaneAttributesCrosswalk(nullptr) {}
  ~LaneAttributesCrosswalk() override;
  explicit PROTOBUF_CONSTEXPR LaneAttributesCrosswalk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttributesCrosswalk(const LaneAttributesCrosswalk& from);
  LaneAttributesCrosswalk(LaneAttributesCrosswalk&& from) noexcept
    : LaneAttributesCrosswalk() {
    *this = ::std::move(from);
  }

  inline LaneAttributesCrosswalk& operator=(const LaneAttributesCrosswalk& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttributesCrosswalk& operator=(LaneAttributesCrosswalk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttributesCrosswalk& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttributesCrosswalk* internal_default_instance() {
    return reinterpret_cast<const LaneAttributesCrosswalk*>(
               &_LaneAttributesCrosswalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(LaneAttributesCrosswalk& a, LaneAttributesCrosswalk& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttributesCrosswalk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttributesCrosswalk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttributesCrosswalk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttributesCrosswalk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttributesCrosswalk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneAttributesCrosswalk& from) {
    LaneAttributesCrosswalk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttributesCrosswalk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneAttributesCrosswalk";
  }
  protected:
  explicit LaneAttributesCrosswalk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPedestrianCrosswalksFieldNumber = 1,
  };
  // uint32 pedestrianCrosswalks = 1;
  void clear_pedestriancrosswalks();
  uint32_t pedestriancrosswalks() const;
  void set_pedestriancrosswalks(uint32_t value);
  private:
  uint32_t _internal_pedestriancrosswalks() const;
  void _internal_set_pedestriancrosswalks(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneAttributesCrosswalk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pedestriancrosswalks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneAttributesBike final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneAttributesBike) */ {
 public:
  inline LaneAttributesBike() : LaneAttributesBike(nullptr) {}
  ~LaneAttributesBike() override;
  explicit PROTOBUF_CONSTEXPR LaneAttributesBike(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttributesBike(const LaneAttributesBike& from);
  LaneAttributesBike(LaneAttributesBike&& from) noexcept
    : LaneAttributesBike() {
    *this = ::std::move(from);
  }

  inline LaneAttributesBike& operator=(const LaneAttributesBike& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttributesBike& operator=(LaneAttributesBike&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttributesBike& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttributesBike* internal_default_instance() {
    return reinterpret_cast<const LaneAttributesBike*>(
               &_LaneAttributesBike_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(LaneAttributesBike& a, LaneAttributesBike& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttributesBike* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttributesBike* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttributesBike* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttributesBike>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttributesBike& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneAttributesBike& from) {
    LaneAttributesBike::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttributesBike* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneAttributesBike";
  }
  protected:
  explicit LaneAttributesBike(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBikeLanesFieldNumber = 1,
  };
  // uint32 bikeLanes = 1;
  void clear_bikelanes();
  uint32_t bikelanes() const;
  void set_bikelanes(uint32_t value);
  private:
  uint32_t _internal_bikelanes() const;
  void _internal_set_bikelanes(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneAttributesBike)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t bikelanes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneAttributesSidewalk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneAttributesSidewalk) */ {
 public:
  inline LaneAttributesSidewalk() : LaneAttributesSidewalk(nullptr) {}
  ~LaneAttributesSidewalk() override;
  explicit PROTOBUF_CONSTEXPR LaneAttributesSidewalk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttributesSidewalk(const LaneAttributesSidewalk& from);
  LaneAttributesSidewalk(LaneAttributesSidewalk&& from) noexcept
    : LaneAttributesSidewalk() {
    *this = ::std::move(from);
  }

  inline LaneAttributesSidewalk& operator=(const LaneAttributesSidewalk& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttributesSidewalk& operator=(LaneAttributesSidewalk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttributesSidewalk& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttributesSidewalk* internal_default_instance() {
    return reinterpret_cast<const LaneAttributesSidewalk*>(
               &_LaneAttributesSidewalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(LaneAttributesSidewalk& a, LaneAttributesSidewalk& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttributesSidewalk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttributesSidewalk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttributesSidewalk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttributesSidewalk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttributesSidewalk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneAttributesSidewalk& from) {
    LaneAttributesSidewalk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttributesSidewalk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneAttributesSidewalk";
  }
  protected:
  explicit LaneAttributesSidewalk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPedestrianSidewalkPathsFieldNumber = 1,
  };
  // uint32 pedestrianSidewalkPaths = 1;
  void clear_pedestriansidewalkpaths();
  uint32_t pedestriansidewalkpaths() const;
  void set_pedestriansidewalkpaths(uint32_t value);
  private:
  uint32_t _internal_pedestriansidewalkpaths() const;
  void _internal_set_pedestriansidewalkpaths(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneAttributesSidewalk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t pedestriansidewalkpaths_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneAttributesBarrier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneAttributesBarrier) */ {
 public:
  inline LaneAttributesBarrier() : LaneAttributesBarrier(nullptr) {}
  ~LaneAttributesBarrier() override;
  explicit PROTOBUF_CONSTEXPR LaneAttributesBarrier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttributesBarrier(const LaneAttributesBarrier& from);
  LaneAttributesBarrier(LaneAttributesBarrier&& from) noexcept
    : LaneAttributesBarrier() {
    *this = ::std::move(from);
  }

  inline LaneAttributesBarrier& operator=(const LaneAttributesBarrier& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttributesBarrier& operator=(LaneAttributesBarrier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttributesBarrier& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttributesBarrier* internal_default_instance() {
    return reinterpret_cast<const LaneAttributesBarrier*>(
               &_LaneAttributesBarrier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(LaneAttributesBarrier& a, LaneAttributesBarrier& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttributesBarrier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttributesBarrier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttributesBarrier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttributesBarrier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttributesBarrier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneAttributesBarrier& from) {
    LaneAttributesBarrier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttributesBarrier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneAttributesBarrier";
  }
  protected:
  explicit LaneAttributesBarrier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMediansChannelizationFieldNumber = 1,
  };
  // uint32 mediansChannelization = 1;
  void clear_medianschannelization();
  uint32_t medianschannelization() const;
  void set_medianschannelization(uint32_t value);
  private:
  uint32_t _internal_medianschannelization() const;
  void _internal_set_medianschannelization(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneAttributesBarrier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t medianschannelization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneAttributesStriping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneAttributesStriping) */ {
 public:
  inline LaneAttributesStriping() : LaneAttributesStriping(nullptr) {}
  ~LaneAttributesStriping() override;
  explicit PROTOBUF_CONSTEXPR LaneAttributesStriping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttributesStriping(const LaneAttributesStriping& from);
  LaneAttributesStriping(LaneAttributesStriping&& from) noexcept
    : LaneAttributesStriping() {
    *this = ::std::move(from);
  }

  inline LaneAttributesStriping& operator=(const LaneAttributesStriping& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttributesStriping& operator=(LaneAttributesStriping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttributesStriping& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttributesStriping* internal_default_instance() {
    return reinterpret_cast<const LaneAttributesStriping*>(
               &_LaneAttributesStriping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(LaneAttributesStriping& a, LaneAttributesStriping& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttributesStriping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttributesStriping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttributesStriping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttributesStriping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttributesStriping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneAttributesStriping& from) {
    LaneAttributesStriping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttributesStriping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneAttributesStriping";
  }
  protected:
  explicit LaneAttributesStriping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadwayMarkingsFieldNumber = 1,
  };
  // uint32 roadwayMarkings = 1;
  void clear_roadwaymarkings();
  uint32_t roadwaymarkings() const;
  void set_roadwaymarkings(uint32_t value);
  private:
  uint32_t _internal_roadwaymarkings() const;
  void _internal_set_roadwaymarkings(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneAttributesStriping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t roadwaymarkings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneAttributesTrackedVehicle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneAttributesTrackedVehicle) */ {
 public:
  inline LaneAttributesTrackedVehicle() : LaneAttributesTrackedVehicle(nullptr) {}
  ~LaneAttributesTrackedVehicle() override;
  explicit PROTOBUF_CONSTEXPR LaneAttributesTrackedVehicle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttributesTrackedVehicle(const LaneAttributesTrackedVehicle& from);
  LaneAttributesTrackedVehicle(LaneAttributesTrackedVehicle&& from) noexcept
    : LaneAttributesTrackedVehicle() {
    *this = ::std::move(from);
  }

  inline LaneAttributesTrackedVehicle& operator=(const LaneAttributesTrackedVehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttributesTrackedVehicle& operator=(LaneAttributesTrackedVehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttributesTrackedVehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttributesTrackedVehicle* internal_default_instance() {
    return reinterpret_cast<const LaneAttributesTrackedVehicle*>(
               &_LaneAttributesTrackedVehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(LaneAttributesTrackedVehicle& a, LaneAttributesTrackedVehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttributesTrackedVehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttributesTrackedVehicle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttributesTrackedVehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttributesTrackedVehicle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttributesTrackedVehicle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneAttributesTrackedVehicle& from) {
    LaneAttributesTrackedVehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttributesTrackedVehicle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneAttributesTrackedVehicle";
  }
  protected:
  explicit LaneAttributesTrackedVehicle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrainsAndTrolleysFieldNumber = 1,
  };
  // uint32 trainsAndTrolleys = 1;
  void clear_trainsandtrolleys();
  uint32_t trainsandtrolleys() const;
  void set_trainsandtrolleys(uint32_t value);
  private:
  uint32_t _internal_trainsandtrolleys() const;
  void _internal_set_trainsandtrolleys(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneAttributesTrackedVehicle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t trainsandtrolleys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneAttributesVehicle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneAttributesVehicle) */ {
 public:
  inline LaneAttributesVehicle() : LaneAttributesVehicle(nullptr) {}
  ~LaneAttributesVehicle() override;
  explicit PROTOBUF_CONSTEXPR LaneAttributesVehicle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttributesVehicle(const LaneAttributesVehicle& from);
  LaneAttributesVehicle(LaneAttributesVehicle&& from) noexcept
    : LaneAttributesVehicle() {
    *this = ::std::move(from);
  }

  inline LaneAttributesVehicle& operator=(const LaneAttributesVehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttributesVehicle& operator=(LaneAttributesVehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttributesVehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttributesVehicle* internal_default_instance() {
    return reinterpret_cast<const LaneAttributesVehicle*>(
               &_LaneAttributesVehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(LaneAttributesVehicle& a, LaneAttributesVehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttributesVehicle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttributesVehicle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttributesVehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttributesVehicle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttributesVehicle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneAttributesVehicle& from) {
    LaneAttributesVehicle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttributesVehicle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneAttributesVehicle";
  }
  protected:
  explicit LaneAttributesVehicle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorVehicleLanesFieldNumber = 1,
  };
  // uint32 motorVehicleLanes = 1;
  void clear_motorvehiclelanes();
  uint32_t motorvehiclelanes() const;
  void set_motorvehiclelanes(uint32_t value);
  private:
  uint32_t _internal_motorvehiclelanes() const;
  void _internal_set_motorvehiclelanes(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneAttributesVehicle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t motorvehiclelanes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneTypeAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneTypeAttributes) */ {
 public:
  inline LaneTypeAttributes() : LaneTypeAttributes(nullptr) {}
  ~LaneTypeAttributes() override;
  explicit PROTOBUF_CONSTEXPR LaneTypeAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneTypeAttributes(const LaneTypeAttributes& from);
  LaneTypeAttributes(LaneTypeAttributes&& from) noexcept
    : LaneTypeAttributes() {
    *this = ::std::move(from);
  }

  inline LaneTypeAttributes& operator=(const LaneTypeAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneTypeAttributes& operator=(LaneTypeAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneTypeAttributes& default_instance() {
    return *internal_default_instance();
  }
  enum LaneTypeAttributesOneOfCase {
    kMotorVehicleLanes = 1,
    kPedestrianCrosswalks = 2,
    kBikeLanes = 3,
    kPedestrianSidewalkPaths = 4,
    kMediansChannelization = 5,
    kRoadwayMarkings = 6,
    kTrainsAndTrolleys = 7,
    kParkingAndStoppingLanes = 8,
    LANETYPEATTRIBUTESONEOF_NOT_SET = 0,
  };

  static inline const LaneTypeAttributes* internal_default_instance() {
    return reinterpret_cast<const LaneTypeAttributes*>(
               &_LaneTypeAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(LaneTypeAttributes& a, LaneTypeAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneTypeAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneTypeAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneTypeAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneTypeAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneTypeAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneTypeAttributes& from) {
    LaneTypeAttributes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneTypeAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneTypeAttributes";
  }
  protected:
  explicit LaneTypeAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorVehicleLanesFieldNumber = 1,
    kPedestrianCrosswalksFieldNumber = 2,
    kBikeLanesFieldNumber = 3,
    kPedestrianSidewalkPathsFieldNumber = 4,
    kMediansChannelizationFieldNumber = 5,
    kRoadwayMarkingsFieldNumber = 6,
    kTrainsAndTrolleysFieldNumber = 7,
    kParkingAndStoppingLanesFieldNumber = 8,
  };
  // .cn.seisys.v2x.pb.LaneAttributesVehicle motorVehicleLanes = 1;
  bool has_motorvehiclelanes() const;
  private:
  bool _internal_has_motorvehiclelanes() const;
  public:
  void clear_motorvehiclelanes();
  const ::cn::seisys::v2x::pb::LaneAttributesVehicle& motorvehiclelanes() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributesVehicle* release_motorvehiclelanes();
  ::cn::seisys::v2x::pb::LaneAttributesVehicle* mutable_motorvehiclelanes();
  void set_allocated_motorvehiclelanes(::cn::seisys::v2x::pb::LaneAttributesVehicle* motorvehiclelanes);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributesVehicle& _internal_motorvehiclelanes() const;
  ::cn::seisys::v2x::pb::LaneAttributesVehicle* _internal_mutable_motorvehiclelanes();
  public:
  void unsafe_arena_set_allocated_motorvehiclelanes(
      ::cn::seisys::v2x::pb::LaneAttributesVehicle* motorvehiclelanes);
  ::cn::seisys::v2x::pb::LaneAttributesVehicle* unsafe_arena_release_motorvehiclelanes();

  // .cn.seisys.v2x.pb.LaneAttributesCrosswalk pedestrianCrosswalks = 2;
  bool has_pedestriancrosswalks() const;
  private:
  bool _internal_has_pedestriancrosswalks() const;
  public:
  void clear_pedestriancrosswalks();
  const ::cn::seisys::v2x::pb::LaneAttributesCrosswalk& pedestriancrosswalks() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* release_pedestriancrosswalks();
  ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* mutable_pedestriancrosswalks();
  void set_allocated_pedestriancrosswalks(::cn::seisys::v2x::pb::LaneAttributesCrosswalk* pedestriancrosswalks);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributesCrosswalk& _internal_pedestriancrosswalks() const;
  ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* _internal_mutable_pedestriancrosswalks();
  public:
  void unsafe_arena_set_allocated_pedestriancrosswalks(
      ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* pedestriancrosswalks);
  ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* unsafe_arena_release_pedestriancrosswalks();

  // .cn.seisys.v2x.pb.LaneAttributesBike bikeLanes = 3;
  bool has_bikelanes() const;
  private:
  bool _internal_has_bikelanes() const;
  public:
  void clear_bikelanes();
  const ::cn::seisys::v2x::pb::LaneAttributesBike& bikelanes() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributesBike* release_bikelanes();
  ::cn::seisys::v2x::pb::LaneAttributesBike* mutable_bikelanes();
  void set_allocated_bikelanes(::cn::seisys::v2x::pb::LaneAttributesBike* bikelanes);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributesBike& _internal_bikelanes() const;
  ::cn::seisys::v2x::pb::LaneAttributesBike* _internal_mutable_bikelanes();
  public:
  void unsafe_arena_set_allocated_bikelanes(
      ::cn::seisys::v2x::pb::LaneAttributesBike* bikelanes);
  ::cn::seisys::v2x::pb::LaneAttributesBike* unsafe_arena_release_bikelanes();

  // .cn.seisys.v2x.pb.LaneAttributesSidewalk pedestrianSidewalkPaths = 4;
  bool has_pedestriansidewalkpaths() const;
  private:
  bool _internal_has_pedestriansidewalkpaths() const;
  public:
  void clear_pedestriansidewalkpaths();
  const ::cn::seisys::v2x::pb::LaneAttributesSidewalk& pedestriansidewalkpaths() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributesSidewalk* release_pedestriansidewalkpaths();
  ::cn::seisys::v2x::pb::LaneAttributesSidewalk* mutable_pedestriansidewalkpaths();
  void set_allocated_pedestriansidewalkpaths(::cn::seisys::v2x::pb::LaneAttributesSidewalk* pedestriansidewalkpaths);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributesSidewalk& _internal_pedestriansidewalkpaths() const;
  ::cn::seisys::v2x::pb::LaneAttributesSidewalk* _internal_mutable_pedestriansidewalkpaths();
  public:
  void unsafe_arena_set_allocated_pedestriansidewalkpaths(
      ::cn::seisys::v2x::pb::LaneAttributesSidewalk* pedestriansidewalkpaths);
  ::cn::seisys::v2x::pb::LaneAttributesSidewalk* unsafe_arena_release_pedestriansidewalkpaths();

  // .cn.seisys.v2x.pb.LaneAttributesBarrier mediansChannelization = 5;
  bool has_medianschannelization() const;
  private:
  bool _internal_has_medianschannelization() const;
  public:
  void clear_medianschannelization();
  const ::cn::seisys::v2x::pb::LaneAttributesBarrier& medianschannelization() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributesBarrier* release_medianschannelization();
  ::cn::seisys::v2x::pb::LaneAttributesBarrier* mutable_medianschannelization();
  void set_allocated_medianschannelization(::cn::seisys::v2x::pb::LaneAttributesBarrier* medianschannelization);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributesBarrier& _internal_medianschannelization() const;
  ::cn::seisys::v2x::pb::LaneAttributesBarrier* _internal_mutable_medianschannelization();
  public:
  void unsafe_arena_set_allocated_medianschannelization(
      ::cn::seisys::v2x::pb::LaneAttributesBarrier* medianschannelization);
  ::cn::seisys::v2x::pb::LaneAttributesBarrier* unsafe_arena_release_medianschannelization();

  // .cn.seisys.v2x.pb.LaneAttributesStriping roadwayMarkings = 6;
  bool has_roadwaymarkings() const;
  private:
  bool _internal_has_roadwaymarkings() const;
  public:
  void clear_roadwaymarkings();
  const ::cn::seisys::v2x::pb::LaneAttributesStriping& roadwaymarkings() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributesStriping* release_roadwaymarkings();
  ::cn::seisys::v2x::pb::LaneAttributesStriping* mutable_roadwaymarkings();
  void set_allocated_roadwaymarkings(::cn::seisys::v2x::pb::LaneAttributesStriping* roadwaymarkings);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributesStriping& _internal_roadwaymarkings() const;
  ::cn::seisys::v2x::pb::LaneAttributesStriping* _internal_mutable_roadwaymarkings();
  public:
  void unsafe_arena_set_allocated_roadwaymarkings(
      ::cn::seisys::v2x::pb::LaneAttributesStriping* roadwaymarkings);
  ::cn::seisys::v2x::pb::LaneAttributesStriping* unsafe_arena_release_roadwaymarkings();

  // .cn.seisys.v2x.pb.LaneAttributesTrackedVehicle trainsAndTrolleys = 7;
  bool has_trainsandtrolleys() const;
  private:
  bool _internal_has_trainsandtrolleys() const;
  public:
  void clear_trainsandtrolleys();
  const ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle& trainsandtrolleys() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* release_trainsandtrolleys();
  ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* mutable_trainsandtrolleys();
  void set_allocated_trainsandtrolleys(::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* trainsandtrolleys);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle& _internal_trainsandtrolleys() const;
  ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* _internal_mutable_trainsandtrolleys();
  public:
  void unsafe_arena_set_allocated_trainsandtrolleys(
      ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* trainsandtrolleys);
  ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* unsafe_arena_release_trainsandtrolleys();

  // .cn.seisys.v2x.pb.LaneAttributesParking parkingAndStoppingLanes = 8;
  bool has_parkingandstoppinglanes() const;
  private:
  bool _internal_has_parkingandstoppinglanes() const;
  public:
  void clear_parkingandstoppinglanes();
  const ::cn::seisys::v2x::pb::LaneAttributesParking& parkingandstoppinglanes() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributesParking* release_parkingandstoppinglanes();
  ::cn::seisys::v2x::pb::LaneAttributesParking* mutable_parkingandstoppinglanes();
  void set_allocated_parkingandstoppinglanes(::cn::seisys::v2x::pb::LaneAttributesParking* parkingandstoppinglanes);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributesParking& _internal_parkingandstoppinglanes() const;
  ::cn::seisys::v2x::pb::LaneAttributesParking* _internal_mutable_parkingandstoppinglanes();
  public:
  void unsafe_arena_set_allocated_parkingandstoppinglanes(
      ::cn::seisys::v2x::pb::LaneAttributesParking* parkingandstoppinglanes);
  ::cn::seisys::v2x::pb::LaneAttributesParking* unsafe_arena_release_parkingandstoppinglanes();

  void clear_LaneTypeAttributesOneOf();
  LaneTypeAttributesOneOfCase LaneTypeAttributesOneOf_case() const;
  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneTypeAttributes)
 private:
  class _Internal;
  void set_has_motorvehiclelanes();
  void set_has_pedestriancrosswalks();
  void set_has_bikelanes();
  void set_has_pedestriansidewalkpaths();
  void set_has_medianschannelization();
  void set_has_roadwaymarkings();
  void set_has_trainsandtrolleys();
  void set_has_parkingandstoppinglanes();

  inline bool has_LaneTypeAttributesOneOf() const;
  inline void clear_has_LaneTypeAttributesOneOf();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union LaneTypeAttributesOneOfUnion {
      constexpr LaneTypeAttributesOneOfUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::cn::seisys::v2x::pb::LaneAttributesVehicle* motorvehiclelanes_;
      ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* pedestriancrosswalks_;
      ::cn::seisys::v2x::pb::LaneAttributesBike* bikelanes_;
      ::cn::seisys::v2x::pb::LaneAttributesSidewalk* pedestriansidewalkpaths_;
      ::cn::seisys::v2x::pb::LaneAttributesBarrier* medianschannelization_;
      ::cn::seisys::v2x::pb::LaneAttributesStriping* roadwaymarkings_;
      ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* trainsandtrolleys_;
      ::cn::seisys::v2x::pb::LaneAttributesParking* parkingandstoppinglanes_;
    } LaneTypeAttributesOneOf_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneSharing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneSharing) */ {
 public:
  inline LaneSharing() : LaneSharing(nullptr) {}
  ~LaneSharing() override;
  explicit PROTOBUF_CONSTEXPR LaneSharing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneSharing(const LaneSharing& from);
  LaneSharing(LaneSharing&& from) noexcept
    : LaneSharing() {
    *this = ::std::move(from);
  }

  inline LaneSharing& operator=(const LaneSharing& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneSharing& operator=(LaneSharing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneSharing& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneSharing* internal_default_instance() {
    return reinterpret_cast<const LaneSharing*>(
               &_LaneSharing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(LaneSharing& a, LaneSharing& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneSharing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneSharing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneSharing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneSharing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneSharing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneSharing& from) {
    LaneSharing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneSharing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneSharing";
  }
  protected:
  explicit LaneSharing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShareWithFieldNumber = 1,
  };
  // uint32 shareWith = 1;
  void clear_sharewith();
  uint32_t sharewith() const;
  void set_sharewith(uint32_t value);
  private:
  uint32_t _internal_sharewith() const;
  void _internal_set_sharewith(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneSharing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t sharewith_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneType) */ {
 public:
  inline LaneType() : LaneType(nullptr) {}
  ~LaneType() override;
  explicit PROTOBUF_CONSTEXPR LaneType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneType(const LaneType& from);
  LaneType(LaneType&& from) noexcept
    : LaneType() {
    *this = ::std::move(from);
  }

  inline LaneType& operator=(const LaneType& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneType& operator=(LaneType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneType& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneType* internal_default_instance() {
    return reinterpret_cast<const LaneType*>(
               &_LaneType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(LaneType& a, LaneType& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneType& from) {
    LaneType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneType";
  }
  protected:
  explicit LaneType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kChoiceIdFieldNumber = 1,
  };
  // .cn.seisys.v2x.pb.LaneTypeAttributes value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::cn::seisys::v2x::pb::LaneTypeAttributes& value() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneTypeAttributes* release_value();
  ::cn::seisys::v2x::pb::LaneTypeAttributes* mutable_value();
  void set_allocated_value(::cn::seisys::v2x::pb::LaneTypeAttributes* value);
  private:
  const ::cn::seisys::v2x::pb::LaneTypeAttributes& _internal_value() const;
  ::cn::seisys::v2x::pb::LaneTypeAttributes* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::cn::seisys::v2x::pb::LaneTypeAttributes* value);
  ::cn::seisys::v2x::pb::LaneTypeAttributes* unsafe_arena_release_value();

  // uint32 choiceId = 1;
  void clear_choiceid();
  uint32_t choiceid() const;
  void set_choiceid(uint32_t value);
  private:
  uint32_t _internal_choiceid() const;
  void _internal_set_choiceid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::LaneTypeAttributes* value_;
    uint32_t choiceid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneAttributes) */ {
 public:
  inline LaneAttributes() : LaneAttributes(nullptr) {}
  ~LaneAttributes() override;
  explicit PROTOBUF_CONSTEXPR LaneAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneAttributes(const LaneAttributes& from);
  LaneAttributes(LaneAttributes&& from) noexcept
    : LaneAttributes() {
    *this = ::std::move(from);
  }

  inline LaneAttributes& operator=(const LaneAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneAttributes& operator=(LaneAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneAttributes* internal_default_instance() {
    return reinterpret_cast<const LaneAttributes*>(
               &_LaneAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(LaneAttributes& a, LaneAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneAttributes& from) {
    LaneAttributes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneAttributes";
  }
  protected:
  explicit LaneAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShareWithFieldNumber = 1,
    kLaneTypeFieldNumber = 2,
  };
  // .cn.seisys.v2x.pb.LaneSharing shareWith = 1;
  bool has_sharewith() const;
  private:
  bool _internal_has_sharewith() const;
  public:
  void clear_sharewith();
  const ::cn::seisys::v2x::pb::LaneSharing& sharewith() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneSharing* release_sharewith();
  ::cn::seisys::v2x::pb::LaneSharing* mutable_sharewith();
  void set_allocated_sharewith(::cn::seisys::v2x::pb::LaneSharing* sharewith);
  private:
  const ::cn::seisys::v2x::pb::LaneSharing& _internal_sharewith() const;
  ::cn::seisys::v2x::pb::LaneSharing* _internal_mutable_sharewith();
  public:
  void unsafe_arena_set_allocated_sharewith(
      ::cn::seisys::v2x::pb::LaneSharing* sharewith);
  ::cn::seisys::v2x::pb::LaneSharing* unsafe_arena_release_sharewith();

  // .cn.seisys.v2x.pb.LaneType laneType = 2;
  bool has_lanetype() const;
  private:
  bool _internal_has_lanetype() const;
  public:
  void clear_lanetype();
  const ::cn::seisys::v2x::pb::LaneType& lanetype() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneType* release_lanetype();
  ::cn::seisys::v2x::pb::LaneType* mutable_lanetype();
  void set_allocated_lanetype(::cn::seisys::v2x::pb::LaneType* lanetype);
  private:
  const ::cn::seisys::v2x::pb::LaneType& _internal_lanetype() const;
  ::cn::seisys::v2x::pb::LaneType* _internal_mutable_lanetype();
  public:
  void unsafe_arena_set_allocated_lanetype(
      ::cn::seisys::v2x::pb::LaneType* lanetype);
  ::cn::seisys::v2x::pb::LaneType* unsafe_arena_release_lanetype();

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::LaneSharing* sharewith_;
    ::cn::seisys::v2x::pb::LaneType* lanetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneBoundary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneBoundary) */ {
 public:
  inline LaneBoundary() : LaneBoundary(nullptr) {}
  ~LaneBoundary() override;
  explicit PROTOBUF_CONSTEXPR LaneBoundary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneBoundary(const LaneBoundary& from);
  LaneBoundary(LaneBoundary&& from) noexcept
    : LaneBoundary() {
    *this = ::std::move(from);
  }

  inline LaneBoundary& operator=(const LaneBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary& operator=(LaneBoundary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneBoundary* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary*>(
               &_LaneBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(LaneBoundary& a, LaneBoundary& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneBoundary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneBoundary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneBoundary& from) {
    LaneBoundary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneBoundary";
  }
  protected:
  explicit LaneBoundary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneBoundaryPointsFieldNumber = 2,
    kLaneBoundaryTypeFieldNumber = 1,
  };
  // repeated .cn.seisys.v2x.pb.Position3D laneBoundaryPoints = 2;
  int laneboundarypoints_size() const;
  private:
  int _internal_laneboundarypoints_size() const;
  public:
  void clear_laneboundarypoints();
  ::cn::seisys::v2x::pb::Position3D* mutable_laneboundarypoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
      mutable_laneboundarypoints();
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_laneboundarypoints(int index) const;
  ::cn::seisys::v2x::pb::Position3D* _internal_add_laneboundarypoints();
  public:
  const ::cn::seisys::v2x::pb::Position3D& laneboundarypoints(int index) const;
  ::cn::seisys::v2x::pb::Position3D* add_laneboundarypoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
      laneboundarypoints() const;

  // uint32 laneBoundaryType = 1;
  void clear_laneboundarytype();
  uint32_t laneboundarytype() const;
  void set_laneboundarytype(uint32_t value);
  private:
  uint32_t _internal_laneboundarytype() const;
  void _internal_set_laneboundarytype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneBoundary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D > laneboundarypoints_;
    uint32_t laneboundarytype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class Lane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.Lane) */ {
 public:
  inline Lane() : Lane(nullptr) {}
  ~Lane() override;
  explicit PROTOBUF_CONSTEXPR Lane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lane(const Lane& from);
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lane& operator=(Lane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }
  inline void Swap(Lane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Lane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Lane& from) {
    Lane::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.Lane";
  }
  protected:
  explicit Lane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectsToFieldNumber = 5,
    kSpeedLimitsFieldNumber = 6,
    kPointsFieldNumber = 7,
    kLeftBoundaryFieldNumber = 8,
    kRightBoundaryFieldNumber = 9,
    kLaneAttributesFieldNumber = 3,
    kManeuversFieldNumber = 4,
    kLaneIdFieldNumber = 1,
    kLaneWidthFieldNumber = 2,
  };
  // repeated .cn.seisys.v2x.pb.Connection connectsTo = 5;
  int connectsto_size() const;
  private:
  int _internal_connectsto_size() const;
  public:
  void clear_connectsto();
  ::cn::seisys::v2x::pb::Connection* mutable_connectsto(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Connection >*
      mutable_connectsto();
  private:
  const ::cn::seisys::v2x::pb::Connection& _internal_connectsto(int index) const;
  ::cn::seisys::v2x::pb::Connection* _internal_add_connectsto();
  public:
  const ::cn::seisys::v2x::pb::Connection& connectsto(int index) const;
  ::cn::seisys::v2x::pb::Connection* add_connectsto();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Connection >&
      connectsto() const;

  // repeated .cn.seisys.v2x.pb.RegulatorySpeedLimit speedLimits = 6;
  int speedlimits_size() const;
  private:
  int _internal_speedlimits_size() const;
  public:
  void clear_speedlimits();
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* mutable_speedlimits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >*
      mutable_speedlimits();
  private:
  const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& _internal_speedlimits(int index) const;
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* _internal_add_speedlimits();
  public:
  const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& speedlimits(int index) const;
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* add_speedlimits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >&
      speedlimits() const;

  // repeated .cn.seisys.v2x.pb.Position3D points = 7;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::cn::seisys::v2x::pb::Position3D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
      mutable_points();
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_points(int index) const;
  ::cn::seisys::v2x::pb::Position3D* _internal_add_points();
  public:
  const ::cn::seisys::v2x::pb::Position3D& points(int index) const;
  ::cn::seisys::v2x::pb::Position3D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
      points() const;

  // repeated .cn.seisys.v2x.pb.LaneBoundary leftBoundary = 8;
  int leftboundary_size() const;
  private:
  int _internal_leftboundary_size() const;
  public:
  void clear_leftboundary();
  ::cn::seisys::v2x::pb::LaneBoundary* mutable_leftboundary(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >*
      mutable_leftboundary();
  private:
  const ::cn::seisys::v2x::pb::LaneBoundary& _internal_leftboundary(int index) const;
  ::cn::seisys::v2x::pb::LaneBoundary* _internal_add_leftboundary();
  public:
  const ::cn::seisys::v2x::pb::LaneBoundary& leftboundary(int index) const;
  ::cn::seisys::v2x::pb::LaneBoundary* add_leftboundary();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >&
      leftboundary() const;

  // repeated .cn.seisys.v2x.pb.LaneBoundary rightBoundary = 9;
  int rightboundary_size() const;
  private:
  int _internal_rightboundary_size() const;
  public:
  void clear_rightboundary();
  ::cn::seisys::v2x::pb::LaneBoundary* mutable_rightboundary(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >*
      mutable_rightboundary();
  private:
  const ::cn::seisys::v2x::pb::LaneBoundary& _internal_rightboundary(int index) const;
  ::cn::seisys::v2x::pb::LaneBoundary* _internal_add_rightboundary();
  public:
  const ::cn::seisys::v2x::pb::LaneBoundary& rightboundary(int index) const;
  ::cn::seisys::v2x::pb::LaneBoundary* add_rightboundary();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >&
      rightboundary() const;

  // .cn.seisys.v2x.pb.LaneAttributes laneAttributes = 3;
  bool has_laneattributes() const;
  private:
  bool _internal_has_laneattributes() const;
  public:
  void clear_laneattributes();
  const ::cn::seisys::v2x::pb::LaneAttributes& laneattributes() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributes* release_laneattributes();
  ::cn::seisys::v2x::pb::LaneAttributes* mutable_laneattributes();
  void set_allocated_laneattributes(::cn::seisys::v2x::pb::LaneAttributes* laneattributes);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributes& _internal_laneattributes() const;
  ::cn::seisys::v2x::pb::LaneAttributes* _internal_mutable_laneattributes();
  public:
  void unsafe_arena_set_allocated_laneattributes(
      ::cn::seisys::v2x::pb::LaneAttributes* laneattributes);
  ::cn::seisys::v2x::pb::LaneAttributes* unsafe_arena_release_laneattributes();

  // .cn.seisys.v2x.pb.AllowedManeuvers maneuvers = 4;
  bool has_maneuvers() const;
  private:
  bool _internal_has_maneuvers() const;
  public:
  void clear_maneuvers();
  const ::cn::seisys::v2x::pb::AllowedManeuvers& maneuvers() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::AllowedManeuvers* release_maneuvers();
  ::cn::seisys::v2x::pb::AllowedManeuvers* mutable_maneuvers();
  void set_allocated_maneuvers(::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers);
  private:
  const ::cn::seisys::v2x::pb::AllowedManeuvers& _internal_maneuvers() const;
  ::cn::seisys::v2x::pb::AllowedManeuvers* _internal_mutable_maneuvers();
  public:
  void unsafe_arena_set_allocated_maneuvers(
      ::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers);
  ::cn::seisys::v2x::pb::AllowedManeuvers* unsafe_arena_release_maneuvers();

  // uint32 laneId = 1;
  void clear_laneid();
  uint32_t laneid() const;
  void set_laneid(uint32_t value);
  private:
  uint32_t _internal_laneid() const;
  void _internal_set_laneid(uint32_t value);
  public:

  // uint32 laneWidth = 2;
  void clear_lanewidth();
  uint32_t lanewidth() const;
  void set_lanewidth(uint32_t value);
  private:
  uint32_t _internal_lanewidth() const;
  void _internal_set_lanewidth(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.Lane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Connection > connectsto_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit > speedlimits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D > points_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary > leftboundary_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary > rightboundary_;
    ::cn::seisys::v2x::pb::LaneAttributes* laneattributes_;
    ::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers_;
    uint32_t laneid_;
    uint32_t lanewidth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class SignalWaitingLane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.SignalWaitingLane) */ {
 public:
  inline SignalWaitingLane() : SignalWaitingLane(nullptr) {}
  ~SignalWaitingLane() override;
  explicit PROTOBUF_CONSTEXPR SignalWaitingLane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalWaitingLane(const SignalWaitingLane& from);
  SignalWaitingLane(SignalWaitingLane&& from) noexcept
    : SignalWaitingLane() {
    *this = ::std::move(from);
  }

  inline SignalWaitingLane& operator=(const SignalWaitingLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalWaitingLane& operator=(SignalWaitingLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalWaitingLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalWaitingLane* internal_default_instance() {
    return reinterpret_cast<const SignalWaitingLane*>(
               &_SignalWaitingLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(SignalWaitingLane& a, SignalWaitingLane& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalWaitingLane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalWaitingLane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalWaitingLane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalWaitingLane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalWaitingLane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalWaitingLane& from) {
    SignalWaitingLane::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalWaitingLane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.SignalWaitingLane";
  }
  protected:
  explicit SignalWaitingLane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedPhaseIdsFieldNumber = 3,
    kPointsFieldNumber = 2,
    kLaneWidthFieldNumber = 1,
  };
  // repeated .cn.seisys.v2x.pb.PhaseId allowedPhaseIds = 3;
  int allowedphaseids_size() const;
  private:
  int _internal_allowedphaseids_size() const;
  public:
  void clear_allowedphaseids();
  ::cn::seisys::v2x::pb::PhaseId* mutable_allowedphaseids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseId >*
      mutable_allowedphaseids();
  private:
  const ::cn::seisys::v2x::pb::PhaseId& _internal_allowedphaseids(int index) const;
  ::cn::seisys::v2x::pb::PhaseId* _internal_add_allowedphaseids();
  public:
  const ::cn::seisys::v2x::pb::PhaseId& allowedphaseids(int index) const;
  ::cn::seisys::v2x::pb::PhaseId* add_allowedphaseids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseId >&
      allowedphaseids() const;

  // .cn.seisys.v2x.pb.Position3D points = 2;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::cn::seisys::v2x::pb::Position3D& points() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_points();
  ::cn::seisys::v2x::pb::Position3D* mutable_points();
  void set_allocated_points(::cn::seisys::v2x::pb::Position3D* points);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_points() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::cn::seisys::v2x::pb::Position3D* points);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_points();

  // int32 laneWidth = 1;
  void clear_lanewidth();
  int32_t lanewidth() const;
  void set_lanewidth(int32_t value);
  private:
  int32_t _internal_lanewidth() const;
  void _internal_set_lanewidth(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.SignalWaitingLane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseId > allowedphaseids_;
    ::cn::seisys::v2x::pb::Position3D* points_;
    int32_t lanewidth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ConnectingLaneEx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ConnectingLaneEx) */ {
 public:
  inline ConnectingLaneEx() : ConnectingLaneEx(nullptr) {}
  ~ConnectingLaneEx() override;
  explicit PROTOBUF_CONSTEXPR ConnectingLaneEx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectingLaneEx(const ConnectingLaneEx& from);
  ConnectingLaneEx(ConnectingLaneEx&& from) noexcept
    : ConnectingLaneEx() {
    *this = ::std::move(from);
  }

  inline ConnectingLaneEx& operator=(const ConnectingLaneEx& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectingLaneEx& operator=(ConnectingLaneEx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectingLaneEx& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectingLaneEx* internal_default_instance() {
    return reinterpret_cast<const ConnectingLaneEx*>(
               &_ConnectingLaneEx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(ConnectingLaneEx& a, ConnectingLaneEx& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectingLaneEx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectingLaneEx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectingLaneEx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectingLaneEx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectingLaneEx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectingLaneEx& from) {
    ConnectingLaneEx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectingLaneEx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ConnectingLaneEx";
  }
  protected:
  explicit ConnectingLaneEx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectingLanePointsFieldNumber = 4,
    kTargetSectionFieldNumber = 1,
    kTargetLaneFieldNumber = 2,
    kConnectingLaneWidthFieldNumber = 3,
    kIsolatedConnectingLaneFieldNumber = 5,
  };
  // .cn.seisys.v2x.pb.Position3D connectingLanePoints = 4;
  bool has_connectinglanepoints() const;
  private:
  bool _internal_has_connectinglanepoints() const;
  public:
  void clear_connectinglanepoints();
  const ::cn::seisys::v2x::pb::Position3D& connectinglanepoints() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_connectinglanepoints();
  ::cn::seisys::v2x::pb::Position3D* mutable_connectinglanepoints();
  void set_allocated_connectinglanepoints(::cn::seisys::v2x::pb::Position3D* connectinglanepoints);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_connectinglanepoints() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_connectinglanepoints();
  public:
  void unsafe_arena_set_allocated_connectinglanepoints(
      ::cn::seisys::v2x::pb::Position3D* connectinglanepoints);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_connectinglanepoints();

  // int32 targetSection = 1;
  void clear_targetsection();
  int32_t targetsection() const;
  void set_targetsection(int32_t value);
  private:
  int32_t _internal_targetsection() const;
  void _internal_set_targetsection(int32_t value);
  public:

  // int32 targetLane = 2;
  void clear_targetlane();
  int32_t targetlane() const;
  void set_targetlane(int32_t value);
  private:
  int32_t _internal_targetlane() const;
  void _internal_set_targetlane(int32_t value);
  public:

  // int32 connectingLaneWidth = 3;
  void clear_connectinglanewidth();
  int32_t connectinglanewidth() const;
  void set_connectinglanewidth(int32_t value);
  private:
  int32_t _internal_connectinglanewidth() const;
  void _internal_set_connectinglanewidth(int32_t value);
  public:

  // bool isolatedConnectingLane = 5;
  void clear_isolatedconnectinglane();
  bool isolatedconnectinglane() const;
  void set_isolatedconnectinglane(bool value);
  private:
  bool _internal_isolatedconnectinglane() const;
  void _internal_set_isolatedconnectinglane(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ConnectingLaneEx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::Position3D* connectinglanepoints_;
    int32_t targetsection_;
    int32_t targetlane_;
    int32_t connectinglanewidth_;
    bool isolatedconnectinglane_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ConnectionEx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ConnectionEx) */ {
 public:
  inline ConnectionEx() : ConnectionEx(nullptr) {}
  ~ConnectionEx() override;
  explicit PROTOBUF_CONSTEXPR ConnectionEx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionEx(const ConnectionEx& from);
  ConnectionEx(ConnectionEx&& from) noexcept
    : ConnectionEx() {
    *this = ::std::move(from);
  }

  inline ConnectionEx& operator=(const ConnectionEx& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionEx& operator=(ConnectionEx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionEx& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionEx* internal_default_instance() {
    return reinterpret_cast<const ConnectionEx*>(
               &_ConnectionEx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(ConnectionEx& a, ConnectionEx& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionEx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionEx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionEx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionEx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionEx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectionEx& from) {
    ConnectionEx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionEx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ConnectionEx";
  }
  protected:
  explicit ConnectionEx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionLaneFieldNumber = 3,
    kRemoteIntersectionFieldNumber = 1,
    kSwlFieldNumber = 2,
    kPhaseIdFieldNumber = 4,
    kTurnDirectionFieldNumber = 5,
  };
  // repeated .cn.seisys.v2x.pb.ConnectingLaneEx connectionLane = 3;
  int connectionlane_size() const;
  private:
  int _internal_connectionlane_size() const;
  public:
  void clear_connectionlane();
  ::cn::seisys::v2x::pb::ConnectingLaneEx* mutable_connectionlane(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectingLaneEx >*
      mutable_connectionlane();
  private:
  const ::cn::seisys::v2x::pb::ConnectingLaneEx& _internal_connectionlane(int index) const;
  ::cn::seisys::v2x::pb::ConnectingLaneEx* _internal_add_connectionlane();
  public:
  const ::cn::seisys::v2x::pb::ConnectingLaneEx& connectionlane(int index) const;
  ::cn::seisys::v2x::pb::ConnectingLaneEx* add_connectionlane();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectingLaneEx >&
      connectionlane() const;

  // .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
  bool has_remoteintersection() const;
  private:
  bool _internal_has_remoteintersection() const;
  public:
  void clear_remoteintersection();
  const ::cn::seisys::v2x::pb::NodeReferenceId& remoteintersection() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_remoteintersection();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_remoteintersection();
  void set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_remoteintersection() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_remoteintersection();
  public:
  void unsafe_arena_set_allocated_remoteintersection(
      ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_remoteintersection();

  // .cn.seisys.v2x.pb.SignalWaitingLane swl = 2;
  bool has_swl() const;
  private:
  bool _internal_has_swl() const;
  public:
  void clear_swl();
  const ::cn::seisys::v2x::pb::SignalWaitingLane& swl() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::SignalWaitingLane* release_swl();
  ::cn::seisys::v2x::pb::SignalWaitingLane* mutable_swl();
  void set_allocated_swl(::cn::seisys::v2x::pb::SignalWaitingLane* swl);
  private:
  const ::cn::seisys::v2x::pb::SignalWaitingLane& _internal_swl() const;
  ::cn::seisys::v2x::pb::SignalWaitingLane* _internal_mutable_swl();
  public:
  void unsafe_arena_set_allocated_swl(
      ::cn::seisys::v2x::pb::SignalWaitingLane* swl);
  ::cn::seisys::v2x::pb::SignalWaitingLane* unsafe_arena_release_swl();

  // uint32 phaseId = 4;
  void clear_phaseid();
  uint32_t phaseid() const;
  void set_phaseid(uint32_t value);
  private:
  uint32_t _internal_phaseid() const;
  void _internal_set_phaseid(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.Maneuver turnDirection = 5;
  void clear_turndirection();
  ::cn::seisys::v2x::pb::Maneuver turndirection() const;
  void set_turndirection(::cn::seisys::v2x::pb::Maneuver value);
  private:
  ::cn::seisys::v2x::pb::Maneuver _internal_turndirection() const;
  void _internal_set_turndirection(::cn::seisys::v2x::pb::Maneuver value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ConnectionEx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectingLaneEx > connectionlane_;
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection_;
    ::cn::seisys::v2x::pb::SignalWaitingLane* swl_;
    uint32_t phaseid_;
    int turndirection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class STPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.STPoint) */ {
 public:
  inline STPoint() : STPoint(nullptr) {}
  ~STPoint() override;
  explicit PROTOBUF_CONSTEXPR STPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STPoint(const STPoint& from);
  STPoint(STPoint&& from) noexcept
    : STPoint() {
    *this = ::std::move(from);
  }

  inline STPoint& operator=(const STPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline STPoint& operator=(STPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const STPoint* internal_default_instance() {
    return reinterpret_cast<const STPoint*>(
               &_STPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(STPoint& a, STPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(STPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STPoint& from) {
    STPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.STPoint";
  }
  protected:
  explicit STPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSAxisFieldNumber = 1,
    kTAxisFieldNumber = 2,
  };
  // int32 sAxis = 1;
  void clear_saxis();
  int32_t saxis() const;
  void set_saxis(int32_t value);
  private:
  int32_t _internal_saxis() const;
  void _internal_set_saxis(int32_t value);
  public:

  // int32 tAxis = 2;
  void clear_taxis();
  int32_t taxis() const;
  void set_taxis(int32_t value);
  private:
  int32_t _internal_taxis() const;
  void _internal_set_taxis(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.STPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t saxis_;
    int32_t taxis_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneEx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneEx) */ {
 public:
  inline LaneEx() : LaneEx(nullptr) {}
  ~LaneEx() override;
  explicit PROTOBUF_CONSTEXPR LaneEx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneEx(const LaneEx& from);
  LaneEx(LaneEx&& from) noexcept
    : LaneEx() {
    *this = ::std::move(from);
  }

  inline LaneEx& operator=(const LaneEx& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneEx& operator=(LaneEx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneEx& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneEx* internal_default_instance() {
    return reinterpret_cast<const LaneEx*>(
               &_LaneEx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(LaneEx& a, LaneEx& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneEx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneEx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneEx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneEx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneEx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneEx& from) {
    LaneEx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneEx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneEx";
  }
  protected:
  explicit LaneEx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectsToExFieldNumber = 5,
    kSpeedLimitsFieldNumber = 6,
    kStPointsFieldNumber = 7,
    kLeftBoundaryFieldNumber = 8,
    kRightBoundaryFieldNumber = 9,
    kLaneAttributesFieldNumber = 3,
    kManeuversFieldNumber = 4,
    kLaneRefIdFieldNumber = 1,
    kLaneWidthFieldNumber = 2,
  };
  // repeated .cn.seisys.v2x.pb.ConnectionEx connectsToEx = 5;
  int connectstoex_size() const;
  private:
  int _internal_connectstoex_size() const;
  public:
  void clear_connectstoex();
  ::cn::seisys::v2x::pb::ConnectionEx* mutable_connectstoex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectionEx >*
      mutable_connectstoex();
  private:
  const ::cn::seisys::v2x::pb::ConnectionEx& _internal_connectstoex(int index) const;
  ::cn::seisys::v2x::pb::ConnectionEx* _internal_add_connectstoex();
  public:
  const ::cn::seisys::v2x::pb::ConnectionEx& connectstoex(int index) const;
  ::cn::seisys::v2x::pb::ConnectionEx* add_connectstoex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectionEx >&
      connectstoex() const;

  // repeated .cn.seisys.v2x.pb.RegulatorySpeedLimit speedLimits = 6;
  int speedlimits_size() const;
  private:
  int _internal_speedlimits_size() const;
  public:
  void clear_speedlimits();
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* mutable_speedlimits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >*
      mutable_speedlimits();
  private:
  const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& _internal_speedlimits(int index) const;
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* _internal_add_speedlimits();
  public:
  const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& speedlimits(int index) const;
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* add_speedlimits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >&
      speedlimits() const;

  // repeated .cn.seisys.v2x.pb.STPoint stPoints = 7;
  int stpoints_size() const;
  private:
  int _internal_stpoints_size() const;
  public:
  void clear_stpoints();
  ::cn::seisys::v2x::pb::STPoint* mutable_stpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::STPoint >*
      mutable_stpoints();
  private:
  const ::cn::seisys::v2x::pb::STPoint& _internal_stpoints(int index) const;
  ::cn::seisys::v2x::pb::STPoint* _internal_add_stpoints();
  public:
  const ::cn::seisys::v2x::pb::STPoint& stpoints(int index) const;
  ::cn::seisys::v2x::pb::STPoint* add_stpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::STPoint >&
      stpoints() const;

  // repeated .cn.seisys.v2x.pb.LaneBoundary leftBoundary = 8;
  int leftboundary_size() const;
  private:
  int _internal_leftboundary_size() const;
  public:
  void clear_leftboundary();
  ::cn::seisys::v2x::pb::LaneBoundary* mutable_leftboundary(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >*
      mutable_leftboundary();
  private:
  const ::cn::seisys::v2x::pb::LaneBoundary& _internal_leftboundary(int index) const;
  ::cn::seisys::v2x::pb::LaneBoundary* _internal_add_leftboundary();
  public:
  const ::cn::seisys::v2x::pb::LaneBoundary& leftboundary(int index) const;
  ::cn::seisys::v2x::pb::LaneBoundary* add_leftboundary();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >&
      leftboundary() const;

  // repeated .cn.seisys.v2x.pb.LaneBoundary rightBoundary = 9;
  int rightboundary_size() const;
  private:
  int _internal_rightboundary_size() const;
  public:
  void clear_rightboundary();
  ::cn::seisys::v2x::pb::LaneBoundary* mutable_rightboundary(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >*
      mutable_rightboundary();
  private:
  const ::cn::seisys::v2x::pb::LaneBoundary& _internal_rightboundary(int index) const;
  ::cn::seisys::v2x::pb::LaneBoundary* _internal_add_rightboundary();
  public:
  const ::cn::seisys::v2x::pb::LaneBoundary& rightboundary(int index) const;
  ::cn::seisys::v2x::pb::LaneBoundary* add_rightboundary();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >&
      rightboundary() const;

  // .cn.seisys.v2x.pb.LaneAttributes laneAttributes = 3;
  bool has_laneattributes() const;
  private:
  bool _internal_has_laneattributes() const;
  public:
  void clear_laneattributes();
  const ::cn::seisys::v2x::pb::LaneAttributes& laneattributes() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneAttributes* release_laneattributes();
  ::cn::seisys::v2x::pb::LaneAttributes* mutable_laneattributes();
  void set_allocated_laneattributes(::cn::seisys::v2x::pb::LaneAttributes* laneattributes);
  private:
  const ::cn::seisys::v2x::pb::LaneAttributes& _internal_laneattributes() const;
  ::cn::seisys::v2x::pb::LaneAttributes* _internal_mutable_laneattributes();
  public:
  void unsafe_arena_set_allocated_laneattributes(
      ::cn::seisys::v2x::pb::LaneAttributes* laneattributes);
  ::cn::seisys::v2x::pb::LaneAttributes* unsafe_arena_release_laneattributes();

  // .cn.seisys.v2x.pb.AllowedManeuvers maneuvers = 4;
  bool has_maneuvers() const;
  private:
  bool _internal_has_maneuvers() const;
  public:
  void clear_maneuvers();
  const ::cn::seisys::v2x::pb::AllowedManeuvers& maneuvers() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::AllowedManeuvers* release_maneuvers();
  ::cn::seisys::v2x::pb::AllowedManeuvers* mutable_maneuvers();
  void set_allocated_maneuvers(::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers);
  private:
  const ::cn::seisys::v2x::pb::AllowedManeuvers& _internal_maneuvers() const;
  ::cn::seisys::v2x::pb::AllowedManeuvers* _internal_mutable_maneuvers();
  public:
  void unsafe_arena_set_allocated_maneuvers(
      ::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers);
  ::cn::seisys::v2x::pb::AllowedManeuvers* unsafe_arena_release_maneuvers();

  // int32 laneRefId = 1;
  void clear_lanerefid();
  int32_t lanerefid() const;
  void set_lanerefid(int32_t value);
  private:
  int32_t _internal_lanerefid() const;
  void _internal_set_lanerefid(int32_t value);
  public:

  // uint32 laneWidth = 2;
  void clear_lanewidth();
  uint32_t lanewidth() const;
  void set_lanewidth(uint32_t value);
  private:
  uint32_t _internal_lanewidth() const;
  void _internal_set_lanewidth(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneEx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectionEx > connectstoex_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit > speedlimits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::STPoint > stpoints_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary > leftboundary_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary > rightboundary_;
    ::cn::seisys::v2x::pb::LaneAttributes* laneattributes_;
    ::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers_;
    int32_t lanerefid_;
    uint32_t lanewidth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class Movement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.Movement) */ {
 public:
  inline Movement() : Movement(nullptr) {}
  ~Movement() override;
  explicit PROTOBUF_CONSTEXPR Movement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Movement(const Movement& from);
  Movement(Movement&& from) noexcept
    : Movement() {
    *this = ::std::move(from);
  }

  inline Movement& operator=(const Movement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Movement& operator=(Movement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Movement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Movement* internal_default_instance() {
    return reinterpret_cast<const Movement*>(
               &_Movement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(Movement& a, Movement& b) {
    a.Swap(&b);
  }
  inline void Swap(Movement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Movement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Movement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Movement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Movement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Movement& from) {
    Movement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Movement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.Movement";
  }
  protected:
  explicit Movement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteIntersectionFieldNumber = 1,
    kPhaseIdFieldNumber = 2,
  };
  // .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
  bool has_remoteintersection() const;
  private:
  bool _internal_has_remoteintersection() const;
  public:
  void clear_remoteintersection();
  const ::cn::seisys::v2x::pb::NodeReferenceId& remoteintersection() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_remoteintersection();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_remoteintersection();
  void set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_remoteintersection() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_remoteintersection();
  public:
  void unsafe_arena_set_allocated_remoteintersection(
      ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_remoteintersection();

  // uint32 phaseId = 2;
  void clear_phaseid();
  uint32_t phaseid() const;
  void set_phaseid(uint32_t value);
  private:
  uint32_t _internal_phaseid() const;
  void _internal_set_phaseid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.Movement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection_;
    uint32_t phaseid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class Section final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.Section) */ {
 public:
  inline Section() : Section(nullptr) {}
  ~Section() override;
  explicit PROTOBUF_CONSTEXPR Section(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Section(const Section& from);
  Section(Section&& from) noexcept
    : Section() {
    *this = ::std::move(from);
  }

  inline Section& operator=(const Section& from) {
    CopyFrom(from);
    return *this;
  }
  inline Section& operator=(Section&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Section& default_instance() {
    return *internal_default_instance();
  }
  static inline const Section* internal_default_instance() {
    return reinterpret_cast<const Section*>(
               &_Section_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(Section& a, Section& b) {
    a.Swap(&b);
  }
  inline void Swap(Section* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Section* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Section* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Section>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Section& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Section& from) {
    Section::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Section* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.Section";
  }
  protected:
  explicit Section(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanesFieldNumber = 2,
    kSecIdFieldNumber = 1,
  };
  // repeated .cn.seisys.v2x.pb.LaneEx lanes = 2;
  int lanes_size() const;
  private:
  int _internal_lanes_size() const;
  public:
  void clear_lanes();
  ::cn::seisys::v2x::pb::LaneEx* mutable_lanes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneEx >*
      mutable_lanes();
  private:
  const ::cn::seisys::v2x::pb::LaneEx& _internal_lanes(int index) const;
  ::cn::seisys::v2x::pb::LaneEx* _internal_add_lanes();
  public:
  const ::cn::seisys::v2x::pb::LaneEx& lanes(int index) const;
  ::cn::seisys::v2x::pb::LaneEx* add_lanes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneEx >&
      lanes() const;

  // uint32 SecId = 1;
  void clear_secid();
  uint32_t secid() const;
  void set_secid(uint32_t value);
  private:
  uint32_t _internal_secid() const;
  void _internal_set_secid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.Section)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneEx > lanes_;
    uint32_t secid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LinkEx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LinkEx) */ {
 public:
  inline LinkEx() : LinkEx(nullptr) {}
  ~LinkEx() override;
  explicit PROTOBUF_CONSTEXPR LinkEx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinkEx(const LinkEx& from);
  LinkEx(LinkEx&& from) noexcept
    : LinkEx() {
    *this = ::std::move(from);
  }

  inline LinkEx& operator=(const LinkEx& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkEx& operator=(LinkEx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinkEx& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinkEx* internal_default_instance() {
    return reinterpret_cast<const LinkEx*>(
               &_LinkEx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(LinkEx& a, LinkEx& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkEx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkEx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinkEx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinkEx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinkEx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LinkEx& from) {
    LinkEx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkEx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LinkEx";
  }
  protected:
  explicit LinkEx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedLimitsFieldNumber = 3,
    kRefLineFieldNumber = 5,
    kMovementsExFieldNumber = 6,
    kSectionsFieldNumber = 7,
    kNameFieldNumber = 1,
    kUpstreamNodeIdFieldNumber = 2,
    kLinkWidthFieldNumber = 4,
  };
  // repeated .cn.seisys.v2x.pb.RegulatorySpeedLimit speedLimits = 3;
  int speedlimits_size() const;
  private:
  int _internal_speedlimits_size() const;
  public:
  void clear_speedlimits();
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* mutable_speedlimits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >*
      mutable_speedlimits();
  private:
  const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& _internal_speedlimits(int index) const;
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* _internal_add_speedlimits();
  public:
  const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& speedlimits(int index) const;
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* add_speedlimits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >&
      speedlimits() const;

  // repeated .cn.seisys.v2x.pb.Position3D refLine = 5;
  int refline_size() const;
  private:
  int _internal_refline_size() const;
  public:
  void clear_refline();
  ::cn::seisys::v2x::pb::Position3D* mutable_refline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
      mutable_refline();
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_refline(int index) const;
  ::cn::seisys::v2x::pb::Position3D* _internal_add_refline();
  public:
  const ::cn::seisys::v2x::pb::Position3D& refline(int index) const;
  ::cn::seisys::v2x::pb::Position3D* add_refline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
      refline() const;

  // repeated .cn.seisys.v2x.pb.MovementEx movementsEx = 6;
  int movementsex_size() const;
  private:
  int _internal_movementsex_size() const;
  public:
  void clear_movementsex();
  ::cn::seisys::v2x::pb::MovementEx* mutable_movementsex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx >*
      mutable_movementsex();
  private:
  const ::cn::seisys::v2x::pb::MovementEx& _internal_movementsex(int index) const;
  ::cn::seisys::v2x::pb::MovementEx* _internal_add_movementsex();
  public:
  const ::cn::seisys::v2x::pb::MovementEx& movementsex(int index) const;
  ::cn::seisys::v2x::pb::MovementEx* add_movementsex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx >&
      movementsex() const;

  // repeated .cn.seisys.v2x.pb.Section sections = 7;
  int sections_size() const;
  private:
  int _internal_sections_size() const;
  public:
  void clear_sections();
  ::cn::seisys::v2x::pb::Section* mutable_sections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Section >*
      mutable_sections();
  private:
  const ::cn::seisys::v2x::pb::Section& _internal_sections(int index) const;
  ::cn::seisys::v2x::pb::Section* _internal_add_sections();
  public:
  const ::cn::seisys::v2x::pb::Section& sections(int index) const;
  ::cn::seisys::v2x::pb::Section* add_sections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Section >&
      sections() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 2;
  bool has_upstreamnodeid() const;
  private:
  bool _internal_has_upstreamnodeid() const;
  public:
  void clear_upstreamnodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& upstreamnodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_upstreamnodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_upstreamnodeid();
  void set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_upstreamnodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_upstreamnodeid();
  public:
  void unsafe_arena_set_allocated_upstreamnodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_upstreamnodeid();

  // uint32 linkWidth = 4;
  void clear_linkwidth();
  uint32_t linkwidth() const;
  void set_linkwidth(uint32_t value);
  private:
  uint32_t _internal_linkwidth() const;
  void _internal_set_linkwidth(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LinkEx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit > speedlimits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D > refline_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx > movementsex_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Section > sections_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid_;
    uint32_t linkwidth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class Link final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.Link) */ {
 public:
  inline Link() : Link(nullptr) {}
  ~Link() override;
  explicit PROTOBUF_CONSTEXPR Link(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Link(const Link& from);
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Link& operator=(Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Link* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Link>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Link& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Link& from) {
    Link::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Link* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.Link";
  }
  protected:
  explicit Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedLimitsFieldNumber = 3,
    kPointsFieldNumber = 5,
    kMovementsFieldNumber = 6,
    kLanesFieldNumber = 7,
    kNameFieldNumber = 1,
    kUpstreamNodeIdFieldNumber = 2,
    kLinkWidthFieldNumber = 4,
  };
  // repeated .cn.seisys.v2x.pb.RegulatorySpeedLimit speedLimits = 3;
  int speedlimits_size() const;
  private:
  int _internal_speedlimits_size() const;
  public:
  void clear_speedlimits();
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* mutable_speedlimits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >*
      mutable_speedlimits();
  private:
  const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& _internal_speedlimits(int index) const;
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* _internal_add_speedlimits();
  public:
  const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& speedlimits(int index) const;
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* add_speedlimits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >&
      speedlimits() const;

  // repeated .cn.seisys.v2x.pb.Position3D points = 5;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::cn::seisys::v2x::pb::Position3D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
      mutable_points();
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_points(int index) const;
  ::cn::seisys::v2x::pb::Position3D* _internal_add_points();
  public:
  const ::cn::seisys::v2x::pb::Position3D& points(int index) const;
  ::cn::seisys::v2x::pb::Position3D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
      points() const;

  // repeated .cn.seisys.v2x.pb.Movement movements = 6;
  int movements_size() const;
  private:
  int _internal_movements_size() const;
  public:
  void clear_movements();
  ::cn::seisys::v2x::pb::Movement* mutable_movements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Movement >*
      mutable_movements();
  private:
  const ::cn::seisys::v2x::pb::Movement& _internal_movements(int index) const;
  ::cn::seisys::v2x::pb::Movement* _internal_add_movements();
  public:
  const ::cn::seisys::v2x::pb::Movement& movements(int index) const;
  ::cn::seisys::v2x::pb::Movement* add_movements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Movement >&
      movements() const;

  // repeated .cn.seisys.v2x.pb.Lane lanes = 7;
  int lanes_size() const;
  private:
  int _internal_lanes_size() const;
  public:
  void clear_lanes();
  ::cn::seisys::v2x::pb::Lane* mutable_lanes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Lane >*
      mutable_lanes();
  private:
  const ::cn::seisys::v2x::pb::Lane& _internal_lanes(int index) const;
  ::cn::seisys::v2x::pb::Lane* _internal_add_lanes();
  public:
  const ::cn::seisys::v2x::pb::Lane& lanes(int index) const;
  ::cn::seisys::v2x::pb::Lane* add_lanes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Lane >&
      lanes() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 2;
  bool has_upstreamnodeid() const;
  private:
  bool _internal_has_upstreamnodeid() const;
  public:
  void clear_upstreamnodeid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& upstreamnodeid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_upstreamnodeid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_upstreamnodeid();
  void set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_upstreamnodeid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_upstreamnodeid();
  public:
  void unsafe_arena_set_allocated_upstreamnodeid(
      ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_upstreamnodeid();

  // uint32 linkWidth = 4;
  void clear_linkwidth();
  uint32_t linkwidth() const;
  void set_linkwidth(uint32_t value);
  private:
  uint32_t _internal_linkwidth() const;
  void _internal_set_linkwidth(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit > speedlimits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D > points_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Movement > movements_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Lane > lanes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid_;
    uint32_t linkwidth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ProhibitedZone final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ProhibitedZone) */ {
 public:
  inline ProhibitedZone() : ProhibitedZone(nullptr) {}
  ~ProhibitedZone() override;
  explicit PROTOBUF_CONSTEXPR ProhibitedZone(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProhibitedZone(const ProhibitedZone& from);
  ProhibitedZone(ProhibitedZone&& from) noexcept
    : ProhibitedZone() {
    *this = ::std::move(from);
  }

  inline ProhibitedZone& operator=(const ProhibitedZone& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProhibitedZone& operator=(ProhibitedZone&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProhibitedZone& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProhibitedZone* internal_default_instance() {
    return reinterpret_cast<const ProhibitedZone*>(
               &_ProhibitedZone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(ProhibitedZone& a, ProhibitedZone& b) {
    a.Swap(&b);
  }
  inline void Swap(ProhibitedZone* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProhibitedZone* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProhibitedZone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProhibitedZone>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProhibitedZone& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProhibitedZone& from) {
    ProhibitedZone::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProhibitedZone* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ProhibitedZone";
  }
  protected:
  explicit ProhibitedZone(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonMotorVehicleProhibitedZonesFieldNumber = 2,
    kGridLineMarkingProhibitedZonesFieldNumber = 3,
    kCentralCircleProhibitedZoneFieldNumber = 1,
  };
  // repeated .cn.seisys.v2x.pb.Polygon nonMotorVehicleProhibitedZones = 2;
  int nonmotorvehicleprohibitedzones_size() const;
  private:
  int _internal_nonmotorvehicleprohibitedzones_size() const;
  public:
  void clear_nonmotorvehicleprohibitedzones();
  ::cn::seisys::v2x::pb::Polygon* mutable_nonmotorvehicleprohibitedzones(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >*
      mutable_nonmotorvehicleprohibitedzones();
  private:
  const ::cn::seisys::v2x::pb::Polygon& _internal_nonmotorvehicleprohibitedzones(int index) const;
  ::cn::seisys::v2x::pb::Polygon* _internal_add_nonmotorvehicleprohibitedzones();
  public:
  const ::cn::seisys::v2x::pb::Polygon& nonmotorvehicleprohibitedzones(int index) const;
  ::cn::seisys::v2x::pb::Polygon* add_nonmotorvehicleprohibitedzones();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >&
      nonmotorvehicleprohibitedzones() const;

  // repeated .cn.seisys.v2x.pb.Polygon gridLineMarkingProhibitedZones = 3;
  int gridlinemarkingprohibitedzones_size() const;
  private:
  int _internal_gridlinemarkingprohibitedzones_size() const;
  public:
  void clear_gridlinemarkingprohibitedzones();
  ::cn::seisys::v2x::pb::Polygon* mutable_gridlinemarkingprohibitedzones(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >*
      mutable_gridlinemarkingprohibitedzones();
  private:
  const ::cn::seisys::v2x::pb::Polygon& _internal_gridlinemarkingprohibitedzones(int index) const;
  ::cn::seisys::v2x::pb::Polygon* _internal_add_gridlinemarkingprohibitedzones();
  public:
  const ::cn::seisys::v2x::pb::Polygon& gridlinemarkingprohibitedzones(int index) const;
  ::cn::seisys::v2x::pb::Polygon* add_gridlinemarkingprohibitedzones();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >&
      gridlinemarkingprohibitedzones() const;

  // .cn.seisys.v2x.pb.Polygon centralCircleProhibitedZone = 1;
  bool has_centralcircleprohibitedzone() const;
  private:
  bool _internal_has_centralcircleprohibitedzone() const;
  public:
  void clear_centralcircleprohibitedzone();
  const ::cn::seisys::v2x::pb::Polygon& centralcircleprohibitedzone() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Polygon* release_centralcircleprohibitedzone();
  ::cn::seisys::v2x::pb::Polygon* mutable_centralcircleprohibitedzone();
  void set_allocated_centralcircleprohibitedzone(::cn::seisys::v2x::pb::Polygon* centralcircleprohibitedzone);
  private:
  const ::cn::seisys::v2x::pb::Polygon& _internal_centralcircleprohibitedzone() const;
  ::cn::seisys::v2x::pb::Polygon* _internal_mutable_centralcircleprohibitedzone();
  public:
  void unsafe_arena_set_allocated_centralcircleprohibitedzone(
      ::cn::seisys::v2x::pb::Polygon* centralcircleprohibitedzone);
  ::cn::seisys::v2x::pb::Polygon* unsafe_arena_release_centralcircleprohibitedzone();

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ProhibitedZone)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon > nonmotorvehicleprohibitedzones_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon > gridlinemarkingprohibitedzones_;
    ::cn::seisys::v2x::pb::Polygon* centralcircleprohibitedzone_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit PROTOBUF_CONSTEXPR Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInLinksFieldNumber = 4,
    kInLinksExFieldNumber = 5,
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kRefPosFieldNumber = 3,
    kProhibitedZoneFieldNumber = 6,
  };
  // repeated .cn.seisys.v2x.pb.Link inLinks = 4;
  int inlinks_size() const;
  private:
  int _internal_inlinks_size() const;
  public:
  void clear_inlinks();
  ::cn::seisys::v2x::pb::Link* mutable_inlinks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Link >*
      mutable_inlinks();
  private:
  const ::cn::seisys::v2x::pb::Link& _internal_inlinks(int index) const;
  ::cn::seisys::v2x::pb::Link* _internal_add_inlinks();
  public:
  const ::cn::seisys::v2x::pb::Link& inlinks(int index) const;
  ::cn::seisys::v2x::pb::Link* add_inlinks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Link >&
      inlinks() const;

  // repeated .cn.seisys.v2x.pb.LinkEx inLinksEx = 5;
  int inlinksex_size() const;
  private:
  int _internal_inlinksex_size() const;
  public:
  void clear_inlinksex();
  ::cn::seisys::v2x::pb::LinkEx* mutable_inlinksex(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkEx >*
      mutable_inlinksex();
  private:
  const ::cn::seisys::v2x::pb::LinkEx& _internal_inlinksex(int index) const;
  ::cn::seisys::v2x::pb::LinkEx* _internal_add_inlinksex();
  public:
  const ::cn::seisys::v2x::pb::LinkEx& inlinksex(int index) const;
  ::cn::seisys::v2x::pb::LinkEx* add_inlinksex();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkEx >&
      inlinksex() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .cn.seisys.v2x.pb.NodeReferenceId id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::cn::seisys::v2x::pb::NodeReferenceId& id() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_id();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_id();
  void set_allocated_id(::cn::seisys::v2x::pb::NodeReferenceId* id);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_id() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::cn::seisys::v2x::pb::NodeReferenceId* id);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_id();

  // .cn.seisys.v2x.pb.Position3D refPos = 3;
  bool has_refpos() const;
  private:
  bool _internal_has_refpos() const;
  public:
  void clear_refpos();
  const ::cn::seisys::v2x::pb::Position3D& refpos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_refpos();
  ::cn::seisys::v2x::pb::Position3D* mutable_refpos();
  void set_allocated_refpos(::cn::seisys::v2x::pb::Position3D* refpos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_refpos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_refpos();
  public:
  void unsafe_arena_set_allocated_refpos(
      ::cn::seisys::v2x::pb::Position3D* refpos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_refpos();

  // .cn.seisys.v2x.pb.ProhibitedZone prohibitedZone = 6;
  bool has_prohibitedzone() const;
  private:
  bool _internal_has_prohibitedzone() const;
  public:
  void clear_prohibitedzone();
  const ::cn::seisys::v2x::pb::ProhibitedZone& prohibitedzone() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ProhibitedZone* release_prohibitedzone();
  ::cn::seisys::v2x::pb::ProhibitedZone* mutable_prohibitedzone();
  void set_allocated_prohibitedzone(::cn::seisys::v2x::pb::ProhibitedZone* prohibitedzone);
  private:
  const ::cn::seisys::v2x::pb::ProhibitedZone& _internal_prohibitedzone() const;
  ::cn::seisys::v2x::pb::ProhibitedZone* _internal_mutable_prohibitedzone();
  public:
  void unsafe_arena_set_allocated_prohibitedzone(
      ::cn::seisys::v2x::pb::ProhibitedZone* prohibitedzone);
  ::cn::seisys::v2x::pb::ProhibitedZone* unsafe_arena_release_prohibitedzone();

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Link > inlinks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkEx > inlinksex_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::cn::seisys::v2x::pb::NodeReferenceId* id_;
    ::cn::seisys::v2x::pb::Position3D* refpos_;
    ::cn::seisys::v2x::pb::ProhibitedZone* prohibitedzone_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class MAP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.MAP) */ {
 public:
  inline MAP() : MAP(nullptr) {}
  ~MAP() override;
  explicit PROTOBUF_CONSTEXPR MAP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MAP(const MAP& from);
  MAP(MAP&& from) noexcept
    : MAP() {
    *this = ::std::move(from);
  }

  inline MAP& operator=(const MAP& from) {
    CopyFrom(from);
    return *this;
  }
  inline MAP& operator=(MAP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MAP& default_instance() {
    return *internal_default_instance();
  }
  static inline const MAP* internal_default_instance() {
    return reinterpret_cast<const MAP*>(
               &_MAP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(MAP& a, MAP& b) {
    a.Swap(&b);
  }
  inline void Swap(MAP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MAP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MAP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MAP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MAP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MAP& from) {
    MAP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MAP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.MAP";
  }
  protected:
  explicit MAP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kMsgCntFieldNumber = 3,
  };
  // repeated .cn.seisys.v2x.pb.Node nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::cn::seisys::v2x::pb::Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Node >*
      mutable_nodes();
  private:
  const ::cn::seisys::v2x::pb::Node& _internal_nodes(int index) const;
  ::cn::seisys::v2x::pb::Node* _internal_add_nodes();
  public:
  const ::cn::seisys::v2x::pb::Node& nodes(int index) const;
  ::cn::seisys::v2x::pb::Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Node >&
      nodes() const;

  // uint32 timestamp = 1;
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // uint32 msgCnt = 3;
  void clear_msgcnt();
  uint32_t msgcnt() const;
  void set_msgcnt(uint32_t value);
  private:
  uint32_t _internal_msgcnt() const;
  void _internal_set_msgcnt(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.MAP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Node > nodes_;
    uint32_t timestamp_;
    uint32_t msgcnt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class MapData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.MapData) */ {
 public:
  inline MapData() : MapData(nullptr) {}
  ~MapData() override;
  explicit PROTOBUF_CONSTEXPR MapData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapData(const MapData& from);
  MapData(MapData&& from) noexcept
    : MapData() {
    *this = ::std::move(from);
  }

  inline MapData& operator=(const MapData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapData& operator=(MapData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapData* internal_default_instance() {
    return reinterpret_cast<const MapData*>(
               &_MapData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(MapData& a, MapData& b) {
    a.Swap(&b);
  }
  inline void Swap(MapData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapData& from) {
    MapData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.MapData";
  }
  protected:
  explicit MapData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapSliceFieldNumber = 1,
    kETagFieldNumber = 3,
    kSeqNumFieldNumber = 5,
    kMapFieldNumber = 2,
    kAckFieldNumber = 4,
  };
  // string mapSlice = 1;
  void clear_mapslice();
  const std::string& mapslice() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapslice(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapslice();
  PROTOBUF_NODISCARD std::string* release_mapslice();
  void set_allocated_mapslice(std::string* mapslice);
  private:
  const std::string& _internal_mapslice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapslice(const std::string& value);
  std::string* _internal_mutable_mapslice();
  public:

  // string eTag = 3;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // string seqNum = 5;
  void clear_seqnum();
  const std::string& seqnum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seqnum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seqnum();
  PROTOBUF_NODISCARD std::string* release_seqnum();
  void set_allocated_seqnum(std::string* seqnum);
  private:
  const std::string& _internal_seqnum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seqnum(const std::string& value);
  std::string* _internal_mutable_seqnum();
  public:

  // .cn.seisys.v2x.pb.MAP map = 2;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::cn::seisys::v2x::pb::MAP& map() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::MAP* release_map();
  ::cn::seisys::v2x::pb::MAP* mutable_map();
  void set_allocated_map(::cn::seisys::v2x::pb::MAP* map);
  private:
  const ::cn::seisys::v2x::pb::MAP& _internal_map() const;
  ::cn::seisys::v2x::pb::MAP* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::cn::seisys::v2x::pb::MAP* map);
  ::cn::seisys::v2x::pb::MAP* unsafe_arena_release_map();

  // bool ack = 4;
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.MapData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapslice_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seqnum_;
    ::cn::seisys::v2x::pb::MAP* map_;
    bool ack_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ReqLaneChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ReqLaneChange) */ {
 public:
  inline ReqLaneChange() : ReqLaneChange(nullptr) {}
  ~ReqLaneChange() override;
  explicit PROTOBUF_CONSTEXPR ReqLaneChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqLaneChange(const ReqLaneChange& from);
  ReqLaneChange(ReqLaneChange&& from) noexcept
    : ReqLaneChange() {
    *this = ::std::move(from);
  }

  inline ReqLaneChange& operator=(const ReqLaneChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqLaneChange& operator=(ReqLaneChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqLaneChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqLaneChange* internal_default_instance() {
    return reinterpret_cast<const ReqLaneChange*>(
               &_ReqLaneChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(ReqLaneChange& a, ReqLaneChange& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqLaneChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqLaneChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqLaneChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqLaneChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqLaneChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqLaneChange& from) {
    ReqLaneChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqLaneChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ReqLaneChange";
  }
  protected:
  explicit ReqLaneChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpStreamNodeFieldNumber = 1,
    kDownStreamNodeFieldNumber = 2,
    kTargetLaneFieldNumber = 3,
  };
  // .cn.seisys.v2x.pb.NodeReferenceId upStreamNode = 1;
  bool has_upstreamnode() const;
  private:
  bool _internal_has_upstreamnode() const;
  public:
  void clear_upstreamnode();
  const ::cn::seisys::v2x::pb::NodeReferenceId& upstreamnode() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_upstreamnode();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_upstreamnode();
  void set_allocated_upstreamnode(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_upstreamnode() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_upstreamnode();
  public:
  void unsafe_arena_set_allocated_upstreamnode(
      ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_upstreamnode();

  // .cn.seisys.v2x.pb.NodeReferenceId downStreamNode = 2;
  bool has_downstreamnode() const;
  private:
  bool _internal_has_downstreamnode() const;
  public:
  void clear_downstreamnode();
  const ::cn::seisys::v2x::pb::NodeReferenceId& downstreamnode() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_downstreamnode();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_downstreamnode();
  void set_allocated_downstreamnode(::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_downstreamnode() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_downstreamnode();
  public:
  void unsafe_arena_set_allocated_downstreamnode(
      ::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_downstreamnode();

  // uint32 targetLane = 3;
  void clear_targetlane();
  uint32_t targetlane() const;
  void set_targetlane(uint32_t value);
  private:
  uint32_t _internal_targetlane() const;
  void _internal_set_targetlane(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ReqLaneChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode_;
    ::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode_;
    uint32_t targetlane_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ReqClearTheWay final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ReqClearTheWay) */ {
 public:
  inline ReqClearTheWay() : ReqClearTheWay(nullptr) {}
  ~ReqClearTheWay() override;
  explicit PROTOBUF_CONSTEXPR ReqClearTheWay(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqClearTheWay(const ReqClearTheWay& from);
  ReqClearTheWay(ReqClearTheWay&& from) noexcept
    : ReqClearTheWay() {
    *this = ::std::move(from);
  }

  inline ReqClearTheWay& operator=(const ReqClearTheWay& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqClearTheWay& operator=(ReqClearTheWay&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqClearTheWay& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqClearTheWay* internal_default_instance() {
    return reinterpret_cast<const ReqClearTheWay*>(
               &_ReqClearTheWay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(ReqClearTheWay& a, ReqClearTheWay& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqClearTheWay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqClearTheWay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqClearTheWay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqClearTheWay>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqClearTheWay& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqClearTheWay& from) {
    ReqClearTheWay::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqClearTheWay* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ReqClearTheWay";
  }
  protected:
  explicit ReqClearTheWay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpStreamNodeFieldNumber = 1,
    kDownStreamNodeFieldNumber = 2,
    kTargetLaneFieldNumber = 3,
  };
  // .cn.seisys.v2x.pb.NodeReferenceId upStreamNode = 1;
  bool has_upstreamnode() const;
  private:
  bool _internal_has_upstreamnode() const;
  public:
  void clear_upstreamnode();
  const ::cn::seisys::v2x::pb::NodeReferenceId& upstreamnode() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_upstreamnode();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_upstreamnode();
  void set_allocated_upstreamnode(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_upstreamnode() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_upstreamnode();
  public:
  void unsafe_arena_set_allocated_upstreamnode(
      ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_upstreamnode();

  // .cn.seisys.v2x.pb.NodeReferenceId downStreamNode = 2;
  bool has_downstreamnode() const;
  private:
  bool _internal_has_downstreamnode() const;
  public:
  void clear_downstreamnode();
  const ::cn::seisys::v2x::pb::NodeReferenceId& downstreamnode() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_downstreamnode();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_downstreamnode();
  void set_allocated_downstreamnode(::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_downstreamnode() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_downstreamnode();
  public:
  void unsafe_arena_set_allocated_downstreamnode(
      ::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_downstreamnode();

  // uint32 targetLane = 3;
  void clear_targetlane();
  uint32_t targetlane() const;
  void set_targetlane(uint32_t value);
  private:
  uint32_t _internal_targetlane() const;
  void _internal_set_targetlane(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ReqClearTheWay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode_;
    ::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode_;
    uint32_t targetlane_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ReqSignalPriority final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ReqSignalPriority) */ {
 public:
  inline ReqSignalPriority() : ReqSignalPriority(nullptr) {}
  ~ReqSignalPriority() override;
  explicit PROTOBUF_CONSTEXPR ReqSignalPriority(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSignalPriority(const ReqSignalPriority& from);
  ReqSignalPriority(ReqSignalPriority&& from) noexcept
    : ReqSignalPriority() {
    *this = ::std::move(from);
  }

  inline ReqSignalPriority& operator=(const ReqSignalPriority& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSignalPriority& operator=(ReqSignalPriority&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSignalPriority& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSignalPriority* internal_default_instance() {
    return reinterpret_cast<const ReqSignalPriority*>(
               &_ReqSignalPriority_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(ReqSignalPriority& a, ReqSignalPriority& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSignalPriority* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSignalPriority* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSignalPriority* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSignalPriority>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSignalPriority& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqSignalPriority& from) {
    ReqSignalPriority::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSignalPriority* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ReqSignalPriority";
  }
  protected:
  explicit ReqSignalPriority(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntersectionIdFieldNumber = 1,
    kRequiredMoveFieldNumber = 2,
    kEstimatedArrivalTimeFieldNumber = 3,
    kDistance2IntersectionFieldNumber = 4,
  };
  // .cn.seisys.v2x.pb.NodeReferenceId intersectionId = 1;
  bool has_intersectionid() const;
  private:
  bool _internal_has_intersectionid() const;
  public:
  void clear_intersectionid();
  const ::cn::seisys::v2x::pb::NodeReferenceId& intersectionid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::NodeReferenceId* release_intersectionid();
  ::cn::seisys::v2x::pb::NodeReferenceId* mutable_intersectionid();
  void set_allocated_intersectionid(::cn::seisys::v2x::pb::NodeReferenceId* intersectionid);
  private:
  const ::cn::seisys::v2x::pb::NodeReferenceId& _internal_intersectionid() const;
  ::cn::seisys::v2x::pb::NodeReferenceId* _internal_mutable_intersectionid();
  public:
  void unsafe_arena_set_allocated_intersectionid(
      ::cn::seisys::v2x::pb::NodeReferenceId* intersectionid);
  ::cn::seisys::v2x::pb::NodeReferenceId* unsafe_arena_release_intersectionid();

  // .cn.seisys.v2x.pb.MovementStatInfo requiredMove = 2;
  bool has_requiredmove() const;
  private:
  bool _internal_has_requiredmove() const;
  public:
  void clear_requiredmove();
  const ::cn::seisys::v2x::pb::MovementStatInfo& requiredmove() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::MovementStatInfo* release_requiredmove();
  ::cn::seisys::v2x::pb::MovementStatInfo* mutable_requiredmove();
  void set_allocated_requiredmove(::cn::seisys::v2x::pb::MovementStatInfo* requiredmove);
  private:
  const ::cn::seisys::v2x::pb::MovementStatInfo& _internal_requiredmove() const;
  ::cn::seisys::v2x::pb::MovementStatInfo* _internal_mutable_requiredmove();
  public:
  void unsafe_arena_set_allocated_requiredmove(
      ::cn::seisys::v2x::pb::MovementStatInfo* requiredmove);
  ::cn::seisys::v2x::pb::MovementStatInfo* unsafe_arena_release_requiredmove();

  // uint32 estimatedArrivalTime = 3;
  void clear_estimatedarrivaltime();
  uint32_t estimatedarrivaltime() const;
  void set_estimatedarrivaltime(uint32_t value);
  private:
  uint32_t _internal_estimatedarrivaltime() const;
  void _internal_set_estimatedarrivaltime(uint32_t value);
  public:

  // uint32 distance2Intersection = 4;
  void clear_distance2intersection();
  uint32_t distance2intersection() const;
  void set_distance2intersection(uint32_t value);
  private:
  uint32_t _internal_distance2intersection() const;
  void _internal_set_distance2intersection(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ReqSignalPriority)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::NodeReferenceId* intersectionid_;
    ::cn::seisys::v2x::pb::MovementStatInfo* requiredmove_;
    uint32_t estimatedarrivaltime_;
    uint32_t distance2intersection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ReqSensorSharing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ReqSensorSharing) */ {
 public:
  inline ReqSensorSharing() : ReqSensorSharing(nullptr) {}
  ~ReqSensorSharing() override;
  explicit PROTOBUF_CONSTEXPR ReqSensorSharing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSensorSharing(const ReqSensorSharing& from);
  ReqSensorSharing(ReqSensorSharing&& from) noexcept
    : ReqSensorSharing() {
    *this = ::std::move(from);
  }

  inline ReqSensorSharing& operator=(const ReqSensorSharing& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSensorSharing& operator=(ReqSensorSharing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSensorSharing& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSensorSharing* internal_default_instance() {
    return reinterpret_cast<const ReqSensorSharing*>(
               &_ReqSensorSharing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(ReqSensorSharing& a, ReqSensorSharing& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSensorSharing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSensorSharing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSensorSharing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSensorSharing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSensorSharing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqSensorSharing& from) {
    ReqSensorSharing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSensorSharing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ReqSensorSharing";
  }
  protected:
  explicit ReqSensorSharing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectorAreaFieldNumber = 1,
  };
  // repeated .cn.seisys.v2x.pb.ReferencePath detectorArea = 1;
  int detectorarea_size() const;
  private:
  int _internal_detectorarea_size() const;
  public:
  void clear_detectorarea();
  ::cn::seisys::v2x::pb::ReferencePath* mutable_detectorarea(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >*
      mutable_detectorarea();
  private:
  const ::cn::seisys::v2x::pb::ReferencePath& _internal_detectorarea(int index) const;
  ::cn::seisys::v2x::pb::ReferencePath* _internal_add_detectorarea();
  public:
  const ::cn::seisys::v2x::pb::ReferencePath& detectorarea(int index) const;
  ::cn::seisys::v2x::pb::ReferencePath* add_detectorarea();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >&
      detectorarea() const;

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ReqSensorSharing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath > detectorarea_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ParkingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ParkingRequest) */ {
 public:
  inline ParkingRequest() : ParkingRequest(nullptr) {}
  ~ParkingRequest() override;
  explicit PROTOBUF_CONSTEXPR ParkingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParkingRequest(const ParkingRequest& from);
  ParkingRequest(ParkingRequest&& from) noexcept
    : ParkingRequest() {
    *this = ::std::move(from);
  }

  inline ParkingRequest& operator=(const ParkingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParkingRequest& operator=(ParkingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParkingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParkingRequest* internal_default_instance() {
    return reinterpret_cast<const ParkingRequest*>(
               &_ParkingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(ParkingRequest& a, ParkingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ParkingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParkingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParkingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParkingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParkingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParkingRequest& from) {
    ParkingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ParkingRequest";
  }
  protected:
  explicit ParkingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
  };
  // uint32 req = 1;
  void clear_req();
  uint32_t req() const;
  void set_req(uint32_t value);
  private:
  uint32_t _internal_req() const;
  void _internal_set_req(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ParkingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ParkingType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ParkingType) */ {
 public:
  inline ParkingType() : ParkingType(nullptr) {}
  ~ParkingType() override;
  explicit PROTOBUF_CONSTEXPR ParkingType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParkingType(const ParkingType& from);
  ParkingType(ParkingType&& from) noexcept
    : ParkingType() {
    *this = ::std::move(from);
  }

  inline ParkingType& operator=(const ParkingType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParkingType& operator=(ParkingType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParkingType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParkingType* internal_default_instance() {
    return reinterpret_cast<const ParkingType*>(
               &_ParkingType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(ParkingType& a, ParkingType& b) {
    a.Swap(&b);
  }
  inline void Swap(ParkingType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParkingType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParkingType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParkingType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParkingType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParkingType& from) {
    ParkingType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkingType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ParkingType";
  }
  protected:
  explicit ParkingType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParkingTypeFieldNumber = 1,
  };
  // uint32 parkingType = 1;
  void clear_parkingtype();
  uint32_t parkingtype() const;
  void set_parkingtype(uint32_t value);
  private:
  uint32_t _internal_parkingtype() const;
  void _internal_set_parkingtype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ParkingType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t parkingtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ReqParkingArea final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ReqParkingArea) */ {
 public:
  inline ReqParkingArea() : ReqParkingArea(nullptr) {}
  ~ReqParkingArea() override;
  explicit PROTOBUF_CONSTEXPR ReqParkingArea(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqParkingArea(const ReqParkingArea& from);
  ReqParkingArea(ReqParkingArea&& from) noexcept
    : ReqParkingArea() {
    *this = ::std::move(from);
  }

  inline ReqParkingArea& operator=(const ReqParkingArea& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqParkingArea& operator=(ReqParkingArea&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqParkingArea& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqParkingArea* internal_default_instance() {
    return reinterpret_cast<const ReqParkingArea*>(
               &_ReqParkingArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(ReqParkingArea& a, ReqParkingArea& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqParkingArea* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqParkingArea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqParkingArea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqParkingArea>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqParkingArea& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqParkingArea& from) {
    ReqParkingArea::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqParkingArea* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ReqParkingArea";
  }
  protected:
  explicit ReqParkingArea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 2,
    kParkingTypeFieldNumber = 3,
    kVehicleTypeFieldNumber = 1,
    kExpectedParkingSlotIdFieldNumber = 4,
  };
  // .cn.seisys.v2x.pb.ParkingRequest req = 2;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::cn::seisys::v2x::pb::ParkingRequest& req() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ParkingRequest* release_req();
  ::cn::seisys::v2x::pb::ParkingRequest* mutable_req();
  void set_allocated_req(::cn::seisys::v2x::pb::ParkingRequest* req);
  private:
  const ::cn::seisys::v2x::pb::ParkingRequest& _internal_req() const;
  ::cn::seisys::v2x::pb::ParkingRequest* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::cn::seisys::v2x::pb::ParkingRequest* req);
  ::cn::seisys::v2x::pb::ParkingRequest* unsafe_arena_release_req();

  // .cn.seisys.v2x.pb.ParkingType parkingType = 3;
  bool has_parkingtype() const;
  private:
  bool _internal_has_parkingtype() const;
  public:
  void clear_parkingtype();
  const ::cn::seisys::v2x::pb::ParkingType& parkingtype() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ParkingType* release_parkingtype();
  ::cn::seisys::v2x::pb::ParkingType* mutable_parkingtype();
  void set_allocated_parkingtype(::cn::seisys::v2x::pb::ParkingType* parkingtype);
  private:
  const ::cn::seisys::v2x::pb::ParkingType& _internal_parkingtype() const;
  ::cn::seisys::v2x::pb::ParkingType* _internal_mutable_parkingtype();
  public:
  void unsafe_arena_set_allocated_parkingtype(
      ::cn::seisys::v2x::pb::ParkingType* parkingtype);
  ::cn::seisys::v2x::pb::ParkingType* unsafe_arena_release_parkingtype();

  // .cn.seisys.v2x.pb.VehicleType vehicleType = 1;
  void clear_vehicletype();
  ::cn::seisys::v2x::pb::VehicleType vehicletype() const;
  void set_vehicletype(::cn::seisys::v2x::pb::VehicleType value);
  private:
  ::cn::seisys::v2x::pb::VehicleType _internal_vehicletype() const;
  void _internal_set_vehicletype(::cn::seisys::v2x::pb::VehicleType value);
  public:

  // uint32 expectedParkingSlotId = 4;
  void clear_expectedparkingslotid();
  uint32_t expectedparkingslotid() const;
  void set_expectedparkingslotid(uint32_t value);
  private:
  uint32_t _internal_expectedparkingslotid() const;
  void _internal_set_expectedparkingslotid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ReqParkingArea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::ParkingRequest* req_;
    ::cn::seisys::v2x::pb::ParkingType* parkingtype_;
    int vehicletype_;
    uint32_t expectedparkingslotid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class ReqInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.ReqInfo) */ {
 public:
  inline ReqInfo() : ReqInfo(nullptr) {}
  ~ReqInfo() override;
  explicit PROTOBUF_CONSTEXPR ReqInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqInfo(const ReqInfo& from);
  ReqInfo(ReqInfo&& from) noexcept
    : ReqInfo() {
    *this = ::std::move(from);
  }

  inline ReqInfo& operator=(const ReqInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqInfo& operator=(ReqInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqInfo& default_instance() {
    return *internal_default_instance();
  }
  enum ReqInfoOneOfCase {
    kLaneChange = 1,
    kClearTheWay = 2,
    kSignalPriority = 3,
    kSensorSharing = 4,
    kParking = 5,
    REQINFOONEOF_NOT_SET = 0,
  };

  static inline const ReqInfo* internal_default_instance() {
    return reinterpret_cast<const ReqInfo*>(
               &_ReqInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(ReqInfo& a, ReqInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqInfo& from) {
    ReqInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.ReqInfo";
  }
  protected:
  explicit ReqInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneChangeFieldNumber = 1,
    kClearTheWayFieldNumber = 2,
    kSignalPriorityFieldNumber = 3,
    kSensorSharingFieldNumber = 4,
    kParkingFieldNumber = 5,
  };
  // .cn.seisys.v2x.pb.ReqLaneChange laneChange = 1;
  bool has_lanechange() const;
  private:
  bool _internal_has_lanechange() const;
  public:
  void clear_lanechange();
  const ::cn::seisys::v2x::pb::ReqLaneChange& lanechange() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReqLaneChange* release_lanechange();
  ::cn::seisys::v2x::pb::ReqLaneChange* mutable_lanechange();
  void set_allocated_lanechange(::cn::seisys::v2x::pb::ReqLaneChange* lanechange);
  private:
  const ::cn::seisys::v2x::pb::ReqLaneChange& _internal_lanechange() const;
  ::cn::seisys::v2x::pb::ReqLaneChange* _internal_mutable_lanechange();
  public:
  void unsafe_arena_set_allocated_lanechange(
      ::cn::seisys::v2x::pb::ReqLaneChange* lanechange);
  ::cn::seisys::v2x::pb::ReqLaneChange* unsafe_arena_release_lanechange();

  // .cn.seisys.v2x.pb.ReqClearTheWay clearTheWay = 2;
  bool has_cleartheway() const;
  private:
  bool _internal_has_cleartheway() const;
  public:
  void clear_cleartheway();
  const ::cn::seisys::v2x::pb::ReqClearTheWay& cleartheway() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReqClearTheWay* release_cleartheway();
  ::cn::seisys::v2x::pb::ReqClearTheWay* mutable_cleartheway();
  void set_allocated_cleartheway(::cn::seisys::v2x::pb::ReqClearTheWay* cleartheway);
  private:
  const ::cn::seisys::v2x::pb::ReqClearTheWay& _internal_cleartheway() const;
  ::cn::seisys::v2x::pb::ReqClearTheWay* _internal_mutable_cleartheway();
  public:
  void unsafe_arena_set_allocated_cleartheway(
      ::cn::seisys::v2x::pb::ReqClearTheWay* cleartheway);
  ::cn::seisys::v2x::pb::ReqClearTheWay* unsafe_arena_release_cleartheway();

  // .cn.seisys.v2x.pb.ReqSignalPriority signalPriority = 3;
  bool has_signalpriority() const;
  private:
  bool _internal_has_signalpriority() const;
  public:
  void clear_signalpriority();
  const ::cn::seisys::v2x::pb::ReqSignalPriority& signalpriority() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReqSignalPriority* release_signalpriority();
  ::cn::seisys::v2x::pb::ReqSignalPriority* mutable_signalpriority();
  void set_allocated_signalpriority(::cn::seisys::v2x::pb::ReqSignalPriority* signalpriority);
  private:
  const ::cn::seisys::v2x::pb::ReqSignalPriority& _internal_signalpriority() const;
  ::cn::seisys::v2x::pb::ReqSignalPriority* _internal_mutable_signalpriority();
  public:
  void unsafe_arena_set_allocated_signalpriority(
      ::cn::seisys::v2x::pb::ReqSignalPriority* signalpriority);
  ::cn::seisys::v2x::pb::ReqSignalPriority* unsafe_arena_release_signalpriority();

  // .cn.seisys.v2x.pb.ReqSensorSharing sensorSharing = 4;
  bool has_sensorsharing() const;
  private:
  bool _internal_has_sensorsharing() const;
  public:
  void clear_sensorsharing();
  const ::cn::seisys::v2x::pb::ReqSensorSharing& sensorsharing() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReqSensorSharing* release_sensorsharing();
  ::cn::seisys::v2x::pb::ReqSensorSharing* mutable_sensorsharing();
  void set_allocated_sensorsharing(::cn::seisys::v2x::pb::ReqSensorSharing* sensorsharing);
  private:
  const ::cn::seisys::v2x::pb::ReqSensorSharing& _internal_sensorsharing() const;
  ::cn::seisys::v2x::pb::ReqSensorSharing* _internal_mutable_sensorsharing();
  public:
  void unsafe_arena_set_allocated_sensorsharing(
      ::cn::seisys::v2x::pb::ReqSensorSharing* sensorsharing);
  ::cn::seisys::v2x::pb::ReqSensorSharing* unsafe_arena_release_sensorsharing();

  // .cn.seisys.v2x.pb.ReqParkingArea parking = 5;
  bool has_parking() const;
  private:
  bool _internal_has_parking() const;
  public:
  void clear_parking();
  const ::cn::seisys::v2x::pb::ReqParkingArea& parking() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReqParkingArea* release_parking();
  ::cn::seisys::v2x::pb::ReqParkingArea* mutable_parking();
  void set_allocated_parking(::cn::seisys::v2x::pb::ReqParkingArea* parking);
  private:
  const ::cn::seisys::v2x::pb::ReqParkingArea& _internal_parking() const;
  ::cn::seisys::v2x::pb::ReqParkingArea* _internal_mutable_parking();
  public:
  void unsafe_arena_set_allocated_parking(
      ::cn::seisys::v2x::pb::ReqParkingArea* parking);
  ::cn::seisys::v2x::pb::ReqParkingArea* unsafe_arena_release_parking();

  void clear_ReqInfoOneOf();
  ReqInfoOneOfCase ReqInfoOneOf_case() const;
  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.ReqInfo)
 private:
  class _Internal;
  void set_has_lanechange();
  void set_has_cleartheway();
  void set_has_signalpriority();
  void set_has_sensorsharing();
  void set_has_parking();

  inline bool has_ReqInfoOneOf() const;
  inline void clear_has_ReqInfoOneOf();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ReqInfoOneOfUnion {
      constexpr ReqInfoOneOfUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::cn::seisys::v2x::pb::ReqLaneChange* lanechange_;
      ::cn::seisys::v2x::pb::ReqClearTheWay* cleartheway_;
      ::cn::seisys::v2x::pb::ReqSignalPriority* signalpriority_;
      ::cn::seisys::v2x::pb::ReqSensorSharing* sensorsharing_;
      ::cn::seisys::v2x::pb::ReqParkingArea* parking_;
    } ReqInfoOneOf_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class DriveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.DriveRequest) */ {
 public:
  inline DriveRequest() : DriveRequest(nullptr) {}
  ~DriveRequest() override;
  explicit PROTOBUF_CONSTEXPR DriveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriveRequest(const DriveRequest& from);
  DriveRequest(DriveRequest&& from) noexcept
    : DriveRequest() {
    *this = ::std::move(from);
  }

  inline DriveRequest& operator=(const DriveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriveRequest& operator=(DriveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DriveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DriveRequest* internal_default_instance() {
    return reinterpret_cast<const DriveRequest*>(
               &_DriveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(DriveRequest& a, DriveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DriveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DriveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DriveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DriveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DriveRequest& from) {
    DriveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DriveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.DriveRequest";
  }
  protected:
  explicit DriveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DriveRequest_ReqStatus ReqStatus;
  static constexpr ReqStatus UNKNOWN =
    DriveRequest_ReqStatus_UNKNOWN;
  static constexpr ReqStatus REQUEST =
    DriveRequest_ReqStatus_REQUEST;
  static constexpr ReqStatus COMFIRMED =
    DriveRequest_ReqStatus_COMFIRMED;
  static constexpr ReqStatus CANCEL =
    DriveRequest_ReqStatus_CANCEL;
  static constexpr ReqStatus COMPLETE =
    DriveRequest_ReqStatus_COMPLETE;
  static inline bool ReqStatus_IsValid(int value) {
    return DriveRequest_ReqStatus_IsValid(value);
  }
  static constexpr ReqStatus ReqStatus_MIN =
    DriveRequest_ReqStatus_ReqStatus_MIN;
  static constexpr ReqStatus ReqStatus_MAX =
    DriveRequest_ReqStatus_ReqStatus_MAX;
  static constexpr int ReqStatus_ARRAYSIZE =
    DriveRequest_ReqStatus_ReqStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ReqStatus_descriptor() {
    return DriveRequest_ReqStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ReqStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReqStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReqStatus_Name.");
    return DriveRequest_ReqStatus_Name(enum_t_value);
  }
  static inline bool ReqStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ReqStatus* value) {
    return DriveRequest_ReqStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReqPriorityFieldNumber = 3,
    kTargetVehFieldNumber = 4,
    kTargetRsuFieldNumber = 5,
    kInfoFieldNumber = 6,
    kReqIdFieldNumber = 1,
    kStatusFieldNumber = 2,
    kLifeTimeFieldNumber = 7,
  };
  // string reqPriority = 3;
  void clear_reqpriority();
  const std::string& reqpriority() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reqpriority(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reqpriority();
  PROTOBUF_NODISCARD std::string* release_reqpriority();
  void set_allocated_reqpriority(std::string* reqpriority);
  private:
  const std::string& _internal_reqpriority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reqpriority(const std::string& value);
  std::string* _internal_mutable_reqpriority();
  public:

  // string targetVeh = 4;
  void clear_targetveh();
  const std::string& targetveh() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetveh(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetveh();
  PROTOBUF_NODISCARD std::string* release_targetveh();
  void set_allocated_targetveh(std::string* targetveh);
  private:
  const std::string& _internal_targetveh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetveh(const std::string& value);
  std::string* _internal_mutable_targetveh();
  public:

  // string targetRsu = 5;
  void clear_targetrsu();
  const std::string& targetrsu() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetrsu(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetrsu();
  PROTOBUF_NODISCARD std::string* release_targetrsu();
  void set_allocated_targetrsu(std::string* targetrsu);
  private:
  const std::string& _internal_targetrsu() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetrsu(const std::string& value);
  std::string* _internal_mutable_targetrsu();
  public:

  // .cn.seisys.v2x.pb.ReqInfo info = 6;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::cn::seisys::v2x::pb::ReqInfo& info() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReqInfo* release_info();
  ::cn::seisys::v2x::pb::ReqInfo* mutable_info();
  void set_allocated_info(::cn::seisys::v2x::pb::ReqInfo* info);
  private:
  const ::cn::seisys::v2x::pb::ReqInfo& _internal_info() const;
  ::cn::seisys::v2x::pb::ReqInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::cn::seisys::v2x::pb::ReqInfo* info);
  ::cn::seisys::v2x::pb::ReqInfo* unsafe_arena_release_info();

  // uint32 reqId = 1;
  void clear_reqid();
  uint32_t reqid() const;
  void set_reqid(uint32_t value);
  private:
  uint32_t _internal_reqid() const;
  void _internal_set_reqid(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.DriveRequest.ReqStatus status = 2;
  void clear_status();
  ::cn::seisys::v2x::pb::DriveRequest_ReqStatus status() const;
  void set_status(::cn::seisys::v2x::pb::DriveRequest_ReqStatus value);
  private:
  ::cn::seisys::v2x::pb::DriveRequest_ReqStatus _internal_status() const;
  void _internal_set_status(::cn::seisys::v2x::pb::DriveRequest_ReqStatus value);
  public:

  // uint32 lifeTime = 7;
  void clear_lifetime();
  uint32_t lifetime() const;
  void set_lifetime(uint32_t value);
  private:
  uint32_t _internal_lifetime() const;
  void _internal_set_lifetime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.DriveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reqpriority_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetveh_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetrsu_;
    ::cn::seisys::v2x::pb::ReqInfo* info_;
    uint32_t reqid_;
    int status_;
    uint32_t lifetime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class DriveBehavior final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.DriveBehavior) */ {
 public:
  inline DriveBehavior() : DriveBehavior(nullptr) {}
  ~DriveBehavior() override;
  explicit PROTOBUF_CONSTEXPR DriveBehavior(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriveBehavior(const DriveBehavior& from);
  DriveBehavior(DriveBehavior&& from) noexcept
    : DriveBehavior() {
    *this = ::std::move(from);
  }

  inline DriveBehavior& operator=(const DriveBehavior& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriveBehavior& operator=(DriveBehavior&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DriveBehavior& default_instance() {
    return *internal_default_instance();
  }
  static inline const DriveBehavior* internal_default_instance() {
    return reinterpret_cast<const DriveBehavior*>(
               &_DriveBehavior_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(DriveBehavior& a, DriveBehavior& b) {
    a.Swap(&b);
  }
  inline void Swap(DriveBehavior* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriveBehavior* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DriveBehavior* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DriveBehavior>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DriveBehavior& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DriveBehavior& from) {
    DriveBehavior::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DriveBehavior* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.DriveBehavior";
  }
  protected:
  explicit DriveBehavior(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriveBehaviorFieldNumber = 1,
  };
  // int32 driveBehavior = 1;
  void clear_drivebehavior();
  int32_t drivebehavior() const;
  void set_drivebehavior(int32_t value);
  private:
  int32_t _internal_drivebehavior() const;
  void _internal_set_drivebehavior(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.DriveBehavior)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t drivebehavior_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class PathPlanningPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.PathPlanningPoint) */ {
 public:
  inline PathPlanningPoint() : PathPlanningPoint(nullptr) {}
  ~PathPlanningPoint() override;
  explicit PROTOBUF_CONSTEXPR PathPlanningPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathPlanningPoint(const PathPlanningPoint& from);
  PathPlanningPoint(PathPlanningPoint&& from) noexcept
    : PathPlanningPoint() {
    *this = ::std::move(from);
  }

  inline PathPlanningPoint& operator=(const PathPlanningPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathPlanningPoint& operator=(PathPlanningPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathPlanningPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathPlanningPoint* internal_default_instance() {
    return reinterpret_cast<const PathPlanningPoint*>(
               &_PathPlanningPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(PathPlanningPoint& a, PathPlanningPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(PathPlanningPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathPlanningPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathPlanningPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathPlanningPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathPlanningPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathPlanningPoint& from) {
    PathPlanningPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathPlanningPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.PathPlanningPoint";
  }
  protected:
  explicit PathPlanningPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kPosConfidFieldNumber = 2,
    kAccelerationFieldNumber = 7,
    kAccelerationConfidFieldNumber = 8,
    kPosInMapFieldNumber = 11,
    kSpeedFieldNumber = 3,
    kHeadingFieldNumber = 4,
    kSpeedConfidFieldNumber = 5,
    kHeadingConfidFieldNumber = 6,
    kEstimatedTimeFieldNumber = 9,
    kTimeConfidenceFieldNumber = 10,
  };
  // .cn.seisys.v2x.pb.Position3D pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::cn::seisys::v2x::pb::Position3D& pos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_pos();
  ::cn::seisys::v2x::pb::Position3D* mutable_pos();
  void set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_pos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::cn::seisys::v2x::pb::Position3D* pos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_pos();

  // .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 2;
  bool has_posconfid() const;
  private:
  bool _internal_has_posconfid() const;
  public:
  void clear_posconfid();
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& posconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PositionConfidenceSet* release_posconfid();
  ::cn::seisys::v2x::pb::PositionConfidenceSet* mutable_posconfid();
  void set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  private:
  const ::cn::seisys::v2x::pb::PositionConfidenceSet& _internal_posconfid() const;
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _internal_mutable_posconfid();
  public:
  void unsafe_arena_set_allocated_posconfid(
      ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid);
  ::cn::seisys::v2x::pb::PositionConfidenceSet* unsafe_arena_release_posconfid();

  // .cn.seisys.v2x.pb.AccelerationSet4Way acceleration = 7;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::cn::seisys::v2x::pb::AccelerationSet4Way& acceleration() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::AccelerationSet4Way* release_acceleration();
  ::cn::seisys::v2x::pb::AccelerationSet4Way* mutable_acceleration();
  void set_allocated_acceleration(::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration);
  private:
  const ::cn::seisys::v2x::pb::AccelerationSet4Way& _internal_acceleration() const;
  ::cn::seisys::v2x::pb::AccelerationSet4Way* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration);
  ::cn::seisys::v2x::pb::AccelerationSet4Way* unsafe_arena_release_acceleration();

  // .cn.seisys.v2x.pb.AccelerationConfidence accelerationConfid = 8;
  bool has_accelerationconfid() const;
  private:
  bool _internal_has_accelerationconfid() const;
  public:
  void clear_accelerationconfid();
  const ::cn::seisys::v2x::pb::AccelerationConfidence& accelerationconfid() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::AccelerationConfidence* release_accelerationconfid();
  ::cn::seisys::v2x::pb::AccelerationConfidence* mutable_accelerationconfid();
  void set_allocated_accelerationconfid(::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid);
  private:
  const ::cn::seisys::v2x::pb::AccelerationConfidence& _internal_accelerationconfid() const;
  ::cn::seisys::v2x::pb::AccelerationConfidence* _internal_mutable_accelerationconfid();
  public:
  void unsafe_arena_set_allocated_accelerationconfid(
      ::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid);
  ::cn::seisys::v2x::pb::AccelerationConfidence* unsafe_arena_release_accelerationconfid();

  // .cn.seisys.v2x.pb.ReferenceLink posInMap = 11;
  bool has_posinmap() const;
  private:
  bool _internal_has_posinmap() const;
  public:
  void clear_posinmap();
  const ::cn::seisys::v2x::pb::ReferenceLink& posinmap() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReferenceLink* release_posinmap();
  ::cn::seisys::v2x::pb::ReferenceLink* mutable_posinmap();
  void set_allocated_posinmap(::cn::seisys::v2x::pb::ReferenceLink* posinmap);
  private:
  const ::cn::seisys::v2x::pb::ReferenceLink& _internal_posinmap() const;
  ::cn::seisys::v2x::pb::ReferenceLink* _internal_mutable_posinmap();
  public:
  void unsafe_arena_set_allocated_posinmap(
      ::cn::seisys::v2x::pb::ReferenceLink* posinmap);
  ::cn::seisys::v2x::pb::ReferenceLink* unsafe_arena_release_posinmap();

  // uint32 speed = 3;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // uint32 heading = 4;
  void clear_heading();
  uint32_t heading() const;
  void set_heading(uint32_t value);
  private:
  uint32_t _internal_heading() const;
  void _internal_set_heading(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.SpeedConfidence speedConfid = 5;
  void clear_speedconfid();
  ::cn::seisys::v2x::pb::SpeedConfidence speedconfid() const;
  void set_speedconfid(::cn::seisys::v2x::pb::SpeedConfidence value);
  private:
  ::cn::seisys::v2x::pb::SpeedConfidence _internal_speedconfid() const;
  void _internal_set_speedconfid(::cn::seisys::v2x::pb::SpeedConfidence value);
  public:

  // .cn.seisys.v2x.pb.HeadingConfidence headingConfid = 6;
  void clear_headingconfid();
  ::cn::seisys::v2x::pb::HeadingConfidence headingconfid() const;
  void set_headingconfid(::cn::seisys::v2x::pb::HeadingConfidence value);
  private:
  ::cn::seisys::v2x::pb::HeadingConfidence _internal_headingconfid() const;
  void _internal_set_headingconfid(::cn::seisys::v2x::pb::HeadingConfidence value);
  public:

  // uint32 estimatedTime = 9;
  void clear_estimatedtime();
  uint32_t estimatedtime() const;
  void set_estimatedtime(uint32_t value);
  private:
  uint32_t _internal_estimatedtime() const;
  void _internal_set_estimatedtime(uint32_t value);
  public:

  // .cn.seisys.v2x.pb.TimeConfidence timeConfidence = 10;
  void clear_timeconfidence();
  ::cn::seisys::v2x::pb::TimeConfidence timeconfidence() const;
  void set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  private:
  ::cn::seisys::v2x::pb::TimeConfidence _internal_timeconfidence() const;
  void _internal_set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.PathPlanningPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::Position3D* pos_;
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid_;
    ::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration_;
    ::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid_;
    ::cn::seisys::v2x::pb::ReferenceLink* posinmap_;
    uint32_t speed_;
    uint32_t heading_;
    int speedconfid_;
    int headingconfid_;
    uint32_t estimatedtime_;
    int timeconfidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class PathPlanning final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.PathPlanning) */ {
 public:
  inline PathPlanning() : PathPlanning(nullptr) {}
  ~PathPlanning() override;
  explicit PROTOBUF_CONSTEXPR PathPlanning(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathPlanning(const PathPlanning& from);
  PathPlanning(PathPlanning&& from) noexcept
    : PathPlanning() {
    *this = ::std::move(from);
  }

  inline PathPlanning& operator=(const PathPlanning& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathPlanning& operator=(PathPlanning&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathPlanning& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathPlanning* internal_default_instance() {
    return reinterpret_cast<const PathPlanning*>(
               &_PathPlanning_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(PathPlanning& a, PathPlanning& b) {
    a.Swap(&b);
  }
  inline void Swap(PathPlanning* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathPlanning* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathPlanning* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathPlanning>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathPlanning& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathPlanning& from) {
    PathPlanning::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathPlanning* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.PathPlanning";
  }
  protected:
  explicit PathPlanning(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathPlanningFieldNumber = 1,
  };
  // repeated .cn.seisys.v2x.pb.PathPlanningPoint pathPlanning = 1;
  int pathplanning_size() const;
  private:
  int _internal_pathplanning_size() const;
  public:
  void clear_pathplanning();
  ::cn::seisys::v2x::pb::PathPlanningPoint* mutable_pathplanning(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathPlanningPoint >*
      mutable_pathplanning();
  private:
  const ::cn::seisys::v2x::pb::PathPlanningPoint& _internal_pathplanning(int index) const;
  ::cn::seisys::v2x::pb::PathPlanningPoint* _internal_add_pathplanning();
  public:
  const ::cn::seisys::v2x::pb::PathPlanningPoint& pathplanning(int index) const;
  ::cn::seisys::v2x::pb::PathPlanningPoint* add_pathplanning();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathPlanningPoint >&
      pathplanning() const;

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.PathPlanning)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathPlanningPoint > pathplanning_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class IarData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.IarData) */ {
 public:
  inline IarData() : IarData(nullptr) {}
  ~IarData() override;
  explicit PROTOBUF_CONSTEXPR IarData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IarData(const IarData& from);
  IarData(IarData&& from) noexcept
    : IarData() {
    *this = ::std::move(from);
  }

  inline IarData& operator=(const IarData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IarData& operator=(IarData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IarData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IarData* internal_default_instance() {
    return reinterpret_cast<const IarData*>(
               &_IarData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(IarData& a, IarData& b) {
    a.Swap(&b);
  }
  inline void Swap(IarData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IarData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IarData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IarData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IarData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IarData& from) {
    IarData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IarData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.IarData";
  }
  protected:
  explicit IarData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqsFieldNumber = 4,
    kCurrentPosFieldNumber = 1,
    kPathPlanningFieldNumber = 2,
    kCurrentBehaviorFieldNumber = 3,
  };
  // repeated .cn.seisys.v2x.pb.DriveRequest reqs = 4;
  int reqs_size() const;
  private:
  int _internal_reqs_size() const;
  public:
  void clear_reqs();
  ::cn::seisys::v2x::pb::DriveRequest* mutable_reqs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::DriveRequest >*
      mutable_reqs();
  private:
  const ::cn::seisys::v2x::pb::DriveRequest& _internal_reqs(int index) const;
  ::cn::seisys::v2x::pb::DriveRequest* _internal_add_reqs();
  public:
  const ::cn::seisys::v2x::pb::DriveRequest& reqs(int index) const;
  ::cn::seisys::v2x::pb::DriveRequest* add_reqs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::DriveRequest >&
      reqs() const;

  // .cn.seisys.v2x.pb.PathPlanningPoint currentPos = 1;
  bool has_currentpos() const;
  private:
  bool _internal_has_currentpos() const;
  public:
  void clear_currentpos();
  const ::cn::seisys::v2x::pb::PathPlanningPoint& currentpos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PathPlanningPoint* release_currentpos();
  ::cn::seisys::v2x::pb::PathPlanningPoint* mutable_currentpos();
  void set_allocated_currentpos(::cn::seisys::v2x::pb::PathPlanningPoint* currentpos);
  private:
  const ::cn::seisys::v2x::pb::PathPlanningPoint& _internal_currentpos() const;
  ::cn::seisys::v2x::pb::PathPlanningPoint* _internal_mutable_currentpos();
  public:
  void unsafe_arena_set_allocated_currentpos(
      ::cn::seisys::v2x::pb::PathPlanningPoint* currentpos);
  ::cn::seisys::v2x::pb::PathPlanningPoint* unsafe_arena_release_currentpos();

  // .cn.seisys.v2x.pb.PathPlanning pathPlanning = 2;
  bool has_pathplanning() const;
  private:
  bool _internal_has_pathplanning() const;
  public:
  void clear_pathplanning();
  const ::cn::seisys::v2x::pb::PathPlanning& pathplanning() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PathPlanning* release_pathplanning();
  ::cn::seisys::v2x::pb::PathPlanning* mutable_pathplanning();
  void set_allocated_pathplanning(::cn::seisys::v2x::pb::PathPlanning* pathplanning);
  private:
  const ::cn::seisys::v2x::pb::PathPlanning& _internal_pathplanning() const;
  ::cn::seisys::v2x::pb::PathPlanning* _internal_mutable_pathplanning();
  public:
  void unsafe_arena_set_allocated_pathplanning(
      ::cn::seisys::v2x::pb::PathPlanning* pathplanning);
  ::cn::seisys::v2x::pb::PathPlanning* unsafe_arena_release_pathplanning();

  // .cn.seisys.v2x.pb.DriveBehavior currentBehavior = 3;
  bool has_currentbehavior() const;
  private:
  bool _internal_has_currentbehavior() const;
  public:
  void clear_currentbehavior();
  const ::cn::seisys::v2x::pb::DriveBehavior& currentbehavior() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::DriveBehavior* release_currentbehavior();
  ::cn::seisys::v2x::pb::DriveBehavior* mutable_currentbehavior();
  void set_allocated_currentbehavior(::cn::seisys::v2x::pb::DriveBehavior* currentbehavior);
  private:
  const ::cn::seisys::v2x::pb::DriveBehavior& _internal_currentbehavior() const;
  ::cn::seisys::v2x::pb::DriveBehavior* _internal_mutable_currentbehavior();
  public:
  void unsafe_arena_set_allocated_currentbehavior(
      ::cn::seisys::v2x::pb::DriveBehavior* currentbehavior);
  ::cn::seisys::v2x::pb::DriveBehavior* unsafe_arena_release_currentbehavior();

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.IarData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::DriveRequest > reqs_;
    ::cn::seisys::v2x::pb::PathPlanningPoint* currentpos_;
    ::cn::seisys::v2x::pb::PathPlanning* pathplanning_;
    ::cn::seisys::v2x::pb::DriveBehavior* currentbehavior_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class VirData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.VirData) */ {
 public:
  inline VirData() : VirData(nullptr) {}
  ~VirData() override;
  explicit PROTOBUF_CONSTEXPR VirData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirData(const VirData& from);
  VirData(VirData&& from) noexcept
    : VirData() {
    *this = ::std::move(from);
  }

  inline VirData& operator=(const VirData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirData& operator=(VirData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirData* internal_default_instance() {
    return reinterpret_cast<const VirData*>(
               &_VirData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(VirData& a, VirData& b) {
    a.Swap(&b);
  }
  inline void Swap(VirData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VirData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VirData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VirData& from) {
    VirData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.VirData";
  }
  protected:
  explicit VirData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehicleIdFieldNumber = 2,
    kPosFieldNumber = 4,
    kIntAndReqFieldNumber = 5,
    kTimestampFieldNumber = 3,
    kMsgCntFieldNumber = 1,
  };
  // string vehicleId = 2;
  void clear_vehicleid();
  const std::string& vehicleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vehicleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vehicleid();
  PROTOBUF_NODISCARD std::string* release_vehicleid();
  void set_allocated_vehicleid(std::string* vehicleid);
  private:
  const std::string& _internal_vehicleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehicleid(const std::string& value);
  std::string* _internal_mutable_vehicleid();
  public:

  // .cn.seisys.v2x.pb.Position3D pos = 4;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::cn::seisys::v2x::pb::Position3D& pos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_pos();
  ::cn::seisys::v2x::pb::Position3D* mutable_pos();
  void set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_pos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::cn::seisys::v2x::pb::Position3D* pos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_pos();

  // .cn.seisys.v2x.pb.IarData intAndReq = 5;
  bool has_intandreq() const;
  private:
  bool _internal_has_intandreq() const;
  public:
  void clear_intandreq();
  const ::cn::seisys::v2x::pb::IarData& intandreq() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::IarData* release_intandreq();
  ::cn::seisys::v2x::pb::IarData* mutable_intandreq();
  void set_allocated_intandreq(::cn::seisys::v2x::pb::IarData* intandreq);
  private:
  const ::cn::seisys::v2x::pb::IarData& _internal_intandreq() const;
  ::cn::seisys::v2x::pb::IarData* _internal_mutable_intandreq();
  public:
  void unsafe_arena_set_allocated_intandreq(
      ::cn::seisys::v2x::pb::IarData* intandreq);
  ::cn::seisys::v2x::pb::IarData* unsafe_arena_release_intandreq();

  // uint64 timestamp = 3;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 msgCnt = 1;
  void clear_msgcnt();
  uint32_t msgcnt() const;
  void set_msgcnt(uint32_t value);
  private:
  uint32_t _internal_msgcnt() const;
  void _internal_set_msgcnt(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.VirData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehicleid_;
    ::cn::seisys::v2x::pb::Position3D* pos_;
    ::cn::seisys::v2x::pb::IarData* intandreq_;
    uint64_t timestamp_;
    uint32_t msgcnt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class DriveSuggestion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.DriveSuggestion) */ {
 public:
  inline DriveSuggestion() : DriveSuggestion(nullptr) {}
  ~DriveSuggestion() override;
  explicit PROTOBUF_CONSTEXPR DriveSuggestion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriveSuggestion(const DriveSuggestion& from);
  DriveSuggestion(DriveSuggestion&& from) noexcept
    : DriveSuggestion() {
    *this = ::std::move(from);
  }

  inline DriveSuggestion& operator=(const DriveSuggestion& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriveSuggestion& operator=(DriveSuggestion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DriveSuggestion& default_instance() {
    return *internal_default_instance();
  }
  static inline const DriveSuggestion* internal_default_instance() {
    return reinterpret_cast<const DriveSuggestion*>(
               &_DriveSuggestion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(DriveSuggestion& a, DriveSuggestion& b) {
    a.Swap(&b);
  }
  inline void Swap(DriveSuggestion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriveSuggestion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DriveSuggestion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DriveSuggestion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DriveSuggestion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DriveSuggestion& from) {
    DriveSuggestion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DriveSuggestion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.DriveSuggestion";
  }
  protected:
  explicit DriveSuggestion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuggestionFieldNumber = 1,
    kRelatedLinkFieldNumber = 3,
    kRelatedPathFieldNumber = 4,
    kTimeOffsetFieldNumber = 2,
  };
  // .cn.seisys.v2x.pb.DriveBehavior suggestion = 1;
  bool has_suggestion() const;
  private:
  bool _internal_has_suggestion() const;
  public:
  void clear_suggestion();
  const ::cn::seisys::v2x::pb::DriveBehavior& suggestion() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::DriveBehavior* release_suggestion();
  ::cn::seisys::v2x::pb::DriveBehavior* mutable_suggestion();
  void set_allocated_suggestion(::cn::seisys::v2x::pb::DriveBehavior* suggestion);
  private:
  const ::cn::seisys::v2x::pb::DriveBehavior& _internal_suggestion() const;
  ::cn::seisys::v2x::pb::DriveBehavior* _internal_mutable_suggestion();
  public:
  void unsafe_arena_set_allocated_suggestion(
      ::cn::seisys::v2x::pb::DriveBehavior* suggestion);
  ::cn::seisys::v2x::pb::DriveBehavior* unsafe_arena_release_suggestion();

  // .cn.seisys.v2x.pb.ReferenceLink relatedLink = 3;
  bool has_relatedlink() const;
  private:
  bool _internal_has_relatedlink() const;
  public:
  void clear_relatedlink();
  const ::cn::seisys::v2x::pb::ReferenceLink& relatedlink() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReferenceLink* release_relatedlink();
  ::cn::seisys::v2x::pb::ReferenceLink* mutable_relatedlink();
  void set_allocated_relatedlink(::cn::seisys::v2x::pb::ReferenceLink* relatedlink);
  private:
  const ::cn::seisys::v2x::pb::ReferenceLink& _internal_relatedlink() const;
  ::cn::seisys::v2x::pb::ReferenceLink* _internal_mutable_relatedlink();
  public:
  void unsafe_arena_set_allocated_relatedlink(
      ::cn::seisys::v2x::pb::ReferenceLink* relatedlink);
  ::cn::seisys::v2x::pb::ReferenceLink* unsafe_arena_release_relatedlink();

  // .cn.seisys.v2x.pb.ReferencePath relatedPath = 4;
  bool has_relatedpath() const;
  private:
  bool _internal_has_relatedpath() const;
  public:
  void clear_relatedpath();
  const ::cn::seisys::v2x::pb::ReferencePath& relatedpath() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReferencePath* release_relatedpath();
  ::cn::seisys::v2x::pb::ReferencePath* mutable_relatedpath();
  void set_allocated_relatedpath(::cn::seisys::v2x::pb::ReferencePath* relatedpath);
  private:
  const ::cn::seisys::v2x::pb::ReferencePath& _internal_relatedpath() const;
  ::cn::seisys::v2x::pb::ReferencePath* _internal_mutable_relatedpath();
  public:
  void unsafe_arena_set_allocated_relatedpath(
      ::cn::seisys::v2x::pb::ReferencePath* relatedpath);
  ::cn::seisys::v2x::pb::ReferencePath* unsafe_arena_release_relatedpath();

  // uint32 timeOffset = 2;
  void clear_timeoffset();
  uint32_t timeoffset() const;
  void set_timeoffset(uint32_t value);
  private:
  uint32_t _internal_timeoffset() const;
  void _internal_set_timeoffset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.DriveSuggestion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::cn::seisys::v2x::pb::DriveBehavior* suggestion_;
    ::cn::seisys::v2x::pb::ReferenceLink* relatedlink_;
    ::cn::seisys::v2x::pb::ReferencePath* relatedpath_;
    uint32_t timeoffset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class CoordinationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.CoordinationInfo) */ {
 public:
  inline CoordinationInfo() : CoordinationInfo(nullptr) {}
  ~CoordinationInfo() override;
  explicit PROTOBUF_CONSTEXPR CoordinationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoordinationInfo(const CoordinationInfo& from);
  CoordinationInfo(CoordinationInfo&& from) noexcept
    : CoordinationInfo() {
    *this = ::std::move(from);
  }

  inline CoordinationInfo& operator=(const CoordinationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinationInfo& operator=(CoordinationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoordinationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoordinationInfo* internal_default_instance() {
    return reinterpret_cast<const CoordinationInfo*>(
               &_CoordinationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(CoordinationInfo& a, CoordinationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordinationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoordinationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoordinationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoordinationInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoordinationInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CoordinationInfo& from) {
    CoordinationInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.CoordinationInfo";
  }
  protected:
  explicit CoordinationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordinationInfoFieldNumber = 1,
  };
  // int32 coordinationInfo = 1;
  void clear_coordinationinfo();
  int32_t coordinationinfo() const;
  void set_coordinationinfo(int32_t value);
  private:
  int32_t _internal_coordinationinfo() const;
  void _internal_set_coordinationinfo(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.CoordinationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t coordinationinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class VehicleCoordination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.VehicleCoordination) */ {
 public:
  inline VehicleCoordination() : VehicleCoordination(nullptr) {}
  ~VehicleCoordination() override;
  explicit PROTOBUF_CONSTEXPR VehicleCoordination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehicleCoordination(const VehicleCoordination& from);
  VehicleCoordination(VehicleCoordination&& from) noexcept
    : VehicleCoordination() {
    *this = ::std::move(from);
  }

  inline VehicleCoordination& operator=(const VehicleCoordination& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleCoordination& operator=(VehicleCoordination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleCoordination& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleCoordination* internal_default_instance() {
    return reinterpret_cast<const VehicleCoordination*>(
               &_VehicleCoordination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(VehicleCoordination& a, VehicleCoordination& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleCoordination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleCoordination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleCoordination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehicleCoordination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehicleCoordination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VehicleCoordination& from) {
    VehicleCoordination::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleCoordination* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.VehicleCoordination";
  }
  protected:
  explicit VehicleCoordination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehIdFieldNumber = 1,
    kDriveSuggestionFieldNumber = 2,
    kPathGuidanceFieldNumber = 3,
    kInfoFieldNumber = 4,
  };
  // string vehId = 1;
  void clear_vehid();
  const std::string& vehid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vehid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vehid();
  PROTOBUF_NODISCARD std::string* release_vehid();
  void set_allocated_vehid(std::string* vehid);
  private:
  const std::string& _internal_vehid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vehid(const std::string& value);
  std::string* _internal_mutable_vehid();
  public:

  // .cn.seisys.v2x.pb.DriveSuggestion driveSuggestion = 2;
  bool has_drivesuggestion() const;
  private:
  bool _internal_has_drivesuggestion() const;
  public:
  void clear_drivesuggestion();
  const ::cn::seisys::v2x::pb::DriveSuggestion& drivesuggestion() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::DriveSuggestion* release_drivesuggestion();
  ::cn::seisys::v2x::pb::DriveSuggestion* mutable_drivesuggestion();
  void set_allocated_drivesuggestion(::cn::seisys::v2x::pb::DriveSuggestion* drivesuggestion);
  private:
  const ::cn::seisys::v2x::pb::DriveSuggestion& _internal_drivesuggestion() const;
  ::cn::seisys::v2x::pb::DriveSuggestion* _internal_mutable_drivesuggestion();
  public:
  void unsafe_arena_set_allocated_drivesuggestion(
      ::cn::seisys::v2x::pb::DriveSuggestion* drivesuggestion);
  ::cn::seisys::v2x::pb::DriveSuggestion* unsafe_arena_release_drivesuggestion();

  // .cn.seisys.v2x.pb.PathPlanning pathGuidance = 3;
  bool has_pathguidance() const;
  private:
  bool _internal_has_pathguidance() const;
  public:
  void clear_pathguidance();
  const ::cn::seisys::v2x::pb::PathPlanning& pathguidance() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::PathPlanning* release_pathguidance();
  ::cn::seisys::v2x::pb::PathPlanning* mutable_pathguidance();
  void set_allocated_pathguidance(::cn::seisys::v2x::pb::PathPlanning* pathguidance);
  private:
  const ::cn::seisys::v2x::pb::PathPlanning& _internal_pathguidance() const;
  ::cn::seisys::v2x::pb::PathPlanning* _internal_mutable_pathguidance();
  public:
  void unsafe_arena_set_allocated_pathguidance(
      ::cn::seisys::v2x::pb::PathPlanning* pathguidance);
  ::cn::seisys::v2x::pb::PathPlanning* unsafe_arena_release_pathguidance();

  // .cn.seisys.v2x.pb.CoordinationInfo info = 4;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::cn::seisys::v2x::pb::CoordinationInfo& info() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::CoordinationInfo* release_info();
  ::cn::seisys::v2x::pb::CoordinationInfo* mutable_info();
  void set_allocated_info(::cn::seisys::v2x::pb::CoordinationInfo* info);
  private:
  const ::cn::seisys::v2x::pb::CoordinationInfo& _internal_info() const;
  ::cn::seisys::v2x::pb::CoordinationInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::cn::seisys::v2x::pb::CoordinationInfo* info);
  ::cn::seisys::v2x::pb::CoordinationInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.VehicleCoordination)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vehid_;
    ::cn::seisys::v2x::pb::DriveSuggestion* drivesuggestion_;
    ::cn::seisys::v2x::pb::PathPlanning* pathguidance_;
    ::cn::seisys::v2x::pb::CoordinationInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class LaneCoordination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.LaneCoordination) */ {
 public:
  inline LaneCoordination() : LaneCoordination(nullptr) {}
  ~LaneCoordination() override;
  explicit PROTOBUF_CONSTEXPR LaneCoordination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaneCoordination(const LaneCoordination& from);
  LaneCoordination(LaneCoordination&& from) noexcept
    : LaneCoordination() {
    *this = ::std::move(from);
  }

  inline LaneCoordination& operator=(const LaneCoordination& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneCoordination& operator=(LaneCoordination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneCoordination& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneCoordination* internal_default_instance() {
    return reinterpret_cast<const LaneCoordination*>(
               &_LaneCoordination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(LaneCoordination& a, LaneCoordination& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneCoordination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneCoordination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneCoordination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneCoordination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaneCoordination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaneCoordination& from) {
    LaneCoordination::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneCoordination* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.LaneCoordination";
  }
  protected:
  explicit LaneCoordination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 8,
    kTargetLaneFieldNumber = 1,
    kRelatedPathFieldNumber = 2,
    kRecommendedBehaviorFieldNumber = 6,
    kInfoFieldNumber = 7,
    kTBeginFieldNumber = 3,
    kTEndFieldNumber = 4,
    kRecommendedSpeedFieldNumber = 5,
  };
  // string description = 8;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .cn.seisys.v2x.pb.ReferenceLink targetLane = 1;
  bool has_targetlane() const;
  private:
  bool _internal_has_targetlane() const;
  public:
  void clear_targetlane();
  const ::cn::seisys::v2x::pb::ReferenceLink& targetlane() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReferenceLink* release_targetlane();
  ::cn::seisys::v2x::pb::ReferenceLink* mutable_targetlane();
  void set_allocated_targetlane(::cn::seisys::v2x::pb::ReferenceLink* targetlane);
  private:
  const ::cn::seisys::v2x::pb::ReferenceLink& _internal_targetlane() const;
  ::cn::seisys::v2x::pb::ReferenceLink* _internal_mutable_targetlane();
  public:
  void unsafe_arena_set_allocated_targetlane(
      ::cn::seisys::v2x::pb::ReferenceLink* targetlane);
  ::cn::seisys::v2x::pb::ReferenceLink* unsafe_arena_release_targetlane();

  // .cn.seisys.v2x.pb.ReferencePath relatedPath = 2;
  bool has_relatedpath() const;
  private:
  bool _internal_has_relatedpath() const;
  public:
  void clear_relatedpath();
  const ::cn::seisys::v2x::pb::ReferencePath& relatedpath() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::ReferencePath* release_relatedpath();
  ::cn::seisys::v2x::pb::ReferencePath* mutable_relatedpath();
  void set_allocated_relatedpath(::cn::seisys::v2x::pb::ReferencePath* relatedpath);
  private:
  const ::cn::seisys::v2x::pb::ReferencePath& _internal_relatedpath() const;
  ::cn::seisys::v2x::pb::ReferencePath* _internal_mutable_relatedpath();
  public:
  void unsafe_arena_set_allocated_relatedpath(
      ::cn::seisys::v2x::pb::ReferencePath* relatedpath);
  ::cn::seisys::v2x::pb::ReferencePath* unsafe_arena_release_relatedpath();

  // .cn.seisys.v2x.pb.DriveBehavior recommendedBehavior = 6;
  bool has_recommendedbehavior() const;
  private:
  bool _internal_has_recommendedbehavior() const;
  public:
  void clear_recommendedbehavior();
  const ::cn::seisys::v2x::pb::DriveBehavior& recommendedbehavior() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::DriveBehavior* release_recommendedbehavior();
  ::cn::seisys::v2x::pb::DriveBehavior* mutable_recommendedbehavior();
  void set_allocated_recommendedbehavior(::cn::seisys::v2x::pb::DriveBehavior* recommendedbehavior);
  private:
  const ::cn::seisys::v2x::pb::DriveBehavior& _internal_recommendedbehavior() const;
  ::cn::seisys::v2x::pb::DriveBehavior* _internal_mutable_recommendedbehavior();
  public:
  void unsafe_arena_set_allocated_recommendedbehavior(
      ::cn::seisys::v2x::pb::DriveBehavior* recommendedbehavior);
  ::cn::seisys::v2x::pb::DriveBehavior* unsafe_arena_release_recommendedbehavior();

  // .cn.seisys.v2x.pb.CoordinationInfo info = 7;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::cn::seisys::v2x::pb::CoordinationInfo& info() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::CoordinationInfo* release_info();
  ::cn::seisys::v2x::pb::CoordinationInfo* mutable_info();
  void set_allocated_info(::cn::seisys::v2x::pb::CoordinationInfo* info);
  private:
  const ::cn::seisys::v2x::pb::CoordinationInfo& _internal_info() const;
  ::cn::seisys::v2x::pb::CoordinationInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::cn::seisys::v2x::pb::CoordinationInfo* info);
  ::cn::seisys::v2x::pb::CoordinationInfo* unsafe_arena_release_info();

  // uint64 tBegin = 3;
  void clear_tbegin();
  uint64_t tbegin() const;
  void set_tbegin(uint64_t value);
  private:
  uint64_t _internal_tbegin() const;
  void _internal_set_tbegin(uint64_t value);
  public:

  // uint64 tEnd = 4;
  void clear_tend();
  uint64_t tend() const;
  void set_tend(uint64_t value);
  private:
  uint64_t _internal_tend() const;
  void _internal_set_tend(uint64_t value);
  public:

  // uint32 recommendedSpeed = 5;
  void clear_recommendedspeed();
  uint32_t recommendedspeed() const;
  void set_recommendedspeed(uint32_t value);
  private:
  uint32_t _internal_recommendedspeed() const;
  void _internal_set_recommendedspeed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.LaneCoordination)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::cn::seisys::v2x::pb::ReferenceLink* targetlane_;
    ::cn::seisys::v2x::pb::ReferencePath* relatedpath_;
    ::cn::seisys::v2x::pb::DriveBehavior* recommendedbehavior_;
    ::cn::seisys::v2x::pb::CoordinationInfo* info_;
    uint64_t tbegin_;
    uint64_t tend_;
    uint32_t recommendedspeed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class RscData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.RscData) */ {
 public:
  inline RscData() : RscData(nullptr) {}
  ~RscData() override;
  explicit PROTOBUF_CONSTEXPR RscData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RscData(const RscData& from);
  RscData(RscData&& from) noexcept
    : RscData() {
    *this = ::std::move(from);
  }

  inline RscData& operator=(const RscData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RscData& operator=(RscData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RscData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RscData* internal_default_instance() {
    return reinterpret_cast<const RscData*>(
               &_RscData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(RscData& a, RscData& b) {
    a.Swap(&b);
  }
  inline void Swap(RscData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RscData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RscData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RscData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RscData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RscData& from) {
    RscData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RscData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.RscData";
  }
  protected:
  explicit RscData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRsuIdFieldNumber = 2,
    kPosFieldNumber = 4,
    kCoordinatesFieldNumber = 5,
    kLaneCoordinatesFieldNumber = 6,
    kTimestampFieldNumber = 3,
    kMsgCntFieldNumber = 1,
  };
  // string rsuId = 2;
  void clear_rsuid();
  const std::string& rsuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rsuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rsuid();
  PROTOBUF_NODISCARD std::string* release_rsuid();
  void set_allocated_rsuid(std::string* rsuid);
  private:
  const std::string& _internal_rsuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rsuid(const std::string& value);
  std::string* _internal_mutable_rsuid();
  public:

  // .cn.seisys.v2x.pb.Position3D pos = 4;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::cn::seisys::v2x::pb::Position3D& pos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_pos();
  ::cn::seisys::v2x::pb::Position3D* mutable_pos();
  void set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_pos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::cn::seisys::v2x::pb::Position3D* pos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_pos();

  // .cn.seisys.v2x.pb.VehicleCoordination coordinates = 5;
  bool has_coordinates() const;
  private:
  bool _internal_has_coordinates() const;
  public:
  void clear_coordinates();
  const ::cn::seisys::v2x::pb::VehicleCoordination& coordinates() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::VehicleCoordination* release_coordinates();
  ::cn::seisys::v2x::pb::VehicleCoordination* mutable_coordinates();
  void set_allocated_coordinates(::cn::seisys::v2x::pb::VehicleCoordination* coordinates);
  private:
  const ::cn::seisys::v2x::pb::VehicleCoordination& _internal_coordinates() const;
  ::cn::seisys::v2x::pb::VehicleCoordination* _internal_mutable_coordinates();
  public:
  void unsafe_arena_set_allocated_coordinates(
      ::cn::seisys::v2x::pb::VehicleCoordination* coordinates);
  ::cn::seisys::v2x::pb::VehicleCoordination* unsafe_arena_release_coordinates();

  // .cn.seisys.v2x.pb.LaneCoordination laneCoordinates = 6;
  bool has_lanecoordinates() const;
  private:
  bool _internal_has_lanecoordinates() const;
  public:
  void clear_lanecoordinates();
  const ::cn::seisys::v2x::pb::LaneCoordination& lanecoordinates() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::LaneCoordination* release_lanecoordinates();
  ::cn::seisys::v2x::pb::LaneCoordination* mutable_lanecoordinates();
  void set_allocated_lanecoordinates(::cn::seisys::v2x::pb::LaneCoordination* lanecoordinates);
  private:
  const ::cn::seisys::v2x::pb::LaneCoordination& _internal_lanecoordinates() const;
  ::cn::seisys::v2x::pb::LaneCoordination* _internal_mutable_lanecoordinates();
  public:
  void unsafe_arena_set_allocated_lanecoordinates(
      ::cn::seisys::v2x::pb::LaneCoordination* lanecoordinates);
  ::cn::seisys::v2x::pb::LaneCoordination* unsafe_arena_release_lanecoordinates();

  // uint64 timestamp = 3;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint32 msgCnt = 1;
  void clear_msgcnt();
  uint32_t msgcnt() const;
  void set_msgcnt(uint32_t value);
  private:
  uint32_t _internal_msgcnt() const;
  void _internal_set_msgcnt(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.RscData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rsuid_;
    ::cn::seisys::v2x::pb::Position3D* pos_;
    ::cn::seisys::v2x::pb::VehicleCoordination* coordinates_;
    ::cn::seisys::v2x::pb::LaneCoordination* lanecoordinates_;
    uint64_t timestamp_;
    uint32_t msgcnt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class CamData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.CamData) */ {
 public:
  inline CamData() : CamData(nullptr) {}
  ~CamData() override;
  explicit PROTOBUF_CONSTEXPR CamData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CamData(const CamData& from);
  CamData(CamData&& from) noexcept
    : CamData() {
    *this = ::std::move(from);
  }

  inline CamData& operator=(const CamData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CamData& operator=(CamData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CamData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CamData* internal_default_instance() {
    return reinterpret_cast<const CamData*>(
               &_CamData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(CamData& a, CamData& b) {
    a.Swap(&b);
  }
  inline void Swap(CamData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CamData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CamData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CamData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CamData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CamData& from) {
    CamData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CamData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.CamData";
  }
  protected:
  explicit CamData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtcListFieldNumber = 9,
    kObstacleListFieldNumber = 10,
    kRteListFieldNumber = 11,
    kRtsListFieldNumber = 12,
    kBsmListFieldNumber = 13,
    kVirListFieldNumber = 14,
    kRscListFieldNumber = 15,
    kTrafficFlowFieldNumber = 17,
    kSignalSchemeListFieldNumber = 18,
    kDetectedRegionFieldNumber = 19,
    kVerFieldNumber = 2,
    kDeviceIdFieldNumber = 5,
    kMapDeviceIdFieldNumber = 6,
    kRefPosFieldNumber = 7,
    kRoadSignalStateFieldNumber = 16,
    kTypeFieldNumber = 1,
    kMsgCntFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kToAlgorithmTimeFieldNumber = 20,
    kToDatabusTimeFieldNumber = 21,
    kToCloudTimeFieldNumber = 22,
    kIdFieldNumber = 23,
    kSceneTypeFieldNumber = 8,
  };
  // repeated .cn.seisys.v2x.pb.ParticipantData ptcList = 9;
  int ptclist_size() const;
  private:
  int _internal_ptclist_size() const;
  public:
  void clear_ptclist();
  ::cn::seisys::v2x::pb::ParticipantData* mutable_ptclist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ParticipantData >*
      mutable_ptclist();
  private:
  const ::cn::seisys::v2x::pb::ParticipantData& _internal_ptclist(int index) const;
  ::cn::seisys::v2x::pb::ParticipantData* _internal_add_ptclist();
  public:
  const ::cn::seisys::v2x::pb::ParticipantData& ptclist(int index) const;
  ::cn::seisys::v2x::pb::ParticipantData* add_ptclist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ParticipantData >&
      ptclist() const;

  // repeated .cn.seisys.v2x.pb.ObstacleData obstacleList = 10;
  int obstaclelist_size() const;
  private:
  int _internal_obstaclelist_size() const;
  public:
  void clear_obstaclelist();
  ::cn::seisys::v2x::pb::ObstacleData* mutable_obstaclelist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObstacleData >*
      mutable_obstaclelist();
  private:
  const ::cn::seisys::v2x::pb::ObstacleData& _internal_obstaclelist(int index) const;
  ::cn::seisys::v2x::pb::ObstacleData* _internal_add_obstaclelist();
  public:
  const ::cn::seisys::v2x::pb::ObstacleData& obstaclelist(int index) const;
  ::cn::seisys::v2x::pb::ObstacleData* add_obstaclelist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObstacleData >&
      obstaclelist() const;

  // repeated .cn.seisys.v2x.pb.RteData rteList = 11;
  int rtelist_size() const;
  private:
  int _internal_rtelist_size() const;
  public:
  void clear_rtelist();
  ::cn::seisys::v2x::pb::RteData* mutable_rtelist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RteData >*
      mutable_rtelist();
  private:
  const ::cn::seisys::v2x::pb::RteData& _internal_rtelist(int index) const;
  ::cn::seisys::v2x::pb::RteData* _internal_add_rtelist();
  public:
  const ::cn::seisys::v2x::pb::RteData& rtelist(int index) const;
  ::cn::seisys::v2x::pb::RteData* add_rtelist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RteData >&
      rtelist() const;

  // repeated .cn.seisys.v2x.pb.RtsData rtsList = 12;
  int rtslist_size() const;
  private:
  int _internal_rtslist_size() const;
  public:
  void clear_rtslist();
  ::cn::seisys::v2x::pb::RtsData* mutable_rtslist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RtsData >*
      mutable_rtslist();
  private:
  const ::cn::seisys::v2x::pb::RtsData& _internal_rtslist(int index) const;
  ::cn::seisys::v2x::pb::RtsData* _internal_add_rtslist();
  public:
  const ::cn::seisys::v2x::pb::RtsData& rtslist(int index) const;
  ::cn::seisys::v2x::pb::RtsData* add_rtslist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RtsData >&
      rtslist() const;

  // repeated .cn.seisys.v2x.pb.BsmData bsmList = 13;
  int bsmlist_size() const;
  private:
  int _internal_bsmlist_size() const;
  public:
  void clear_bsmlist();
  ::cn::seisys::v2x::pb::BsmData* mutable_bsmlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::BsmData >*
      mutable_bsmlist();
  private:
  const ::cn::seisys::v2x::pb::BsmData& _internal_bsmlist(int index) const;
  ::cn::seisys::v2x::pb::BsmData* _internal_add_bsmlist();
  public:
  const ::cn::seisys::v2x::pb::BsmData& bsmlist(int index) const;
  ::cn::seisys::v2x::pb::BsmData* add_bsmlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::BsmData >&
      bsmlist() const;

  // repeated .cn.seisys.v2x.pb.VirData virList = 14;
  int virlist_size() const;
  private:
  int _internal_virlist_size() const;
  public:
  void clear_virlist();
  ::cn::seisys::v2x::pb::VirData* mutable_virlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::VirData >*
      mutable_virlist();
  private:
  const ::cn::seisys::v2x::pb::VirData& _internal_virlist(int index) const;
  ::cn::seisys::v2x::pb::VirData* _internal_add_virlist();
  public:
  const ::cn::seisys::v2x::pb::VirData& virlist(int index) const;
  ::cn::seisys::v2x::pb::VirData* add_virlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::VirData >&
      virlist() const;

  // repeated .cn.seisys.v2x.pb.RscData rscList = 15;
  int rsclist_size() const;
  private:
  int _internal_rsclist_size() const;
  public:
  void clear_rsclist();
  ::cn::seisys::v2x::pb::RscData* mutable_rsclist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RscData >*
      mutable_rsclist();
  private:
  const ::cn::seisys::v2x::pb::RscData& _internal_rsclist(int index) const;
  ::cn::seisys::v2x::pb::RscData* _internal_add_rsclist();
  public:
  const ::cn::seisys::v2x::pb::RscData& rsclist(int index) const;
  ::cn::seisys::v2x::pb::RscData* add_rsclist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RscData >&
      rsclist() const;

  // repeated .cn.seisys.v2x.pb.TrafficFlow trafficFlow = 17;
  int trafficflow_size() const;
  private:
  int _internal_trafficflow_size() const;
  public:
  void clear_trafficflow();
  ::cn::seisys::v2x::pb::TrafficFlow* mutable_trafficflow(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlow >*
      mutable_trafficflow();
  private:
  const ::cn::seisys::v2x::pb::TrafficFlow& _internal_trafficflow(int index) const;
  ::cn::seisys::v2x::pb::TrafficFlow* _internal_add_trafficflow();
  public:
  const ::cn::seisys::v2x::pb::TrafficFlow& trafficflow(int index) const;
  ::cn::seisys::v2x::pb::TrafficFlow* add_trafficflow();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlow >&
      trafficflow() const;

  // repeated .cn.seisys.v2x.pb.SignalScheme signalSchemeList = 18;
  int signalschemelist_size() const;
  private:
  int _internal_signalschemelist_size() const;
  public:
  void clear_signalschemelist();
  ::cn::seisys::v2x::pb::SignalScheme* mutable_signalschemelist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalScheme >*
      mutable_signalschemelist();
  private:
  const ::cn::seisys::v2x::pb::SignalScheme& _internal_signalschemelist(int index) const;
  ::cn::seisys::v2x::pb::SignalScheme* _internal_add_signalschemelist();
  public:
  const ::cn::seisys::v2x::pb::SignalScheme& signalschemelist(int index) const;
  ::cn::seisys::v2x::pb::SignalScheme* add_signalschemelist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalScheme >&
      signalschemelist() const;

  // repeated .cn.seisys.v2x.pb.Polygon detectedRegion = 19;
  int detectedregion_size() const;
  private:
  int _internal_detectedregion_size() const;
  public:
  void clear_detectedregion();
  ::cn::seisys::v2x::pb::Polygon* mutable_detectedregion(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >*
      mutable_detectedregion();
  private:
  const ::cn::seisys::v2x::pb::Polygon& _internal_detectedregion(int index) const;
  ::cn::seisys::v2x::pb::Polygon* _internal_add_detectedregion();
  public:
  const ::cn::seisys::v2x::pb::Polygon& detectedregion(int index) const;
  ::cn::seisys::v2x::pb::Polygon* add_detectedregion();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >&
      detectedregion() const;

  // string ver = 2;
  void clear_ver();
  const std::string& ver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ver();
  PROTOBUF_NODISCARD std::string* release_ver();
  void set_allocated_ver(std::string* ver);
  private:
  const std::string& _internal_ver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ver(const std::string& value);
  std::string* _internal_mutable_ver();
  public:

  // string deviceId = 5;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string mapDeviceId = 6;
  void clear_mapdeviceid();
  const std::string& mapdeviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapdeviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapdeviceid();
  PROTOBUF_NODISCARD std::string* release_mapdeviceid();
  void set_allocated_mapdeviceid(std::string* mapdeviceid);
  private:
  const std::string& _internal_mapdeviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapdeviceid(const std::string& value);
  std::string* _internal_mutable_mapdeviceid();
  public:

  // .cn.seisys.v2x.pb.Position3D refPos = 7;
  bool has_refpos() const;
  private:
  bool _internal_has_refpos() const;
  public:
  void clear_refpos();
  const ::cn::seisys::v2x::pb::Position3D& refpos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_refpos();
  ::cn::seisys::v2x::pb::Position3D* mutable_refpos();
  void set_allocated_refpos(::cn::seisys::v2x::pb::Position3D* refpos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_refpos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_refpos();
  public:
  void unsafe_arena_set_allocated_refpos(
      ::cn::seisys::v2x::pb::Position3D* refpos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_refpos();

  // .cn.seisys.v2x.pb.SpatData roadSignalState = 16;
  bool has_roadsignalstate() const;
  private:
  bool _internal_has_roadsignalstate() const;
  public:
  void clear_roadsignalstate();
  const ::cn::seisys::v2x::pb::SpatData& roadsignalstate() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::SpatData* release_roadsignalstate();
  ::cn::seisys::v2x::pb::SpatData* mutable_roadsignalstate();
  void set_allocated_roadsignalstate(::cn::seisys::v2x::pb::SpatData* roadsignalstate);
  private:
  const ::cn::seisys::v2x::pb::SpatData& _internal_roadsignalstate() const;
  ::cn::seisys::v2x::pb::SpatData* _internal_mutable_roadsignalstate();
  public:
  void unsafe_arena_set_allocated_roadsignalstate(
      ::cn::seisys::v2x::pb::SpatData* roadsignalstate);
  ::cn::seisys::v2x::pb::SpatData* unsafe_arena_release_roadsignalstate();

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 msgCnt = 3;
  void clear_msgcnt();
  uint32_t msgcnt() const;
  void set_msgcnt(uint32_t value);
  private:
  uint32_t _internal_msgcnt() const;
  void _internal_set_msgcnt(uint32_t value);
  public:

  // uint64 timestamp = 4;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint64 toAlgorithmTime = 20;
  void clear_toalgorithmtime();
  uint64_t toalgorithmtime() const;
  void set_toalgorithmtime(uint64_t value);
  private:
  uint64_t _internal_toalgorithmtime() const;
  void _internal_set_toalgorithmtime(uint64_t value);
  public:

  // uint64 toDatabusTime = 21;
  void clear_todatabustime();
  uint64_t todatabustime() const;
  void set_todatabustime(uint64_t value);
  private:
  uint64_t _internal_todatabustime() const;
  void _internal_set_todatabustime(uint64_t value);
  public:

  // uint64 toCloudTime = 22;
  void clear_tocloudtime();
  uint64_t tocloudtime() const;
  void set_tocloudtime(uint64_t value);
  private:
  uint64_t _internal_tocloudtime() const;
  void _internal_set_tocloudtime(uint64_t value);
  public:

  // uint64 id = 23;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.SceneType sceneType = 8;
  void clear_scenetype();
  ::cn::seisys::v2x::pb::SceneType scenetype() const;
  void set_scenetype(::cn::seisys::v2x::pb::SceneType value);
  private:
  ::cn::seisys::v2x::pb::SceneType _internal_scenetype() const;
  void _internal_set_scenetype(::cn::seisys::v2x::pb::SceneType value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.CamData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ParticipantData > ptclist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObstacleData > obstaclelist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RteData > rtelist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RtsData > rtslist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::BsmData > bsmlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::VirData > virlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RscData > rsclist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlow > trafficflow_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalScheme > signalschemelist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon > detectedregion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapdeviceid_;
    ::cn::seisys::v2x::pb::Position3D* refpos_;
    ::cn::seisys::v2x::pb::SpatData* roadsignalstate_;
    uint32_t type_;
    uint32_t msgcnt_;
    uint64_t timestamp_;
    uint64_t toalgorithmtime_;
    uint64_t todatabustime_;
    uint64_t tocloudtime_;
    uint64_t id_;
    int scenetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class StatusData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.StatusData) */ {
 public:
  inline StatusData() : StatusData(nullptr) {}
  ~StatusData() override;
  explicit PROTOBUF_CONSTEXPR StatusData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusData(const StatusData& from);
  StatusData(StatusData&& from) noexcept
    : StatusData() {
    *this = ::std::move(from);
  }

  inline StatusData& operator=(const StatusData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusData& operator=(StatusData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusData& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusData* internal_default_instance() {
    return reinterpret_cast<const StatusData*>(
               &_StatusData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(StatusData& a, StatusData& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusData& from) {
    StatusData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.StatusData";
  }
  protected:
  explicit StatusData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StatusData_StatusType StatusType;
  static constexpr StatusType DEV_STATUS_UNKNOWN =
    StatusData_StatusType_DEV_STATUS_UNKNOWN;
  static constexpr StatusType DEV_STATUS_OK =
    StatusData_StatusType_DEV_STATUS_OK;
  static constexpr StatusType DEV_STATUS_ABNORMAL =
    StatusData_StatusType_DEV_STATUS_ABNORMAL;
  static constexpr StatusType DEV_STATUS_OFF =
    StatusData_StatusType_DEV_STATUS_OFF;
  static constexpr StatusType DEV_STATUS_REBOOT =
    StatusData_StatusType_DEV_STATUS_REBOOT;
  static constexpr StatusType DEV_STATUS_MAINTAIN =
    StatusData_StatusType_DEV_STATUS_MAINTAIN;
  static constexpr StatusType DEV_STATUS_SCRAP =
    StatusData_StatusType_DEV_STATUS_SCRAP;
  static inline bool StatusType_IsValid(int value) {
    return StatusData_StatusType_IsValid(value);
  }
  static constexpr StatusType StatusType_MIN =
    StatusData_StatusType_StatusType_MIN;
  static constexpr StatusType StatusType_MAX =
    StatusData_StatusType_StatusType_MAX;
  static constexpr int StatusType_ARRAYSIZE =
    StatusData_StatusType_StatusType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StatusType_descriptor() {
    return StatusData_StatusType_descriptor();
  }
  template<typename T>
  static inline const std::string& StatusType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StatusType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StatusType_Name.");
    return StatusData_StatusType_Name(enum_t_value);
  }
  static inline bool StatusType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StatusType* value) {
    return StatusData_StatusType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 1,
    kMapDeviceIdFieldNumber = 2,
    kPosDeviceFieldNumber = 5,
    kDeviceTypeFieldNumber = 3,
    kStatusTypeFieldNumber = 4,
  };
  // string deviceId = 1;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string mapDeviceId = 2;
  void clear_mapdeviceid();
  const std::string& mapdeviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapdeviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapdeviceid();
  PROTOBUF_NODISCARD std::string* release_mapdeviceid();
  void set_allocated_mapdeviceid(std::string* mapdeviceid);
  private:
  const std::string& _internal_mapdeviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapdeviceid(const std::string& value);
  std::string* _internal_mutable_mapdeviceid();
  public:

  // .cn.seisys.v2x.pb.Position3D posDevice = 5;
  bool has_posdevice() const;
  private:
  bool _internal_has_posdevice() const;
  public:
  void clear_posdevice();
  const ::cn::seisys::v2x::pb::Position3D& posdevice() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_posdevice();
  ::cn::seisys::v2x::pb::Position3D* mutable_posdevice();
  void set_allocated_posdevice(::cn::seisys::v2x::pb::Position3D* posdevice);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_posdevice() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_posdevice();
  public:
  void unsafe_arena_set_allocated_posdevice(
      ::cn::seisys::v2x::pb::Position3D* posdevice);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_posdevice();

  // .cn.seisys.v2x.pb.DeviceType deviceType = 3;
  void clear_devicetype();
  ::cn::seisys::v2x::pb::DeviceType devicetype() const;
  void set_devicetype(::cn::seisys::v2x::pb::DeviceType value);
  private:
  ::cn::seisys::v2x::pb::DeviceType _internal_devicetype() const;
  void _internal_set_devicetype(::cn::seisys::v2x::pb::DeviceType value);
  public:

  // .cn.seisys.v2x.pb.StatusData.StatusType statusType = 4;
  void clear_statustype();
  ::cn::seisys::v2x::pb::StatusData_StatusType statustype() const;
  void set_statustype(::cn::seisys::v2x::pb::StatusData_StatusType value);
  private:
  ::cn::seisys::v2x::pb::StatusData_StatusType _internal_statustype() const;
  void _internal_set_statustype(::cn::seisys::v2x::pb::StatusData_StatusType value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.StatusData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapdeviceid_;
    ::cn::seisys::v2x::pb::Position3D* posdevice_;
    int devicetype_;
    int statustype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class DenmData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.DenmData) */ {
 public:
  inline DenmData() : DenmData(nullptr) {}
  ~DenmData() override;
  explicit PROTOBUF_CONSTEXPR DenmData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DenmData(const DenmData& from);
  DenmData(DenmData&& from) noexcept
    : DenmData() {
    *this = ::std::move(from);
  }

  inline DenmData& operator=(const DenmData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DenmData& operator=(DenmData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DenmData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DenmData* internal_default_instance() {
    return reinterpret_cast<const DenmData*>(
               &_DenmData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(DenmData& a, DenmData& b) {
    a.Swap(&b);
  }
  inline void Swap(DenmData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DenmData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DenmData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DenmData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DenmData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DenmData& from) {
    DenmData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DenmData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.DenmData";
  }
  protected:
  explicit DenmData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusListFieldNumber = 8,
    kVerFieldNumber = 2,
    kAddressFieldNumber = 5,
    kRefPosFieldNumber = 6,
    kTypeFieldNumber = 1,
    kMsgCntFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kSceneTypeFieldNumber = 7,
  };
  // repeated .cn.seisys.v2x.pb.StatusData statusList = 8;
  int statuslist_size() const;
  private:
  int _internal_statuslist_size() const;
  public:
  void clear_statuslist();
  ::cn::seisys::v2x::pb::StatusData* mutable_statuslist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::StatusData >*
      mutable_statuslist();
  private:
  const ::cn::seisys::v2x::pb::StatusData& _internal_statuslist(int index) const;
  ::cn::seisys::v2x::pb::StatusData* _internal_add_statuslist();
  public:
  const ::cn::seisys::v2x::pb::StatusData& statuslist(int index) const;
  ::cn::seisys::v2x::pb::StatusData* add_statuslist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::StatusData >&
      statuslist() const;

  // string ver = 2;
  void clear_ver();
  const std::string& ver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ver();
  PROTOBUF_NODISCARD std::string* release_ver();
  void set_allocated_ver(std::string* ver);
  private:
  const std::string& _internal_ver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ver(const std::string& value);
  std::string* _internal_mutable_ver();
  public:

  // string address = 5;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .cn.seisys.v2x.pb.Position3D refPos = 6;
  bool has_refpos() const;
  private:
  bool _internal_has_refpos() const;
  public:
  void clear_refpos();
  const ::cn::seisys::v2x::pb::Position3D& refpos() const;
  PROTOBUF_NODISCARD ::cn::seisys::v2x::pb::Position3D* release_refpos();
  ::cn::seisys::v2x::pb::Position3D* mutable_refpos();
  void set_allocated_refpos(::cn::seisys::v2x::pb::Position3D* refpos);
  private:
  const ::cn::seisys::v2x::pb::Position3D& _internal_refpos() const;
  ::cn::seisys::v2x::pb::Position3D* _internal_mutable_refpos();
  public:
  void unsafe_arena_set_allocated_refpos(
      ::cn::seisys::v2x::pb::Position3D* refpos);
  ::cn::seisys::v2x::pb::Position3D* unsafe_arena_release_refpos();

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 msgCnt = 3;
  void clear_msgcnt();
  uint32_t msgcnt() const;
  void set_msgcnt(uint32_t value);
  private:
  uint32_t _internal_msgcnt() const;
  void _internal_set_msgcnt(uint32_t value);
  public:

  // uint64 timestamp = 4;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .cn.seisys.v2x.pb.SceneType sceneType = 7;
  void clear_scenetype();
  ::cn::seisys::v2x::pb::SceneType scenetype() const;
  void set_scenetype(::cn::seisys::v2x::pb::SceneType value);
  private:
  ::cn::seisys::v2x::pb::SceneType _internal_scenetype() const;
  void _internal_set_scenetype(::cn::seisys::v2x::pb::SceneType value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.DenmData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::StatusData > statuslist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::cn::seisys::v2x::pb::Position3D* refpos_;
    uint32_t type_;
    uint32_t msgcnt_;
    uint64_t timestamp_;
    int scenetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class RsiReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.RsiReply) */ {
 public:
  inline RsiReply() : RsiReply(nullptr) {}
  ~RsiReply() override;
  explicit PROTOBUF_CONSTEXPR RsiReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RsiReply(const RsiReply& from);
  RsiReply(RsiReply&& from) noexcept
    : RsiReply() {
    *this = ::std::move(from);
  }

  inline RsiReply& operator=(const RsiReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RsiReply& operator=(RsiReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RsiReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RsiReply* internal_default_instance() {
    return reinterpret_cast<const RsiReply*>(
               &_RsiReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(RsiReply& a, RsiReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RsiReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RsiReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RsiReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RsiReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RsiReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RsiReply& from) {
    RsiReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RsiReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.RsiReply";
  }
  protected:
  explicit RsiReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceDeviceIdFieldNumber = 3,
    kTargetDeviceIdFieldNumber = 4,
    kCreatTimeFieldNumber = 5,
    kDistributionTimeFieldNumber = 6,
    kCompletionTimeFieldNumber = 7,
    kUpdateTimeFieldNumber = 8,
    kDescriptionFieldNumber = 14,
    kSourceTopicFieldNumber = 15,
    kTargetTopicFieldNumber = 16,
    kIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kOperationTypeFieldNumber = 9,
    kCamDataIdFieldNumber = 10,
    kDataIdFieldNumber = 11,
    kEventSourceIdFieldNumber = 12,
    kDistributionStatusIdFieldNumber = 13,
  };
  // string sourceDeviceId = 3;
  void clear_sourcedeviceid();
  const std::string& sourcedeviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcedeviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcedeviceid();
  PROTOBUF_NODISCARD std::string* release_sourcedeviceid();
  void set_allocated_sourcedeviceid(std::string* sourcedeviceid);
  private:
  const std::string& _internal_sourcedeviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcedeviceid(const std::string& value);
  std::string* _internal_mutable_sourcedeviceid();
  public:

  // string targetDeviceId = 4;
  void clear_targetdeviceid();
  const std::string& targetdeviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetdeviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetdeviceid();
  PROTOBUF_NODISCARD std::string* release_targetdeviceid();
  void set_allocated_targetdeviceid(std::string* targetdeviceid);
  private:
  const std::string& _internal_targetdeviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetdeviceid(const std::string& value);
  std::string* _internal_mutable_targetdeviceid();
  public:

  // string creatTime = 5;
  void clear_creattime();
  const std::string& creattime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creattime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creattime();
  PROTOBUF_NODISCARD std::string* release_creattime();
  void set_allocated_creattime(std::string* creattime);
  private:
  const std::string& _internal_creattime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creattime(const std::string& value);
  std::string* _internal_mutable_creattime();
  public:

  // string distributionTime = 6;
  void clear_distributiontime();
  const std::string& distributiontime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_distributiontime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_distributiontime();
  PROTOBUF_NODISCARD std::string* release_distributiontime();
  void set_allocated_distributiontime(std::string* distributiontime);
  private:
  const std::string& _internal_distributiontime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_distributiontime(const std::string& value);
  std::string* _internal_mutable_distributiontime();
  public:

  // string completionTime = 7;
  void clear_completiontime();
  const std::string& completiontime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_completiontime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_completiontime();
  PROTOBUF_NODISCARD std::string* release_completiontime();
  void set_allocated_completiontime(std::string* completiontime);
  private:
  const std::string& _internal_completiontime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completiontime(const std::string& value);
  std::string* _internal_mutable_completiontime();
  public:

  // string updateTime = 8;
  void clear_updatetime();
  const std::string& updatetime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updatetime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updatetime();
  PROTOBUF_NODISCARD std::string* release_updatetime();
  void set_allocated_updatetime(std::string* updatetime);
  private:
  const std::string& _internal_updatetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updatetime(const std::string& value);
  std::string* _internal_mutable_updatetime();
  public:

  // string description = 14;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string sourceTopic = 15;
  void clear_sourcetopic();
  const std::string& sourcetopic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcetopic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcetopic();
  PROTOBUF_NODISCARD std::string* release_sourcetopic();
  void set_allocated_sourcetopic(std::string* sourcetopic);
  private:
  const std::string& _internal_sourcetopic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcetopic(const std::string& value);
  std::string* _internal_mutable_sourcetopic();
  public:

  // string targetTopic = 16;
  void clear_targettopic();
  const std::string& targettopic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targettopic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targettopic();
  PROTOBUF_NODISCARD std::string* release_targettopic();
  void set_allocated_targettopic(std::string* targettopic);
  private:
  const std::string& _internal_targettopic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targettopic(const std::string& value);
  std::string* _internal_mutable_targettopic();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint32 eventType = 2;
  void clear_eventtype();
  uint32_t eventtype() const;
  void set_eventtype(uint32_t value);
  private:
  uint32_t _internal_eventtype() const;
  void _internal_set_eventtype(uint32_t value);
  public:

  // uint32 operationType = 9;
  void clear_operationtype();
  uint32_t operationtype() const;
  void set_operationtype(uint32_t value);
  private:
  uint32_t _internal_operationtype() const;
  void _internal_set_operationtype(uint32_t value);
  public:

  // uint64 camDataId = 10;
  void clear_camdataid();
  uint64_t camdataid() const;
  void set_camdataid(uint64_t value);
  private:
  uint64_t _internal_camdataid() const;
  void _internal_set_camdataid(uint64_t value);
  public:

  // uint64 dataId = 11;
  void clear_dataid();
  uint64_t dataid() const;
  void set_dataid(uint64_t value);
  private:
  uint64_t _internal_dataid() const;
  void _internal_set_dataid(uint64_t value);
  public:

  // uint64 eventSourceId = 12;
  void clear_eventsourceid();
  uint64_t eventsourceid() const;
  void set_eventsourceid(uint64_t value);
  private:
  uint64_t _internal_eventsourceid() const;
  void _internal_set_eventsourceid(uint64_t value);
  public:

  // uint32 distributionStatusId = 13;
  void clear_distributionstatusid();
  uint32_t distributionstatusid() const;
  void set_distributionstatusid(uint32_t value);
  private:
  uint32_t _internal_distributionstatusid() const;
  void _internal_set_distributionstatusid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.RsiReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcedeviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetdeviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creattime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr distributiontime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr completiontime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updatetime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcetopic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targettopic_;
    uint64_t id_;
    uint32_t eventtype_;
    uint32_t operationtype_;
    uint64_t camdataid_;
    uint64_t dataid_;
    uint64_t eventsourceid_;
    uint32_t distributionstatusid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class RsuRsmReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.RsuRsmReply) */ {
 public:
  inline RsuRsmReply() : RsuRsmReply(nullptr) {}
  ~RsuRsmReply() override;
  explicit PROTOBUF_CONSTEXPR RsuRsmReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RsuRsmReply(const RsuRsmReply& from);
  RsuRsmReply(RsuRsmReply&& from) noexcept
    : RsuRsmReply() {
    *this = ::std::move(from);
  }

  inline RsuRsmReply& operator=(const RsuRsmReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RsuRsmReply& operator=(RsuRsmReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RsuRsmReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RsuRsmReply* internal_default_instance() {
    return reinterpret_cast<const RsuRsmReply*>(
               &_RsuRsmReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(RsuRsmReply& a, RsuRsmReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RsuRsmReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RsuRsmReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RsuRsmReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RsuRsmReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RsuRsmReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RsuRsmReply& from) {
    RsuRsmReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RsuRsmReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.RsuRsmReply";
  }
  protected:
  explicit RsuRsmReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRsmReplyListFieldNumber = 4,
    kSourceDeviceIdFieldNumber = 1,
    kTargetDeviceIdFieldNumber = 2,
    kTargetTopicFieldNumber = 5,
    kCamDataIdFieldNumber = 3,
    kTimestampFieldNumber = 6,
  };
  // repeated .cn.seisys.v2x.pb.RsmReply rsmReplyList = 4;
  int rsmreplylist_size() const;
  private:
  int _internal_rsmreplylist_size() const;
  public:
  void clear_rsmreplylist();
  ::cn::seisys::v2x::pb::RsmReply* mutable_rsmreplylist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RsmReply >*
      mutable_rsmreplylist();
  private:
  const ::cn::seisys::v2x::pb::RsmReply& _internal_rsmreplylist(int index) const;
  ::cn::seisys::v2x::pb::RsmReply* _internal_add_rsmreplylist();
  public:
  const ::cn::seisys::v2x::pb::RsmReply& rsmreplylist(int index) const;
  ::cn::seisys::v2x::pb::RsmReply* add_rsmreplylist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RsmReply >&
      rsmreplylist() const;

  // string sourceDeviceId = 1;
  void clear_sourcedeviceid();
  const std::string& sourcedeviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcedeviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcedeviceid();
  PROTOBUF_NODISCARD std::string* release_sourcedeviceid();
  void set_allocated_sourcedeviceid(std::string* sourcedeviceid);
  private:
  const std::string& _internal_sourcedeviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcedeviceid(const std::string& value);
  std::string* _internal_mutable_sourcedeviceid();
  public:

  // string targetDeviceId = 2;
  void clear_targetdeviceid();
  const std::string& targetdeviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetdeviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetdeviceid();
  PROTOBUF_NODISCARD std::string* release_targetdeviceid();
  void set_allocated_targetdeviceid(std::string* targetdeviceid);
  private:
  const std::string& _internal_targetdeviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetdeviceid(const std::string& value);
  std::string* _internal_mutable_targetdeviceid();
  public:

  // string targetTopic = 5;
  void clear_targettopic();
  const std::string& targettopic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targettopic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targettopic();
  PROTOBUF_NODISCARD std::string* release_targettopic();
  void set_allocated_targettopic(std::string* targettopic);
  private:
  const std::string& _internal_targettopic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targettopic(const std::string& value);
  std::string* _internal_mutable_targettopic();
  public:

  // uint64 camDataId = 3;
  void clear_camdataid();
  uint64_t camdataid() const;
  void set_camdataid(uint64_t value);
  private:
  uint64_t _internal_camdataid() const;
  void _internal_set_camdataid(uint64_t value);
  public:

  // uint64 timestamp = 6;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.RsuRsmReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RsmReply > rsmreplylist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcedeviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetdeviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targettopic_;
    uint64_t camdataid_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class RsmReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.RsmReply) */ {
 public:
  inline RsmReply() : RsmReply(nullptr) {}
  ~RsmReply() override;
  explicit PROTOBUF_CONSTEXPR RsmReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RsmReply(const RsmReply& from);
  RsmReply(RsmReply&& from) noexcept
    : RsmReply() {
    *this = ::std::move(from);
  }

  inline RsmReply& operator=(const RsmReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RsmReply& operator=(RsmReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RsmReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RsmReply* internal_default_instance() {
    return reinterpret_cast<const RsmReply*>(
               &_RsmReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(RsmReply& a, RsmReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RsmReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RsmReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RsmReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RsmReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RsmReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RsmReply& from) {
    RsmReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RsmReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.RsmReply";
  }
  protected:
  explicit RsmReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 3,
    kDataIdFieldNumber = 1,
    kDistributionStatusIdFieldNumber = 2,
  };
  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // uint64 dataId = 1;
  void clear_dataid();
  uint64_t dataid() const;
  void set_dataid(uint64_t value);
  private:
  uint64_t _internal_dataid() const;
  void _internal_set_dataid(uint64_t value);
  public:

  // uint32 distributionStatusId = 2;
  void clear_distributionstatusid();
  uint32_t distributionstatusid() const;
  void set_distributionstatusid(uint32_t value);
  private:
  uint32_t _internal_distributionstatusid() const;
  void _internal_set_distributionstatusid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.RsmReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    uint64_t dataid_;
    uint32_t distributionstatusid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// -------------------------------------------------------------------

class MonitorStatsData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.v2x.pb.MonitorStatsData) */ {
 public:
  inline MonitorStatsData() : MonitorStatsData(nullptr) {}
  ~MonitorStatsData() override;
  explicit PROTOBUF_CONSTEXPR MonitorStatsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonitorStatsData(const MonitorStatsData& from);
  MonitorStatsData(MonitorStatsData&& from) noexcept
    : MonitorStatsData() {
    *this = ::std::move(from);
  }

  inline MonitorStatsData& operator=(const MonitorStatsData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitorStatsData& operator=(MonitorStatsData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonitorStatsData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonitorStatsData* internal_default_instance() {
    return reinterpret_cast<const MonitorStatsData*>(
               &_MonitorStatsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(MonitorStatsData& a, MonitorStatsData& b) {
    a.Swap(&b);
  }
  inline void Swap(MonitorStatsData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonitorStatsData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonitorStatsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonitorStatsData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MonitorStatsData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MonitorStatsData& from) {
    MonitorStatsData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonitorStatsData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.v2x.pb.MonitorStatsData";
  }
  protected:
  explicit MonitorStatsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kCamNumsFieldNumber = 3,
    kParticipantNumsFieldNumber = 4,
    kRteNumsFieldNumber = 5,
    kTrafficflowNumsFieldNumber = 6,
    kTrafficflowStatNumsFieldNumber = 7,
    kIntersectionStatNumsFieldNumber = 8,
    kPhaseStatNumsFieldNumber = 9,
    kRtsNumsFieldNumber = 10,
    kCameraPathListNumsFieldNumber = 11,
    kCameraPathNumsFieldNumber = 12,
    kRadarPathListNumsFieldNumber = 13,
    kRadarPathNumsFieldNumber = 14,
  };
  // string deviceId = 2;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // uint64 camNums = 3;
  void clear_camnums();
  uint64_t camnums() const;
  void set_camnums(uint64_t value);
  private:
  uint64_t _internal_camnums() const;
  void _internal_set_camnums(uint64_t value);
  public:

  // uint64 participantNums = 4;
  void clear_participantnums();
  uint64_t participantnums() const;
  void set_participantnums(uint64_t value);
  private:
  uint64_t _internal_participantnums() const;
  void _internal_set_participantnums(uint64_t value);
  public:

  // uint64 rteNums = 5;
  void clear_rtenums();
  uint64_t rtenums() const;
  void set_rtenums(uint64_t value);
  private:
  uint64_t _internal_rtenums() const;
  void _internal_set_rtenums(uint64_t value);
  public:

  // uint64 trafficflowNums = 6;
  void clear_trafficflownums();
  uint64_t trafficflownums() const;
  void set_trafficflownums(uint64_t value);
  private:
  uint64_t _internal_trafficflownums() const;
  void _internal_set_trafficflownums(uint64_t value);
  public:

  // uint64 trafficflowStatNums = 7;
  void clear_trafficflowstatnums();
  uint64_t trafficflowstatnums() const;
  void set_trafficflowstatnums(uint64_t value);
  private:
  uint64_t _internal_trafficflowstatnums() const;
  void _internal_set_trafficflowstatnums(uint64_t value);
  public:

  // uint64 intersectionStatNums = 8;
  void clear_intersectionstatnums();
  uint64_t intersectionstatnums() const;
  void set_intersectionstatnums(uint64_t value);
  private:
  uint64_t _internal_intersectionstatnums() const;
  void _internal_set_intersectionstatnums(uint64_t value);
  public:

  // uint64 phaseStatNums = 9;
  void clear_phasestatnums();
  uint64_t phasestatnums() const;
  void set_phasestatnums(uint64_t value);
  private:
  uint64_t _internal_phasestatnums() const;
  void _internal_set_phasestatnums(uint64_t value);
  public:

  // uint64 rtsNums = 10;
  void clear_rtsnums();
  uint64_t rtsnums() const;
  void set_rtsnums(uint64_t value);
  private:
  uint64_t _internal_rtsnums() const;
  void _internal_set_rtsnums(uint64_t value);
  public:

  // uint64 cameraPathListNums = 11;
  void clear_camerapathlistnums();
  uint64_t camerapathlistnums() const;
  void set_camerapathlistnums(uint64_t value);
  private:
  uint64_t _internal_camerapathlistnums() const;
  void _internal_set_camerapathlistnums(uint64_t value);
  public:

  // uint64 cameraPathNums = 12;
  void clear_camerapathnums();
  uint64_t camerapathnums() const;
  void set_camerapathnums(uint64_t value);
  private:
  uint64_t _internal_camerapathnums() const;
  void _internal_set_camerapathnums(uint64_t value);
  public:

  // uint64 radarPathListNums = 13;
  void clear_radarpathlistnums();
  uint64_t radarpathlistnums() const;
  void set_radarpathlistnums(uint64_t value);
  private:
  uint64_t _internal_radarpathlistnums() const;
  void _internal_set_radarpathlistnums(uint64_t value);
  public:

  // uint64 radarPathNums = 14;
  void clear_radarpathnums();
  uint64_t radarpathnums() const;
  void set_radarpathnums(uint64_t value);
  private:
  uint64_t _internal_radarpathnums() const;
  void _internal_set_radarpathnums(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.v2x.pb.MonitorStatsData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    uint64_t timestamp_;
    uint64_t camnums_;
    uint64_t participantnums_;
    uint64_t rtenums_;
    uint64_t trafficflownums_;
    uint64_t trafficflowstatnums_;
    uint64_t intersectionstatnums_;
    uint64_t phasestatnums_;
    uint64_t rtsnums_;
    uint64_t camerapathlistnums_;
    uint64_t camerapathnums_;
    uint64_t radarpathlistnums_;
    uint64_t radarpathnums_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_v2x_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RsiTimeDetails

// uint64 startTime = 1;
inline void RsiTimeDetails::clear_starttime() {
  _impl_.starttime_ = uint64_t{0u};
}
inline uint64_t RsiTimeDetails::_internal_starttime() const {
  return _impl_.starttime_;
}
inline uint64_t RsiTimeDetails::starttime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiTimeDetails.startTime)
  return _internal_starttime();
}
inline void RsiTimeDetails::_internal_set_starttime(uint64_t value) {
  
  _impl_.starttime_ = value;
}
inline void RsiTimeDetails::set_starttime(uint64_t value) {
  _internal_set_starttime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiTimeDetails.startTime)
}

// uint64 endTime = 2;
inline void RsiTimeDetails::clear_endtime() {
  _impl_.endtime_ = uint64_t{0u};
}
inline uint64_t RsiTimeDetails::_internal_endtime() const {
  return _impl_.endtime_;
}
inline uint64_t RsiTimeDetails::endtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiTimeDetails.endTime)
  return _internal_endtime();
}
inline void RsiTimeDetails::_internal_set_endtime(uint64_t value) {
  
  _impl_.endtime_ = value;
}
inline void RsiTimeDetails::set_endtime(uint64_t value) {
  _internal_set_endtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiTimeDetails.endTime)
}

// .cn.seisys.v2x.pb.TimeConfidence endTimeConfidence = 3;
inline void RsiTimeDetails::clear_endtimeconfidence() {
  _impl_.endtimeconfidence_ = 0;
}
inline ::cn::seisys::v2x::pb::TimeConfidence RsiTimeDetails::_internal_endtimeconfidence() const {
  return static_cast< ::cn::seisys::v2x::pb::TimeConfidence >(_impl_.endtimeconfidence_);
}
inline ::cn::seisys::v2x::pb::TimeConfidence RsiTimeDetails::endtimeconfidence() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiTimeDetails.endTimeConfidence)
  return _internal_endtimeconfidence();
}
inline void RsiTimeDetails::_internal_set_endtimeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  
  _impl_.endtimeconfidence_ = value;
}
inline void RsiTimeDetails::set_endtimeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  _internal_set_endtimeconfidence(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiTimeDetails.endTimeConfidence)
}

// -------------------------------------------------------------------

// Position3D

// int32 lat = 1;
inline void Position3D::clear_lat() {
  _impl_.lat_ = 0;
}
inline int32_t Position3D::_internal_lat() const {
  return _impl_.lat_;
}
inline int32_t Position3D::lat() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Position3D.lat)
  return _internal_lat();
}
inline void Position3D::_internal_set_lat(int32_t value) {
  
  _impl_.lat_ = value;
}
inline void Position3D::set_lat(int32_t value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Position3D.lat)
}

// int32 lon = 2;
inline void Position3D::clear_lon() {
  _impl_.lon_ = 0;
}
inline int32_t Position3D::_internal_lon() const {
  return _impl_.lon_;
}
inline int32_t Position3D::lon() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Position3D.lon)
  return _internal_lon();
}
inline void Position3D::_internal_set_lon(int32_t value) {
  
  _impl_.lon_ = value;
}
inline void Position3D::set_lon(int32_t value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Position3D.lon)
}

// int32 ele = 3;
inline void Position3D::clear_ele() {
  _impl_.ele_ = 0;
}
inline int32_t Position3D::_internal_ele() const {
  return _impl_.ele_;
}
inline int32_t Position3D::ele() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Position3D.ele)
  return _internal_ele();
}
inline void Position3D::_internal_set_ele(int32_t value) {
  
  _impl_.ele_ = value;
}
inline void Position3D::set_ele(int32_t value) {
  _internal_set_ele(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Position3D.ele)
}

// -------------------------------------------------------------------

// PositionConfidenceSet

// .cn.seisys.v2x.pb.PositionConfidenceSet.PositionConfidence posConfid = 1;
inline void PositionConfidenceSet::clear_posconfid() {
  _impl_.posconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence PositionConfidenceSet::_internal_posconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence >(_impl_.posconfid_);
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence PositionConfidenceSet::posconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PositionConfidenceSet.posConfid)
  return _internal_posconfid();
}
inline void PositionConfidenceSet::_internal_set_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence value) {
  
  _impl_.posconfid_ = value;
}
inline void PositionConfidenceSet::set_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence value) {
  _internal_set_posconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PositionConfidenceSet.posConfid)
}

// .cn.seisys.v2x.pb.PositionConfidenceSet.ElevationConfidence eleConfid = 2;
inline void PositionConfidenceSet::clear_eleconfid() {
  _impl_.eleconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence PositionConfidenceSet::_internal_eleconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence >(_impl_.eleconfid_);
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence PositionConfidenceSet::eleconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PositionConfidenceSet.eleConfid)
  return _internal_eleconfid();
}
inline void PositionConfidenceSet::_internal_set_eleconfid(::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence value) {
  
  _impl_.eleconfid_ = value;
}
inline void PositionConfidenceSet::set_eleconfid(::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence value) {
  _internal_set_eleconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PositionConfidenceSet.eleConfid)
}

// -------------------------------------------------------------------

// ParticipantSize

// uint32 width = 1;
inline void ParticipantSize::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t ParticipantSize::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t ParticipantSize::width() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantSize.width)
  return _internal_width();
}
inline void ParticipantSize::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void ParticipantSize::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantSize.width)
}

// uint32 length = 2;
inline void ParticipantSize::clear_length() {
  _impl_.length_ = 0u;
}
inline uint32_t ParticipantSize::_internal_length() const {
  return _impl_.length_;
}
inline uint32_t ParticipantSize::length() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantSize.length)
  return _internal_length();
}
inline void ParticipantSize::_internal_set_length(uint32_t value) {
  
  _impl_.length_ = value;
}
inline void ParticipantSize::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantSize.length)
}

// uint32 height = 3;
inline void ParticipantSize::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t ParticipantSize::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t ParticipantSize::height() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantSize.height)
  return _internal_height();
}
inline void ParticipantSize::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void ParticipantSize::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantSize.height)
}

// -------------------------------------------------------------------

// ParticipantSizeConfidence

// .cn.seisys.v2x.pb.ParticipantSizeConfidence.SizeValueConfidence widthConfid = 1;
inline void ParticipantSizeConfidence::clear_widthconfid() {
  _impl_.widthconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence ParticipantSizeConfidence::_internal_widthconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence >(_impl_.widthconfid_);
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence ParticipantSizeConfidence::widthconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantSizeConfidence.widthConfid)
  return _internal_widthconfid();
}
inline void ParticipantSizeConfidence::_internal_set_widthconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value) {
  
  _impl_.widthconfid_ = value;
}
inline void ParticipantSizeConfidence::set_widthconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value) {
  _internal_set_widthconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantSizeConfidence.widthConfid)
}

// .cn.seisys.v2x.pb.ParticipantSizeConfidence.SizeValueConfidence lengthConfid = 2;
inline void ParticipantSizeConfidence::clear_lengthconfid() {
  _impl_.lengthconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence ParticipantSizeConfidence::_internal_lengthconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence >(_impl_.lengthconfid_);
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence ParticipantSizeConfidence::lengthconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantSizeConfidence.lengthConfid)
  return _internal_lengthconfid();
}
inline void ParticipantSizeConfidence::_internal_set_lengthconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value) {
  
  _impl_.lengthconfid_ = value;
}
inline void ParticipantSizeConfidence::set_lengthconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value) {
  _internal_set_lengthconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantSizeConfidence.lengthConfid)
}

// .cn.seisys.v2x.pb.ParticipantSizeConfidence.SizeValueConfidence heightConfid = 3;
inline void ParticipantSizeConfidence::clear_heightconfid() {
  _impl_.heightconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence ParticipantSizeConfidence::_internal_heightconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence >(_impl_.heightconfid_);
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence ParticipantSizeConfidence::heightconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantSizeConfidence.heightConfid)
  return _internal_heightconfid();
}
inline void ParticipantSizeConfidence::_internal_set_heightconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value) {
  
  _impl_.heightconfid_ = value;
}
inline void ParticipantSizeConfidence::set_heightconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence value) {
  _internal_set_heightconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantSizeConfidence.heightConfid)
}

// -------------------------------------------------------------------

// Polygon

// repeated .cn.seisys.v2x.pb.Position3D pos = 1;
inline int Polygon::_internal_pos_size() const {
  return _impl_.pos_.size();
}
inline int Polygon::pos_size() const {
  return _internal_pos_size();
}
inline void Polygon::clear_pos() {
  _impl_.pos_.Clear();
}
inline ::cn::seisys::v2x::pb::Position3D* Polygon::mutable_pos(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Polygon.pos)
  return _impl_.pos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
Polygon::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Polygon.pos)
  return &_impl_.pos_;
}
inline const ::cn::seisys::v2x::pb::Position3D& Polygon::_internal_pos(int index) const {
  return _impl_.pos_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Position3D& Polygon::pos(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Polygon.pos)
  return _internal_pos(index);
}
inline ::cn::seisys::v2x::pb::Position3D* Polygon::_internal_add_pos() {
  return _impl_.pos_.Add();
}
inline ::cn::seisys::v2x::pb::Position3D* Polygon::add_pos() {
  ::cn::seisys::v2x::pb::Position3D* _add = _internal_add_pos();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Polygon.pos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
Polygon::pos() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Polygon.pos)
  return _impl_.pos_;
}

// -------------------------------------------------------------------

// DetectorArea

// int32 areaId = 1;
inline void DetectorArea::clear_areaid() {
  _impl_.areaid_ = 0;
}
inline int32_t DetectorArea::_internal_areaid() const {
  return _impl_.areaid_;
}
inline int32_t DetectorArea::areaid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DetectorArea.areaId)
  return _internal_areaid();
}
inline void DetectorArea::_internal_set_areaid(int32_t value) {
  
  _impl_.areaid_ = value;
}
inline void DetectorArea::set_areaid(int32_t value) {
  _internal_set_areaid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DetectorArea.areaId)
}

// int64 setTime = 2;
inline void DetectorArea::clear_settime() {
  _impl_.settime_ = int64_t{0};
}
inline int64_t DetectorArea::_internal_settime() const {
  return _impl_.settime_;
}
inline int64_t DetectorArea::settime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DetectorArea.setTime)
  return _internal_settime();
}
inline void DetectorArea::_internal_set_settime(int64_t value) {
  
  _impl_.settime_ = value;
}
inline void DetectorArea::set_settime(int64_t value) {
  _internal_set_settime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DetectorArea.setTime)
}

// .cn.seisys.v2x.pb.Polygon polygon = 3;
inline bool DetectorArea::_internal_has_polygon() const {
  return this != internal_default_instance() && _impl_.polygon_ != nullptr;
}
inline bool DetectorArea::has_polygon() const {
  return _internal_has_polygon();
}
inline void DetectorArea::clear_polygon() {
  if (GetArenaForAllocation() == nullptr && _impl_.polygon_ != nullptr) {
    delete _impl_.polygon_;
  }
  _impl_.polygon_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Polygon& DetectorArea::_internal_polygon() const {
  const ::cn::seisys::v2x::pb::Polygon* p = _impl_.polygon_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Polygon&>(
      ::cn::seisys::v2x::pb::_Polygon_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Polygon& DetectorArea::polygon() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DetectorArea.polygon)
  return _internal_polygon();
}
inline void DetectorArea::unsafe_arena_set_allocated_polygon(
    ::cn::seisys::v2x::pb::Polygon* polygon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.polygon_);
  }
  _impl_.polygon_ = polygon;
  if (polygon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.DetectorArea.polygon)
}
inline ::cn::seisys::v2x::pb::Polygon* DetectorArea::release_polygon() {
  
  ::cn::seisys::v2x::pb::Polygon* temp = _impl_.polygon_;
  _impl_.polygon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Polygon* DetectorArea::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DetectorArea.polygon)
  
  ::cn::seisys::v2x::pb::Polygon* temp = _impl_.polygon_;
  _impl_.polygon_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Polygon* DetectorArea::_internal_mutable_polygon() {
  
  if (_impl_.polygon_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Polygon>(GetArenaForAllocation());
    _impl_.polygon_ = p;
  }
  return _impl_.polygon_;
}
inline ::cn::seisys::v2x::pb::Polygon* DetectorArea::mutable_polygon() {
  ::cn::seisys::v2x::pb::Polygon* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DetectorArea.polygon)
  return _msg;
}
inline void DetectorArea::set_allocated_polygon(::cn::seisys::v2x::pb::Polygon* polygon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.polygon_;
  }
  if (polygon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(polygon);
    if (message_arena != submessage_arena) {
      polygon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polygon, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.polygon_ = polygon;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DetectorArea.polygon)
}

// .cn.seisys.v2x.pb.NodeReferenceId nodeId = 4;
inline bool DetectorArea::_internal_has_nodeid() const {
  return this != internal_default_instance() && _impl_.nodeid_ != nullptr;
}
inline bool DetectorArea::has_nodeid() const {
  return _internal_has_nodeid();
}
inline void DetectorArea::clear_nodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodeid_ != nullptr) {
    delete _impl_.nodeid_;
  }
  _impl_.nodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& DetectorArea::_internal_nodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.nodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& DetectorArea::nodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DetectorArea.nodeId)
  return _internal_nodeid();
}
inline void DetectorArea::unsafe_arena_set_allocated_nodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodeid_);
  }
  _impl_.nodeid_ = nodeid;
  if (nodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.DetectorArea.nodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* DetectorArea::release_nodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* DetectorArea::unsafe_arena_release_nodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DetectorArea.nodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* DetectorArea::_internal_mutable_nodeid() {
  
  if (_impl_.nodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.nodeid_ = p;
  }
  return _impl_.nodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* DetectorArea::mutable_nodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DetectorArea.nodeId)
  return _msg;
}
inline void DetectorArea::set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodeid_;
  }
  if (nodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodeid);
    if (message_arena != submessage_arena) {
      nodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodeid_ = nodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DetectorArea.nodeId)
}

// int32 laneId = 5;
inline void DetectorArea::clear_laneid() {
  _impl_.laneid_ = 0;
}
inline int32_t DetectorArea::_internal_laneid() const {
  return _impl_.laneid_;
}
inline int32_t DetectorArea::laneid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DetectorArea.laneId)
  return _internal_laneid();
}
inline void DetectorArea::_internal_set_laneid(int32_t value) {
  
  _impl_.laneid_ = value;
}
inline void DetectorArea::set_laneid(int32_t value) {
  _internal_set_laneid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DetectorArea.laneId)
}

// -------------------------------------------------------------------

// RegulatorySpeedLimit

// .cn.seisys.v2x.pb.RegulatorySpeedLimit.SpeedLimitType speedLimitType = 1;
inline void RegulatorySpeedLimit::clear_speedlimittype() {
  _impl_.speedlimittype_ = 0;
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType RegulatorySpeedLimit::_internal_speedlimittype() const {
  return static_cast< ::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType >(_impl_.speedlimittype_);
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType RegulatorySpeedLimit::speedlimittype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RegulatorySpeedLimit.speedLimitType)
  return _internal_speedlimittype();
}
inline void RegulatorySpeedLimit::_internal_set_speedlimittype(::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType value) {
  
  _impl_.speedlimittype_ = value;
}
inline void RegulatorySpeedLimit::set_speedlimittype(::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType value) {
  _internal_set_speedlimittype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RegulatorySpeedLimit.speedLimitType)
}

// int32 speed = 2;
inline void RegulatorySpeedLimit::clear_speed() {
  _impl_.speed_ = 0;
}
inline int32_t RegulatorySpeedLimit::_internal_speed() const {
  return _impl_.speed_;
}
inline int32_t RegulatorySpeedLimit::speed() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RegulatorySpeedLimit.speed)
  return _internal_speed();
}
inline void RegulatorySpeedLimit::_internal_set_speed(int32_t value) {
  
  _impl_.speed_ = value;
}
inline void RegulatorySpeedLimit::set_speed(int32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RegulatorySpeedLimit.speed)
}

// -------------------------------------------------------------------

// AccelerationSet4Way

// int32 lat = 1;
inline void AccelerationSet4Way::clear_lat() {
  _impl_.lat_ = 0;
}
inline int32_t AccelerationSet4Way::_internal_lat() const {
  return _impl_.lat_;
}
inline int32_t AccelerationSet4Way::lat() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.AccelerationSet4Way.lat)
  return _internal_lat();
}
inline void AccelerationSet4Way::_internal_set_lat(int32_t value) {
  
  _impl_.lat_ = value;
}
inline void AccelerationSet4Way::set_lat(int32_t value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.AccelerationSet4Way.lat)
}

// int32 lon = 2;
inline void AccelerationSet4Way::clear_lon() {
  _impl_.lon_ = 0;
}
inline int32_t AccelerationSet4Way::_internal_lon() const {
  return _impl_.lon_;
}
inline int32_t AccelerationSet4Way::lon() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.AccelerationSet4Way.lon)
  return _internal_lon();
}
inline void AccelerationSet4Way::_internal_set_lon(int32_t value) {
  
  _impl_.lon_ = value;
}
inline void AccelerationSet4Way::set_lon(int32_t value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.AccelerationSet4Way.lon)
}

// int32 vert = 3;
inline void AccelerationSet4Way::clear_vert() {
  _impl_.vert_ = 0;
}
inline int32_t AccelerationSet4Way::_internal_vert() const {
  return _impl_.vert_;
}
inline int32_t AccelerationSet4Way::vert() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.AccelerationSet4Way.vert)
  return _internal_vert();
}
inline void AccelerationSet4Way::_internal_set_vert(int32_t value) {
  
  _impl_.vert_ = value;
}
inline void AccelerationSet4Way::set_vert(int32_t value) {
  _internal_set_vert(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.AccelerationSet4Way.vert)
}

// int32 yaw = 4;
inline void AccelerationSet4Way::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline int32_t AccelerationSet4Way::_internal_yaw() const {
  return _impl_.yaw_;
}
inline int32_t AccelerationSet4Way::yaw() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.AccelerationSet4Way.yaw)
  return _internal_yaw();
}
inline void AccelerationSet4Way::_internal_set_yaw(int32_t value) {
  
  _impl_.yaw_ = value;
}
inline void AccelerationSet4Way::set_yaw(int32_t value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.AccelerationSet4Way.yaw)
}

// -------------------------------------------------------------------

// AccelerationConfidence

// .cn.seisys.v2x.pb.AccelerationConfidence.AccConfidence lonAccelConfid = 1;
inline void AccelerationConfidence::clear_lonaccelconfid() {
  _impl_.lonaccelconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence AccelerationConfidence::_internal_lonaccelconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence >(_impl_.lonaccelconfid_);
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence AccelerationConfidence::lonaccelconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.AccelerationConfidence.lonAccelConfid)
  return _internal_lonaccelconfid();
}
inline void AccelerationConfidence::_internal_set_lonaccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value) {
  
  _impl_.lonaccelconfid_ = value;
}
inline void AccelerationConfidence::set_lonaccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value) {
  _internal_set_lonaccelconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.AccelerationConfidence.lonAccelConfid)
}

// .cn.seisys.v2x.pb.AccelerationConfidence.AccConfidence latAccelConfid = 2;
inline void AccelerationConfidence::clear_lataccelconfid() {
  _impl_.lataccelconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence AccelerationConfidence::_internal_lataccelconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence >(_impl_.lataccelconfid_);
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence AccelerationConfidence::lataccelconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.AccelerationConfidence.latAccelConfid)
  return _internal_lataccelconfid();
}
inline void AccelerationConfidence::_internal_set_lataccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value) {
  
  _impl_.lataccelconfid_ = value;
}
inline void AccelerationConfidence::set_lataccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value) {
  _internal_set_lataccelconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.AccelerationConfidence.latAccelConfid)
}

// .cn.seisys.v2x.pb.AccelerationConfidence.AccConfidence verticalAccelConfid = 3;
inline void AccelerationConfidence::clear_verticalaccelconfid() {
  _impl_.verticalaccelconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence AccelerationConfidence::_internal_verticalaccelconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence >(_impl_.verticalaccelconfid_);
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence AccelerationConfidence::verticalaccelconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.AccelerationConfidence.verticalAccelConfid)
  return _internal_verticalaccelconfid();
}
inline void AccelerationConfidence::_internal_set_verticalaccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value) {
  
  _impl_.verticalaccelconfid_ = value;
}
inline void AccelerationConfidence::set_verticalaccelconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence value) {
  _internal_set_verticalaccelconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.AccelerationConfidence.verticalAccelConfid)
}

// .cn.seisys.v2x.pb.AccelerationConfidence.AngularVConfidence yawRateConfid = 4;
inline void AccelerationConfidence::clear_yawrateconfid() {
  _impl_.yawrateconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence AccelerationConfidence::_internal_yawrateconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence >(_impl_.yawrateconfid_);
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence AccelerationConfidence::yawrateconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.AccelerationConfidence.yawRateConfid)
  return _internal_yawrateconfid();
}
inline void AccelerationConfidence::_internal_set_yawrateconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence value) {
  
  _impl_.yawrateconfid_ = value;
}
inline void AccelerationConfidence::set_yawrateconfid(::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence value) {
  _internal_set_yawrateconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.AccelerationConfidence.yawRateConfid)
}

// -------------------------------------------------------------------

// MotionConfidenceSet

// .cn.seisys.v2x.pb.SpeedConfidence speedCfd = 1;
inline void MotionConfidenceSet::clear_speedcfd() {
  _impl_.speedcfd_ = 0;
}
inline ::cn::seisys::v2x::pb::SpeedConfidence MotionConfidenceSet::_internal_speedcfd() const {
  return static_cast< ::cn::seisys::v2x::pb::SpeedConfidence >(_impl_.speedcfd_);
}
inline ::cn::seisys::v2x::pb::SpeedConfidence MotionConfidenceSet::speedcfd() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MotionConfidenceSet.speedCfd)
  return _internal_speedcfd();
}
inline void MotionConfidenceSet::_internal_set_speedcfd(::cn::seisys::v2x::pb::SpeedConfidence value) {
  
  _impl_.speedcfd_ = value;
}
inline void MotionConfidenceSet::set_speedcfd(::cn::seisys::v2x::pb::SpeedConfidence value) {
  _internal_set_speedcfd(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MotionConfidenceSet.speedCfd)
}

// .cn.seisys.v2x.pb.HeadingConfidence headingCfd = 2;
inline void MotionConfidenceSet::clear_headingcfd() {
  _impl_.headingcfd_ = 0;
}
inline ::cn::seisys::v2x::pb::HeadingConfidence MotionConfidenceSet::_internal_headingcfd() const {
  return static_cast< ::cn::seisys::v2x::pb::HeadingConfidence >(_impl_.headingcfd_);
}
inline ::cn::seisys::v2x::pb::HeadingConfidence MotionConfidenceSet::headingcfd() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MotionConfidenceSet.headingCfd)
  return _internal_headingcfd();
}
inline void MotionConfidenceSet::_internal_set_headingcfd(::cn::seisys::v2x::pb::HeadingConfidence value) {
  
  _impl_.headingcfd_ = value;
}
inline void MotionConfidenceSet::set_headingcfd(::cn::seisys::v2x::pb::HeadingConfidence value) {
  _internal_set_headingcfd(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MotionConfidenceSet.headingCfd)
}

// .cn.seisys.v2x.pb.MotionConfidenceSet.SteeringWheelAngleConfidence steerCfd = 3;
inline void MotionConfidenceSet::clear_steercfd() {
  _impl_.steercfd_ = 0;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence MotionConfidenceSet::_internal_steercfd() const {
  return static_cast< ::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence >(_impl_.steercfd_);
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence MotionConfidenceSet::steercfd() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MotionConfidenceSet.steerCfd)
  return _internal_steercfd();
}
inline void MotionConfidenceSet::_internal_set_steercfd(::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence value) {
  
  _impl_.steercfd_ = value;
}
inline void MotionConfidenceSet::set_steercfd(::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence value) {
  _internal_set_steercfd(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MotionConfidenceSet.steerCfd)
}

// -------------------------------------------------------------------

// VehicleSize

// int32 width = 1;
inline void VehicleSize::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t VehicleSize::_internal_width() const {
  return _impl_.width_;
}
inline int32_t VehicleSize::width() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VehicleSize.width)
  return _internal_width();
}
inline void VehicleSize::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void VehicleSize::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.VehicleSize.width)
}

// int32 length = 2;
inline void VehicleSize::clear_length() {
  _impl_.length_ = 0;
}
inline int32_t VehicleSize::_internal_length() const {
  return _impl_.length_;
}
inline int32_t VehicleSize::length() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VehicleSize.length)
  return _internal_length();
}
inline void VehicleSize::_internal_set_length(int32_t value) {
  
  _impl_.length_ = value;
}
inline void VehicleSize::set_length(int32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.VehicleSize.length)
}

// int32 height = 3;
inline void VehicleSize::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t VehicleSize::_internal_height() const {
  return _impl_.height_;
}
inline int32_t VehicleSize::height() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VehicleSize.height)
  return _internal_height();
}
inline void VehicleSize::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void VehicleSize::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.VehicleSize.height)
}

// -------------------------------------------------------------------

// NodeReferenceId

// uint32 region = 1;
inline void NodeReferenceId::clear_region() {
  _impl_.region_ = 0u;
}
inline uint32_t NodeReferenceId::_internal_region() const {
  return _impl_.region_;
}
inline uint32_t NodeReferenceId::region() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeReferenceId.region)
  return _internal_region();
}
inline void NodeReferenceId::_internal_set_region(uint32_t value) {
  
  _impl_.region_ = value;
}
inline void NodeReferenceId::set_region(uint32_t value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeReferenceId.region)
}

// uint32 nodeId = 2;
inline void NodeReferenceId::clear_nodeid() {
  _impl_.nodeid_ = 0u;
}
inline uint32_t NodeReferenceId::_internal_nodeid() const {
  return _impl_.nodeid_;
}
inline uint32_t NodeReferenceId::nodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeReferenceId.nodeId)
  return _internal_nodeid();
}
inline void NodeReferenceId::_internal_set_nodeid(uint32_t value) {
  
  _impl_.nodeid_ = value;
}
inline void NodeReferenceId::set_nodeid(uint32_t value) {
  _internal_set_nodeid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeReferenceId.nodeId)
}

// -------------------------------------------------------------------

// MapLocation

// .cn.seisys.v2x.pb.NodeReferenceId nodeId = 1;
inline bool MapLocation::_internal_has_nodeid() const {
  return this != internal_default_instance() && _impl_.nodeid_ != nullptr;
}
inline bool MapLocation::has_nodeid() const {
  return _internal_has_nodeid();
}
inline void MapLocation::clear_nodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodeid_ != nullptr) {
    delete _impl_.nodeid_;
  }
  _impl_.nodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& MapLocation::_internal_nodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.nodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& MapLocation::nodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapLocation.nodeId)
  return _internal_nodeid();
}
inline void MapLocation::unsafe_arena_set_allocated_nodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodeid_);
  }
  _impl_.nodeid_ = nodeid;
  if (nodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.MapLocation.nodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MapLocation::release_nodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MapLocation::unsafe_arena_release_nodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MapLocation.nodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MapLocation::_internal_mutable_nodeid() {
  
  if (_impl_.nodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.nodeid_ = p;
  }
  return _impl_.nodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MapLocation::mutable_nodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MapLocation.nodeId)
  return _msg;
}
inline void MapLocation::set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodeid_;
  }
  if (nodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodeid);
    if (message_arena != submessage_arena) {
      nodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodeid_ = nodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MapLocation.nodeId)
}

// string linkName = 2;
inline void MapLocation::clear_linkname() {
  _impl_.linkname_.ClearToEmpty();
}
inline const std::string& MapLocation::linkname() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapLocation.linkName)
  return _internal_linkname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapLocation::set_linkname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.linkname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MapLocation.linkName)
}
inline std::string* MapLocation::mutable_linkname() {
  std::string* _s = _internal_mutable_linkname();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MapLocation.linkName)
  return _s;
}
inline const std::string& MapLocation::_internal_linkname() const {
  return _impl_.linkname_.Get();
}
inline void MapLocation::_internal_set_linkname(const std::string& value) {
  
  _impl_.linkname_.Set(value, GetArenaForAllocation());
}
inline std::string* MapLocation::_internal_mutable_linkname() {
  
  return _impl_.linkname_.Mutable(GetArenaForAllocation());
}
inline std::string* MapLocation::release_linkname() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MapLocation.linkName)
  return _impl_.linkname_.Release();
}
inline void MapLocation::set_allocated_linkname(std::string* linkname) {
  if (linkname != nullptr) {
    
  } else {
    
  }
  _impl_.linkname_.SetAllocated(linkname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.linkname_.IsDefault()) {
    _impl_.linkname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MapLocation.linkName)
}

// .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 3;
inline bool MapLocation::_internal_has_upstreamnodeid() const {
  return this != internal_default_instance() && _impl_.upstreamnodeid_ != nullptr;
}
inline bool MapLocation::has_upstreamnodeid() const {
  return _internal_has_upstreamnodeid();
}
inline void MapLocation::clear_upstreamnodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.upstreamnodeid_ != nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  _impl_.upstreamnodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& MapLocation::_internal_upstreamnodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.upstreamnodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& MapLocation::upstreamnodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapLocation.upstreamNodeId)
  return _internal_upstreamnodeid();
}
inline void MapLocation::unsafe_arena_set_allocated_upstreamnodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upstreamnodeid_);
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  if (upstreamnodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.MapLocation.upstreamNodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MapLocation::release_upstreamnodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MapLocation::unsafe_arena_release_upstreamnodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MapLocation.upstreamNodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MapLocation::_internal_mutable_upstreamnodeid() {
  
  if (_impl_.upstreamnodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.upstreamnodeid_ = p;
  }
  return _impl_.upstreamnodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MapLocation::mutable_upstreamnodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_upstreamnodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MapLocation.upstreamNodeId)
  return _msg;
}
inline void MapLocation::set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  if (upstreamnodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upstreamnodeid);
    if (message_arena != submessage_arena) {
      upstreamnodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upstreamnodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MapLocation.upstreamNodeId)
}

// uint32 sectionId = 4;
inline void MapLocation::clear_sectionid() {
  _impl_.sectionid_ = 0u;
}
inline uint32_t MapLocation::_internal_sectionid() const {
  return _impl_.sectionid_;
}
inline uint32_t MapLocation::sectionid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapLocation.sectionId)
  return _internal_sectionid();
}
inline void MapLocation::_internal_set_sectionid(uint32_t value) {
  
  _impl_.sectionid_ = value;
}
inline void MapLocation::set_sectionid(uint32_t value) {
  _internal_set_sectionid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MapLocation.sectionId)
}

// uint32 laneId = 5;
inline void MapLocation::clear_laneid() {
  _impl_.laneid_ = 0u;
}
inline uint32_t MapLocation::_internal_laneid() const {
  return _impl_.laneid_;
}
inline uint32_t MapLocation::laneid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapLocation.laneId)
  return _internal_laneid();
}
inline void MapLocation::_internal_set_laneid(uint32_t value) {
  
  _impl_.laneid_ = value;
}
inline void MapLocation::set_laneid(uint32_t value) {
  _internal_set_laneid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MapLocation.laneId)
}

// -------------------------------------------------------------------

// PhaseId

// uint32 phaseId = 1;
inline void PhaseId::clear_phaseid() {
  _impl_.phaseid_ = 0u;
}
inline uint32_t PhaseId::_internal_phaseid() const {
  return _impl_.phaseid_;
}
inline uint32_t PhaseId::phaseid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PhaseId.phaseId)
  return _internal_phaseid();
}
inline void PhaseId::_internal_set_phaseid(uint32_t value) {
  
  _impl_.phaseid_ = value;
}
inline void PhaseId::set_phaseid(uint32_t value) {
  _internal_set_phaseid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PhaseId.phaseId)
}

// -------------------------------------------------------------------

// ReferenceLanes

// uint32 referenceLanes = 1;
inline void ReferenceLanes::clear_referencelanes() {
  _impl_.referencelanes_ = 0u;
}
inline uint32_t ReferenceLanes::_internal_referencelanes() const {
  return _impl_.referencelanes_;
}
inline uint32_t ReferenceLanes::referencelanes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReferenceLanes.referenceLanes)
  return _internal_referencelanes();
}
inline void ReferenceLanes::_internal_set_referencelanes(uint32_t value) {
  
  _impl_.referencelanes_ = value;
}
inline void ReferenceLanes::set_referencelanes(uint32_t value) {
  _internal_set_referencelanes(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ReferenceLanes.referenceLanes)
}

// -------------------------------------------------------------------

// ReferencePath

// repeated .cn.seisys.v2x.pb.Position3D activePath = 1;
inline int ReferencePath::_internal_activepath_size() const {
  return _impl_.activepath_.size();
}
inline int ReferencePath::activepath_size() const {
  return _internal_activepath_size();
}
inline void ReferencePath::clear_activepath() {
  _impl_.activepath_.Clear();
}
inline ::cn::seisys::v2x::pb::Position3D* ReferencePath::mutable_activepath(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReferencePath.activePath)
  return _impl_.activepath_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
ReferencePath::mutable_activepath() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.ReferencePath.activePath)
  return &_impl_.activepath_;
}
inline const ::cn::seisys::v2x::pb::Position3D& ReferencePath::_internal_activepath(int index) const {
  return _impl_.activepath_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Position3D& ReferencePath::activepath(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReferencePath.activePath)
  return _internal_activepath(index);
}
inline ::cn::seisys::v2x::pb::Position3D* ReferencePath::_internal_add_activepath() {
  return _impl_.activepath_.Add();
}
inline ::cn::seisys::v2x::pb::Position3D* ReferencePath::add_activepath() {
  ::cn::seisys::v2x::pb::Position3D* _add = _internal_add_activepath();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.ReferencePath.activePath)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
ReferencePath::activepath() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.ReferencePath.activePath)
  return _impl_.activepath_;
}

// uint32 pathRadius = 2;
inline void ReferencePath::clear_pathradius() {
  _impl_.pathradius_ = 0u;
}
inline uint32_t ReferencePath::_internal_pathradius() const {
  return _impl_.pathradius_;
}
inline uint32_t ReferencePath::pathradius() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReferencePath.pathRadius)
  return _internal_pathradius();
}
inline void ReferencePath::_internal_set_pathradius(uint32_t value) {
  
  _impl_.pathradius_ = value;
}
inline void ReferencePath::set_pathradius(uint32_t value) {
  _internal_set_pathradius(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ReferencePath.pathRadius)
}

// -------------------------------------------------------------------

// ReferenceLink

// .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 1;
inline bool ReferenceLink::_internal_has_upstreamnodeid() const {
  return this != internal_default_instance() && _impl_.upstreamnodeid_ != nullptr;
}
inline bool ReferenceLink::has_upstreamnodeid() const {
  return _internal_has_upstreamnodeid();
}
inline void ReferenceLink::clear_upstreamnodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.upstreamnodeid_ != nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  _impl_.upstreamnodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReferenceLink::_internal_upstreamnodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.upstreamnodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReferenceLink::upstreamnodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReferenceLink.upstreamNodeId)
  return _internal_upstreamnodeid();
}
inline void ReferenceLink::unsafe_arena_set_allocated_upstreamnodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upstreamnodeid_);
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  if (upstreamnodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReferenceLink.upstreamNodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReferenceLink::release_upstreamnodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReferenceLink::unsafe_arena_release_upstreamnodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReferenceLink.upstreamNodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReferenceLink::_internal_mutable_upstreamnodeid() {
  
  if (_impl_.upstreamnodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.upstreamnodeid_ = p;
  }
  return _impl_.upstreamnodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReferenceLink::mutable_upstreamnodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_upstreamnodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReferenceLink.upstreamNodeId)
  return _msg;
}
inline void ReferenceLink::set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  if (upstreamnodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upstreamnodeid);
    if (message_arena != submessage_arena) {
      upstreamnodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upstreamnodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReferenceLink.upstreamNodeId)
}

// .cn.seisys.v2x.pb.NodeReferenceId downstreamNodeId = 2;
inline bool ReferenceLink::_internal_has_downstreamnodeid() const {
  return this != internal_default_instance() && _impl_.downstreamnodeid_ != nullptr;
}
inline bool ReferenceLink::has_downstreamnodeid() const {
  return _internal_has_downstreamnodeid();
}
inline void ReferenceLink::clear_downstreamnodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.downstreamnodeid_ != nullptr) {
    delete _impl_.downstreamnodeid_;
  }
  _impl_.downstreamnodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReferenceLink::_internal_downstreamnodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.downstreamnodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReferenceLink::downstreamnodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReferenceLink.downstreamNodeId)
  return _internal_downstreamnodeid();
}
inline void ReferenceLink::unsafe_arena_set_allocated_downstreamnodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* downstreamnodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.downstreamnodeid_);
  }
  _impl_.downstreamnodeid_ = downstreamnodeid;
  if (downstreamnodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReferenceLink.downstreamNodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReferenceLink::release_downstreamnodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.downstreamnodeid_;
  _impl_.downstreamnodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReferenceLink::unsafe_arena_release_downstreamnodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReferenceLink.downstreamNodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.downstreamnodeid_;
  _impl_.downstreamnodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReferenceLink::_internal_mutable_downstreamnodeid() {
  
  if (_impl_.downstreamnodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.downstreamnodeid_ = p;
  }
  return _impl_.downstreamnodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReferenceLink::mutable_downstreamnodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_downstreamnodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReferenceLink.downstreamNodeId)
  return _msg;
}
inline void ReferenceLink::set_allocated_downstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* downstreamnodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.downstreamnodeid_;
  }
  if (downstreamnodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(downstreamnodeid);
    if (message_arena != submessage_arena) {
      downstreamnodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, downstreamnodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.downstreamnodeid_ = downstreamnodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReferenceLink.downstreamNodeId)
}

// .cn.seisys.v2x.pb.ReferenceLanes referenceLanes = 3;
inline bool ReferenceLink::_internal_has_referencelanes() const {
  return this != internal_default_instance() && _impl_.referencelanes_ != nullptr;
}
inline bool ReferenceLink::has_referencelanes() const {
  return _internal_has_referencelanes();
}
inline void ReferenceLink::clear_referencelanes() {
  if (GetArenaForAllocation() == nullptr && _impl_.referencelanes_ != nullptr) {
    delete _impl_.referencelanes_;
  }
  _impl_.referencelanes_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ReferenceLanes& ReferenceLink::_internal_referencelanes() const {
  const ::cn::seisys::v2x::pb::ReferenceLanes* p = _impl_.referencelanes_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ReferenceLanes&>(
      ::cn::seisys::v2x::pb::_ReferenceLanes_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReferenceLanes& ReferenceLink::referencelanes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReferenceLink.referenceLanes)
  return _internal_referencelanes();
}
inline void ReferenceLink::unsafe_arena_set_allocated_referencelanes(
    ::cn::seisys::v2x::pb::ReferenceLanes* referencelanes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.referencelanes_);
  }
  _impl_.referencelanes_ = referencelanes;
  if (referencelanes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReferenceLink.referenceLanes)
}
inline ::cn::seisys::v2x::pb::ReferenceLanes* ReferenceLink::release_referencelanes() {
  
  ::cn::seisys::v2x::pb::ReferenceLanes* temp = _impl_.referencelanes_;
  _impl_.referencelanes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferenceLanes* ReferenceLink::unsafe_arena_release_referencelanes() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReferenceLink.referenceLanes)
  
  ::cn::seisys::v2x::pb::ReferenceLanes* temp = _impl_.referencelanes_;
  _impl_.referencelanes_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferenceLanes* ReferenceLink::_internal_mutable_referencelanes() {
  
  if (_impl_.referencelanes_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ReferenceLanes>(GetArenaForAllocation());
    _impl_.referencelanes_ = p;
  }
  return _impl_.referencelanes_;
}
inline ::cn::seisys::v2x::pb::ReferenceLanes* ReferenceLink::mutable_referencelanes() {
  ::cn::seisys::v2x::pb::ReferenceLanes* _msg = _internal_mutable_referencelanes();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReferenceLink.referenceLanes)
  return _msg;
}
inline void ReferenceLink::set_allocated_referencelanes(::cn::seisys::v2x::pb::ReferenceLanes* referencelanes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.referencelanes_;
  }
  if (referencelanes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(referencelanes);
    if (message_arena != submessage_arena) {
      referencelanes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, referencelanes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.referencelanes_ = referencelanes;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReferenceLink.referenceLanes)
}

// -------------------------------------------------------------------

// AllowedManeuvers

// uint32 maneuvers = 1;
inline void AllowedManeuvers::clear_maneuvers() {
  _impl_.maneuvers_ = 0u;
}
inline uint32_t AllowedManeuvers::_internal_maneuvers() const {
  return _impl_.maneuvers_;
}
inline uint32_t AllowedManeuvers::maneuvers() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.AllowedManeuvers.maneuvers)
  return _internal_maneuvers();
}
inline void AllowedManeuvers::_internal_set_maneuvers(uint32_t value) {
  
  _impl_.maneuvers_ = value;
}
inline void AllowedManeuvers::set_maneuvers(uint32_t value) {
  _internal_set_maneuvers(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.AllowedManeuvers.maneuvers)
}

// -------------------------------------------------------------------

// LaneStatInfo

// uint32 laneId = 1;
inline void LaneStatInfo::clear_laneid() {
  _impl_.laneid_ = 0u;
}
inline uint32_t LaneStatInfo::_internal_laneid() const {
  return _impl_.laneid_;
}
inline uint32_t LaneStatInfo::laneid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneStatInfo.laneId)
  return _internal_laneid();
}
inline void LaneStatInfo::_internal_set_laneid(uint32_t value) {
  
  _impl_.laneid_ = value;
}
inline void LaneStatInfo::set_laneid(uint32_t value) {
  _internal_set_laneid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneStatInfo.laneId)
}

// .cn.seisys.v2x.pb.LinkStatInfo linkStatInfo = 2;
inline bool LaneStatInfo::_internal_has_linkstatinfo() const {
  return this != internal_default_instance() && _impl_.linkstatinfo_ != nullptr;
}
inline bool LaneStatInfo::has_linkstatinfo() const {
  return _internal_has_linkstatinfo();
}
inline void LaneStatInfo::clear_linkstatinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.linkstatinfo_ != nullptr) {
    delete _impl_.linkstatinfo_;
  }
  _impl_.linkstatinfo_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LinkStatInfo& LaneStatInfo::_internal_linkstatinfo() const {
  const ::cn::seisys::v2x::pb::LinkStatInfo* p = _impl_.linkstatinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LinkStatInfo&>(
      ::cn::seisys::v2x::pb::_LinkStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LinkStatInfo& LaneStatInfo::linkstatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneStatInfo.linkStatInfo)
  return _internal_linkstatinfo();
}
inline void LaneStatInfo::unsafe_arena_set_allocated_linkstatinfo(
    ::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linkstatinfo_);
  }
  _impl_.linkstatinfo_ = linkstatinfo;
  if (linkstatinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneStatInfo.linkStatInfo)
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* LaneStatInfo::release_linkstatinfo() {
  
  ::cn::seisys::v2x::pb::LinkStatInfo* temp = _impl_.linkstatinfo_;
  _impl_.linkstatinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* LaneStatInfo::unsafe_arena_release_linkstatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneStatInfo.linkStatInfo)
  
  ::cn::seisys::v2x::pb::LinkStatInfo* temp = _impl_.linkstatinfo_;
  _impl_.linkstatinfo_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* LaneStatInfo::_internal_mutable_linkstatinfo() {
  
  if (_impl_.linkstatinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LinkStatInfo>(GetArenaForAllocation());
    _impl_.linkstatinfo_ = p;
  }
  return _impl_.linkstatinfo_;
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* LaneStatInfo::mutable_linkstatinfo() {
  ::cn::seisys::v2x::pb::LinkStatInfo* _msg = _internal_mutable_linkstatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneStatInfo.linkStatInfo)
  return _msg;
}
inline void LaneStatInfo::set_allocated_linkstatinfo(::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linkstatinfo_;
  }
  if (linkstatinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linkstatinfo);
    if (message_arena != submessage_arena) {
      linkstatinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linkstatinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linkstatinfo_ = linkstatinfo;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneStatInfo.linkStatInfo)
}

// .cn.seisys.v2x.pb.SectionStatInfo sectionStatInfo = 3;
inline bool LaneStatInfo::_internal_has_sectionstatinfo() const {
  return this != internal_default_instance() && _impl_.sectionstatinfo_ != nullptr;
}
inline bool LaneStatInfo::has_sectionstatinfo() const {
  return _internal_has_sectionstatinfo();
}
inline void LaneStatInfo::clear_sectionstatinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.sectionstatinfo_ != nullptr) {
    delete _impl_.sectionstatinfo_;
  }
  _impl_.sectionstatinfo_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::SectionStatInfo& LaneStatInfo::_internal_sectionstatinfo() const {
  const ::cn::seisys::v2x::pb::SectionStatInfo* p = _impl_.sectionstatinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::SectionStatInfo&>(
      ::cn::seisys::v2x::pb::_SectionStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::SectionStatInfo& LaneStatInfo::sectionstatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneStatInfo.sectionStatInfo)
  return _internal_sectionstatinfo();
}
inline void LaneStatInfo::unsafe_arena_set_allocated_sectionstatinfo(
    ::cn::seisys::v2x::pb::SectionStatInfo* sectionstatinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectionstatinfo_);
  }
  _impl_.sectionstatinfo_ = sectionstatinfo;
  if (sectionstatinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneStatInfo.sectionStatInfo)
}
inline ::cn::seisys::v2x::pb::SectionStatInfo* LaneStatInfo::release_sectionstatinfo() {
  
  ::cn::seisys::v2x::pb::SectionStatInfo* temp = _impl_.sectionstatinfo_;
  _impl_.sectionstatinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::SectionStatInfo* LaneStatInfo::unsafe_arena_release_sectionstatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneStatInfo.sectionStatInfo)
  
  ::cn::seisys::v2x::pb::SectionStatInfo* temp = _impl_.sectionstatinfo_;
  _impl_.sectionstatinfo_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::SectionStatInfo* LaneStatInfo::_internal_mutable_sectionstatinfo() {
  
  if (_impl_.sectionstatinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::SectionStatInfo>(GetArenaForAllocation());
    _impl_.sectionstatinfo_ = p;
  }
  return _impl_.sectionstatinfo_;
}
inline ::cn::seisys::v2x::pb::SectionStatInfo* LaneStatInfo::mutable_sectionstatinfo() {
  ::cn::seisys::v2x::pb::SectionStatInfo* _msg = _internal_mutable_sectionstatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneStatInfo.sectionStatInfo)
  return _msg;
}
inline void LaneStatInfo::set_allocated_sectionstatinfo(::cn::seisys::v2x::pb::SectionStatInfo* sectionstatinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectionstatinfo_;
  }
  if (sectionstatinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectionstatinfo);
    if (message_arena != submessage_arena) {
      sectionstatinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectionstatinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sectionstatinfo_ = sectionstatinfo;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneStatInfo.sectionStatInfo)
}

// string extId = 4;
inline void LaneStatInfo::clear_extid() {
  _impl_.extid_.ClearToEmpty();
}
inline const std::string& LaneStatInfo::extid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneStatInfo.extId)
  return _internal_extid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LaneStatInfo::set_extid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneStatInfo.extId)
}
inline std::string* LaneStatInfo::mutable_extid() {
  std::string* _s = _internal_mutable_extid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneStatInfo.extId)
  return _s;
}
inline const std::string& LaneStatInfo::_internal_extid() const {
  return _impl_.extid_.Get();
}
inline void LaneStatInfo::_internal_set_extid(const std::string& value) {
  
  _impl_.extid_.Set(value, GetArenaForAllocation());
}
inline std::string* LaneStatInfo::_internal_mutable_extid() {
  
  return _impl_.extid_.Mutable(GetArenaForAllocation());
}
inline std::string* LaneStatInfo::release_extid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneStatInfo.extId)
  return _impl_.extid_.Release();
}
inline void LaneStatInfo::set_allocated_extid(std::string* extid) {
  if (extid != nullptr) {
    
  } else {
    
  }
  _impl_.extid_.SetAllocated(extid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extid_.IsDefault()) {
    _impl_.extid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneStatInfo.extId)
}

// -------------------------------------------------------------------

// SectionStatInfo

// uint32 sectionId = 1;
inline void SectionStatInfo::clear_sectionid() {
  _impl_.sectionid_ = 0u;
}
inline uint32_t SectionStatInfo::_internal_sectionid() const {
  return _impl_.sectionid_;
}
inline uint32_t SectionStatInfo::sectionid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SectionStatInfo.sectionId)
  return _internal_sectionid();
}
inline void SectionStatInfo::_internal_set_sectionid(uint32_t value) {
  
  _impl_.sectionid_ = value;
}
inline void SectionStatInfo::set_sectionid(uint32_t value) {
  _internal_set_sectionid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SectionStatInfo.sectionId)
}

// .cn.seisys.v2x.pb.LinkStatInfo linkStatInfo = 2;
inline bool SectionStatInfo::_internal_has_linkstatinfo() const {
  return this != internal_default_instance() && _impl_.linkstatinfo_ != nullptr;
}
inline bool SectionStatInfo::has_linkstatinfo() const {
  return _internal_has_linkstatinfo();
}
inline void SectionStatInfo::clear_linkstatinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.linkstatinfo_ != nullptr) {
    delete _impl_.linkstatinfo_;
  }
  _impl_.linkstatinfo_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LinkStatInfo& SectionStatInfo::_internal_linkstatinfo() const {
  const ::cn::seisys::v2x::pb::LinkStatInfo* p = _impl_.linkstatinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LinkStatInfo&>(
      ::cn::seisys::v2x::pb::_LinkStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LinkStatInfo& SectionStatInfo::linkstatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SectionStatInfo.linkStatInfo)
  return _internal_linkstatinfo();
}
inline void SectionStatInfo::unsafe_arena_set_allocated_linkstatinfo(
    ::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linkstatinfo_);
  }
  _impl_.linkstatinfo_ = linkstatinfo;
  if (linkstatinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.SectionStatInfo.linkStatInfo)
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* SectionStatInfo::release_linkstatinfo() {
  
  ::cn::seisys::v2x::pb::LinkStatInfo* temp = _impl_.linkstatinfo_;
  _impl_.linkstatinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* SectionStatInfo::unsafe_arena_release_linkstatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.SectionStatInfo.linkStatInfo)
  
  ::cn::seisys::v2x::pb::LinkStatInfo* temp = _impl_.linkstatinfo_;
  _impl_.linkstatinfo_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* SectionStatInfo::_internal_mutable_linkstatinfo() {
  
  if (_impl_.linkstatinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LinkStatInfo>(GetArenaForAllocation());
    _impl_.linkstatinfo_ = p;
  }
  return _impl_.linkstatinfo_;
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* SectionStatInfo::mutable_linkstatinfo() {
  ::cn::seisys::v2x::pb::LinkStatInfo* _msg = _internal_mutable_linkstatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.SectionStatInfo.linkStatInfo)
  return _msg;
}
inline void SectionStatInfo::set_allocated_linkstatinfo(::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.linkstatinfo_;
  }
  if (linkstatinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linkstatinfo);
    if (message_arena != submessage_arena) {
      linkstatinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linkstatinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.linkstatinfo_ = linkstatinfo;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.SectionStatInfo.linkStatInfo)
}

// string extId = 3;
inline void SectionStatInfo::clear_extid() {
  _impl_.extid_.ClearToEmpty();
}
inline const std::string& SectionStatInfo::extid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SectionStatInfo.extId)
  return _internal_extid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SectionStatInfo::set_extid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SectionStatInfo.extId)
}
inline std::string* SectionStatInfo::mutable_extid() {
  std::string* _s = _internal_mutable_extid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.SectionStatInfo.extId)
  return _s;
}
inline const std::string& SectionStatInfo::_internal_extid() const {
  return _impl_.extid_.Get();
}
inline void SectionStatInfo::_internal_set_extid(const std::string& value) {
  
  _impl_.extid_.Set(value, GetArenaForAllocation());
}
inline std::string* SectionStatInfo::_internal_mutable_extid() {
  
  return _impl_.extid_.Mutable(GetArenaForAllocation());
}
inline std::string* SectionStatInfo::release_extid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.SectionStatInfo.extId)
  return _impl_.extid_.Release();
}
inline void SectionStatInfo::set_allocated_extid(std::string* extid) {
  if (extid != nullptr) {
    
  } else {
    
  }
  _impl_.extid_.SetAllocated(extid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extid_.IsDefault()) {
    _impl_.extid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.SectionStatInfo.extId)
}

// -------------------------------------------------------------------

// LinkStatInfo

// .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 1;
inline bool LinkStatInfo::_internal_has_upstreamnodeid() const {
  return this != internal_default_instance() && _impl_.upstreamnodeid_ != nullptr;
}
inline bool LinkStatInfo::has_upstreamnodeid() const {
  return _internal_has_upstreamnodeid();
}
inline void LinkStatInfo::clear_upstreamnodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.upstreamnodeid_ != nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  _impl_.upstreamnodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& LinkStatInfo::_internal_upstreamnodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.upstreamnodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& LinkStatInfo::upstreamnodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkStatInfo.upstreamNodeId)
  return _internal_upstreamnodeid();
}
inline void LinkStatInfo::unsafe_arena_set_allocated_upstreamnodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upstreamnodeid_);
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  if (upstreamnodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LinkStatInfo.upstreamNodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* LinkStatInfo::release_upstreamnodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* LinkStatInfo::unsafe_arena_release_upstreamnodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LinkStatInfo.upstreamNodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* LinkStatInfo::_internal_mutable_upstreamnodeid() {
  
  if (_impl_.upstreamnodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.upstreamnodeid_ = p;
  }
  return _impl_.upstreamnodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* LinkStatInfo::mutable_upstreamnodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_upstreamnodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkStatInfo.upstreamNodeId)
  return _msg;
}
inline void LinkStatInfo::set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  if (upstreamnodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upstreamnodeid);
    if (message_arena != submessage_arena) {
      upstreamnodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upstreamnodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LinkStatInfo.upstreamNodeId)
}

// string name = 2;
inline void LinkStatInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LinkStatInfo::name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkStatInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinkStatInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkStatInfo.name)
}
inline std::string* LinkStatInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkStatInfo.name)
  return _s;
}
inline const std::string& LinkStatInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LinkStatInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LinkStatInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LinkStatInfo::release_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LinkStatInfo.name)
  return _impl_.name_.Release();
}
inline void LinkStatInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LinkStatInfo.name)
}

// .cn.seisys.v2x.pb.NodeStatInfo nodeStatInfo = 3;
inline bool LinkStatInfo::_internal_has_nodestatinfo() const {
  return this != internal_default_instance() && _impl_.nodestatinfo_ != nullptr;
}
inline bool LinkStatInfo::has_nodestatinfo() const {
  return _internal_has_nodestatinfo();
}
inline void LinkStatInfo::clear_nodestatinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodestatinfo_ != nullptr) {
    delete _impl_.nodestatinfo_;
  }
  _impl_.nodestatinfo_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeStatInfo& LinkStatInfo::_internal_nodestatinfo() const {
  const ::cn::seisys::v2x::pb::NodeStatInfo* p = _impl_.nodestatinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeStatInfo&>(
      ::cn::seisys::v2x::pb::_NodeStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeStatInfo& LinkStatInfo::nodestatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkStatInfo.nodeStatInfo)
  return _internal_nodestatinfo();
}
inline void LinkStatInfo::unsafe_arena_set_allocated_nodestatinfo(
    ::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodestatinfo_);
  }
  _impl_.nodestatinfo_ = nodestatinfo;
  if (nodestatinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LinkStatInfo.nodeStatInfo)
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* LinkStatInfo::release_nodestatinfo() {
  
  ::cn::seisys::v2x::pb::NodeStatInfo* temp = _impl_.nodestatinfo_;
  _impl_.nodestatinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* LinkStatInfo::unsafe_arena_release_nodestatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LinkStatInfo.nodeStatInfo)
  
  ::cn::seisys::v2x::pb::NodeStatInfo* temp = _impl_.nodestatinfo_;
  _impl_.nodestatinfo_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* LinkStatInfo::_internal_mutable_nodestatinfo() {
  
  if (_impl_.nodestatinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeStatInfo>(GetArenaForAllocation());
    _impl_.nodestatinfo_ = p;
  }
  return _impl_.nodestatinfo_;
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* LinkStatInfo::mutable_nodestatinfo() {
  ::cn::seisys::v2x::pb::NodeStatInfo* _msg = _internal_mutable_nodestatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkStatInfo.nodeStatInfo)
  return _msg;
}
inline void LinkStatInfo::set_allocated_nodestatinfo(::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodestatinfo_;
  }
  if (nodestatinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodestatinfo);
    if (message_arena != submessage_arena) {
      nodestatinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodestatinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodestatinfo_ = nodestatinfo;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LinkStatInfo.nodeStatInfo)
}

// string extId = 4;
inline void LinkStatInfo::clear_extid() {
  _impl_.extid_.ClearToEmpty();
}
inline const std::string& LinkStatInfo::extid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkStatInfo.extId)
  return _internal_extid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinkStatInfo::set_extid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkStatInfo.extId)
}
inline std::string* LinkStatInfo::mutable_extid() {
  std::string* _s = _internal_mutable_extid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkStatInfo.extId)
  return _s;
}
inline const std::string& LinkStatInfo::_internal_extid() const {
  return _impl_.extid_.Get();
}
inline void LinkStatInfo::_internal_set_extid(const std::string& value) {
  
  _impl_.extid_.Set(value, GetArenaForAllocation());
}
inline std::string* LinkStatInfo::_internal_mutable_extid() {
  
  return _impl_.extid_.Mutable(GetArenaForAllocation());
}
inline std::string* LinkStatInfo::release_extid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LinkStatInfo.extId)
  return _impl_.extid_.Release();
}
inline void LinkStatInfo::set_allocated_extid(std::string* extid) {
  if (extid != nullptr) {
    
  } else {
    
  }
  _impl_.extid_.SetAllocated(extid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extid_.IsDefault()) {
    _impl_.extid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LinkStatInfo.extId)
}

// -------------------------------------------------------------------

// NodeStatInfo

// .cn.seisys.v2x.pb.NodeReferenceId nodeId = 1;
inline bool NodeStatInfo::_internal_has_nodeid() const {
  return this != internal_default_instance() && _impl_.nodeid_ != nullptr;
}
inline bool NodeStatInfo::has_nodeid() const {
  return _internal_has_nodeid();
}
inline void NodeStatInfo::clear_nodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodeid_ != nullptr) {
    delete _impl_.nodeid_;
  }
  _impl_.nodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& NodeStatInfo::_internal_nodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.nodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& NodeStatInfo::nodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeStatInfo.nodeId)
  return _internal_nodeid();
}
inline void NodeStatInfo::unsafe_arena_set_allocated_nodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodeid_);
  }
  _impl_.nodeid_ = nodeid;
  if (nodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.NodeStatInfo.nodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* NodeStatInfo::release_nodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* NodeStatInfo::unsafe_arena_release_nodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.NodeStatInfo.nodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* NodeStatInfo::_internal_mutable_nodeid() {
  
  if (_impl_.nodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.nodeid_ = p;
  }
  return _impl_.nodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* NodeStatInfo::mutable_nodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.NodeStatInfo.nodeId)
  return _msg;
}
inline void NodeStatInfo::set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodeid_;
  }
  if (nodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodeid);
    if (message_arena != submessage_arena) {
      nodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodeid_ = nodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.NodeStatInfo.nodeId)
}

// -------------------------------------------------------------------

// MovementStatInfo

// .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
inline bool MovementStatInfo::_internal_has_remoteintersection() const {
  return this != internal_default_instance() && _impl_.remoteintersection_ != nullptr;
}
inline bool MovementStatInfo::has_remoteintersection() const {
  return _internal_has_remoteintersection();
}
inline void MovementStatInfo::clear_remoteintersection() {
  if (GetArenaForAllocation() == nullptr && _impl_.remoteintersection_ != nullptr) {
    delete _impl_.remoteintersection_;
  }
  _impl_.remoteintersection_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& MovementStatInfo::_internal_remoteintersection() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.remoteintersection_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& MovementStatInfo::remoteintersection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementStatInfo.remoteIntersection)
  return _internal_remoteintersection();
}
inline void MovementStatInfo::unsafe_arena_set_allocated_remoteintersection(
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remoteintersection_);
  }
  _impl_.remoteintersection_ = remoteintersection;
  if (remoteintersection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.MovementStatInfo.remoteIntersection)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MovementStatInfo::release_remoteintersection() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MovementStatInfo::unsafe_arena_release_remoteintersection() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MovementStatInfo.remoteIntersection)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MovementStatInfo::_internal_mutable_remoteintersection() {
  
  if (_impl_.remoteintersection_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.remoteintersection_ = p;
  }
  return _impl_.remoteintersection_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MovementStatInfo::mutable_remoteintersection() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_remoteintersection();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MovementStatInfo.remoteIntersection)
  return _msg;
}
inline void MovementStatInfo::set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remoteintersection_;
  }
  if (remoteintersection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remoteintersection);
    if (message_arena != submessage_arena) {
      remoteintersection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remoteintersection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remoteintersection_ = remoteintersection;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MovementStatInfo.remoteIntersection)
}

// .cn.seisys.v2x.pb.Maneuver turnDirection = 2;
inline void MovementStatInfo::clear_turndirection() {
  _impl_.turndirection_ = 0;
}
inline ::cn::seisys::v2x::pb::Maneuver MovementStatInfo::_internal_turndirection() const {
  return static_cast< ::cn::seisys::v2x::pb::Maneuver >(_impl_.turndirection_);
}
inline ::cn::seisys::v2x::pb::Maneuver MovementStatInfo::turndirection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementStatInfo.turnDirection)
  return _internal_turndirection();
}
inline void MovementStatInfo::_internal_set_turndirection(::cn::seisys::v2x::pb::Maneuver value) {
  
  _impl_.turndirection_ = value;
}
inline void MovementStatInfo::set_turndirection(::cn::seisys::v2x::pb::Maneuver value) {
  _internal_set_turndirection(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementStatInfo.turnDirection)
}

// .cn.seisys.v2x.pb.NodeStatInfo nodeStatInfo = 3;
inline bool MovementStatInfo::_internal_has_nodestatinfo() const {
  return this != internal_default_instance() && _impl_.nodestatinfo_ != nullptr;
}
inline bool MovementStatInfo::has_nodestatinfo() const {
  return _internal_has_nodestatinfo();
}
inline void MovementStatInfo::clear_nodestatinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodestatinfo_ != nullptr) {
    delete _impl_.nodestatinfo_;
  }
  _impl_.nodestatinfo_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeStatInfo& MovementStatInfo::_internal_nodestatinfo() const {
  const ::cn::seisys::v2x::pb::NodeStatInfo* p = _impl_.nodestatinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeStatInfo&>(
      ::cn::seisys::v2x::pb::_NodeStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeStatInfo& MovementStatInfo::nodestatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementStatInfo.nodeStatInfo)
  return _internal_nodestatinfo();
}
inline void MovementStatInfo::unsafe_arena_set_allocated_nodestatinfo(
    ::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodestatinfo_);
  }
  _impl_.nodestatinfo_ = nodestatinfo;
  if (nodestatinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.MovementStatInfo.nodeStatInfo)
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* MovementStatInfo::release_nodestatinfo() {
  
  ::cn::seisys::v2x::pb::NodeStatInfo* temp = _impl_.nodestatinfo_;
  _impl_.nodestatinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* MovementStatInfo::unsafe_arena_release_nodestatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MovementStatInfo.nodeStatInfo)
  
  ::cn::seisys::v2x::pb::NodeStatInfo* temp = _impl_.nodestatinfo_;
  _impl_.nodestatinfo_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* MovementStatInfo::_internal_mutable_nodestatinfo() {
  
  if (_impl_.nodestatinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeStatInfo>(GetArenaForAllocation());
    _impl_.nodestatinfo_ = p;
  }
  return _impl_.nodestatinfo_;
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* MovementStatInfo::mutable_nodestatinfo() {
  ::cn::seisys::v2x::pb::NodeStatInfo* _msg = _internal_mutable_nodestatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MovementStatInfo.nodeStatInfo)
  return _msg;
}
inline void MovementStatInfo::set_allocated_nodestatinfo(::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodestatinfo_;
  }
  if (nodestatinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodestatinfo);
    if (message_arena != submessage_arena) {
      nodestatinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodestatinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodestatinfo_ = nodestatinfo;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MovementStatInfo.nodeStatInfo)
}

// string extId = 4;
inline void MovementStatInfo::clear_extid() {
  _impl_.extid_.ClearToEmpty();
}
inline const std::string& MovementStatInfo::extid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementStatInfo.extId)
  return _internal_extid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MovementStatInfo::set_extid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementStatInfo.extId)
}
inline std::string* MovementStatInfo::mutable_extid() {
  std::string* _s = _internal_mutable_extid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MovementStatInfo.extId)
  return _s;
}
inline const std::string& MovementStatInfo::_internal_extid() const {
  return _impl_.extid_.Get();
}
inline void MovementStatInfo::_internal_set_extid(const std::string& value) {
  
  _impl_.extid_.Set(value, GetArenaForAllocation());
}
inline std::string* MovementStatInfo::_internal_mutable_extid() {
  
  return _impl_.extid_.Mutable(GetArenaForAllocation());
}
inline std::string* MovementStatInfo::release_extid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MovementStatInfo.extId)
  return _impl_.extid_.Release();
}
inline void MovementStatInfo::set_allocated_extid(std::string* extid) {
  if (extid != nullptr) {
    
  } else {
    
  }
  _impl_.extid_.SetAllocated(extid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extid_.IsDefault()) {
    _impl_.extid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MovementStatInfo.extId)
}

// -------------------------------------------------------------------

// TrafficFlowStatByInterval

// uint32 interval = 1;
inline void TrafficFlowStatByInterval::clear_interval() {
  _impl_.interval_ = 0u;
}
inline uint32_t TrafficFlowStatByInterval::_internal_interval() const {
  return _impl_.interval_;
}
inline uint32_t TrafficFlowStatByInterval::interval() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatByInterval.interval)
  return _internal_interval();
}
inline void TrafficFlowStatByInterval::_internal_set_interval(uint32_t value) {
  
  _impl_.interval_ = value;
}
inline void TrafficFlowStatByInterval::set_interval(uint32_t value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStatByInterval.interval)
}

// -------------------------------------------------------------------

// TrafficFlowStatBySignalCycle

// uint64 cycleStartTime = 1;
inline void TrafficFlowStatBySignalCycle::clear_cyclestarttime() {
  _impl_.cyclestarttime_ = uint64_t{0u};
}
inline uint64_t TrafficFlowStatBySignalCycle::_internal_cyclestarttime() const {
  return _impl_.cyclestarttime_;
}
inline uint64_t TrafficFlowStatBySignalCycle::cyclestarttime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle.cycleStartTime)
  return _internal_cyclestarttime();
}
inline void TrafficFlowStatBySignalCycle::_internal_set_cyclestarttime(uint64_t value) {
  
  _impl_.cyclestarttime_ = value;
}
inline void TrafficFlowStatBySignalCycle::set_cyclestarttime(uint64_t value) {
  _internal_set_cyclestarttime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle.cycleStartTime)
}

// uint64 cycleEndTime = 2;
inline void TrafficFlowStatBySignalCycle::clear_cycleendtime() {
  _impl_.cycleendtime_ = uint64_t{0u};
}
inline uint64_t TrafficFlowStatBySignalCycle::_internal_cycleendtime() const {
  return _impl_.cycleendtime_;
}
inline uint64_t TrafficFlowStatBySignalCycle::cycleendtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle.cycleEndTime)
  return _internal_cycleendtime();
}
inline void TrafficFlowStatBySignalCycle::_internal_set_cycleendtime(uint64_t value) {
  
  _impl_.cycleendtime_ = value;
}
inline void TrafficFlowStatBySignalCycle::set_cycleendtime(uint64_t value) {
  _internal_set_cycleendtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle.cycleEndTime)
}

// uint32 cycleTime = 3;
inline void TrafficFlowStatBySignalCycle::clear_cycletime() {
  _impl_.cycletime_ = 0u;
}
inline uint32_t TrafficFlowStatBySignalCycle::_internal_cycletime() const {
  return _impl_.cycletime_;
}
inline uint32_t TrafficFlowStatBySignalCycle::cycletime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle.cycleTime)
  return _internal_cycletime();
}
inline void TrafficFlowStatBySignalCycle::_internal_set_cycletime(uint32_t value) {
  
  _impl_.cycletime_ = value;
}
inline void TrafficFlowStatBySignalCycle::set_cycletime(uint32_t value) {
  _internal_set_cycletime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle.cycleTime)
}

// -------------------------------------------------------------------

// TrafficFlowStatType

// .cn.seisys.v2x.pb.TrafficFlowStatByInterval interval = 1;
inline bool TrafficFlowStatType::_internal_has_interval() const {
  return this != internal_default_instance() && _impl_.interval_ != nullptr;
}
inline bool TrafficFlowStatType::has_interval() const {
  return _internal_has_interval();
}
inline void TrafficFlowStatType::clear_interval() {
  if (GetArenaForAllocation() == nullptr && _impl_.interval_ != nullptr) {
    delete _impl_.interval_;
  }
  _impl_.interval_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStatByInterval& TrafficFlowStatType::_internal_interval() const {
  const ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::TrafficFlowStatByInterval&>(
      ::cn::seisys::v2x::pb::_TrafficFlowStatByInterval_default_instance_);
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStatByInterval& TrafficFlowStatType::interval() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatType.interval)
  return _internal_interval();
}
inline void TrafficFlowStatType::unsafe_arena_set_allocated_interval(
    ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatType.interval)
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* TrafficFlowStatType::release_interval() {
  
  ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* TrafficFlowStatType::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStatType.interval)
  
  ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* TrafficFlowStatType::_internal_mutable_interval() {
  
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowStatByInterval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* TrafficFlowStatType::mutable_interval() {
  ::cn::seisys::v2x::pb::TrafficFlowStatByInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStatType.interval)
  return _msg;
}
inline void TrafficFlowStatType::set_allocated_interval(::cn::seisys::v2x::pb::TrafficFlowStatByInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.interval_;
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interval);
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatType.interval)
}

// .cn.seisys.v2x.pb.TrafficFlowStatBySignalCycle sequence = 2;
inline bool TrafficFlowStatType::_internal_has_sequence() const {
  return this != internal_default_instance() && _impl_.sequence_ != nullptr;
}
inline bool TrafficFlowStatType::has_sequence() const {
  return _internal_has_sequence();
}
inline void TrafficFlowStatType::clear_sequence() {
  if (GetArenaForAllocation() == nullptr && _impl_.sequence_ != nullptr) {
    delete _impl_.sequence_;
  }
  _impl_.sequence_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle& TrafficFlowStatType::_internal_sequence() const {
  const ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* p = _impl_.sequence_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle&>(
      ::cn::seisys::v2x::pb::_TrafficFlowStatBySignalCycle_default_instance_);
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle& TrafficFlowStatType::sequence() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatType.sequence)
  return _internal_sequence();
}
inline void TrafficFlowStatType::unsafe_arena_set_allocated_sequence(
    ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* sequence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sequence_);
  }
  _impl_.sequence_ = sequence;
  if (sequence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatType.sequence)
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* TrafficFlowStatType::release_sequence() {
  
  ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* temp = _impl_.sequence_;
  _impl_.sequence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* TrafficFlowStatType::unsafe_arena_release_sequence() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStatType.sequence)
  
  ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* temp = _impl_.sequence_;
  _impl_.sequence_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* TrafficFlowStatType::_internal_mutable_sequence() {
  
  if (_impl_.sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle>(GetArenaForAllocation());
    _impl_.sequence_ = p;
  }
  return _impl_.sequence_;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* TrafficFlowStatType::mutable_sequence() {
  ::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* _msg = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStatType.sequence)
  return _msg;
}
inline void TrafficFlowStatType::set_allocated_sequence(::cn::seisys::v2x::pb::TrafficFlowStatBySignalCycle* sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sequence_;
  }
  if (sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sequence);
    if (message_arena != submessage_arena) {
      sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sequence_ = sequence;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatType.sequence)
}

// -------------------------------------------------------------------

// TrafficFlowStatMapElement

// .cn.seisys.v2x.pb.DetectorArea detectorArea = 1;
inline bool TrafficFlowStatMapElement::_internal_has_detectorarea() const {
  return TrafficFlowStatMapElementOneOf_case() == kDetectorArea;
}
inline bool TrafficFlowStatMapElement::has_detectorarea() const {
  return _internal_has_detectorarea();
}
inline void TrafficFlowStatMapElement::set_has_detectorarea() {
  _impl_._oneof_case_[0] = kDetectorArea;
}
inline void TrafficFlowStatMapElement::clear_detectorarea() {
  if (_internal_has_detectorarea()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.TrafficFlowStatMapElementOneOf_.detectorarea_;
    }
    clear_has_TrafficFlowStatMapElementOneOf();
  }
}
inline ::cn::seisys::v2x::pb::DetectorArea* TrafficFlowStatMapElement::release_detectorarea() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.detectorArea)
  if (_internal_has_detectorarea()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::DetectorArea* temp = _impl_.TrafficFlowStatMapElementOneOf_.detectorarea_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.TrafficFlowStatMapElementOneOf_.detectorarea_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::DetectorArea& TrafficFlowStatMapElement::_internal_detectorarea() const {
  return _internal_has_detectorarea()
      ? *_impl_.TrafficFlowStatMapElementOneOf_.detectorarea_
      : reinterpret_cast< ::cn::seisys::v2x::pb::DetectorArea&>(::cn::seisys::v2x::pb::_DetectorArea_default_instance_);
}
inline const ::cn::seisys::v2x::pb::DetectorArea& TrafficFlowStatMapElement::detectorarea() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatMapElement.detectorArea)
  return _internal_detectorarea();
}
inline ::cn::seisys::v2x::pb::DetectorArea* TrafficFlowStatMapElement::unsafe_arena_release_detectorarea() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.detectorArea)
  if (_internal_has_detectorarea()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::DetectorArea* temp = _impl_.TrafficFlowStatMapElementOneOf_.detectorarea_;
    _impl_.TrafficFlowStatMapElementOneOf_.detectorarea_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficFlowStatMapElement::unsafe_arena_set_allocated_detectorarea(::cn::seisys::v2x::pb::DetectorArea* detectorarea) {
  clear_TrafficFlowStatMapElementOneOf();
  if (detectorarea) {
    set_has_detectorarea();
    _impl_.TrafficFlowStatMapElementOneOf_.detectorarea_ = detectorarea;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatMapElement.detectorArea)
}
inline ::cn::seisys::v2x::pb::DetectorArea* TrafficFlowStatMapElement::_internal_mutable_detectorarea() {
  if (!_internal_has_detectorarea()) {
    clear_TrafficFlowStatMapElementOneOf();
    set_has_detectorarea();
    _impl_.TrafficFlowStatMapElementOneOf_.detectorarea_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::DetectorArea >(GetArenaForAllocation());
  }
  return _impl_.TrafficFlowStatMapElementOneOf_.detectorarea_;
}
inline ::cn::seisys::v2x::pb::DetectorArea* TrafficFlowStatMapElement::mutable_detectorarea() {
  ::cn::seisys::v2x::pb::DetectorArea* _msg = _internal_mutable_detectorarea();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStatMapElement.detectorArea)
  return _msg;
}

// .cn.seisys.v2x.pb.LaneStatInfo laneStatInfo = 2;
inline bool TrafficFlowStatMapElement::_internal_has_lanestatinfo() const {
  return TrafficFlowStatMapElementOneOf_case() == kLaneStatInfo;
}
inline bool TrafficFlowStatMapElement::has_lanestatinfo() const {
  return _internal_has_lanestatinfo();
}
inline void TrafficFlowStatMapElement::set_has_lanestatinfo() {
  _impl_._oneof_case_[0] = kLaneStatInfo;
}
inline void TrafficFlowStatMapElement::clear_lanestatinfo() {
  if (_internal_has_lanestatinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.TrafficFlowStatMapElementOneOf_.lanestatinfo_;
    }
    clear_has_TrafficFlowStatMapElementOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LaneStatInfo* TrafficFlowStatMapElement::release_lanestatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.laneStatInfo)
  if (_internal_has_lanestatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::LaneStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.lanestatinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.TrafficFlowStatMapElementOneOf_.lanestatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LaneStatInfo& TrafficFlowStatMapElement::_internal_lanestatinfo() const {
  return _internal_has_lanestatinfo()
      ? *_impl_.TrafficFlowStatMapElementOneOf_.lanestatinfo_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LaneStatInfo&>(::cn::seisys::v2x::pb::_LaneStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneStatInfo& TrafficFlowStatMapElement::lanestatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatMapElement.laneStatInfo)
  return _internal_lanestatinfo();
}
inline ::cn::seisys::v2x::pb::LaneStatInfo* TrafficFlowStatMapElement::unsafe_arena_release_lanestatinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.laneStatInfo)
  if (_internal_has_lanestatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::LaneStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.lanestatinfo_;
    _impl_.TrafficFlowStatMapElementOneOf_.lanestatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficFlowStatMapElement::unsafe_arena_set_allocated_lanestatinfo(::cn::seisys::v2x::pb::LaneStatInfo* lanestatinfo) {
  clear_TrafficFlowStatMapElementOneOf();
  if (lanestatinfo) {
    set_has_lanestatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.lanestatinfo_ = lanestatinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatMapElement.laneStatInfo)
}
inline ::cn::seisys::v2x::pb::LaneStatInfo* TrafficFlowStatMapElement::_internal_mutable_lanestatinfo() {
  if (!_internal_has_lanestatinfo()) {
    clear_TrafficFlowStatMapElementOneOf();
    set_has_lanestatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.lanestatinfo_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LaneStatInfo >(GetArenaForAllocation());
  }
  return _impl_.TrafficFlowStatMapElementOneOf_.lanestatinfo_;
}
inline ::cn::seisys::v2x::pb::LaneStatInfo* TrafficFlowStatMapElement::mutable_lanestatinfo() {
  ::cn::seisys::v2x::pb::LaneStatInfo* _msg = _internal_mutable_lanestatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStatMapElement.laneStatInfo)
  return _msg;
}

// .cn.seisys.v2x.pb.SectionStatInfo sectionStatInfo = 3;
inline bool TrafficFlowStatMapElement::_internal_has_sectionstatinfo() const {
  return TrafficFlowStatMapElementOneOf_case() == kSectionStatInfo;
}
inline bool TrafficFlowStatMapElement::has_sectionstatinfo() const {
  return _internal_has_sectionstatinfo();
}
inline void TrafficFlowStatMapElement::set_has_sectionstatinfo() {
  _impl_._oneof_case_[0] = kSectionStatInfo;
}
inline void TrafficFlowStatMapElement::clear_sectionstatinfo() {
  if (_internal_has_sectionstatinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.TrafficFlowStatMapElementOneOf_.sectionstatinfo_;
    }
    clear_has_TrafficFlowStatMapElementOneOf();
  }
}
inline ::cn::seisys::v2x::pb::SectionStatInfo* TrafficFlowStatMapElement::release_sectionstatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.sectionStatInfo)
  if (_internal_has_sectionstatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::SectionStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.sectionstatinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.TrafficFlowStatMapElementOneOf_.sectionstatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::SectionStatInfo& TrafficFlowStatMapElement::_internal_sectionstatinfo() const {
  return _internal_has_sectionstatinfo()
      ? *_impl_.TrafficFlowStatMapElementOneOf_.sectionstatinfo_
      : reinterpret_cast< ::cn::seisys::v2x::pb::SectionStatInfo&>(::cn::seisys::v2x::pb::_SectionStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::SectionStatInfo& TrafficFlowStatMapElement::sectionstatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatMapElement.sectionStatInfo)
  return _internal_sectionstatinfo();
}
inline ::cn::seisys::v2x::pb::SectionStatInfo* TrafficFlowStatMapElement::unsafe_arena_release_sectionstatinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.sectionStatInfo)
  if (_internal_has_sectionstatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::SectionStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.sectionstatinfo_;
    _impl_.TrafficFlowStatMapElementOneOf_.sectionstatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficFlowStatMapElement::unsafe_arena_set_allocated_sectionstatinfo(::cn::seisys::v2x::pb::SectionStatInfo* sectionstatinfo) {
  clear_TrafficFlowStatMapElementOneOf();
  if (sectionstatinfo) {
    set_has_sectionstatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.sectionstatinfo_ = sectionstatinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatMapElement.sectionStatInfo)
}
inline ::cn::seisys::v2x::pb::SectionStatInfo* TrafficFlowStatMapElement::_internal_mutable_sectionstatinfo() {
  if (!_internal_has_sectionstatinfo()) {
    clear_TrafficFlowStatMapElementOneOf();
    set_has_sectionstatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.sectionstatinfo_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::SectionStatInfo >(GetArenaForAllocation());
  }
  return _impl_.TrafficFlowStatMapElementOneOf_.sectionstatinfo_;
}
inline ::cn::seisys::v2x::pb::SectionStatInfo* TrafficFlowStatMapElement::mutable_sectionstatinfo() {
  ::cn::seisys::v2x::pb::SectionStatInfo* _msg = _internal_mutable_sectionstatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStatMapElement.sectionStatInfo)
  return _msg;
}

// .cn.seisys.v2x.pb.LinkStatInfo linkStatInfo = 4;
inline bool TrafficFlowStatMapElement::_internal_has_linkstatinfo() const {
  return TrafficFlowStatMapElementOneOf_case() == kLinkStatInfo;
}
inline bool TrafficFlowStatMapElement::has_linkstatinfo() const {
  return _internal_has_linkstatinfo();
}
inline void TrafficFlowStatMapElement::set_has_linkstatinfo() {
  _impl_._oneof_case_[0] = kLinkStatInfo;
}
inline void TrafficFlowStatMapElement::clear_linkstatinfo() {
  if (_internal_has_linkstatinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.TrafficFlowStatMapElementOneOf_.linkstatinfo_;
    }
    clear_has_TrafficFlowStatMapElementOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* TrafficFlowStatMapElement::release_linkstatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.linkStatInfo)
  if (_internal_has_linkstatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::LinkStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.linkstatinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.TrafficFlowStatMapElementOneOf_.linkstatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LinkStatInfo& TrafficFlowStatMapElement::_internal_linkstatinfo() const {
  return _internal_has_linkstatinfo()
      ? *_impl_.TrafficFlowStatMapElementOneOf_.linkstatinfo_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LinkStatInfo&>(::cn::seisys::v2x::pb::_LinkStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LinkStatInfo& TrafficFlowStatMapElement::linkstatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatMapElement.linkStatInfo)
  return _internal_linkstatinfo();
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* TrafficFlowStatMapElement::unsafe_arena_release_linkstatinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.linkStatInfo)
  if (_internal_has_linkstatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::LinkStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.linkstatinfo_;
    _impl_.TrafficFlowStatMapElementOneOf_.linkstatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficFlowStatMapElement::unsafe_arena_set_allocated_linkstatinfo(::cn::seisys::v2x::pb::LinkStatInfo* linkstatinfo) {
  clear_TrafficFlowStatMapElementOneOf();
  if (linkstatinfo) {
    set_has_linkstatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.linkstatinfo_ = linkstatinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatMapElement.linkStatInfo)
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* TrafficFlowStatMapElement::_internal_mutable_linkstatinfo() {
  if (!_internal_has_linkstatinfo()) {
    clear_TrafficFlowStatMapElementOneOf();
    set_has_linkstatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.linkstatinfo_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LinkStatInfo >(GetArenaForAllocation());
  }
  return _impl_.TrafficFlowStatMapElementOneOf_.linkstatinfo_;
}
inline ::cn::seisys::v2x::pb::LinkStatInfo* TrafficFlowStatMapElement::mutable_linkstatinfo() {
  ::cn::seisys::v2x::pb::LinkStatInfo* _msg = _internal_mutable_linkstatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStatMapElement.linkStatInfo)
  return _msg;
}

// .cn.seisys.v2x.pb.NodeStatInfo nodeStatInfo = 5;
inline bool TrafficFlowStatMapElement::_internal_has_nodestatinfo() const {
  return TrafficFlowStatMapElementOneOf_case() == kNodeStatInfo;
}
inline bool TrafficFlowStatMapElement::has_nodestatinfo() const {
  return _internal_has_nodestatinfo();
}
inline void TrafficFlowStatMapElement::set_has_nodestatinfo() {
  _impl_._oneof_case_[0] = kNodeStatInfo;
}
inline void TrafficFlowStatMapElement::clear_nodestatinfo() {
  if (_internal_has_nodestatinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.TrafficFlowStatMapElementOneOf_.nodestatinfo_;
    }
    clear_has_TrafficFlowStatMapElementOneOf();
  }
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* TrafficFlowStatMapElement::release_nodestatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.nodeStatInfo)
  if (_internal_has_nodestatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::NodeStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.nodestatinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.TrafficFlowStatMapElementOneOf_.nodestatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::NodeStatInfo& TrafficFlowStatMapElement::_internal_nodestatinfo() const {
  return _internal_has_nodestatinfo()
      ? *_impl_.TrafficFlowStatMapElementOneOf_.nodestatinfo_
      : reinterpret_cast< ::cn::seisys::v2x::pb::NodeStatInfo&>(::cn::seisys::v2x::pb::_NodeStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeStatInfo& TrafficFlowStatMapElement::nodestatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatMapElement.nodeStatInfo)
  return _internal_nodestatinfo();
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* TrafficFlowStatMapElement::unsafe_arena_release_nodestatinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.nodeStatInfo)
  if (_internal_has_nodestatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::NodeStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.nodestatinfo_;
    _impl_.TrafficFlowStatMapElementOneOf_.nodestatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficFlowStatMapElement::unsafe_arena_set_allocated_nodestatinfo(::cn::seisys::v2x::pb::NodeStatInfo* nodestatinfo) {
  clear_TrafficFlowStatMapElementOneOf();
  if (nodestatinfo) {
    set_has_nodestatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.nodestatinfo_ = nodestatinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatMapElement.nodeStatInfo)
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* TrafficFlowStatMapElement::_internal_mutable_nodestatinfo() {
  if (!_internal_has_nodestatinfo()) {
    clear_TrafficFlowStatMapElementOneOf();
    set_has_nodestatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.nodestatinfo_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::NodeStatInfo >(GetArenaForAllocation());
  }
  return _impl_.TrafficFlowStatMapElementOneOf_.nodestatinfo_;
}
inline ::cn::seisys::v2x::pb::NodeStatInfo* TrafficFlowStatMapElement::mutable_nodestatinfo() {
  ::cn::seisys::v2x::pb::NodeStatInfo* _msg = _internal_mutable_nodestatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStatMapElement.nodeStatInfo)
  return _msg;
}

// .cn.seisys.v2x.pb.MovementStatInfo movementStatInfo = 6;
inline bool TrafficFlowStatMapElement::_internal_has_movementstatinfo() const {
  return TrafficFlowStatMapElementOneOf_case() == kMovementStatInfo;
}
inline bool TrafficFlowStatMapElement::has_movementstatinfo() const {
  return _internal_has_movementstatinfo();
}
inline void TrafficFlowStatMapElement::set_has_movementstatinfo() {
  _impl_._oneof_case_[0] = kMovementStatInfo;
}
inline void TrafficFlowStatMapElement::clear_movementstatinfo() {
  if (_internal_has_movementstatinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.TrafficFlowStatMapElementOneOf_.movementstatinfo_;
    }
    clear_has_TrafficFlowStatMapElementOneOf();
  }
}
inline ::cn::seisys::v2x::pb::MovementStatInfo* TrafficFlowStatMapElement::release_movementstatinfo() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.movementStatInfo)
  if (_internal_has_movementstatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::MovementStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.movementstatinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.TrafficFlowStatMapElementOneOf_.movementstatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::MovementStatInfo& TrafficFlowStatMapElement::_internal_movementstatinfo() const {
  return _internal_has_movementstatinfo()
      ? *_impl_.TrafficFlowStatMapElementOneOf_.movementstatinfo_
      : reinterpret_cast< ::cn::seisys::v2x::pb::MovementStatInfo&>(::cn::seisys::v2x::pb::_MovementStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::MovementStatInfo& TrafficFlowStatMapElement::movementstatinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStatMapElement.movementStatInfo)
  return _internal_movementstatinfo();
}
inline ::cn::seisys::v2x::pb::MovementStatInfo* TrafficFlowStatMapElement::unsafe_arena_release_movementstatinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.TrafficFlowStatMapElement.movementStatInfo)
  if (_internal_has_movementstatinfo()) {
    clear_has_TrafficFlowStatMapElementOneOf();
    ::cn::seisys::v2x::pb::MovementStatInfo* temp = _impl_.TrafficFlowStatMapElementOneOf_.movementstatinfo_;
    _impl_.TrafficFlowStatMapElementOneOf_.movementstatinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficFlowStatMapElement::unsafe_arena_set_allocated_movementstatinfo(::cn::seisys::v2x::pb::MovementStatInfo* movementstatinfo) {
  clear_TrafficFlowStatMapElementOneOf();
  if (movementstatinfo) {
    set_has_movementstatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.movementstatinfo_ = movementstatinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStatMapElement.movementStatInfo)
}
inline ::cn::seisys::v2x::pb::MovementStatInfo* TrafficFlowStatMapElement::_internal_mutable_movementstatinfo() {
  if (!_internal_has_movementstatinfo()) {
    clear_TrafficFlowStatMapElementOneOf();
    set_has_movementstatinfo();
    _impl_.TrafficFlowStatMapElementOneOf_.movementstatinfo_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::MovementStatInfo >(GetArenaForAllocation());
  }
  return _impl_.TrafficFlowStatMapElementOneOf_.movementstatinfo_;
}
inline ::cn::seisys::v2x::pb::MovementStatInfo* TrafficFlowStatMapElement::mutable_movementstatinfo() {
  ::cn::seisys::v2x::pb::MovementStatInfo* _msg = _internal_mutable_movementstatinfo();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStatMapElement.movementStatInfo)
  return _msg;
}

inline bool TrafficFlowStatMapElement::has_TrafficFlowStatMapElementOneOf() const {
  return TrafficFlowStatMapElementOneOf_case() != TRAFFICFLOWSTATMAPELEMENTONEOF_NOT_SET;
}
inline void TrafficFlowStatMapElement::clear_has_TrafficFlowStatMapElementOneOf() {
  _impl_._oneof_case_[0] = TRAFFICFLOWSTATMAPELEMENTONEOF_NOT_SET;
}
inline TrafficFlowStatMapElement::TrafficFlowStatMapElementOneOfCase TrafficFlowStatMapElement::TrafficFlowStatMapElementOneOf_case() const {
  return TrafficFlowStatMapElement::TrafficFlowStatMapElementOneOfCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LaneIndexAdded

// uint64 timestamp = 1;
inline void LaneIndexAdded::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t LaneIndexAdded::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t LaneIndexAdded::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneIndexAdded.timestamp)
  return _internal_timestamp();
}
inline void LaneIndexAdded::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void LaneIndexAdded::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneIndexAdded.timestamp)
}

// uint32 laneCapacity = 2;
inline void LaneIndexAdded::clear_lanecapacity() {
  _impl_.lanecapacity_ = 0u;
}
inline uint32_t LaneIndexAdded::_internal_lanecapacity() const {
  return _impl_.lanecapacity_;
}
inline uint32_t LaneIndexAdded::lanecapacity() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneIndexAdded.laneCapacity)
  return _internal_lanecapacity();
}
inline void LaneIndexAdded::_internal_set_lanecapacity(uint32_t value) {
  
  _impl_.lanecapacity_ = value;
}
inline void LaneIndexAdded::set_lanecapacity(uint32_t value) {
  _internal_set_lanecapacity(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneIndexAdded.laneCapacity)
}

// uint32 laneSaturation = 3;
inline void LaneIndexAdded::clear_lanesaturation() {
  _impl_.lanesaturation_ = 0u;
}
inline uint32_t LaneIndexAdded::_internal_lanesaturation() const {
  return _impl_.lanesaturation_;
}
inline uint32_t LaneIndexAdded::lanesaturation() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneIndexAdded.laneSaturation)
  return _internal_lanesaturation();
}
inline void LaneIndexAdded::_internal_set_lanesaturation(uint32_t value) {
  
  _impl_.lanesaturation_ = value;
}
inline void LaneIndexAdded::set_lanesaturation(uint32_t value) {
  _internal_set_lanesaturation(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneIndexAdded.laneSaturation)
}

// uint32 laneSpaceOccupy = 4;
inline void LaneIndexAdded::clear_lanespaceoccupy() {
  _impl_.lanespaceoccupy_ = 0u;
}
inline uint32_t LaneIndexAdded::_internal_lanespaceoccupy() const {
  return _impl_.lanespaceoccupy_;
}
inline uint32_t LaneIndexAdded::lanespaceoccupy() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneIndexAdded.laneSpaceOccupy)
  return _internal_lanespaceoccupy();
}
inline void LaneIndexAdded::_internal_set_lanespaceoccupy(uint32_t value) {
  
  _impl_.lanespaceoccupy_ = value;
}
inline void LaneIndexAdded::set_lanespaceoccupy(uint32_t value) {
  _internal_set_lanespaceoccupy(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneIndexAdded.laneSpaceOccupy)
}

// uint32 laneTimeOccupy = 5;
inline void LaneIndexAdded::clear_lanetimeoccupy() {
  _impl_.lanetimeoccupy_ = 0u;
}
inline uint32_t LaneIndexAdded::_internal_lanetimeoccupy() const {
  return _impl_.lanetimeoccupy_;
}
inline uint32_t LaneIndexAdded::lanetimeoccupy() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneIndexAdded.laneTimeOccupy)
  return _internal_lanetimeoccupy();
}
inline void LaneIndexAdded::_internal_set_lanetimeoccupy(uint32_t value) {
  
  _impl_.lanetimeoccupy_ = value;
}
inline void LaneIndexAdded::set_lanetimeoccupy(uint32_t value) {
  _internal_set_lanetimeoccupy(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneIndexAdded.laneTimeOccupy)
}

// uint32 laneAvgGrnQueue = 6;
inline void LaneIndexAdded::clear_laneavggrnqueue() {
  _impl_.laneavggrnqueue_ = 0u;
}
inline uint32_t LaneIndexAdded::_internal_laneavggrnqueue() const {
  return _impl_.laneavggrnqueue_;
}
inline uint32_t LaneIndexAdded::laneavggrnqueue() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneIndexAdded.laneAvgGrnQueue)
  return _internal_laneavggrnqueue();
}
inline void LaneIndexAdded::_internal_set_laneavggrnqueue(uint32_t value) {
  
  _impl_.laneavggrnqueue_ = value;
}
inline void LaneIndexAdded::set_laneavggrnqueue(uint32_t value) {
  _internal_set_laneavggrnqueue(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneIndexAdded.laneAvgGrnQueue)
}

// uint32 laneGrnUtilization = 7;
inline void LaneIndexAdded::clear_lanegrnutilization() {
  _impl_.lanegrnutilization_ = 0u;
}
inline uint32_t LaneIndexAdded::_internal_lanegrnutilization() const {
  return _impl_.lanegrnutilization_;
}
inline uint32_t LaneIndexAdded::lanegrnutilization() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneIndexAdded.laneGrnUtilization)
  return _internal_lanegrnutilization();
}
inline void LaneIndexAdded::_internal_set_lanegrnutilization(uint32_t value) {
  
  _impl_.lanegrnutilization_ = value;
}
inline void LaneIndexAdded::set_lanegrnutilization(uint32_t value) {
  _internal_set_lanegrnutilization(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneIndexAdded.laneGrnUtilization)
}

// -------------------------------------------------------------------

// LinkIndexAdded

// uint64 timestamp = 1;
inline void LinkIndexAdded::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t LinkIndexAdded::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t LinkIndexAdded::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkIndexAdded.timestamp)
  return _internal_timestamp();
}
inline void LinkIndexAdded::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void LinkIndexAdded::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkIndexAdded.timestamp)
}

// uint32 linkCapacity = 2;
inline void LinkIndexAdded::clear_linkcapacity() {
  _impl_.linkcapacity_ = 0u;
}
inline uint32_t LinkIndexAdded::_internal_linkcapacity() const {
  return _impl_.linkcapacity_;
}
inline uint32_t LinkIndexAdded::linkcapacity() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkIndexAdded.linkCapacity)
  return _internal_linkcapacity();
}
inline void LinkIndexAdded::_internal_set_linkcapacity(uint32_t value) {
  
  _impl_.linkcapacity_ = value;
}
inline void LinkIndexAdded::set_linkcapacity(uint32_t value) {
  _internal_set_linkcapacity(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkIndexAdded.linkCapacity)
}

// uint32 linkSaturation = 3;
inline void LinkIndexAdded::clear_linksaturation() {
  _impl_.linksaturation_ = 0u;
}
inline uint32_t LinkIndexAdded::_internal_linksaturation() const {
  return _impl_.linksaturation_;
}
inline uint32_t LinkIndexAdded::linksaturation() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkIndexAdded.linkSaturation)
  return _internal_linksaturation();
}
inline void LinkIndexAdded::_internal_set_linksaturation(uint32_t value) {
  
  _impl_.linksaturation_ = value;
}
inline void LinkIndexAdded::set_linksaturation(uint32_t value) {
  _internal_set_linksaturation(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkIndexAdded.linkSaturation)
}

// uint32 linkSpaceOccupy = 4;
inline void LinkIndexAdded::clear_linkspaceoccupy() {
  _impl_.linkspaceoccupy_ = 0u;
}
inline uint32_t LinkIndexAdded::_internal_linkspaceoccupy() const {
  return _impl_.linkspaceoccupy_;
}
inline uint32_t LinkIndexAdded::linkspaceoccupy() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkIndexAdded.linkSpaceOccupy)
  return _internal_linkspaceoccupy();
}
inline void LinkIndexAdded::_internal_set_linkspaceoccupy(uint32_t value) {
  
  _impl_.linkspaceoccupy_ = value;
}
inline void LinkIndexAdded::set_linkspaceoccupy(uint32_t value) {
  _internal_set_linkspaceoccupy(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkIndexAdded.linkSpaceOccupy)
}

// uint32 linkTimeOccupy = 5;
inline void LinkIndexAdded::clear_linktimeoccupy() {
  _impl_.linktimeoccupy_ = 0u;
}
inline uint32_t LinkIndexAdded::_internal_linktimeoccupy() const {
  return _impl_.linktimeoccupy_;
}
inline uint32_t LinkIndexAdded::linktimeoccupy() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkIndexAdded.linkTimeOccupy)
  return _internal_linktimeoccupy();
}
inline void LinkIndexAdded::_internal_set_linktimeoccupy(uint32_t value) {
  
  _impl_.linktimeoccupy_ = value;
}
inline void LinkIndexAdded::set_linktimeoccupy(uint32_t value) {
  _internal_set_linktimeoccupy(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkIndexAdded.linkTimeOccupy)
}

// uint32 linkAvgGrnQueue = 6;
inline void LinkIndexAdded::clear_linkavggrnqueue() {
  _impl_.linkavggrnqueue_ = 0u;
}
inline uint32_t LinkIndexAdded::_internal_linkavggrnqueue() const {
  return _impl_.linkavggrnqueue_;
}
inline uint32_t LinkIndexAdded::linkavggrnqueue() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkIndexAdded.linkAvgGrnQueue)
  return _internal_linkavggrnqueue();
}
inline void LinkIndexAdded::_internal_set_linkavggrnqueue(uint32_t value) {
  
  _impl_.linkavggrnqueue_ = value;
}
inline void LinkIndexAdded::set_linkavggrnqueue(uint32_t value) {
  _internal_set_linkavggrnqueue(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkIndexAdded.linkAvgGrnQueue)
}

// uint32 linkGrnUtilization = 7;
inline void LinkIndexAdded::clear_linkgrnutilization() {
  _impl_.linkgrnutilization_ = 0u;
}
inline uint32_t LinkIndexAdded::_internal_linkgrnutilization() const {
  return _impl_.linkgrnutilization_;
}
inline uint32_t LinkIndexAdded::linkgrnutilization() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkIndexAdded.linkGrnUtilization)
  return _internal_linkgrnutilization();
}
inline void LinkIndexAdded::_internal_set_linkgrnutilization(uint32_t value) {
  
  _impl_.linkgrnutilization_ = value;
}
inline void LinkIndexAdded::set_linkgrnutilization(uint32_t value) {
  _internal_set_linkgrnutilization(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkIndexAdded.linkGrnUtilization)
}

// -------------------------------------------------------------------

// MovementIndexAdded

// uint64 timestamp = 1;
inline void MovementIndexAdded::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t MovementIndexAdded::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t MovementIndexAdded::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementIndexAdded.timestamp)
  return _internal_timestamp();
}
inline void MovementIndexAdded::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void MovementIndexAdded::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementIndexAdded.timestamp)
}

// uint32 movementCapacity = 2;
inline void MovementIndexAdded::clear_movementcapacity() {
  _impl_.movementcapacity_ = 0u;
}
inline uint32_t MovementIndexAdded::_internal_movementcapacity() const {
  return _impl_.movementcapacity_;
}
inline uint32_t MovementIndexAdded::movementcapacity() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementIndexAdded.movementCapacity)
  return _internal_movementcapacity();
}
inline void MovementIndexAdded::_internal_set_movementcapacity(uint32_t value) {
  
  _impl_.movementcapacity_ = value;
}
inline void MovementIndexAdded::set_movementcapacity(uint32_t value) {
  _internal_set_movementcapacity(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementIndexAdded.movementCapacity)
}

// uint32 movementSaturation = 3;
inline void MovementIndexAdded::clear_movementsaturation() {
  _impl_.movementsaturation_ = 0u;
}
inline uint32_t MovementIndexAdded::_internal_movementsaturation() const {
  return _impl_.movementsaturation_;
}
inline uint32_t MovementIndexAdded::movementsaturation() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementIndexAdded.movementSaturation)
  return _internal_movementsaturation();
}
inline void MovementIndexAdded::_internal_set_movementsaturation(uint32_t value) {
  
  _impl_.movementsaturation_ = value;
}
inline void MovementIndexAdded::set_movementsaturation(uint32_t value) {
  _internal_set_movementsaturation(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementIndexAdded.movementSaturation)
}

// uint32 movementSpaceOccupy = 4;
inline void MovementIndexAdded::clear_movementspaceoccupy() {
  _impl_.movementspaceoccupy_ = 0u;
}
inline uint32_t MovementIndexAdded::_internal_movementspaceoccupy() const {
  return _impl_.movementspaceoccupy_;
}
inline uint32_t MovementIndexAdded::movementspaceoccupy() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementIndexAdded.movementSpaceOccupy)
  return _internal_movementspaceoccupy();
}
inline void MovementIndexAdded::_internal_set_movementspaceoccupy(uint32_t value) {
  
  _impl_.movementspaceoccupy_ = value;
}
inline void MovementIndexAdded::set_movementspaceoccupy(uint32_t value) {
  _internal_set_movementspaceoccupy(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementIndexAdded.movementSpaceOccupy)
}

// uint32 movementTimeOccupy = 5;
inline void MovementIndexAdded::clear_movementtimeoccupy() {
  _impl_.movementtimeoccupy_ = 0u;
}
inline uint32_t MovementIndexAdded::_internal_movementtimeoccupy() const {
  return _impl_.movementtimeoccupy_;
}
inline uint32_t MovementIndexAdded::movementtimeoccupy() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementIndexAdded.movementTimeOccupy)
  return _internal_movementtimeoccupy();
}
inline void MovementIndexAdded::_internal_set_movementtimeoccupy(uint32_t value) {
  
  _impl_.movementtimeoccupy_ = value;
}
inline void MovementIndexAdded::set_movementtimeoccupy(uint32_t value) {
  _internal_set_movementtimeoccupy(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementIndexAdded.movementTimeOccupy)
}

// uint32 movementAvgGrnQueue = 6;
inline void MovementIndexAdded::clear_movementavggrnqueue() {
  _impl_.movementavggrnqueue_ = 0u;
}
inline uint32_t MovementIndexAdded::_internal_movementavggrnqueue() const {
  return _impl_.movementavggrnqueue_;
}
inline uint32_t MovementIndexAdded::movementavggrnqueue() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementIndexAdded.movementAvgGrnQueue)
  return _internal_movementavggrnqueue();
}
inline void MovementIndexAdded::_internal_set_movementavggrnqueue(uint32_t value) {
  
  _impl_.movementavggrnqueue_ = value;
}
inline void MovementIndexAdded::set_movementavggrnqueue(uint32_t value) {
  _internal_set_movementavggrnqueue(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementIndexAdded.movementAvgGrnQueue)
}

// uint32 movementGrnUtilization = 7;
inline void MovementIndexAdded::clear_movementgrnutilization() {
  _impl_.movementgrnutilization_ = 0u;
}
inline uint32_t MovementIndexAdded::_internal_movementgrnutilization() const {
  return _impl_.movementgrnutilization_;
}
inline uint32_t MovementIndexAdded::movementgrnutilization() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementIndexAdded.movementGrnUtilization)
  return _internal_movementgrnutilization();
}
inline void MovementIndexAdded::_internal_set_movementgrnutilization(uint32_t value) {
  
  _impl_.movementgrnutilization_ = value;
}
inline void MovementIndexAdded::set_movementgrnutilization(uint32_t value) {
  _internal_set_movementgrnutilization(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementIndexAdded.movementGrnUtilization)
}

// -------------------------------------------------------------------

// NodeIndexAdded

// uint64 timestamp = 1;
inline void NodeIndexAdded::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t NodeIndexAdded::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t NodeIndexAdded::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.timestamp)
  return _internal_timestamp();
}
inline void NodeIndexAdded::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void NodeIndexAdded::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.timestamp)
}

// uint32 nodeSpaceOccupy = 2;
inline void NodeIndexAdded::clear_nodespaceoccupy() {
  _impl_.nodespaceoccupy_ = 0u;
}
inline uint32_t NodeIndexAdded::_internal_nodespaceoccupy() const {
  return _impl_.nodespaceoccupy_;
}
inline uint32_t NodeIndexAdded::nodespaceoccupy() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.nodeSpaceOccupy)
  return _internal_nodespaceoccupy();
}
inline void NodeIndexAdded::_internal_set_nodespaceoccupy(uint32_t value) {
  
  _impl_.nodespaceoccupy_ = value;
}
inline void NodeIndexAdded::set_nodespaceoccupy(uint32_t value) {
  _internal_set_nodespaceoccupy(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.nodeSpaceOccupy)
}

// uint32 nodeTimeOccupy = 3;
inline void NodeIndexAdded::clear_nodetimeoccupy() {
  _impl_.nodetimeoccupy_ = 0u;
}
inline uint32_t NodeIndexAdded::_internal_nodetimeoccupy() const {
  return _impl_.nodetimeoccupy_;
}
inline uint32_t NodeIndexAdded::nodetimeoccupy() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.nodeTimeOccupy)
  return _internal_nodetimeoccupy();
}
inline void NodeIndexAdded::_internal_set_nodetimeoccupy(uint32_t value) {
  
  _impl_.nodetimeoccupy_ = value;
}
inline void NodeIndexAdded::set_nodetimeoccupy(uint32_t value) {
  _internal_set_nodetimeoccupy(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.nodeTimeOccupy)
}

// uint64 nodeCapacity = 4;
inline void NodeIndexAdded::clear_nodecapacity() {
  _impl_.nodecapacity_ = uint64_t{0u};
}
inline uint64_t NodeIndexAdded::_internal_nodecapacity() const {
  return _impl_.nodecapacity_;
}
inline uint64_t NodeIndexAdded::nodecapacity() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.nodeCapacity)
  return _internal_nodecapacity();
}
inline void NodeIndexAdded::_internal_set_nodecapacity(uint64_t value) {
  
  _impl_.nodecapacity_ = value;
}
inline void NodeIndexAdded::set_nodecapacity(uint64_t value) {
  _internal_set_nodecapacity(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.nodeCapacity)
}

// uint32 nodeSaturation = 5;
inline void NodeIndexAdded::clear_nodesaturation() {
  _impl_.nodesaturation_ = 0u;
}
inline uint32_t NodeIndexAdded::_internal_nodesaturation() const {
  return _impl_.nodesaturation_;
}
inline uint32_t NodeIndexAdded::nodesaturation() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.nodeSaturation)
  return _internal_nodesaturation();
}
inline void NodeIndexAdded::_internal_set_nodesaturation(uint32_t value) {
  
  _impl_.nodesaturation_ = value;
}
inline void NodeIndexAdded::set_nodesaturation(uint32_t value) {
  _internal_set_nodesaturation(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.nodeSaturation)
}

// uint32 nodeGrnUtilization = 6;
inline void NodeIndexAdded::clear_nodegrnutilization() {
  _impl_.nodegrnutilization_ = 0u;
}
inline uint32_t NodeIndexAdded::_internal_nodegrnutilization() const {
  return _impl_.nodegrnutilization_;
}
inline uint32_t NodeIndexAdded::nodegrnutilization() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.nodeGrnUtilization)
  return _internal_nodegrnutilization();
}
inline void NodeIndexAdded::_internal_set_nodegrnutilization(uint32_t value) {
  
  _impl_.nodegrnutilization_ = value;
}
inline void NodeIndexAdded::set_nodegrnutilization(uint32_t value) {
  _internal_set_nodegrnutilization(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.nodeGrnUtilization)
}

// uint32 nodeAvgGrnQueue = 7;
inline void NodeIndexAdded::clear_nodeavggrnqueue() {
  _impl_.nodeavggrnqueue_ = 0u;
}
inline uint32_t NodeIndexAdded::_internal_nodeavggrnqueue() const {
  return _impl_.nodeavggrnqueue_;
}
inline uint32_t NodeIndexAdded::nodeavggrnqueue() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.nodeAvgGrnQueue)
  return _internal_nodeavggrnqueue();
}
inline void NodeIndexAdded::_internal_set_nodeavggrnqueue(uint32_t value) {
  
  _impl_.nodeavggrnqueue_ = value;
}
inline void NodeIndexAdded::set_nodeavggrnqueue(uint32_t value) {
  _internal_set_nodeavggrnqueue(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.nodeAvgGrnQueue)
}

// uint32 demandIndex = 8;
inline void NodeIndexAdded::clear_demandindex() {
  _impl_.demandindex_ = 0u;
}
inline uint32_t NodeIndexAdded::_internal_demandindex() const {
  return _impl_.demandindex_;
}
inline uint32_t NodeIndexAdded::demandindex() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.demandIndex)
  return _internal_demandindex();
}
inline void NodeIndexAdded::_internal_set_demandindex(uint32_t value) {
  
  _impl_.demandindex_ = value;
}
inline void NodeIndexAdded::set_demandindex(uint32_t value) {
  _internal_set_demandindex(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.demandIndex)
}

// uint32 supplyIndex = 9;
inline void NodeIndexAdded::clear_supplyindex() {
  _impl_.supplyindex_ = 0u;
}
inline uint32_t NodeIndexAdded::_internal_supplyindex() const {
  return _impl_.supplyindex_;
}
inline uint32_t NodeIndexAdded::supplyindex() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.supplyIndex)
  return _internal_supplyindex();
}
inline void NodeIndexAdded::_internal_set_supplyindex(uint32_t value) {
  
  _impl_.supplyindex_ = value;
}
inline void NodeIndexAdded::set_supplyindex(uint32_t value) {
  _internal_set_supplyindex(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.supplyIndex)
}

// uint32 theoryIndex = 10;
inline void NodeIndexAdded::clear_theoryindex() {
  _impl_.theoryindex_ = 0u;
}
inline uint32_t NodeIndexAdded::_internal_theoryindex() const {
  return _impl_.theoryindex_;
}
inline uint32_t NodeIndexAdded::theoryindex() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.NodeIndexAdded.theoryIndex)
  return _internal_theoryindex();
}
inline void NodeIndexAdded::_internal_set_theoryindex(uint32_t value) {
  
  _impl_.theoryindex_ = value;
}
inline void NodeIndexAdded::set_theoryindex(uint32_t value) {
  _internal_set_theoryindex(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.NodeIndexAdded.theoryIndex)
}

// -------------------------------------------------------------------

// SignalControlIndexAdded

// uint32 phaseId = 1;
inline void SignalControlIndexAdded::clear_phaseid() {
  _impl_.phaseid_ = 0u;
}
inline uint32_t SignalControlIndexAdded::_internal_phaseid() const {
  return _impl_.phaseid_;
}
inline uint32_t SignalControlIndexAdded::phaseid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalControlIndexAdded.phaseId)
  return _internal_phaseid();
}
inline void SignalControlIndexAdded::_internal_set_phaseid(uint32_t value) {
  
  _impl_.phaseid_ = value;
}
inline void SignalControlIndexAdded::set_phaseid(uint32_t value) {
  _internal_set_phaseid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SignalControlIndexAdded.phaseId)
}

// uint32 greenStartQueue = 2;
inline void SignalControlIndexAdded::clear_greenstartqueue() {
  _impl_.greenstartqueue_ = 0u;
}
inline uint32_t SignalControlIndexAdded::_internal_greenstartqueue() const {
  return _impl_.greenstartqueue_;
}
inline uint32_t SignalControlIndexAdded::greenstartqueue() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalControlIndexAdded.greenStartQueue)
  return _internal_greenstartqueue();
}
inline void SignalControlIndexAdded::_internal_set_greenstartqueue(uint32_t value) {
  
  _impl_.greenstartqueue_ = value;
}
inline void SignalControlIndexAdded::set_greenstartqueue(uint32_t value) {
  _internal_set_greenstartqueue(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SignalControlIndexAdded.greenStartQueue)
}

// uint32 redStartQueue = 3;
inline void SignalControlIndexAdded::clear_redstartqueue() {
  _impl_.redstartqueue_ = 0u;
}
inline uint32_t SignalControlIndexAdded::_internal_redstartqueue() const {
  return _impl_.redstartqueue_;
}
inline uint32_t SignalControlIndexAdded::redstartqueue() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalControlIndexAdded.redStartQueue)
  return _internal_redstartqueue();
}
inline void SignalControlIndexAdded::_internal_set_redstartqueue(uint32_t value) {
  
  _impl_.redstartqueue_ = value;
}
inline void SignalControlIndexAdded::set_redstartqueue(uint32_t value) {
  _internal_set_redstartqueue(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SignalControlIndexAdded.redStartQueue)
}

// uint32 greenUtilization = 4;
inline void SignalControlIndexAdded::clear_greenutilization() {
  _impl_.greenutilization_ = 0u;
}
inline uint32_t SignalControlIndexAdded::_internal_greenutilization() const {
  return _impl_.greenutilization_;
}
inline uint32_t SignalControlIndexAdded::greenutilization() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalControlIndexAdded.greenUtilization)
  return _internal_greenutilization();
}
inline void SignalControlIndexAdded::_internal_set_greenutilization(uint32_t value) {
  
  _impl_.greenutilization_ = value;
}
inline void SignalControlIndexAdded::set_greenutilization(uint32_t value) {
  _internal_set_greenutilization(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SignalControlIndexAdded.greenUtilization)
}

// -------------------------------------------------------------------

// TrafficFlowExtension

// repeated .cn.seisys.v2x.pb.LaneIndexAdded laneIndex = 1;
inline int TrafficFlowExtension::_internal_laneindex_size() const {
  return _impl_.laneindex_.size();
}
inline int TrafficFlowExtension::laneindex_size() const {
  return _internal_laneindex_size();
}
inline void TrafficFlowExtension::clear_laneindex() {
  _impl_.laneindex_.Clear();
}
inline ::cn::seisys::v2x::pb::LaneIndexAdded* TrafficFlowExtension::mutable_laneindex(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowExtension.laneIndex)
  return _impl_.laneindex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneIndexAdded >*
TrafficFlowExtension::mutable_laneindex() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.TrafficFlowExtension.laneIndex)
  return &_impl_.laneindex_;
}
inline const ::cn::seisys::v2x::pb::LaneIndexAdded& TrafficFlowExtension::_internal_laneindex(int index) const {
  return _impl_.laneindex_.Get(index);
}
inline const ::cn::seisys::v2x::pb::LaneIndexAdded& TrafficFlowExtension::laneindex(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowExtension.laneIndex)
  return _internal_laneindex(index);
}
inline ::cn::seisys::v2x::pb::LaneIndexAdded* TrafficFlowExtension::_internal_add_laneindex() {
  return _impl_.laneindex_.Add();
}
inline ::cn::seisys::v2x::pb::LaneIndexAdded* TrafficFlowExtension::add_laneindex() {
  ::cn::seisys::v2x::pb::LaneIndexAdded* _add = _internal_add_laneindex();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.TrafficFlowExtension.laneIndex)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneIndexAdded >&
TrafficFlowExtension::laneindex() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.TrafficFlowExtension.laneIndex)
  return _impl_.laneindex_;
}

// repeated .cn.seisys.v2x.pb.LinkIndexAdded linkIndex = 2;
inline int TrafficFlowExtension::_internal_linkindex_size() const {
  return _impl_.linkindex_.size();
}
inline int TrafficFlowExtension::linkindex_size() const {
  return _internal_linkindex_size();
}
inline void TrafficFlowExtension::clear_linkindex() {
  _impl_.linkindex_.Clear();
}
inline ::cn::seisys::v2x::pb::LinkIndexAdded* TrafficFlowExtension::mutable_linkindex(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowExtension.linkIndex)
  return _impl_.linkindex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkIndexAdded >*
TrafficFlowExtension::mutable_linkindex() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.TrafficFlowExtension.linkIndex)
  return &_impl_.linkindex_;
}
inline const ::cn::seisys::v2x::pb::LinkIndexAdded& TrafficFlowExtension::_internal_linkindex(int index) const {
  return _impl_.linkindex_.Get(index);
}
inline const ::cn::seisys::v2x::pb::LinkIndexAdded& TrafficFlowExtension::linkindex(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowExtension.linkIndex)
  return _internal_linkindex(index);
}
inline ::cn::seisys::v2x::pb::LinkIndexAdded* TrafficFlowExtension::_internal_add_linkindex() {
  return _impl_.linkindex_.Add();
}
inline ::cn::seisys::v2x::pb::LinkIndexAdded* TrafficFlowExtension::add_linkindex() {
  ::cn::seisys::v2x::pb::LinkIndexAdded* _add = _internal_add_linkindex();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.TrafficFlowExtension.linkIndex)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkIndexAdded >&
TrafficFlowExtension::linkindex() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.TrafficFlowExtension.linkIndex)
  return _impl_.linkindex_;
}

// repeated .cn.seisys.v2x.pb.MovementIndexAdded movementIndex = 3;
inline int TrafficFlowExtension::_internal_movementindex_size() const {
  return _impl_.movementindex_.size();
}
inline int TrafficFlowExtension::movementindex_size() const {
  return _internal_movementindex_size();
}
inline void TrafficFlowExtension::clear_movementindex() {
  _impl_.movementindex_.Clear();
}
inline ::cn::seisys::v2x::pb::MovementIndexAdded* TrafficFlowExtension::mutable_movementindex(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowExtension.movementIndex)
  return _impl_.movementindex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementIndexAdded >*
TrafficFlowExtension::mutable_movementindex() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.TrafficFlowExtension.movementIndex)
  return &_impl_.movementindex_;
}
inline const ::cn::seisys::v2x::pb::MovementIndexAdded& TrafficFlowExtension::_internal_movementindex(int index) const {
  return _impl_.movementindex_.Get(index);
}
inline const ::cn::seisys::v2x::pb::MovementIndexAdded& TrafficFlowExtension::movementindex(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowExtension.movementIndex)
  return _internal_movementindex(index);
}
inline ::cn::seisys::v2x::pb::MovementIndexAdded* TrafficFlowExtension::_internal_add_movementindex() {
  return _impl_.movementindex_.Add();
}
inline ::cn::seisys::v2x::pb::MovementIndexAdded* TrafficFlowExtension::add_movementindex() {
  ::cn::seisys::v2x::pb::MovementIndexAdded* _add = _internal_add_movementindex();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.TrafficFlowExtension.movementIndex)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementIndexAdded >&
TrafficFlowExtension::movementindex() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.TrafficFlowExtension.movementIndex)
  return _impl_.movementindex_;
}

// repeated .cn.seisys.v2x.pb.NodeIndexAdded nodeIndex = 4;
inline int TrafficFlowExtension::_internal_nodeindex_size() const {
  return _impl_.nodeindex_.size();
}
inline int TrafficFlowExtension::nodeindex_size() const {
  return _internal_nodeindex_size();
}
inline void TrafficFlowExtension::clear_nodeindex() {
  _impl_.nodeindex_.Clear();
}
inline ::cn::seisys::v2x::pb::NodeIndexAdded* TrafficFlowExtension::mutable_nodeindex(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowExtension.nodeIndex)
  return _impl_.nodeindex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::NodeIndexAdded >*
TrafficFlowExtension::mutable_nodeindex() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.TrafficFlowExtension.nodeIndex)
  return &_impl_.nodeindex_;
}
inline const ::cn::seisys::v2x::pb::NodeIndexAdded& TrafficFlowExtension::_internal_nodeindex(int index) const {
  return _impl_.nodeindex_.Get(index);
}
inline const ::cn::seisys::v2x::pb::NodeIndexAdded& TrafficFlowExtension::nodeindex(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowExtension.nodeIndex)
  return _internal_nodeindex(index);
}
inline ::cn::seisys::v2x::pb::NodeIndexAdded* TrafficFlowExtension::_internal_add_nodeindex() {
  return _impl_.nodeindex_.Add();
}
inline ::cn::seisys::v2x::pb::NodeIndexAdded* TrafficFlowExtension::add_nodeindex() {
  ::cn::seisys::v2x::pb::NodeIndexAdded* _add = _internal_add_nodeindex();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.TrafficFlowExtension.nodeIndex)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::NodeIndexAdded >&
TrafficFlowExtension::nodeindex() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.TrafficFlowExtension.nodeIndex)
  return _impl_.nodeindex_;
}

// repeated .cn.seisys.v2x.pb.SignalControlIndexAdded signalIndex = 5;
inline int TrafficFlowExtension::_internal_signalindex_size() const {
  return _impl_.signalindex_.size();
}
inline int TrafficFlowExtension::signalindex_size() const {
  return _internal_signalindex_size();
}
inline void TrafficFlowExtension::clear_signalindex() {
  _impl_.signalindex_.Clear();
}
inline ::cn::seisys::v2x::pb::SignalControlIndexAdded* TrafficFlowExtension::mutable_signalindex(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowExtension.signalIndex)
  return _impl_.signalindex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalControlIndexAdded >*
TrafficFlowExtension::mutable_signalindex() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.TrafficFlowExtension.signalIndex)
  return &_impl_.signalindex_;
}
inline const ::cn::seisys::v2x::pb::SignalControlIndexAdded& TrafficFlowExtension::_internal_signalindex(int index) const {
  return _impl_.signalindex_.Get(index);
}
inline const ::cn::seisys::v2x::pb::SignalControlIndexAdded& TrafficFlowExtension::signalindex(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowExtension.signalIndex)
  return _internal_signalindex(index);
}
inline ::cn::seisys::v2x::pb::SignalControlIndexAdded* TrafficFlowExtension::_internal_add_signalindex() {
  return _impl_.signalindex_.Add();
}
inline ::cn::seisys::v2x::pb::SignalControlIndexAdded* TrafficFlowExtension::add_signalindex() {
  ::cn::seisys::v2x::pb::SignalControlIndexAdded* _add = _internal_add_signalindex();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.TrafficFlowExtension.signalIndex)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalControlIndexAdded >&
TrafficFlowExtension::signalindex() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.TrafficFlowExtension.signalIndex)
  return _impl_.signalindex_;
}

// -------------------------------------------------------------------

// TrafficFlowStat

// .cn.seisys.v2x.pb.TrafficFlowStatMapElement mapElement = 1;
inline bool TrafficFlowStat::_internal_has_mapelement() const {
  return this != internal_default_instance() && _impl_.mapelement_ != nullptr;
}
inline bool TrafficFlowStat::has_mapelement() const {
  return _internal_has_mapelement();
}
inline void TrafficFlowStat::clear_mapelement() {
  if (GetArenaForAllocation() == nullptr && _impl_.mapelement_ != nullptr) {
    delete _impl_.mapelement_;
  }
  _impl_.mapelement_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStatMapElement& TrafficFlowStat::_internal_mapelement() const {
  const ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* p = _impl_.mapelement_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::TrafficFlowStatMapElement&>(
      ::cn::seisys::v2x::pb::_TrafficFlowStatMapElement_default_instance_);
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStatMapElement& TrafficFlowStat::mapelement() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.mapElement)
  return _internal_mapelement();
}
inline void TrafficFlowStat::unsafe_arena_set_allocated_mapelement(
    ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* mapelement) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mapelement_);
  }
  _impl_.mapelement_ = mapelement;
  if (mapelement) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStat.mapElement)
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* TrafficFlowStat::release_mapelement() {
  
  ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* temp = _impl_.mapelement_;
  _impl_.mapelement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* TrafficFlowStat::unsafe_arena_release_mapelement() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStat.mapElement)
  
  ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* temp = _impl_.mapelement_;
  _impl_.mapelement_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* TrafficFlowStat::_internal_mutable_mapelement() {
  
  if (_impl_.mapelement_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowStatMapElement>(GetArenaForAllocation());
    _impl_.mapelement_ = p;
  }
  return _impl_.mapelement_;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* TrafficFlowStat::mutable_mapelement() {
  ::cn::seisys::v2x::pb::TrafficFlowStatMapElement* _msg = _internal_mutable_mapelement();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStat.mapElement)
  return _msg;
}
inline void TrafficFlowStat::set_allocated_mapelement(::cn::seisys::v2x::pb::TrafficFlowStatMapElement* mapelement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mapelement_;
  }
  if (mapelement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mapelement);
    if (message_arena != submessage_arena) {
      mapelement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapelement, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mapelement_ = mapelement;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.TrafficFlowStat.mapElement)
}

// .cn.seisys.v2x.pb.MapElementType mapElementType = 2;
inline void TrafficFlowStat::clear_mapelementtype() {
  _impl_.mapelementtype_ = 0;
}
inline ::cn::seisys::v2x::pb::MapElementType TrafficFlowStat::_internal_mapelementtype() const {
  return static_cast< ::cn::seisys::v2x::pb::MapElementType >(_impl_.mapelementtype_);
}
inline ::cn::seisys::v2x::pb::MapElementType TrafficFlowStat::mapelementtype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.mapElementType)
  return _internal_mapelementtype();
}
inline void TrafficFlowStat::_internal_set_mapelementtype(::cn::seisys::v2x::pb::MapElementType value) {
  
  _impl_.mapelementtype_ = value;
}
inline void TrafficFlowStat::set_mapelementtype(::cn::seisys::v2x::pb::MapElementType value) {
  _internal_set_mapelementtype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.mapElementType)
}

// .cn.seisys.v2x.pb.ParticipantType ptcType = 3;
inline void TrafficFlowStat::clear_ptctype() {
  _impl_.ptctype_ = 0;
}
inline ::cn::seisys::v2x::pb::ParticipantType TrafficFlowStat::_internal_ptctype() const {
  return static_cast< ::cn::seisys::v2x::pb::ParticipantType >(_impl_.ptctype_);
}
inline ::cn::seisys::v2x::pb::ParticipantType TrafficFlowStat::ptctype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.ptcType)
  return _internal_ptctype();
}
inline void TrafficFlowStat::_internal_set_ptctype(::cn::seisys::v2x::pb::ParticipantType value) {
  
  _impl_.ptctype_ = value;
}
inline void TrafficFlowStat::set_ptctype(::cn::seisys::v2x::pb::ParticipantType value) {
  _internal_set_ptctype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.ptcType)
}

// .cn.seisys.v2x.pb.VehicleType vehicleType = 4;
inline void TrafficFlowStat::clear_vehicletype() {
  _impl_.vehicletype_ = 0;
}
inline ::cn::seisys::v2x::pb::VehicleType TrafficFlowStat::_internal_vehicletype() const {
  return static_cast< ::cn::seisys::v2x::pb::VehicleType >(_impl_.vehicletype_);
}
inline ::cn::seisys::v2x::pb::VehicleType TrafficFlowStat::vehicletype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.vehicleType)
  return _internal_vehicletype();
}
inline void TrafficFlowStat::_internal_set_vehicletype(::cn::seisys::v2x::pb::VehicleType value) {
  
  _impl_.vehicletype_ = value;
}
inline void TrafficFlowStat::set_vehicletype(::cn::seisys::v2x::pb::VehicleType value) {
  _internal_set_vehicletype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.vehicleType)
}

// uint64 timestamp = 5;
inline void TrafficFlowStat::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t TrafficFlowStat::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t TrafficFlowStat::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.timestamp)
  return _internal_timestamp();
}
inline void TrafficFlowStat::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void TrafficFlowStat::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.timestamp)
}

// uint32 volume = 6;
inline void TrafficFlowStat::clear_volume() {
  _impl_.volume_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_volume() const {
  return _impl_.volume_;
}
inline uint32_t TrafficFlowStat::volume() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.volume)
  return _internal_volume();
}
inline void TrafficFlowStat::_internal_set_volume(uint32_t value) {
  
  _impl_.volume_ = value;
}
inline void TrafficFlowStat::set_volume(uint32_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.volume)
}

// uint32 speedPoint = 7;
inline void TrafficFlowStat::clear_speedpoint() {
  _impl_.speedpoint_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_speedpoint() const {
  return _impl_.speedpoint_;
}
inline uint32_t TrafficFlowStat::speedpoint() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.speedPoint)
  return _internal_speedpoint();
}
inline void TrafficFlowStat::_internal_set_speedpoint(uint32_t value) {
  
  _impl_.speedpoint_ = value;
}
inline void TrafficFlowStat::set_speedpoint(uint32_t value) {
  _internal_set_speedpoint(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.speedPoint)
}

// uint32 speedArea = 8;
inline void TrafficFlowStat::clear_speedarea() {
  _impl_.speedarea_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_speedarea() const {
  return _impl_.speedarea_;
}
inline uint32_t TrafficFlowStat::speedarea() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.speedArea)
  return _internal_speedarea();
}
inline void TrafficFlowStat::_internal_set_speedarea(uint32_t value) {
  
  _impl_.speedarea_ = value;
}
inline void TrafficFlowStat::set_speedarea(uint32_t value) {
  _internal_set_speedarea(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.speedArea)
}

// uint32 density = 9;
inline void TrafficFlowStat::clear_density() {
  _impl_.density_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_density() const {
  return _impl_.density_;
}
inline uint32_t TrafficFlowStat::density() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.density)
  return _internal_density();
}
inline void TrafficFlowStat::_internal_set_density(uint32_t value) {
  
  _impl_.density_ = value;
}
inline void TrafficFlowStat::set_density(uint32_t value) {
  _internal_set_density(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.density)
}

// uint32 travelTime = 10;
inline void TrafficFlowStat::clear_traveltime() {
  _impl_.traveltime_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_traveltime() const {
  return _impl_.traveltime_;
}
inline uint32_t TrafficFlowStat::traveltime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.travelTime)
  return _internal_traveltime();
}
inline void TrafficFlowStat::_internal_set_traveltime(uint32_t value) {
  
  _impl_.traveltime_ = value;
}
inline void TrafficFlowStat::set_traveltime(uint32_t value) {
  _internal_set_traveltime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.travelTime)
}

// uint32 delay = 11;
inline void TrafficFlowStat::clear_delay() {
  _impl_.delay_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_delay() const {
  return _impl_.delay_;
}
inline uint32_t TrafficFlowStat::delay() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.delay)
  return _internal_delay();
}
inline void TrafficFlowStat::_internal_set_delay(uint32_t value) {
  
  _impl_.delay_ = value;
}
inline void TrafficFlowStat::set_delay(uint32_t value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.delay)
}

// uint32 queueLength = 12;
inline void TrafficFlowStat::clear_queuelength() {
  _impl_.queuelength_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_queuelength() const {
  return _impl_.queuelength_;
}
inline uint32_t TrafficFlowStat::queuelength() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.queueLength)
  return _internal_queuelength();
}
inline void TrafficFlowStat::_internal_set_queuelength(uint32_t value) {
  
  _impl_.queuelength_ = value;
}
inline void TrafficFlowStat::set_queuelength(uint32_t value) {
  _internal_set_queuelength(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.queueLength)
}

// uint32 queueInt = 13;
inline void TrafficFlowStat::clear_queueint() {
  _impl_.queueint_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_queueint() const {
  return _impl_.queueint_;
}
inline uint32_t TrafficFlowStat::queueint() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.queueInt)
  return _internal_queueint();
}
inline void TrafficFlowStat::_internal_set_queueint(uint32_t value) {
  
  _impl_.queueint_ = value;
}
inline void TrafficFlowStat::set_queueint(uint32_t value) {
  _internal_set_queueint(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.queueInt)
}

// uint32 congestion = 14;
inline void TrafficFlowStat::clear_congestion() {
  _impl_.congestion_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_congestion() const {
  return _impl_.congestion_;
}
inline uint32_t TrafficFlowStat::congestion() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.congestion)
  return _internal_congestion();
}
inline void TrafficFlowStat::_internal_set_congestion(uint32_t value) {
  
  _impl_.congestion_ = value;
}
inline void TrafficFlowStat::set_congestion(uint32_t value) {
  _internal_set_congestion(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.congestion)
}

// .cn.seisys.v2x.pb.TrafficFlowExtension trafficFlowExtension = 15;
inline bool TrafficFlowStat::_internal_has_trafficflowextension() const {
  return this != internal_default_instance() && _impl_.trafficflowextension_ != nullptr;
}
inline bool TrafficFlowStat::has_trafficflowextension() const {
  return _internal_has_trafficflowextension();
}
inline void TrafficFlowStat::clear_trafficflowextension() {
  if (GetArenaForAllocation() == nullptr && _impl_.trafficflowextension_ != nullptr) {
    delete _impl_.trafficflowextension_;
  }
  _impl_.trafficflowextension_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::TrafficFlowExtension& TrafficFlowStat::_internal_trafficflowextension() const {
  const ::cn::seisys::v2x::pb::TrafficFlowExtension* p = _impl_.trafficflowextension_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::TrafficFlowExtension&>(
      ::cn::seisys::v2x::pb::_TrafficFlowExtension_default_instance_);
}
inline const ::cn::seisys::v2x::pb::TrafficFlowExtension& TrafficFlowStat::trafficflowextension() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.trafficFlowExtension)
  return _internal_trafficflowextension();
}
inline void TrafficFlowStat::unsafe_arena_set_allocated_trafficflowextension(
    ::cn::seisys::v2x::pb::TrafficFlowExtension* trafficflowextension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trafficflowextension_);
  }
  _impl_.trafficflowextension_ = trafficflowextension;
  if (trafficflowextension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlowStat.trafficFlowExtension)
}
inline ::cn::seisys::v2x::pb::TrafficFlowExtension* TrafficFlowStat::release_trafficflowextension() {
  
  ::cn::seisys::v2x::pb::TrafficFlowExtension* temp = _impl_.trafficflowextension_;
  _impl_.trafficflowextension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowExtension* TrafficFlowStat::unsafe_arena_release_trafficflowextension() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlowStat.trafficFlowExtension)
  
  ::cn::seisys::v2x::pb::TrafficFlowExtension* temp = _impl_.trafficflowextension_;
  _impl_.trafficflowextension_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowExtension* TrafficFlowStat::_internal_mutable_trafficflowextension() {
  
  if (_impl_.trafficflowextension_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowExtension>(GetArenaForAllocation());
    _impl_.trafficflowextension_ = p;
  }
  return _impl_.trafficflowextension_;
}
inline ::cn::seisys::v2x::pb::TrafficFlowExtension* TrafficFlowStat::mutable_trafficflowextension() {
  ::cn::seisys::v2x::pb::TrafficFlowExtension* _msg = _internal_mutable_trafficflowextension();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlowStat.trafficFlowExtension)
  return _msg;
}
inline void TrafficFlowStat::set_allocated_trafficflowextension(::cn::seisys::v2x::pb::TrafficFlowExtension* trafficflowextension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trafficflowextension_;
  }
  if (trafficflowextension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trafficflowextension);
    if (message_arena != submessage_arena) {
      trafficflowextension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trafficflowextension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trafficflowextension_ = trafficflowextension;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.TrafficFlowStat.trafficFlowExtension)
}

// uint32 timeHeadway = 16;
inline void TrafficFlowStat::clear_timeheadway() {
  _impl_.timeheadway_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_timeheadway() const {
  return _impl_.timeheadway_;
}
inline uint32_t TrafficFlowStat::timeheadway() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.timeHeadway)
  return _internal_timeheadway();
}
inline void TrafficFlowStat::_internal_set_timeheadway(uint32_t value) {
  
  _impl_.timeheadway_ = value;
}
inline void TrafficFlowStat::set_timeheadway(uint32_t value) {
  _internal_set_timeheadway(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.timeHeadway)
}

// uint32 spaceHeadway = 17;
inline void TrafficFlowStat::clear_spaceheadway() {
  _impl_.spaceheadway_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_spaceheadway() const {
  return _impl_.spaceheadway_;
}
inline uint32_t TrafficFlowStat::spaceheadway() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.spaceHeadway)
  return _internal_spaceheadway();
}
inline void TrafficFlowStat::_internal_set_spaceheadway(uint32_t value) {
  
  _impl_.spaceheadway_ = value;
}
inline void TrafficFlowStat::set_spaceheadway(uint32_t value) {
  _internal_set_spaceheadway(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.spaceHeadway)
}

// uint32 stopNums = 18;
inline void TrafficFlowStat::clear_stopnums() {
  _impl_.stopnums_ = 0u;
}
inline uint32_t TrafficFlowStat::_internal_stopnums() const {
  return _impl_.stopnums_;
}
inline uint32_t TrafficFlowStat::stopnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlowStat.stopNums)
  return _internal_stopnums();
}
inline void TrafficFlowStat::_internal_set_stopnums(uint32_t value) {
  
  _impl_.stopnums_ = value;
}
inline void TrafficFlowStat::set_stopnums(uint32_t value) {
  _internal_set_stopnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlowStat.stopNums)
}

// -------------------------------------------------------------------

// TrafficFlow

// .cn.seisys.v2x.pb.NodeReferenceId nodeId = 1;
inline bool TrafficFlow::_internal_has_nodeid() const {
  return this != internal_default_instance() && _impl_.nodeid_ != nullptr;
}
inline bool TrafficFlow::has_nodeid() const {
  return _internal_has_nodeid();
}
inline void TrafficFlow::clear_nodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodeid_ != nullptr) {
    delete _impl_.nodeid_;
  }
  _impl_.nodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& TrafficFlow::_internal_nodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.nodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& TrafficFlow::nodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlow.nodeId)
  return _internal_nodeid();
}
inline void TrafficFlow::unsafe_arena_set_allocated_nodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodeid_);
  }
  _impl_.nodeid_ = nodeid;
  if (nodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlow.nodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* TrafficFlow::release_nodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* TrafficFlow::unsafe_arena_release_nodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlow.nodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* TrafficFlow::_internal_mutable_nodeid() {
  
  if (_impl_.nodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.nodeid_ = p;
  }
  return _impl_.nodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* TrafficFlow::mutable_nodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlow.nodeId)
  return _msg;
}
inline void TrafficFlow::set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodeid_;
  }
  if (nodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodeid);
    if (message_arena != submessage_arena) {
      nodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodeid_ = nodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.TrafficFlow.nodeId)
}

// uint64 genTime = 2;
inline void TrafficFlow::clear_gentime() {
  _impl_.gentime_ = uint64_t{0u};
}
inline uint64_t TrafficFlow::_internal_gentime() const {
  return _impl_.gentime_;
}
inline uint64_t TrafficFlow::gentime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlow.genTime)
  return _internal_gentime();
}
inline void TrafficFlow::_internal_set_gentime(uint64_t value) {
  
  _impl_.gentime_ = value;
}
inline void TrafficFlow::set_gentime(uint64_t value) {
  _internal_set_gentime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TrafficFlow.genTime)
}

// .cn.seisys.v2x.pb.TrafficFlowStatType statType = 3;
inline bool TrafficFlow::_internal_has_stattype() const {
  return this != internal_default_instance() && _impl_.stattype_ != nullptr;
}
inline bool TrafficFlow::has_stattype() const {
  return _internal_has_stattype();
}
inline void TrafficFlow::clear_stattype() {
  if (GetArenaForAllocation() == nullptr && _impl_.stattype_ != nullptr) {
    delete _impl_.stattype_;
  }
  _impl_.stattype_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStatType& TrafficFlow::_internal_stattype() const {
  const ::cn::seisys::v2x::pb::TrafficFlowStatType* p = _impl_.stattype_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::TrafficFlowStatType&>(
      ::cn::seisys::v2x::pb::_TrafficFlowStatType_default_instance_);
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStatType& TrafficFlow::stattype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlow.statType)
  return _internal_stattype();
}
inline void TrafficFlow::unsafe_arena_set_allocated_stattype(
    ::cn::seisys::v2x::pb::TrafficFlowStatType* stattype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stattype_);
  }
  _impl_.stattype_ = stattype;
  if (stattype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.TrafficFlow.statType)
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatType* TrafficFlow::release_stattype() {
  
  ::cn::seisys::v2x::pb::TrafficFlowStatType* temp = _impl_.stattype_;
  _impl_.stattype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatType* TrafficFlow::unsafe_arena_release_stattype() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.TrafficFlow.statType)
  
  ::cn::seisys::v2x::pb::TrafficFlowStatType* temp = _impl_.stattype_;
  _impl_.stattype_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatType* TrafficFlow::_internal_mutable_stattype() {
  
  if (_impl_.stattype_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::TrafficFlowStatType>(GetArenaForAllocation());
    _impl_.stattype_ = p;
  }
  return _impl_.stattype_;
}
inline ::cn::seisys::v2x::pb::TrafficFlowStatType* TrafficFlow::mutable_stattype() {
  ::cn::seisys::v2x::pb::TrafficFlowStatType* _msg = _internal_mutable_stattype();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlow.statType)
  return _msg;
}
inline void TrafficFlow::set_allocated_stattype(::cn::seisys::v2x::pb::TrafficFlowStatType* stattype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stattype_;
  }
  if (stattype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stattype);
    if (message_arena != submessage_arena) {
      stattype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stattype, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stattype_ = stattype;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.TrafficFlow.statType)
}

// repeated .cn.seisys.v2x.pb.TrafficFlowStat stats = 4;
inline int TrafficFlow::_internal_stats_size() const {
  return _impl_.stats_.size();
}
inline int TrafficFlow::stats_size() const {
  return _internal_stats_size();
}
inline void TrafficFlow::clear_stats() {
  _impl_.stats_.Clear();
}
inline ::cn::seisys::v2x::pb::TrafficFlowStat* TrafficFlow::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.TrafficFlow.stats)
  return _impl_.stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlowStat >*
TrafficFlow::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.TrafficFlow.stats)
  return &_impl_.stats_;
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStat& TrafficFlow::_internal_stats(int index) const {
  return _impl_.stats_.Get(index);
}
inline const ::cn::seisys::v2x::pb::TrafficFlowStat& TrafficFlow::stats(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TrafficFlow.stats)
  return _internal_stats(index);
}
inline ::cn::seisys::v2x::pb::TrafficFlowStat* TrafficFlow::_internal_add_stats() {
  return _impl_.stats_.Add();
}
inline ::cn::seisys::v2x::pb::TrafficFlowStat* TrafficFlow::add_stats() {
  ::cn::seisys::v2x::pb::TrafficFlowStat* _add = _internal_add_stats();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.TrafficFlow.stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlowStat >&
TrafficFlow::stats() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.TrafficFlow.stats)
  return _impl_.stats_;
}

// -------------------------------------------------------------------

// TimeCountingDown

// uint32 startTime = 1;
inline void TimeCountingDown::clear_starttime() {
  _impl_.starttime_ = 0u;
}
inline uint32_t TimeCountingDown::_internal_starttime() const {
  return _impl_.starttime_;
}
inline uint32_t TimeCountingDown::starttime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TimeCountingDown.startTime)
  return _internal_starttime();
}
inline void TimeCountingDown::_internal_set_starttime(uint32_t value) {
  
  _impl_.starttime_ = value;
}
inline void TimeCountingDown::set_starttime(uint32_t value) {
  _internal_set_starttime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TimeCountingDown.startTime)
}

// uint32 minEndTime = 2;
inline void TimeCountingDown::clear_minendtime() {
  _impl_.minendtime_ = 0u;
}
inline uint32_t TimeCountingDown::_internal_minendtime() const {
  return _impl_.minendtime_;
}
inline uint32_t TimeCountingDown::minendtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TimeCountingDown.minEndTime)
  return _internal_minendtime();
}
inline void TimeCountingDown::_internal_set_minendtime(uint32_t value) {
  
  _impl_.minendtime_ = value;
}
inline void TimeCountingDown::set_minendtime(uint32_t value) {
  _internal_set_minendtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TimeCountingDown.minEndTime)
}

// uint32 maxEndTime = 3;
inline void TimeCountingDown::clear_maxendtime() {
  _impl_.maxendtime_ = 0u;
}
inline uint32_t TimeCountingDown::_internal_maxendtime() const {
  return _impl_.maxendtime_;
}
inline uint32_t TimeCountingDown::maxendtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TimeCountingDown.maxEndTime)
  return _internal_maxendtime();
}
inline void TimeCountingDown::_internal_set_maxendtime(uint32_t value) {
  
  _impl_.maxendtime_ = value;
}
inline void TimeCountingDown::set_maxendtime(uint32_t value) {
  _internal_set_maxendtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TimeCountingDown.maxEndTime)
}

// uint32 likelyEndTime = 4;
inline void TimeCountingDown::clear_likelyendtime() {
  _impl_.likelyendtime_ = 0u;
}
inline uint32_t TimeCountingDown::_internal_likelyendtime() const {
  return _impl_.likelyendtime_;
}
inline uint32_t TimeCountingDown::likelyendtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TimeCountingDown.likelyEndTime)
  return _internal_likelyendtime();
}
inline void TimeCountingDown::_internal_set_likelyendtime(uint32_t value) {
  
  _impl_.likelyendtime_ = value;
}
inline void TimeCountingDown::set_likelyendtime(uint32_t value) {
  _internal_set_likelyendtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TimeCountingDown.likelyEndTime)
}

// .cn.seisys.v2x.pb.TimeConfidence timeConfidence = 5;
inline void TimeCountingDown::clear_timeconfidence() {
  _impl_.timeconfidence_ = 0;
}
inline ::cn::seisys::v2x::pb::TimeConfidence TimeCountingDown::_internal_timeconfidence() const {
  return static_cast< ::cn::seisys::v2x::pb::TimeConfidence >(_impl_.timeconfidence_);
}
inline ::cn::seisys::v2x::pb::TimeConfidence TimeCountingDown::timeconfidence() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TimeCountingDown.timeConfidence)
  return _internal_timeconfidence();
}
inline void TimeCountingDown::_internal_set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  
  _impl_.timeconfidence_ = value;
}
inline void TimeCountingDown::set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  _internal_set_timeconfidence(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TimeCountingDown.timeConfidence)
}

// uint32 nextStartTime = 6;
inline void TimeCountingDown::clear_nextstarttime() {
  _impl_.nextstarttime_ = 0u;
}
inline uint32_t TimeCountingDown::_internal_nextstarttime() const {
  return _impl_.nextstarttime_;
}
inline uint32_t TimeCountingDown::nextstarttime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TimeCountingDown.nextStartTime)
  return _internal_nextstarttime();
}
inline void TimeCountingDown::_internal_set_nextstarttime(uint32_t value) {
  
  _impl_.nextstarttime_ = value;
}
inline void TimeCountingDown::set_nextstarttime(uint32_t value) {
  _internal_set_nextstarttime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TimeCountingDown.nextStartTime)
}

// uint32 nextDuration = 7;
inline void TimeCountingDown::clear_nextduration() {
  _impl_.nextduration_ = 0u;
}
inline uint32_t TimeCountingDown::_internal_nextduration() const {
  return _impl_.nextduration_;
}
inline uint32_t TimeCountingDown::nextduration() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.TimeCountingDown.nextDuration)
  return _internal_nextduration();
}
inline void TimeCountingDown::_internal_set_nextduration(uint32_t value) {
  
  _impl_.nextduration_ = value;
}
inline void TimeCountingDown::set_nextduration(uint32_t value) {
  _internal_set_nextduration(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.TimeCountingDown.nextDuration)
}

// -------------------------------------------------------------------

// PhaseState

// .cn.seisys.v2x.pb.PhaseState.LightState light = 1;
inline void PhaseState::clear_light() {
  _impl_.light_ = 0;
}
inline ::cn::seisys::v2x::pb::PhaseState_LightState PhaseState::_internal_light() const {
  return static_cast< ::cn::seisys::v2x::pb::PhaseState_LightState >(_impl_.light_);
}
inline ::cn::seisys::v2x::pb::PhaseState_LightState PhaseState::light() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PhaseState.light)
  return _internal_light();
}
inline void PhaseState::_internal_set_light(::cn::seisys::v2x::pb::PhaseState_LightState value) {
  
  _impl_.light_ = value;
}
inline void PhaseState::set_light(::cn::seisys::v2x::pb::PhaseState_LightState value) {
  _internal_set_light(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PhaseState.light)
}

// .cn.seisys.v2x.pb.TimeCountingDown timing = 2;
inline bool PhaseState::_internal_has_timing() const {
  return this != internal_default_instance() && _impl_.timing_ != nullptr;
}
inline bool PhaseState::has_timing() const {
  return _internal_has_timing();
}
inline void PhaseState::clear_timing() {
  if (GetArenaForAllocation() == nullptr && _impl_.timing_ != nullptr) {
    delete _impl_.timing_;
  }
  _impl_.timing_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::TimeCountingDown& PhaseState::_internal_timing() const {
  const ::cn::seisys::v2x::pb::TimeCountingDown* p = _impl_.timing_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::TimeCountingDown&>(
      ::cn::seisys::v2x::pb::_TimeCountingDown_default_instance_);
}
inline const ::cn::seisys::v2x::pb::TimeCountingDown& PhaseState::timing() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PhaseState.timing)
  return _internal_timing();
}
inline void PhaseState::unsafe_arena_set_allocated_timing(
    ::cn::seisys::v2x::pb::TimeCountingDown* timing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timing_);
  }
  _impl_.timing_ = timing;
  if (timing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PhaseState.timing)
}
inline ::cn::seisys::v2x::pb::TimeCountingDown* PhaseState::release_timing() {
  
  ::cn::seisys::v2x::pb::TimeCountingDown* temp = _impl_.timing_;
  _impl_.timing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::TimeCountingDown* PhaseState::unsafe_arena_release_timing() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PhaseState.timing)
  
  ::cn::seisys::v2x::pb::TimeCountingDown* temp = _impl_.timing_;
  _impl_.timing_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::TimeCountingDown* PhaseState::_internal_mutable_timing() {
  
  if (_impl_.timing_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::TimeCountingDown>(GetArenaForAllocation());
    _impl_.timing_ = p;
  }
  return _impl_.timing_;
}
inline ::cn::seisys::v2x::pb::TimeCountingDown* PhaseState::mutable_timing() {
  ::cn::seisys::v2x::pb::TimeCountingDown* _msg = _internal_mutable_timing();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PhaseState.timing)
  return _msg;
}
inline void PhaseState::set_allocated_timing(::cn::seisys::v2x::pb::TimeCountingDown* timing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timing_;
  }
  if (timing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timing);
    if (message_arena != submessage_arena) {
      timing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timing, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timing_ = timing;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PhaseState.timing)
}

// -------------------------------------------------------------------

// Phase

// uint32 id = 1;
inline void Phase::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Phase::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Phase::id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Phase.id)
  return _internal_id();
}
inline void Phase::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Phase::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Phase.id)
}

// repeated .cn.seisys.v2x.pb.PhaseState phaseStates = 2;
inline int Phase::_internal_phasestates_size() const {
  return _impl_.phasestates_.size();
}
inline int Phase::phasestates_size() const {
  return _internal_phasestates_size();
}
inline void Phase::clear_phasestates() {
  _impl_.phasestates_.Clear();
}
inline ::cn::seisys::v2x::pb::PhaseState* Phase::mutable_phasestates(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Phase.phaseStates)
  return _impl_.phasestates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseState >*
Phase::mutable_phasestates() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Phase.phaseStates)
  return &_impl_.phasestates_;
}
inline const ::cn::seisys::v2x::pb::PhaseState& Phase::_internal_phasestates(int index) const {
  return _impl_.phasestates_.Get(index);
}
inline const ::cn::seisys::v2x::pb::PhaseState& Phase::phasestates(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Phase.phaseStates)
  return _internal_phasestates(index);
}
inline ::cn::seisys::v2x::pb::PhaseState* Phase::_internal_add_phasestates() {
  return _impl_.phasestates_.Add();
}
inline ::cn::seisys::v2x::pb::PhaseState* Phase::add_phasestates() {
  ::cn::seisys::v2x::pb::PhaseState* _add = _internal_add_phasestates();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Phase.phaseStates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseState >&
Phase::phasestates() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Phase.phaseStates)
  return _impl_.phasestates_;
}

// -------------------------------------------------------------------

// IntersectionState

// .cn.seisys.v2x.pb.NodeReferenceId intersectionId = 1;
inline bool IntersectionState::_internal_has_intersectionid() const {
  return this != internal_default_instance() && _impl_.intersectionid_ != nullptr;
}
inline bool IntersectionState::has_intersectionid() const {
  return _internal_has_intersectionid();
}
inline void IntersectionState::clear_intersectionid() {
  if (GetArenaForAllocation() == nullptr && _impl_.intersectionid_ != nullptr) {
    delete _impl_.intersectionid_;
  }
  _impl_.intersectionid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& IntersectionState::_internal_intersectionid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.intersectionid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& IntersectionState::intersectionid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.IntersectionState.intersectionId)
  return _internal_intersectionid();
}
inline void IntersectionState::unsafe_arena_set_allocated_intersectionid(
    ::cn::seisys::v2x::pb::NodeReferenceId* intersectionid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intersectionid_);
  }
  _impl_.intersectionid_ = intersectionid;
  if (intersectionid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.IntersectionState.intersectionId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* IntersectionState::release_intersectionid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.intersectionid_;
  _impl_.intersectionid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* IntersectionState::unsafe_arena_release_intersectionid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.IntersectionState.intersectionId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.intersectionid_;
  _impl_.intersectionid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* IntersectionState::_internal_mutable_intersectionid() {
  
  if (_impl_.intersectionid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.intersectionid_ = p;
  }
  return _impl_.intersectionid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* IntersectionState::mutable_intersectionid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_intersectionid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.IntersectionState.intersectionId)
  return _msg;
}
inline void IntersectionState::set_allocated_intersectionid(::cn::seisys::v2x::pb::NodeReferenceId* intersectionid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.intersectionid_;
  }
  if (intersectionid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intersectionid);
    if (message_arena != submessage_arena) {
      intersectionid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intersectionid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.intersectionid_ = intersectionid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.IntersectionState.intersectionId)
}

// string status = 2;
inline void IntersectionState::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& IntersectionState::status() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.IntersectionState.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IntersectionState::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.IntersectionState.status)
}
inline std::string* IntersectionState::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.IntersectionState.status)
  return _s;
}
inline const std::string& IntersectionState::_internal_status() const {
  return _impl_.status_.Get();
}
inline void IntersectionState::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* IntersectionState::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* IntersectionState::release_status() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.IntersectionState.status)
  return _impl_.status_.Release();
}
inline void IntersectionState::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.IntersectionState.status)
}

// uint64 timestamp = 3;
inline void IntersectionState::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t IntersectionState::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t IntersectionState::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.IntersectionState.timestamp)
  return _internal_timestamp();
}
inline void IntersectionState::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void IntersectionState::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.IntersectionState.timestamp)
}

// .cn.seisys.v2x.pb.TimeConfidence timeConfidence = 4;
inline void IntersectionState::clear_timeconfidence() {
  _impl_.timeconfidence_ = 0;
}
inline ::cn::seisys::v2x::pb::TimeConfidence IntersectionState::_internal_timeconfidence() const {
  return static_cast< ::cn::seisys::v2x::pb::TimeConfidence >(_impl_.timeconfidence_);
}
inline ::cn::seisys::v2x::pb::TimeConfidence IntersectionState::timeconfidence() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.IntersectionState.timeConfidence)
  return _internal_timeconfidence();
}
inline void IntersectionState::_internal_set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  
  _impl_.timeconfidence_ = value;
}
inline void IntersectionState::set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  _internal_set_timeconfidence(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.IntersectionState.timeConfidence)
}

// repeated .cn.seisys.v2x.pb.Phase phases = 5;
inline int IntersectionState::_internal_phases_size() const {
  return _impl_.phases_.size();
}
inline int IntersectionState::phases_size() const {
  return _internal_phases_size();
}
inline void IntersectionState::clear_phases() {
  _impl_.phases_.Clear();
}
inline ::cn::seisys::v2x::pb::Phase* IntersectionState::mutable_phases(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.IntersectionState.phases)
  return _impl_.phases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Phase >*
IntersectionState::mutable_phases() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.IntersectionState.phases)
  return &_impl_.phases_;
}
inline const ::cn::seisys::v2x::pb::Phase& IntersectionState::_internal_phases(int index) const {
  return _impl_.phases_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Phase& IntersectionState::phases(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.IntersectionState.phases)
  return _internal_phases(index);
}
inline ::cn::seisys::v2x::pb::Phase* IntersectionState::_internal_add_phases() {
  return _impl_.phases_.Add();
}
inline ::cn::seisys::v2x::pb::Phase* IntersectionState::add_phases() {
  ::cn::seisys::v2x::pb::Phase* _add = _internal_add_phases();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.IntersectionState.phases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Phase >&
IntersectionState::phases() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.IntersectionState.phases)
  return _impl_.phases_;
}

// -------------------------------------------------------------------

// SpatData

// uint32 msgCnt = 1;
inline void SpatData::clear_msgcnt() {
  _impl_.msgcnt_ = 0u;
}
inline uint32_t SpatData::_internal_msgcnt() const {
  return _impl_.msgcnt_;
}
inline uint32_t SpatData::msgcnt() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SpatData.msgCnt)
  return _internal_msgcnt();
}
inline void SpatData::_internal_set_msgcnt(uint32_t value) {
  
  _impl_.msgcnt_ = value;
}
inline void SpatData::set_msgcnt(uint32_t value) {
  _internal_set_msgcnt(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SpatData.msgCnt)
}

// uint64 timestamp = 2;
inline void SpatData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t SpatData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t SpatData::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SpatData.timestamp)
  return _internal_timestamp();
}
inline void SpatData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void SpatData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SpatData.timestamp)
}

// repeated .cn.seisys.v2x.pb.IntersectionState intersections = 3;
inline int SpatData::_internal_intersections_size() const {
  return _impl_.intersections_.size();
}
inline int SpatData::intersections_size() const {
  return _internal_intersections_size();
}
inline void SpatData::clear_intersections() {
  _impl_.intersections_.Clear();
}
inline ::cn::seisys::v2x::pb::IntersectionState* SpatData::mutable_intersections(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.SpatData.intersections)
  return _impl_.intersections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::IntersectionState >*
SpatData::mutable_intersections() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.SpatData.intersections)
  return &_impl_.intersections_;
}
inline const ::cn::seisys::v2x::pb::IntersectionState& SpatData::_internal_intersections(int index) const {
  return _impl_.intersections_.Get(index);
}
inline const ::cn::seisys::v2x::pb::IntersectionState& SpatData::intersections(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SpatData.intersections)
  return _internal_intersections(index);
}
inline ::cn::seisys::v2x::pb::IntersectionState* SpatData::_internal_add_intersections() {
  return _impl_.intersections_.Add();
}
inline ::cn::seisys::v2x::pb::IntersectionState* SpatData::add_intersections() {
  ::cn::seisys::v2x::pb::IntersectionState* _add = _internal_add_intersections();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.SpatData.intersections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::IntersectionState >&
SpatData::intersections() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.SpatData.intersections)
  return _impl_.intersections_;
}

// -------------------------------------------------------------------

// LocalTimePoint

// int32 hh = 1;
inline void LocalTimePoint::clear_hh() {
  _impl_.hh_ = 0;
}
inline int32_t LocalTimePoint::_internal_hh() const {
  return _impl_.hh_;
}
inline int32_t LocalTimePoint::hh() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LocalTimePoint.hh)
  return _internal_hh();
}
inline void LocalTimePoint::_internal_set_hh(int32_t value) {
  
  _impl_.hh_ = value;
}
inline void LocalTimePoint::set_hh(int32_t value) {
  _internal_set_hh(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LocalTimePoint.hh)
}

// int32 mm = 2;
inline void LocalTimePoint::clear_mm() {
  _impl_.mm_ = 0;
}
inline int32_t LocalTimePoint::_internal_mm() const {
  return _impl_.mm_;
}
inline int32_t LocalTimePoint::mm() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LocalTimePoint.mm)
  return _internal_mm();
}
inline void LocalTimePoint::_internal_set_mm(int32_t value) {
  
  _impl_.mm_ = value;
}
inline void LocalTimePoint::set_mm(int32_t value) {
  _internal_set_mm(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LocalTimePoint.mm)
}

// int32 ss = 3;
inline void LocalTimePoint::clear_ss() {
  _impl_.ss_ = 0;
}
inline int32_t LocalTimePoint::_internal_ss() const {
  return _impl_.ss_;
}
inline int32_t LocalTimePoint::ss() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LocalTimePoint.ss)
  return _internal_ss();
}
inline void LocalTimePoint::_internal_set_ss(int32_t value) {
  
  _impl_.ss_ = value;
}
inline void LocalTimePoint::set_ss(int32_t value) {
  _internal_set_ss(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LocalTimePoint.ss)
}

// -------------------------------------------------------------------

// PeriodictimeSpan

// int32 monthFilter = 1;
inline void PeriodictimeSpan::clear_monthfilter() {
  _impl_.monthfilter_ = 0;
}
inline int32_t PeriodictimeSpan::_internal_monthfilter() const {
  return _impl_.monthfilter_;
}
inline int32_t PeriodictimeSpan::monthfilter() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PeriodictimeSpan.monthFilter)
  return _internal_monthfilter();
}
inline void PeriodictimeSpan::_internal_set_monthfilter(int32_t value) {
  
  _impl_.monthfilter_ = value;
}
inline void PeriodictimeSpan::set_monthfilter(int32_t value) {
  _internal_set_monthfilter(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PeriodictimeSpan.monthFilter)
}

// int32 dayFilter = 2;
inline void PeriodictimeSpan::clear_dayfilter() {
  _impl_.dayfilter_ = 0;
}
inline int32_t PeriodictimeSpan::_internal_dayfilter() const {
  return _impl_.dayfilter_;
}
inline int32_t PeriodictimeSpan::dayfilter() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PeriodictimeSpan.dayFilter)
  return _internal_dayfilter();
}
inline void PeriodictimeSpan::_internal_set_dayfilter(int32_t value) {
  
  _impl_.dayfilter_ = value;
}
inline void PeriodictimeSpan::set_dayfilter(int32_t value) {
  _internal_set_dayfilter(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PeriodictimeSpan.dayFilter)
}

// int32 weekdayFilter = 3;
inline void PeriodictimeSpan::clear_weekdayfilter() {
  _impl_.weekdayfilter_ = 0;
}
inline int32_t PeriodictimeSpan::_internal_weekdayfilter() const {
  return _impl_.weekdayfilter_;
}
inline int32_t PeriodictimeSpan::weekdayfilter() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PeriodictimeSpan.weekdayFilter)
  return _internal_weekdayfilter();
}
inline void PeriodictimeSpan::_internal_set_weekdayfilter(int32_t value) {
  
  _impl_.weekdayfilter_ = value;
}
inline void PeriodictimeSpan::set_weekdayfilter(int32_t value) {
  _internal_set_weekdayfilter(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PeriodictimeSpan.weekdayFilter)
}

// .cn.seisys.v2x.pb.LocalTimePoint fromTimePoint = 4;
inline bool PeriodictimeSpan::_internal_has_fromtimepoint() const {
  return this != internal_default_instance() && _impl_.fromtimepoint_ != nullptr;
}
inline bool PeriodictimeSpan::has_fromtimepoint() const {
  return _internal_has_fromtimepoint();
}
inline void PeriodictimeSpan::clear_fromtimepoint() {
  if (GetArenaForAllocation() == nullptr && _impl_.fromtimepoint_ != nullptr) {
    delete _impl_.fromtimepoint_;
  }
  _impl_.fromtimepoint_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LocalTimePoint& PeriodictimeSpan::_internal_fromtimepoint() const {
  const ::cn::seisys::v2x::pb::LocalTimePoint* p = _impl_.fromtimepoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LocalTimePoint&>(
      ::cn::seisys::v2x::pb::_LocalTimePoint_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LocalTimePoint& PeriodictimeSpan::fromtimepoint() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PeriodictimeSpan.fromTimePoint)
  return _internal_fromtimepoint();
}
inline void PeriodictimeSpan::unsafe_arena_set_allocated_fromtimepoint(
    ::cn::seisys::v2x::pb::LocalTimePoint* fromtimepoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fromtimepoint_);
  }
  _impl_.fromtimepoint_ = fromtimepoint;
  if (fromtimepoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PeriodictimeSpan.fromTimePoint)
}
inline ::cn::seisys::v2x::pb::LocalTimePoint* PeriodictimeSpan::release_fromtimepoint() {
  
  ::cn::seisys::v2x::pb::LocalTimePoint* temp = _impl_.fromtimepoint_;
  _impl_.fromtimepoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LocalTimePoint* PeriodictimeSpan::unsafe_arena_release_fromtimepoint() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PeriodictimeSpan.fromTimePoint)
  
  ::cn::seisys::v2x::pb::LocalTimePoint* temp = _impl_.fromtimepoint_;
  _impl_.fromtimepoint_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LocalTimePoint* PeriodictimeSpan::_internal_mutable_fromtimepoint() {
  
  if (_impl_.fromtimepoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LocalTimePoint>(GetArenaForAllocation());
    _impl_.fromtimepoint_ = p;
  }
  return _impl_.fromtimepoint_;
}
inline ::cn::seisys::v2x::pb::LocalTimePoint* PeriodictimeSpan::mutable_fromtimepoint() {
  ::cn::seisys::v2x::pb::LocalTimePoint* _msg = _internal_mutable_fromtimepoint();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PeriodictimeSpan.fromTimePoint)
  return _msg;
}
inline void PeriodictimeSpan::set_allocated_fromtimepoint(::cn::seisys::v2x::pb::LocalTimePoint* fromtimepoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fromtimepoint_;
  }
  if (fromtimepoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fromtimepoint);
    if (message_arena != submessage_arena) {
      fromtimepoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fromtimepoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fromtimepoint_ = fromtimepoint;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PeriodictimeSpan.fromTimePoint)
}

// .cn.seisys.v2x.pb.LocalTimePoint toTimePoint = 5;
inline bool PeriodictimeSpan::_internal_has_totimepoint() const {
  return this != internal_default_instance() && _impl_.totimepoint_ != nullptr;
}
inline bool PeriodictimeSpan::has_totimepoint() const {
  return _internal_has_totimepoint();
}
inline void PeriodictimeSpan::clear_totimepoint() {
  if (GetArenaForAllocation() == nullptr && _impl_.totimepoint_ != nullptr) {
    delete _impl_.totimepoint_;
  }
  _impl_.totimepoint_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LocalTimePoint& PeriodictimeSpan::_internal_totimepoint() const {
  const ::cn::seisys::v2x::pb::LocalTimePoint* p = _impl_.totimepoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LocalTimePoint&>(
      ::cn::seisys::v2x::pb::_LocalTimePoint_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LocalTimePoint& PeriodictimeSpan::totimepoint() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PeriodictimeSpan.toTimePoint)
  return _internal_totimepoint();
}
inline void PeriodictimeSpan::unsafe_arena_set_allocated_totimepoint(
    ::cn::seisys::v2x::pb::LocalTimePoint* totimepoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.totimepoint_);
  }
  _impl_.totimepoint_ = totimepoint;
  if (totimepoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PeriodictimeSpan.toTimePoint)
}
inline ::cn::seisys::v2x::pb::LocalTimePoint* PeriodictimeSpan::release_totimepoint() {
  
  ::cn::seisys::v2x::pb::LocalTimePoint* temp = _impl_.totimepoint_;
  _impl_.totimepoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LocalTimePoint* PeriodictimeSpan::unsafe_arena_release_totimepoint() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PeriodictimeSpan.toTimePoint)
  
  ::cn::seisys::v2x::pb::LocalTimePoint* temp = _impl_.totimepoint_;
  _impl_.totimepoint_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LocalTimePoint* PeriodictimeSpan::_internal_mutable_totimepoint() {
  
  if (_impl_.totimepoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LocalTimePoint>(GetArenaForAllocation());
    _impl_.totimepoint_ = p;
  }
  return _impl_.totimepoint_;
}
inline ::cn::seisys::v2x::pb::LocalTimePoint* PeriodictimeSpan::mutable_totimepoint() {
  ::cn::seisys::v2x::pb::LocalTimePoint* _msg = _internal_mutable_totimepoint();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PeriodictimeSpan.toTimePoint)
  return _msg;
}
inline void PeriodictimeSpan::set_allocated_totimepoint(::cn::seisys::v2x::pb::LocalTimePoint* totimepoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.totimepoint_;
  }
  if (totimepoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(totimepoint);
    if (message_arena != submessage_arena) {
      totimepoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, totimepoint, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.totimepoint_ = totimepoint;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PeriodictimeSpan.toTimePoint)
}

// -------------------------------------------------------------------

// SingleTimeSpan

// uint64 startTime = 1;
inline void SingleTimeSpan::clear_starttime() {
  _impl_.starttime_ = uint64_t{0u};
}
inline uint64_t SingleTimeSpan::_internal_starttime() const {
  return _impl_.starttime_;
}
inline uint64_t SingleTimeSpan::starttime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SingleTimeSpan.startTime)
  return _internal_starttime();
}
inline void SingleTimeSpan::_internal_set_starttime(uint64_t value) {
  
  _impl_.starttime_ = value;
}
inline void SingleTimeSpan::set_starttime(uint64_t value) {
  _internal_set_starttime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SingleTimeSpan.startTime)
}

// uint64 endTime = 2;
inline void SingleTimeSpan::clear_endtime() {
  _impl_.endtime_ = uint64_t{0u};
}
inline uint64_t SingleTimeSpan::_internal_endtime() const {
  return _impl_.endtime_;
}
inline uint64_t SingleTimeSpan::endtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SingleTimeSpan.endTime)
  return _internal_endtime();
}
inline void SingleTimeSpan::_internal_set_endtime(uint64_t value) {
  
  _impl_.endtime_ = value;
}
inline void SingleTimeSpan::set_endtime(uint64_t value) {
  _internal_set_endtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SingleTimeSpan.endTime)
}

// -------------------------------------------------------------------

// OptimTimeType

// .cn.seisys.v2x.pb.SingleTimeSpan single = 1;
inline bool OptimTimeType::_internal_has_single() const {
  return OptimTimeTypeOneOf_case() == kSingle;
}
inline bool OptimTimeType::has_single() const {
  return _internal_has_single();
}
inline void OptimTimeType::set_has_single() {
  _impl_._oneof_case_[0] = kSingle;
}
inline void OptimTimeType::clear_single() {
  if (_internal_has_single()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.OptimTimeTypeOneOf_.single_;
    }
    clear_has_OptimTimeTypeOneOf();
  }
}
inline ::cn::seisys::v2x::pb::SingleTimeSpan* OptimTimeType::release_single() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.OptimTimeType.single)
  if (_internal_has_single()) {
    clear_has_OptimTimeTypeOneOf();
    ::cn::seisys::v2x::pb::SingleTimeSpan* temp = _impl_.OptimTimeTypeOneOf_.single_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.OptimTimeTypeOneOf_.single_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::SingleTimeSpan& OptimTimeType::_internal_single() const {
  return _internal_has_single()
      ? *_impl_.OptimTimeTypeOneOf_.single_
      : reinterpret_cast< ::cn::seisys::v2x::pb::SingleTimeSpan&>(::cn::seisys::v2x::pb::_SingleTimeSpan_default_instance_);
}
inline const ::cn::seisys::v2x::pb::SingleTimeSpan& OptimTimeType::single() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimTimeType.single)
  return _internal_single();
}
inline ::cn::seisys::v2x::pb::SingleTimeSpan* OptimTimeType::unsafe_arena_release_single() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.OptimTimeType.single)
  if (_internal_has_single()) {
    clear_has_OptimTimeTypeOneOf();
    ::cn::seisys::v2x::pb::SingleTimeSpan* temp = _impl_.OptimTimeTypeOneOf_.single_;
    _impl_.OptimTimeTypeOneOf_.single_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OptimTimeType::unsafe_arena_set_allocated_single(::cn::seisys::v2x::pb::SingleTimeSpan* single) {
  clear_OptimTimeTypeOneOf();
  if (single) {
    set_has_single();
    _impl_.OptimTimeTypeOneOf_.single_ = single;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.OptimTimeType.single)
}
inline ::cn::seisys::v2x::pb::SingleTimeSpan* OptimTimeType::_internal_mutable_single() {
  if (!_internal_has_single()) {
    clear_OptimTimeTypeOneOf();
    set_has_single();
    _impl_.OptimTimeTypeOneOf_.single_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::SingleTimeSpan >(GetArenaForAllocation());
  }
  return _impl_.OptimTimeTypeOneOf_.single_;
}
inline ::cn::seisys::v2x::pb::SingleTimeSpan* OptimTimeType::mutable_single() {
  ::cn::seisys::v2x::pb::SingleTimeSpan* _msg = _internal_mutable_single();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.OptimTimeType.single)
  return _msg;
}

// .cn.seisys.v2x.pb.PeriodictimeSpan periodic = 2;
inline bool OptimTimeType::_internal_has_periodic() const {
  return OptimTimeTypeOneOf_case() == kPeriodic;
}
inline bool OptimTimeType::has_periodic() const {
  return _internal_has_periodic();
}
inline void OptimTimeType::set_has_periodic() {
  _impl_._oneof_case_[0] = kPeriodic;
}
inline void OptimTimeType::clear_periodic() {
  if (_internal_has_periodic()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.OptimTimeTypeOneOf_.periodic_;
    }
    clear_has_OptimTimeTypeOneOf();
  }
}
inline ::cn::seisys::v2x::pb::PeriodictimeSpan* OptimTimeType::release_periodic() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.OptimTimeType.periodic)
  if (_internal_has_periodic()) {
    clear_has_OptimTimeTypeOneOf();
    ::cn::seisys::v2x::pb::PeriodictimeSpan* temp = _impl_.OptimTimeTypeOneOf_.periodic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.OptimTimeTypeOneOf_.periodic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::PeriodictimeSpan& OptimTimeType::_internal_periodic() const {
  return _internal_has_periodic()
      ? *_impl_.OptimTimeTypeOneOf_.periodic_
      : reinterpret_cast< ::cn::seisys::v2x::pb::PeriodictimeSpan&>(::cn::seisys::v2x::pb::_PeriodictimeSpan_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PeriodictimeSpan& OptimTimeType::periodic() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimTimeType.periodic)
  return _internal_periodic();
}
inline ::cn::seisys::v2x::pb::PeriodictimeSpan* OptimTimeType::unsafe_arena_release_periodic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.OptimTimeType.periodic)
  if (_internal_has_periodic()) {
    clear_has_OptimTimeTypeOneOf();
    ::cn::seisys::v2x::pb::PeriodictimeSpan* temp = _impl_.OptimTimeTypeOneOf_.periodic_;
    _impl_.OptimTimeTypeOneOf_.periodic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OptimTimeType::unsafe_arena_set_allocated_periodic(::cn::seisys::v2x::pb::PeriodictimeSpan* periodic) {
  clear_OptimTimeTypeOneOf();
  if (periodic) {
    set_has_periodic();
    _impl_.OptimTimeTypeOneOf_.periodic_ = periodic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.OptimTimeType.periodic)
}
inline ::cn::seisys::v2x::pb::PeriodictimeSpan* OptimTimeType::_internal_mutable_periodic() {
  if (!_internal_has_periodic()) {
    clear_OptimTimeTypeOneOf();
    set_has_periodic();
    _impl_.OptimTimeTypeOneOf_.periodic_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::PeriodictimeSpan >(GetArenaForAllocation());
  }
  return _impl_.OptimTimeTypeOneOf_.periodic_;
}
inline ::cn::seisys::v2x::pb::PeriodictimeSpan* OptimTimeType::mutable_periodic() {
  ::cn::seisys::v2x::pb::PeriodictimeSpan* _msg = _internal_mutable_periodic();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.OptimTimeType.periodic)
  return _msg;
}

inline bool OptimTimeType::has_OptimTimeTypeOneOf() const {
  return OptimTimeTypeOneOf_case() != OPTIMTIMETYPEONEOF_NOT_SET;
}
inline void OptimTimeType::clear_has_OptimTimeTypeOneOf() {
  _impl_._oneof_case_[0] = OPTIMTIMETYPEONEOF_NOT_SET;
}
inline OptimTimeType::OptimTimeTypeOneOfCase OptimTimeType::OptimTimeTypeOneOf_case() const {
  return OptimTimeType::OptimTimeTypeOneOfCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MovementEx

// .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
inline bool MovementEx::_internal_has_remoteintersection() const {
  return this != internal_default_instance() && _impl_.remoteintersection_ != nullptr;
}
inline bool MovementEx::has_remoteintersection() const {
  return _internal_has_remoteintersection();
}
inline void MovementEx::clear_remoteintersection() {
  if (GetArenaForAllocation() == nullptr && _impl_.remoteintersection_ != nullptr) {
    delete _impl_.remoteintersection_;
  }
  _impl_.remoteintersection_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& MovementEx::_internal_remoteintersection() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.remoteintersection_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& MovementEx::remoteintersection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementEx.remoteIntersection)
  return _internal_remoteintersection();
}
inline void MovementEx::unsafe_arena_set_allocated_remoteintersection(
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remoteintersection_);
  }
  _impl_.remoteintersection_ = remoteintersection;
  if (remoteintersection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.MovementEx.remoteIntersection)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MovementEx::release_remoteintersection() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MovementEx::unsafe_arena_release_remoteintersection() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MovementEx.remoteIntersection)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MovementEx::_internal_mutable_remoteintersection() {
  
  if (_impl_.remoteintersection_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.remoteintersection_ = p;
  }
  return _impl_.remoteintersection_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* MovementEx::mutable_remoteintersection() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_remoteintersection();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MovementEx.remoteIntersection)
  return _msg;
}
inline void MovementEx::set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remoteintersection_;
  }
  if (remoteintersection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remoteintersection);
    if (message_arena != submessage_arena) {
      remoteintersection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remoteintersection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remoteintersection_ = remoteintersection;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MovementEx.remoteIntersection)
}

// uint32 phaseId = 2;
inline void MovementEx::clear_phaseid() {
  _impl_.phaseid_ = 0u;
}
inline uint32_t MovementEx::_internal_phaseid() const {
  return _impl_.phaseid_;
}
inline uint32_t MovementEx::phaseid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementEx.phaseId)
  return _internal_phaseid();
}
inline void MovementEx::_internal_set_phaseid(uint32_t value) {
  
  _impl_.phaseid_ = value;
}
inline void MovementEx::set_phaseid(uint32_t value) {
  _internal_set_phaseid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementEx.phaseId)
}

// .cn.seisys.v2x.pb.Maneuver turnDirection = 3;
inline void MovementEx::clear_turndirection() {
  _impl_.turndirection_ = 0;
}
inline ::cn::seisys::v2x::pb::Maneuver MovementEx::_internal_turndirection() const {
  return static_cast< ::cn::seisys::v2x::pb::Maneuver >(_impl_.turndirection_);
}
inline ::cn::seisys::v2x::pb::Maneuver MovementEx::turndirection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MovementEx.turnDirection)
  return _internal_turndirection();
}
inline void MovementEx::_internal_set_turndirection(::cn::seisys::v2x::pb::Maneuver value) {
  
  _impl_.turndirection_ = value;
}
inline void MovementEx::set_turndirection(::cn::seisys::v2x::pb::Maneuver value) {
  _internal_set_turndirection(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MovementEx.turnDirection)
}

// -------------------------------------------------------------------

// OptimPhase

// uint32 phaseId = 1;
inline void OptimPhase::clear_phaseid() {
  _impl_.phaseid_ = 0u;
}
inline uint32_t OptimPhase::_internal_phaseid() const {
  return _impl_.phaseid_;
}
inline uint32_t OptimPhase::phaseid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimPhase.phaseId)
  return _internal_phaseid();
}
inline void OptimPhase::_internal_set_phaseid(uint32_t value) {
  
  _impl_.phaseid_ = value;
}
inline void OptimPhase::set_phaseid(uint32_t value) {
  _internal_set_phaseid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimPhase.phaseId)
}

// uint32 order = 2;
inline void OptimPhase::clear_order() {
  _impl_.order_ = 0u;
}
inline uint32_t OptimPhase::_internal_order() const {
  return _impl_.order_;
}
inline uint32_t OptimPhase::order() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimPhase.order)
  return _internal_order();
}
inline void OptimPhase::_internal_set_order(uint32_t value) {
  
  _impl_.order_ = value;
}
inline void OptimPhase::set_order(uint32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimPhase.order)
}

// repeated .cn.seisys.v2x.pb.MovementEx movementId = 3;
inline int OptimPhase::_internal_movementid_size() const {
  return _impl_.movementid_.size();
}
inline int OptimPhase::movementid_size() const {
  return _internal_movementid_size();
}
inline void OptimPhase::clear_movementid() {
  _impl_.movementid_.Clear();
}
inline ::cn::seisys::v2x::pb::MovementEx* OptimPhase::mutable_movementid(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.OptimPhase.movementId)
  return _impl_.movementid_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx >*
OptimPhase::mutable_movementid() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.OptimPhase.movementId)
  return &_impl_.movementid_;
}
inline const ::cn::seisys::v2x::pb::MovementEx& OptimPhase::_internal_movementid(int index) const {
  return _impl_.movementid_.Get(index);
}
inline const ::cn::seisys::v2x::pb::MovementEx& OptimPhase::movementid(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimPhase.movementId)
  return _internal_movementid(index);
}
inline ::cn::seisys::v2x::pb::MovementEx* OptimPhase::_internal_add_movementid() {
  return _impl_.movementid_.Add();
}
inline ::cn::seisys::v2x::pb::MovementEx* OptimPhase::add_movementid() {
  ::cn::seisys::v2x::pb::MovementEx* _add = _internal_add_movementid();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.OptimPhase.movementId)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx >&
OptimPhase::movementid() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.OptimPhase.movementId)
  return _impl_.movementid_;
}

// uint32 phaseTime = 4;
inline void OptimPhase::clear_phasetime() {
  _impl_.phasetime_ = 0u;
}
inline uint32_t OptimPhase::_internal_phasetime() const {
  return _impl_.phasetime_;
}
inline uint32_t OptimPhase::phasetime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimPhase.phaseTime)
  return _internal_phasetime();
}
inline void OptimPhase::_internal_set_phasetime(uint32_t value) {
  
  _impl_.phasetime_ = value;
}
inline void OptimPhase::set_phasetime(uint32_t value) {
  _internal_set_phasetime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimPhase.phaseTime)
}

// uint32 green = 5;
inline void OptimPhase::clear_green() {
  _impl_.green_ = 0u;
}
inline uint32_t OptimPhase::_internal_green() const {
  return _impl_.green_;
}
inline uint32_t OptimPhase::green() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimPhase.green)
  return _internal_green();
}
inline void OptimPhase::_internal_set_green(uint32_t value) {
  
  _impl_.green_ = value;
}
inline void OptimPhase::set_green(uint32_t value) {
  _internal_set_green(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimPhase.green)
}

// uint32 phaseYellowTime = 6;
inline void OptimPhase::clear_phaseyellowtime() {
  _impl_.phaseyellowtime_ = 0u;
}
inline uint32_t OptimPhase::_internal_phaseyellowtime() const {
  return _impl_.phaseyellowtime_;
}
inline uint32_t OptimPhase::phaseyellowtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimPhase.phaseYellowTime)
  return _internal_phaseyellowtime();
}
inline void OptimPhase::_internal_set_phaseyellowtime(uint32_t value) {
  
  _impl_.phaseyellowtime_ = value;
}
inline void OptimPhase::set_phaseyellowtime(uint32_t value) {
  _internal_set_phaseyellowtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimPhase.phaseYellowTime)
}

// uint32 phaseAllRedTime = 7;
inline void OptimPhase::clear_phaseallredtime() {
  _impl_.phaseallredtime_ = 0u;
}
inline uint32_t OptimPhase::_internal_phaseallredtime() const {
  return _impl_.phaseallredtime_;
}
inline uint32_t OptimPhase::phaseallredtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimPhase.phaseAllRedTime)
  return _internal_phaseallredtime();
}
inline void OptimPhase::_internal_set_phaseallredtime(uint32_t value) {
  
  _impl_.phaseallredtime_ = value;
}
inline void OptimPhase::set_phaseallredtime(uint32_t value) {
  _internal_set_phaseallredtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimPhase.phaseAllRedTime)
}

// uint32 minGreen = 8;
inline void OptimPhase::clear_mingreen() {
  _impl_.mingreen_ = 0u;
}
inline uint32_t OptimPhase::_internal_mingreen() const {
  return _impl_.mingreen_;
}
inline uint32_t OptimPhase::mingreen() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimPhase.minGreen)
  return _internal_mingreen();
}
inline void OptimPhase::_internal_set_mingreen(uint32_t value) {
  
  _impl_.mingreen_ = value;
}
inline void OptimPhase::set_mingreen(uint32_t value) {
  _internal_set_mingreen(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimPhase.minGreen)
}

// uint32 maxGreen = 9;
inline void OptimPhase::clear_maxgreen() {
  _impl_.maxgreen_ = 0u;
}
inline uint32_t OptimPhase::_internal_maxgreen() const {
  return _impl_.maxgreen_;
}
inline uint32_t OptimPhase::maxgreen() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimPhase.maxGreen)
  return _internal_maxgreen();
}
inline void OptimPhase::_internal_set_maxgreen(uint32_t value) {
  
  _impl_.maxgreen_ = value;
}
inline void OptimPhase::set_maxgreen(uint32_t value) {
  _internal_set_maxgreen(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimPhase.maxGreen)
}

// -------------------------------------------------------------------

// OptimData

// .cn.seisys.v2x.pb.OptimTimeType optimTimeType = 1;
inline bool OptimData::_internal_has_optimtimetype() const {
  return this != internal_default_instance() && _impl_.optimtimetype_ != nullptr;
}
inline bool OptimData::has_optimtimetype() const {
  return _internal_has_optimtimetype();
}
inline void OptimData::clear_optimtimetype() {
  if (GetArenaForAllocation() == nullptr && _impl_.optimtimetype_ != nullptr) {
    delete _impl_.optimtimetype_;
  }
  _impl_.optimtimetype_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::OptimTimeType& OptimData::_internal_optimtimetype() const {
  const ::cn::seisys::v2x::pb::OptimTimeType* p = _impl_.optimtimetype_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::OptimTimeType&>(
      ::cn::seisys::v2x::pb::_OptimTimeType_default_instance_);
}
inline const ::cn::seisys::v2x::pb::OptimTimeType& OptimData::optimtimetype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimData.optimTimeType)
  return _internal_optimtimetype();
}
inline void OptimData::unsafe_arena_set_allocated_optimtimetype(
    ::cn::seisys::v2x::pb::OptimTimeType* optimtimetype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.optimtimetype_);
  }
  _impl_.optimtimetype_ = optimtimetype;
  if (optimtimetype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.OptimData.optimTimeType)
}
inline ::cn::seisys::v2x::pb::OptimTimeType* OptimData::release_optimtimetype() {
  
  ::cn::seisys::v2x::pb::OptimTimeType* temp = _impl_.optimtimetype_;
  _impl_.optimtimetype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::OptimTimeType* OptimData::unsafe_arena_release_optimtimetype() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.OptimData.optimTimeType)
  
  ::cn::seisys::v2x::pb::OptimTimeType* temp = _impl_.optimtimetype_;
  _impl_.optimtimetype_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::OptimTimeType* OptimData::_internal_mutable_optimtimetype() {
  
  if (_impl_.optimtimetype_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::OptimTimeType>(GetArenaForAllocation());
    _impl_.optimtimetype_ = p;
  }
  return _impl_.optimtimetype_;
}
inline ::cn::seisys::v2x::pb::OptimTimeType* OptimData::mutable_optimtimetype() {
  ::cn::seisys::v2x::pb::OptimTimeType* _msg = _internal_mutable_optimtimetype();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.OptimData.optimTimeType)
  return _msg;
}
inline void OptimData::set_allocated_optimtimetype(::cn::seisys::v2x::pb::OptimTimeType* optimtimetype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.optimtimetype_;
  }
  if (optimtimetype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optimtimetype);
    if (message_arena != submessage_arena) {
      optimtimetype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optimtimetype, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.optimtimetype_ = optimtimetype;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.OptimData.optimTimeType)
}

// uint32 optimCycleTime = 2;
inline void OptimData::clear_optimcycletime() {
  _impl_.optimcycletime_ = 0u;
}
inline uint32_t OptimData::_internal_optimcycletime() const {
  return _impl_.optimcycletime_;
}
inline uint32_t OptimData::optimcycletime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimData.optimCycleTime)
  return _internal_optimcycletime();
}
inline void OptimData::_internal_set_optimcycletime(uint32_t value) {
  
  _impl_.optimcycletime_ = value;
}
inline void OptimData::set_optimcycletime(uint32_t value) {
  _internal_set_optimcycletime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimData.optimCycleTime)
}

// uint32 minCycleTime = 3;
inline void OptimData::clear_mincycletime() {
  _impl_.mincycletime_ = 0u;
}
inline uint32_t OptimData::_internal_mincycletime() const {
  return _impl_.mincycletime_;
}
inline uint32_t OptimData::mincycletime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimData.minCycleTime)
  return _internal_mincycletime();
}
inline void OptimData::_internal_set_mincycletime(uint32_t value) {
  
  _impl_.mincycletime_ = value;
}
inline void OptimData::set_mincycletime(uint32_t value) {
  _internal_set_mincycletime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimData.minCycleTime)
}

// uint32 maxCycleTime = 4;
inline void OptimData::clear_maxcycletime() {
  _impl_.maxcycletime_ = 0u;
}
inline uint32_t OptimData::_internal_maxcycletime() const {
  return _impl_.maxcycletime_;
}
inline uint32_t OptimData::maxcycletime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimData.maxCycleTime)
  return _internal_maxcycletime();
}
inline void OptimData::_internal_set_maxcycletime(uint32_t value) {
  
  _impl_.maxcycletime_ = value;
}
inline void OptimData::set_maxcycletime(uint32_t value) {
  _internal_set_maxcycletime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimData.maxCycleTime)
}

// repeated .cn.seisys.v2x.pb.OptimPhase optimPhaseList = 5;
inline int OptimData::_internal_optimphaselist_size() const {
  return _impl_.optimphaselist_.size();
}
inline int OptimData::optimphaselist_size() const {
  return _internal_optimphaselist_size();
}
inline void OptimData::clear_optimphaselist() {
  _impl_.optimphaselist_.Clear();
}
inline ::cn::seisys::v2x::pb::OptimPhase* OptimData::mutable_optimphaselist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.OptimData.optimPhaseList)
  return _impl_.optimphaselist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimPhase >*
OptimData::mutable_optimphaselist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.OptimData.optimPhaseList)
  return &_impl_.optimphaselist_;
}
inline const ::cn::seisys::v2x::pb::OptimPhase& OptimData::_internal_optimphaselist(int index) const {
  return _impl_.optimphaselist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::OptimPhase& OptimData::optimphaselist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimData.optimPhaseList)
  return _internal_optimphaselist(index);
}
inline ::cn::seisys::v2x::pb::OptimPhase* OptimData::_internal_add_optimphaselist() {
  return _impl_.optimphaselist_.Add();
}
inline ::cn::seisys::v2x::pb::OptimPhase* OptimData::add_optimphaselist() {
  ::cn::seisys::v2x::pb::OptimPhase* _add = _internal_add_optimphaselist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.OptimData.optimPhaseList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimPhase >&
OptimData::optimphaselist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.OptimData.optimPhaseList)
  return _impl_.optimphaselist_;
}

// string coorPhase = 6;
inline void OptimData::clear_coorphase() {
  _impl_.coorphase_.ClearToEmpty();
}
inline const std::string& OptimData::coorphase() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimData.coorPhase)
  return _internal_coorphase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OptimData::set_coorphase(ArgT0&& arg0, ArgT... args) {
 
 _impl_.coorphase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimData.coorPhase)
}
inline std::string* OptimData::mutable_coorphase() {
  std::string* _s = _internal_mutable_coorphase();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.OptimData.coorPhase)
  return _s;
}
inline const std::string& OptimData::_internal_coorphase() const {
  return _impl_.coorphase_.Get();
}
inline void OptimData::_internal_set_coorphase(const std::string& value) {
  
  _impl_.coorphase_.Set(value, GetArenaForAllocation());
}
inline std::string* OptimData::_internal_mutable_coorphase() {
  
  return _impl_.coorphase_.Mutable(GetArenaForAllocation());
}
inline std::string* OptimData::release_coorphase() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.OptimData.coorPhase)
  return _impl_.coorphase_.Release();
}
inline void OptimData::set_allocated_coorphase(std::string* coorphase) {
  if (coorphase != nullptr) {
    
  } else {
    
  }
  _impl_.coorphase_.SetAllocated(coorphase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.coorphase_.IsDefault()) {
    _impl_.coorphase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.OptimData.coorPhase)
}

// uint32 offset = 7;
inline void OptimData::clear_offset() {
  _impl_.offset_ = 0u;
}
inline uint32_t OptimData::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t OptimData::offset() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.OptimData.offset)
  return _internal_offset();
}
inline void OptimData::_internal_set_offset(uint32_t value) {
  
  _impl_.offset_ = value;
}
inline void OptimData::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.OptimData.offset)
}

// -------------------------------------------------------------------

// SignalScheme

// .cn.seisys.v2x.pb.NodeReferenceId nodeId = 1;
inline bool SignalScheme::_internal_has_nodeid() const {
  return this != internal_default_instance() && _impl_.nodeid_ != nullptr;
}
inline bool SignalScheme::has_nodeid() const {
  return _internal_has_nodeid();
}
inline void SignalScheme::clear_nodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.nodeid_ != nullptr) {
    delete _impl_.nodeid_;
  }
  _impl_.nodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& SignalScheme::_internal_nodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.nodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& SignalScheme::nodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalScheme.nodeId)
  return _internal_nodeid();
}
inline void SignalScheme::unsafe_arena_set_allocated_nodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodeid_);
  }
  _impl_.nodeid_ = nodeid;
  if (nodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.SignalScheme.nodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* SignalScheme::release_nodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* SignalScheme::unsafe_arena_release_nodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.SignalScheme.nodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.nodeid_;
  _impl_.nodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* SignalScheme::_internal_mutable_nodeid() {
  
  if (_impl_.nodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.nodeid_ = p;
  }
  return _impl_.nodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* SignalScheme::mutable_nodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_nodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.SignalScheme.nodeId)
  return _msg;
}
inline void SignalScheme::set_allocated_nodeid(::cn::seisys::v2x::pb::NodeReferenceId* nodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nodeid_;
  }
  if (nodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nodeid);
    if (message_arena != submessage_arena) {
      nodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nodeid_ = nodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.SignalScheme.nodeId)
}

// uint32 optimType = 2;
inline void SignalScheme::clear_optimtype() {
  _impl_.optimtype_ = 0u;
}
inline uint32_t SignalScheme::_internal_optimtype() const {
  return _impl_.optimtype_;
}
inline uint32_t SignalScheme::optimtype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalScheme.optimType)
  return _internal_optimtype();
}
inline void SignalScheme::_internal_set_optimtype(uint32_t value) {
  
  _impl_.optimtype_ = value;
}
inline void SignalScheme::set_optimtype(uint32_t value) {
  _internal_set_optimtype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SignalScheme.optimType)
}

// uint64 timestamp = 3;
inline void SignalScheme::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t SignalScheme::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t SignalScheme::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalScheme.timestamp)
  return _internal_timestamp();
}
inline void SignalScheme::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void SignalScheme::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SignalScheme.timestamp)
}

// repeated .cn.seisys.v2x.pb.OptimData optimDataList = 4;
inline int SignalScheme::_internal_optimdatalist_size() const {
  return _impl_.optimdatalist_.size();
}
inline int SignalScheme::optimdatalist_size() const {
  return _internal_optimdatalist_size();
}
inline void SignalScheme::clear_optimdatalist() {
  _impl_.optimdatalist_.Clear();
}
inline ::cn::seisys::v2x::pb::OptimData* SignalScheme::mutable_optimdatalist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.SignalScheme.optimDataList)
  return _impl_.optimdatalist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimData >*
SignalScheme::mutable_optimdatalist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.SignalScheme.optimDataList)
  return &_impl_.optimdatalist_;
}
inline const ::cn::seisys::v2x::pb::OptimData& SignalScheme::_internal_optimdatalist(int index) const {
  return _impl_.optimdatalist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::OptimData& SignalScheme::optimdatalist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalScheme.optimDataList)
  return _internal_optimdatalist(index);
}
inline ::cn::seisys::v2x::pb::OptimData* SignalScheme::_internal_add_optimdatalist() {
  return _impl_.optimdatalist_.Add();
}
inline ::cn::seisys::v2x::pb::OptimData* SignalScheme::add_optimdatalist() {
  ::cn::seisys::v2x::pb::OptimData* _add = _internal_add_optimdatalist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.SignalScheme.optimDataList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::OptimData >&
SignalScheme::optimdatalist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.SignalScheme.optimDataList)
  return _impl_.optimdatalist_;
}

// -------------------------------------------------------------------

// BrakeSystemStatus

// .cn.seisys.v2x.pb.BrakeSystemStatus.BrakePedalStatus brakePadel = 1;
inline void BrakeSystemStatus::clear_brakepadel() {
  _impl_.brakepadel_ = 0;
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus BrakeSystemStatus::_internal_brakepadel() const {
  return static_cast< ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus >(_impl_.brakepadel_);
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus BrakeSystemStatus::brakepadel() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BrakeSystemStatus.brakePadel)
  return _internal_brakepadel();
}
inline void BrakeSystemStatus::_internal_set_brakepadel(::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus value) {
  
  _impl_.brakepadel_ = value;
}
inline void BrakeSystemStatus::set_brakepadel(::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus value) {
  _internal_set_brakepadel(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BrakeSystemStatus.brakePadel)
}

// uint32 wheelBrakes = 2;
inline void BrakeSystemStatus::clear_wheelbrakes() {
  _impl_.wheelbrakes_ = 0u;
}
inline uint32_t BrakeSystemStatus::_internal_wheelbrakes() const {
  return _impl_.wheelbrakes_;
}
inline uint32_t BrakeSystemStatus::wheelbrakes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BrakeSystemStatus.wheelBrakes)
  return _internal_wheelbrakes();
}
inline void BrakeSystemStatus::_internal_set_wheelbrakes(uint32_t value) {
  
  _impl_.wheelbrakes_ = value;
}
inline void BrakeSystemStatus::set_wheelbrakes(uint32_t value) {
  _internal_set_wheelbrakes(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BrakeSystemStatus.wheelBrakes)
}

// .cn.seisys.v2x.pb.BrakeSystemStatus.TractionControlStatus traction = 3;
inline void BrakeSystemStatus::clear_traction() {
  _impl_.traction_ = 0;
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus BrakeSystemStatus::_internal_traction() const {
  return static_cast< ::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus >(_impl_.traction_);
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus BrakeSystemStatus::traction() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BrakeSystemStatus.traction)
  return _internal_traction();
}
inline void BrakeSystemStatus::_internal_set_traction(::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus value) {
  
  _impl_.traction_ = value;
}
inline void BrakeSystemStatus::set_traction(::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus value) {
  _internal_set_traction(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BrakeSystemStatus.traction)
}

// .cn.seisys.v2x.pb.BrakeSystemStatus.AntiLockBrakeStatus abs = 4;
inline void BrakeSystemStatus::clear_abs() {
  _impl_.abs_ = 0;
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus BrakeSystemStatus::_internal_abs() const {
  return static_cast< ::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus >(_impl_.abs_);
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus BrakeSystemStatus::abs() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BrakeSystemStatus.abs)
  return _internal_abs();
}
inline void BrakeSystemStatus::_internal_set_abs(::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus value) {
  
  _impl_.abs_ = value;
}
inline void BrakeSystemStatus::set_abs(::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus value) {
  _internal_set_abs(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BrakeSystemStatus.abs)
}

// .cn.seisys.v2x.pb.BrakeSystemStatus.StabilityControlStatus scs = 5;
inline void BrakeSystemStatus::clear_scs() {
  _impl_.scs_ = 0;
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus BrakeSystemStatus::_internal_scs() const {
  return static_cast< ::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus >(_impl_.scs_);
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus BrakeSystemStatus::scs() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BrakeSystemStatus.scs)
  return _internal_scs();
}
inline void BrakeSystemStatus::_internal_set_scs(::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus value) {
  
  _impl_.scs_ = value;
}
inline void BrakeSystemStatus::set_scs(::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus value) {
  _internal_set_scs(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BrakeSystemStatus.scs)
}

// .cn.seisys.v2x.pb.BrakeSystemStatus.BrakeBoostApplied brakeBoost = 6;
inline void BrakeSystemStatus::clear_brakeboost() {
  _impl_.brakeboost_ = 0;
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied BrakeSystemStatus::_internal_brakeboost() const {
  return static_cast< ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied >(_impl_.brakeboost_);
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied BrakeSystemStatus::brakeboost() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BrakeSystemStatus.brakeBoost)
  return _internal_brakeboost();
}
inline void BrakeSystemStatus::_internal_set_brakeboost(::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied value) {
  
  _impl_.brakeboost_ = value;
}
inline void BrakeSystemStatus::set_brakeboost(::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied value) {
  _internal_set_brakeboost(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BrakeSystemStatus.brakeBoost)
}

// .cn.seisys.v2x.pb.BrakeSystemStatus.AuxiliaryBrakeStatus auxBrakes = 7;
inline void BrakeSystemStatus::clear_auxbrakes() {
  _impl_.auxbrakes_ = 0;
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus BrakeSystemStatus::_internal_auxbrakes() const {
  return static_cast< ::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus >(_impl_.auxbrakes_);
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus BrakeSystemStatus::auxbrakes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BrakeSystemStatus.auxBrakes)
  return _internal_auxbrakes();
}
inline void BrakeSystemStatus::_internal_set_auxbrakes(::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus value) {
  
  _impl_.auxbrakes_ = value;
}
inline void BrakeSystemStatus::set_auxbrakes(::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus value) {
  _internal_set_auxbrakes(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BrakeSystemStatus.auxBrakes)
}

// uint32 brakeControl = 8;
inline void BrakeSystemStatus::clear_brakecontrol() {
  _impl_.brakecontrol_ = 0u;
}
inline uint32_t BrakeSystemStatus::_internal_brakecontrol() const {
  return _impl_.brakecontrol_;
}
inline uint32_t BrakeSystemStatus::brakecontrol() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BrakeSystemStatus.brakeControl)
  return _internal_brakecontrol();
}
inline void BrakeSystemStatus::_internal_set_brakecontrol(uint32_t value) {
  
  _impl_.brakecontrol_ = value;
}
inline void BrakeSystemStatus::set_brakecontrol(uint32_t value) {
  _internal_set_brakecontrol(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BrakeSystemStatus.brakeControl)
}

// -------------------------------------------------------------------

// PositionAccuracy

// int32 semiMajor = 1;
inline void PositionAccuracy::clear_semimajor() {
  _impl_.semimajor_ = 0;
}
inline int32_t PositionAccuracy::_internal_semimajor() const {
  return _impl_.semimajor_;
}
inline int32_t PositionAccuracy::semimajor() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PositionAccuracy.semiMajor)
  return _internal_semimajor();
}
inline void PositionAccuracy::_internal_set_semimajor(int32_t value) {
  
  _impl_.semimajor_ = value;
}
inline void PositionAccuracy::set_semimajor(int32_t value) {
  _internal_set_semimajor(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PositionAccuracy.semiMajor)
}

// int32 semiMinor = 2;
inline void PositionAccuracy::clear_semiminor() {
  _impl_.semiminor_ = 0;
}
inline int32_t PositionAccuracy::_internal_semiminor() const {
  return _impl_.semiminor_;
}
inline int32_t PositionAccuracy::semiminor() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PositionAccuracy.semiMinor)
  return _internal_semiminor();
}
inline void PositionAccuracy::_internal_set_semiminor(int32_t value) {
  
  _impl_.semiminor_ = value;
}
inline void PositionAccuracy::set_semiminor(int32_t value) {
  _internal_set_semiminor(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PositionAccuracy.semiMinor)
}

// int32 orientation = 3;
inline void PositionAccuracy::clear_orientation() {
  _impl_.orientation_ = 0;
}
inline int32_t PositionAccuracy::_internal_orientation() const {
  return _impl_.orientation_;
}
inline int32_t PositionAccuracy::orientation() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PositionAccuracy.orientation)
  return _internal_orientation();
}
inline void PositionAccuracy::_internal_set_orientation(int32_t value) {
  
  _impl_.orientation_ = value;
}
inline void PositionAccuracy::set_orientation(int32_t value) {
  _internal_set_orientation(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PositionAccuracy.orientation)
}

// -------------------------------------------------------------------

// ThrottleSystemStatus

// uint32 thorttleControl = 1;
inline void ThrottleSystemStatus::clear_thorttlecontrol() {
  _impl_.thorttlecontrol_ = 0u;
}
inline uint32_t ThrottleSystemStatus::_internal_thorttlecontrol() const {
  return _impl_.thorttlecontrol_;
}
inline uint32_t ThrottleSystemStatus::thorttlecontrol() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ThrottleSystemStatus.thorttleControl)
  return _internal_thorttlecontrol();
}
inline void ThrottleSystemStatus::_internal_set_thorttlecontrol(uint32_t value) {
  
  _impl_.thorttlecontrol_ = value;
}
inline void ThrottleSystemStatus::set_thorttlecontrol(uint32_t value) {
  _internal_set_thorttlecontrol(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ThrottleSystemStatus.thorttleControl)
}

// .cn.seisys.v2x.pb.ThrottleSystemStatus.ThrottlePedalStauts throttlePadel = 2;
inline void ThrottleSystemStatus::clear_throttlepadel() {
  _impl_.throttlepadel_ = 0;
}
inline ::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts ThrottleSystemStatus::_internal_throttlepadel() const {
  return static_cast< ::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts >(_impl_.throttlepadel_);
}
inline ::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts ThrottleSystemStatus::throttlepadel() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ThrottleSystemStatus.throttlePadel)
  return _internal_throttlepadel();
}
inline void ThrottleSystemStatus::_internal_set_throttlepadel(::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts value) {
  
  _impl_.throttlepadel_ = value;
}
inline void ThrottleSystemStatus::set_throttlepadel(::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts value) {
  _internal_set_throttlepadel(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ThrottleSystemStatus.throttlePadel)
}

// int32 wheelThrottles = 3;
inline void ThrottleSystemStatus::clear_wheelthrottles() {
  _impl_.wheelthrottles_ = 0;
}
inline int32_t ThrottleSystemStatus::_internal_wheelthrottles() const {
  return _impl_.wheelthrottles_;
}
inline int32_t ThrottleSystemStatus::wheelthrottles() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ThrottleSystemStatus.wheelThrottles)
  return _internal_wheelthrottles();
}
inline void ThrottleSystemStatus::_internal_set_wheelthrottles(int32_t value) {
  
  _impl_.wheelthrottles_ = value;
}
inline void ThrottleSystemStatus::set_wheelthrottles(int32_t value) {
  _internal_set_wheelthrottles(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ThrottleSystemStatus.wheelThrottles)
}

// -------------------------------------------------------------------

// BsmData

// string obuId = 1;
inline void BsmData::clear_obuid() {
  _impl_.obuid_.ClearToEmpty();
}
inline const std::string& BsmData::obuid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.obuId)
  return _internal_obuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BsmData::set_obuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.obuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.obuId)
}
inline std::string* BsmData::mutable_obuid() {
  std::string* _s = _internal_mutable_obuid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.obuId)
  return _s;
}
inline const std::string& BsmData::_internal_obuid() const {
  return _impl_.obuid_.Get();
}
inline void BsmData::_internal_set_obuid(const std::string& value) {
  
  _impl_.obuid_.Set(value, GetArenaForAllocation());
}
inline std::string* BsmData::_internal_mutable_obuid() {
  
  return _impl_.obuid_.Mutable(GetArenaForAllocation());
}
inline std::string* BsmData::release_obuid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.obuId)
  return _impl_.obuid_.Release();
}
inline void BsmData::set_allocated_obuid(std::string* obuid) {
  if (obuid != nullptr) {
    
  } else {
    
  }
  _impl_.obuid_.SetAllocated(obuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obuid_.IsDefault()) {
    _impl_.obuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.obuId)
}

// string plateNo = 2;
inline void BsmData::clear_plateno() {
  _impl_.plateno_.ClearToEmpty();
}
inline const std::string& BsmData::plateno() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.plateNo)
  return _internal_plateno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BsmData::set_plateno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plateno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.plateNo)
}
inline std::string* BsmData::mutable_plateno() {
  std::string* _s = _internal_mutable_plateno();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.plateNo)
  return _s;
}
inline const std::string& BsmData::_internal_plateno() const {
  return _impl_.plateno_.Get();
}
inline void BsmData::_internal_set_plateno(const std::string& value) {
  
  _impl_.plateno_.Set(value, GetArenaForAllocation());
}
inline std::string* BsmData::_internal_mutable_plateno() {
  
  return _impl_.plateno_.Mutable(GetArenaForAllocation());
}
inline std::string* BsmData::release_plateno() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.plateNo)
  return _impl_.plateno_.Release();
}
inline void BsmData::set_allocated_plateno(std::string* plateno) {
  if (plateno != nullptr) {
    
  } else {
    
  }
  _impl_.plateno_.SetAllocated(plateno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plateno_.IsDefault()) {
    _impl_.plateno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.plateNo)
}

// uint64 timestamp = 3;
inline void BsmData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t BsmData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t BsmData::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.timestamp)
  return _internal_timestamp();
}
inline void BsmData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void BsmData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.timestamp)
}

// .cn.seisys.v2x.pb.Position3D pos = 4;
inline bool BsmData::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool BsmData::has_pos() const {
  return _internal_has_pos();
}
inline void BsmData::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& BsmData::_internal_pos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& BsmData::pos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.pos)
  return _internal_pos();
}
inline void BsmData::unsafe_arena_set_allocated_pos(
    ::cn::seisys::v2x::pb::Position3D* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.BsmData.pos)
}
inline ::cn::seisys::v2x::pb::Position3D* BsmData::release_pos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* BsmData::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.pos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* BsmData::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::cn::seisys::v2x::pb::Position3D* BsmData::mutable_pos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.pos)
  return _msg;
}
inline void BsmData::set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.pos)
}

// .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 5;
inline bool BsmData::_internal_has_posconfid() const {
  return this != internal_default_instance() && _impl_.posconfid_ != nullptr;
}
inline bool BsmData::has_posconfid() const {
  return _internal_has_posconfid();
}
inline void BsmData::clear_posconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.posconfid_ != nullptr) {
    delete _impl_.posconfid_;
  }
  _impl_.posconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& BsmData::_internal_posconfid() const {
  const ::cn::seisys::v2x::pb::PositionConfidenceSet* p = _impl_.posconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::PositionConfidenceSet&>(
      ::cn::seisys::v2x::pb::_PositionConfidenceSet_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& BsmData::posconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.posConfid)
  return _internal_posconfid();
}
inline void BsmData::unsafe_arena_set_allocated_posconfid(
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posconfid_);
  }
  _impl_.posconfid_ = posconfid;
  if (posconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.BsmData.posConfid)
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* BsmData::release_posconfid() {
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* BsmData::unsafe_arena_release_posconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.posConfid)
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* BsmData::_internal_mutable_posconfid() {
  
  if (_impl_.posconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::PositionConfidenceSet>(GetArenaForAllocation());
    _impl_.posconfid_ = p;
  }
  return _impl_.posconfid_;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* BsmData::mutable_posconfid() {
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _msg = _internal_mutable_posconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.posConfid)
  return _msg;
}
inline void BsmData::set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posconfid_;
  }
  if (posconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posconfid);
    if (message_arena != submessage_arena) {
      posconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posconfid_ = posconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.posConfid)
}

// .cn.seisys.v2x.pb.PositionAccuracy posAccuracy = 6;
inline bool BsmData::_internal_has_posaccuracy() const {
  return this != internal_default_instance() && _impl_.posaccuracy_ != nullptr;
}
inline bool BsmData::has_posaccuracy() const {
  return _internal_has_posaccuracy();
}
inline void BsmData::clear_posaccuracy() {
  if (GetArenaForAllocation() == nullptr && _impl_.posaccuracy_ != nullptr) {
    delete _impl_.posaccuracy_;
  }
  _impl_.posaccuracy_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::PositionAccuracy& BsmData::_internal_posaccuracy() const {
  const ::cn::seisys::v2x::pb::PositionAccuracy* p = _impl_.posaccuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::PositionAccuracy&>(
      ::cn::seisys::v2x::pb::_PositionAccuracy_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PositionAccuracy& BsmData::posaccuracy() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.posAccuracy)
  return _internal_posaccuracy();
}
inline void BsmData::unsafe_arena_set_allocated_posaccuracy(
    ::cn::seisys::v2x::pb::PositionAccuracy* posaccuracy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posaccuracy_);
  }
  _impl_.posaccuracy_ = posaccuracy;
  if (posaccuracy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.BsmData.posAccuracy)
}
inline ::cn::seisys::v2x::pb::PositionAccuracy* BsmData::release_posaccuracy() {
  
  ::cn::seisys::v2x::pb::PositionAccuracy* temp = _impl_.posaccuracy_;
  _impl_.posaccuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionAccuracy* BsmData::unsafe_arena_release_posaccuracy() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.posAccuracy)
  
  ::cn::seisys::v2x::pb::PositionAccuracy* temp = _impl_.posaccuracy_;
  _impl_.posaccuracy_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionAccuracy* BsmData::_internal_mutable_posaccuracy() {
  
  if (_impl_.posaccuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::PositionAccuracy>(GetArenaForAllocation());
    _impl_.posaccuracy_ = p;
  }
  return _impl_.posaccuracy_;
}
inline ::cn::seisys::v2x::pb::PositionAccuracy* BsmData::mutable_posaccuracy() {
  ::cn::seisys::v2x::pb::PositionAccuracy* _msg = _internal_mutable_posaccuracy();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.posAccuracy)
  return _msg;
}
inline void BsmData::set_allocated_posaccuracy(::cn::seisys::v2x::pb::PositionAccuracy* posaccuracy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posaccuracy_;
  }
  if (posaccuracy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posaccuracy);
    if (message_arena != submessage_arena) {
      posaccuracy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posaccuracy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posaccuracy_ = posaccuracy;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.posAccuracy)
}

// .cn.seisys.v2x.pb.AccelerationSet4Way acceleration = 7;
inline bool BsmData::_internal_has_acceleration() const {
  return this != internal_default_instance() && _impl_.acceleration_ != nullptr;
}
inline bool BsmData::has_acceleration() const {
  return _internal_has_acceleration();
}
inline void BsmData::clear_acceleration() {
  if (GetArenaForAllocation() == nullptr && _impl_.acceleration_ != nullptr) {
    delete _impl_.acceleration_;
  }
  _impl_.acceleration_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::AccelerationSet4Way& BsmData::_internal_acceleration() const {
  const ::cn::seisys::v2x::pb::AccelerationSet4Way* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::AccelerationSet4Way&>(
      ::cn::seisys::v2x::pb::_AccelerationSet4Way_default_instance_);
}
inline const ::cn::seisys::v2x::pb::AccelerationSet4Way& BsmData::acceleration() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.acceleration)
  return _internal_acceleration();
}
inline void BsmData::unsafe_arena_set_allocated_acceleration(
    ::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.BsmData.acceleration)
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* BsmData::release_acceleration() {
  
  ::cn::seisys::v2x::pb::AccelerationSet4Way* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* BsmData::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.acceleration)
  
  ::cn::seisys::v2x::pb::AccelerationSet4Way* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* BsmData::_internal_mutable_acceleration() {
  
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::AccelerationSet4Way>(GetArenaForAllocation());
    _impl_.acceleration_ = p;
  }
  return _impl_.acceleration_;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* BsmData::mutable_acceleration() {
  ::cn::seisys::v2x::pb::AccelerationSet4Way* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.acceleration)
  return _msg;
}
inline void BsmData::set_allocated_acceleration(::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.acceleration_;
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(acceleration);
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.acceleration)
}

// .cn.seisys.v2x.pb.BsmData.TransmissionState transmission = 8;
inline void BsmData::clear_transmission() {
  _impl_.transmission_ = 0;
}
inline ::cn::seisys::v2x::pb::BsmData_TransmissionState BsmData::_internal_transmission() const {
  return static_cast< ::cn::seisys::v2x::pb::BsmData_TransmissionState >(_impl_.transmission_);
}
inline ::cn::seisys::v2x::pb::BsmData_TransmissionState BsmData::transmission() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.transmission)
  return _internal_transmission();
}
inline void BsmData::_internal_set_transmission(::cn::seisys::v2x::pb::BsmData_TransmissionState value) {
  
  _impl_.transmission_ = value;
}
inline void BsmData::set_transmission(::cn::seisys::v2x::pb::BsmData_TransmissionState value) {
  _internal_set_transmission(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.transmission)
}

// uint32 speed = 9;
inline void BsmData::clear_speed() {
  _impl_.speed_ = 0u;
}
inline uint32_t BsmData::_internal_speed() const {
  return _impl_.speed_;
}
inline uint32_t BsmData::speed() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.speed)
  return _internal_speed();
}
inline void BsmData::_internal_set_speed(uint32_t value) {
  
  _impl_.speed_ = value;
}
inline void BsmData::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.speed)
}

// uint32 heading = 10;
inline void BsmData::clear_heading() {
  _impl_.heading_ = 0u;
}
inline uint32_t BsmData::_internal_heading() const {
  return _impl_.heading_;
}
inline uint32_t BsmData::heading() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.heading)
  return _internal_heading();
}
inline void BsmData::_internal_set_heading(uint32_t value) {
  
  _impl_.heading_ = value;
}
inline void BsmData::set_heading(uint32_t value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.heading)
}

// int32 steeringWheelAngle = 11;
inline void BsmData::clear_steeringwheelangle() {
  _impl_.steeringwheelangle_ = 0;
}
inline int32_t BsmData::_internal_steeringwheelangle() const {
  return _impl_.steeringwheelangle_;
}
inline int32_t BsmData::steeringwheelangle() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.steeringWheelAngle)
  return _internal_steeringwheelangle();
}
inline void BsmData::_internal_set_steeringwheelangle(int32_t value) {
  
  _impl_.steeringwheelangle_ = value;
}
inline void BsmData::set_steeringwheelangle(int32_t value) {
  _internal_set_steeringwheelangle(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.steeringWheelAngle)
}

// .cn.seisys.v2x.pb.MotionConfidenceSet motionConfid = 12;
inline bool BsmData::_internal_has_motionconfid() const {
  return this != internal_default_instance() && _impl_.motionconfid_ != nullptr;
}
inline bool BsmData::has_motionconfid() const {
  return _internal_has_motionconfid();
}
inline void BsmData::clear_motionconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.motionconfid_ != nullptr) {
    delete _impl_.motionconfid_;
  }
  _impl_.motionconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::MotionConfidenceSet& BsmData::_internal_motionconfid() const {
  const ::cn::seisys::v2x::pb::MotionConfidenceSet* p = _impl_.motionconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::MotionConfidenceSet&>(
      ::cn::seisys::v2x::pb::_MotionConfidenceSet_default_instance_);
}
inline const ::cn::seisys::v2x::pb::MotionConfidenceSet& BsmData::motionconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.motionConfid)
  return _internal_motionconfid();
}
inline void BsmData::unsafe_arena_set_allocated_motionconfid(
    ::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.motionconfid_);
  }
  _impl_.motionconfid_ = motionconfid;
  if (motionconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.BsmData.motionConfid)
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* BsmData::release_motionconfid() {
  
  ::cn::seisys::v2x::pb::MotionConfidenceSet* temp = _impl_.motionconfid_;
  _impl_.motionconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* BsmData::unsafe_arena_release_motionconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.motionConfid)
  
  ::cn::seisys::v2x::pb::MotionConfidenceSet* temp = _impl_.motionconfid_;
  _impl_.motionconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* BsmData::_internal_mutable_motionconfid() {
  
  if (_impl_.motionconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::MotionConfidenceSet>(GetArenaForAllocation());
    _impl_.motionconfid_ = p;
  }
  return _impl_.motionconfid_;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* BsmData::mutable_motionconfid() {
  ::cn::seisys::v2x::pb::MotionConfidenceSet* _msg = _internal_mutable_motionconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.motionConfid)
  return _msg;
}
inline void BsmData::set_allocated_motionconfid(::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.motionconfid_;
  }
  if (motionconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(motionconfid);
    if (message_arena != submessage_arena) {
      motionconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motionconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.motionconfid_ = motionconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.motionConfid)
}

// .cn.seisys.v2x.pb.BrakeSystemStatus brakes = 13;
inline bool BsmData::_internal_has_brakes() const {
  return this != internal_default_instance() && _impl_.brakes_ != nullptr;
}
inline bool BsmData::has_brakes() const {
  return _internal_has_brakes();
}
inline void BsmData::clear_brakes() {
  if (GetArenaForAllocation() == nullptr && _impl_.brakes_ != nullptr) {
    delete _impl_.brakes_;
  }
  _impl_.brakes_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::BrakeSystemStatus& BsmData::_internal_brakes() const {
  const ::cn::seisys::v2x::pb::BrakeSystemStatus* p = _impl_.brakes_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::BrakeSystemStatus&>(
      ::cn::seisys::v2x::pb::_BrakeSystemStatus_default_instance_);
}
inline const ::cn::seisys::v2x::pb::BrakeSystemStatus& BsmData::brakes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.brakes)
  return _internal_brakes();
}
inline void BsmData::unsafe_arena_set_allocated_brakes(
    ::cn::seisys::v2x::pb::BrakeSystemStatus* brakes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.brakes_);
  }
  _impl_.brakes_ = brakes;
  if (brakes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.BsmData.brakes)
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus* BsmData::release_brakes() {
  
  ::cn::seisys::v2x::pb::BrakeSystemStatus* temp = _impl_.brakes_;
  _impl_.brakes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus* BsmData::unsafe_arena_release_brakes() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.brakes)
  
  ::cn::seisys::v2x::pb::BrakeSystemStatus* temp = _impl_.brakes_;
  _impl_.brakes_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus* BsmData::_internal_mutable_brakes() {
  
  if (_impl_.brakes_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::BrakeSystemStatus>(GetArenaForAllocation());
    _impl_.brakes_ = p;
  }
  return _impl_.brakes_;
}
inline ::cn::seisys::v2x::pb::BrakeSystemStatus* BsmData::mutable_brakes() {
  ::cn::seisys::v2x::pb::BrakeSystemStatus* _msg = _internal_mutable_brakes();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.brakes)
  return _msg;
}
inline void BsmData::set_allocated_brakes(::cn::seisys::v2x::pb::BrakeSystemStatus* brakes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.brakes_;
  }
  if (brakes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(brakes);
    if (message_arena != submessage_arena) {
      brakes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brakes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.brakes_ = brakes;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.brakes)
}

// .cn.seisys.v2x.pb.ThrottleSystemStatus throttle = 14;
inline bool BsmData::_internal_has_throttle() const {
  return this != internal_default_instance() && _impl_.throttle_ != nullptr;
}
inline bool BsmData::has_throttle() const {
  return _internal_has_throttle();
}
inline void BsmData::clear_throttle() {
  if (GetArenaForAllocation() == nullptr && _impl_.throttle_ != nullptr) {
    delete _impl_.throttle_;
  }
  _impl_.throttle_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ThrottleSystemStatus& BsmData::_internal_throttle() const {
  const ::cn::seisys::v2x::pb::ThrottleSystemStatus* p = _impl_.throttle_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ThrottleSystemStatus&>(
      ::cn::seisys::v2x::pb::_ThrottleSystemStatus_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ThrottleSystemStatus& BsmData::throttle() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.throttle)
  return _internal_throttle();
}
inline void BsmData::unsafe_arena_set_allocated_throttle(
    ::cn::seisys::v2x::pb::ThrottleSystemStatus* throttle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.throttle_);
  }
  _impl_.throttle_ = throttle;
  if (throttle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.BsmData.throttle)
}
inline ::cn::seisys::v2x::pb::ThrottleSystemStatus* BsmData::release_throttle() {
  
  ::cn::seisys::v2x::pb::ThrottleSystemStatus* temp = _impl_.throttle_;
  _impl_.throttle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ThrottleSystemStatus* BsmData::unsafe_arena_release_throttle() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.throttle)
  
  ::cn::seisys::v2x::pb::ThrottleSystemStatus* temp = _impl_.throttle_;
  _impl_.throttle_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ThrottleSystemStatus* BsmData::_internal_mutable_throttle() {
  
  if (_impl_.throttle_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ThrottleSystemStatus>(GetArenaForAllocation());
    _impl_.throttle_ = p;
  }
  return _impl_.throttle_;
}
inline ::cn::seisys::v2x::pb::ThrottleSystemStatus* BsmData::mutable_throttle() {
  ::cn::seisys::v2x::pb::ThrottleSystemStatus* _msg = _internal_mutable_throttle();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.throttle)
  return _msg;
}
inline void BsmData::set_allocated_throttle(::cn::seisys::v2x::pb::ThrottleSystemStatus* throttle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.throttle_;
  }
  if (throttle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(throttle);
    if (message_arena != submessage_arena) {
      throttle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, throttle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.throttle_ = throttle;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.throttle)
}

// .cn.seisys.v2x.pb.VehicleSize size = 15;
inline bool BsmData::_internal_has_size() const {
  return this != internal_default_instance() && _impl_.size_ != nullptr;
}
inline bool BsmData::has_size() const {
  return _internal_has_size();
}
inline void BsmData::clear_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.size_ != nullptr) {
    delete _impl_.size_;
  }
  _impl_.size_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::VehicleSize& BsmData::_internal_size() const {
  const ::cn::seisys::v2x::pb::VehicleSize* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::VehicleSize&>(
      ::cn::seisys::v2x::pb::_VehicleSize_default_instance_);
}
inline const ::cn::seisys::v2x::pb::VehicleSize& BsmData::size() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.size)
  return _internal_size();
}
inline void BsmData::unsafe_arena_set_allocated_size(
    ::cn::seisys::v2x::pb::VehicleSize* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.BsmData.size)
}
inline ::cn::seisys::v2x::pb::VehicleSize* BsmData::release_size() {
  
  ::cn::seisys::v2x::pb::VehicleSize* temp = _impl_.size_;
  _impl_.size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::VehicleSize* BsmData::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.BsmData.size)
  
  ::cn::seisys::v2x::pb::VehicleSize* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::VehicleSize* BsmData::_internal_mutable_size() {
  
  if (_impl_.size_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::VehicleSize>(GetArenaForAllocation());
    _impl_.size_ = p;
  }
  return _impl_.size_;
}
inline ::cn::seisys::v2x::pb::VehicleSize* BsmData::mutable_size() {
  ::cn::seisys::v2x::pb::VehicleSize* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.BsmData.size)
  return _msg;
}
inline void BsmData::set_allocated_size(::cn::seisys::v2x::pb::VehicleSize* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.size_ = size;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.BsmData.size)
}

// .cn.seisys.v2x.pb.VehicleType vehicleType = 16;
inline void BsmData::clear_vehicletype() {
  _impl_.vehicletype_ = 0;
}
inline ::cn::seisys::v2x::pb::VehicleType BsmData::_internal_vehicletype() const {
  return static_cast< ::cn::seisys::v2x::pb::VehicleType >(_impl_.vehicletype_);
}
inline ::cn::seisys::v2x::pb::VehicleType BsmData::vehicletype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.vehicleType)
  return _internal_vehicletype();
}
inline void BsmData::_internal_set_vehicletype(::cn::seisys::v2x::pb::VehicleType value) {
  
  _impl_.vehicletype_ = value;
}
inline void BsmData::set_vehicletype(::cn::seisys::v2x::pb::VehicleType value) {
  _internal_set_vehicletype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.vehicleType)
}

// .cn.seisys.v2x.pb.BsmData.VehicleFuelType fuelType = 17;
inline void BsmData::clear_fueltype() {
  _impl_.fueltype_ = 0;
}
inline ::cn::seisys::v2x::pb::BsmData_VehicleFuelType BsmData::_internal_fueltype() const {
  return static_cast< ::cn::seisys::v2x::pb::BsmData_VehicleFuelType >(_impl_.fueltype_);
}
inline ::cn::seisys::v2x::pb::BsmData_VehicleFuelType BsmData::fueltype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.fuelType)
  return _internal_fueltype();
}
inline void BsmData::_internal_set_fueltype(::cn::seisys::v2x::pb::BsmData_VehicleFuelType value) {
  
  _impl_.fueltype_ = value;
}
inline void BsmData::set_fueltype(::cn::seisys::v2x::pb::BsmData_VehicleFuelType value) {
  _internal_set_fueltype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.fuelType)
}

// .cn.seisys.v2x.pb.BsmData.DriveStatus driveModedriveStatus = 18;
inline void BsmData::clear_drivemodedrivestatus() {
  _impl_.drivemodedrivestatus_ = 0;
}
inline ::cn::seisys::v2x::pb::BsmData_DriveStatus BsmData::_internal_drivemodedrivestatus() const {
  return static_cast< ::cn::seisys::v2x::pb::BsmData_DriveStatus >(_impl_.drivemodedrivestatus_);
}
inline ::cn::seisys::v2x::pb::BsmData_DriveStatus BsmData::drivemodedrivestatus() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.driveModedriveStatus)
  return _internal_drivemodedrivestatus();
}
inline void BsmData::_internal_set_drivemodedrivestatus(::cn::seisys::v2x::pb::BsmData_DriveStatus value) {
  
  _impl_.drivemodedrivestatus_ = value;
}
inline void BsmData::set_drivemodedrivestatus(::cn::seisys::v2x::pb::BsmData_DriveStatus value) {
  _internal_set_drivemodedrivestatus(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.driveModedriveStatus)
}

// .cn.seisys.v2x.pb.BsmData.EmergenyStatus emergencyStatus = 19;
inline void BsmData::clear_emergencystatus() {
  _impl_.emergencystatus_ = 0;
}
inline ::cn::seisys::v2x::pb::BsmData_EmergenyStatus BsmData::_internal_emergencystatus() const {
  return static_cast< ::cn::seisys::v2x::pb::BsmData_EmergenyStatus >(_impl_.emergencystatus_);
}
inline ::cn::seisys::v2x::pb::BsmData_EmergenyStatus BsmData::emergencystatus() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.emergencyStatus)
  return _internal_emergencystatus();
}
inline void BsmData::_internal_set_emergencystatus(::cn::seisys::v2x::pb::BsmData_EmergenyStatus value) {
  
  _impl_.emergencystatus_ = value;
}
inline void BsmData::set_emergencystatus(::cn::seisys::v2x::pb::BsmData_EmergenyStatus value) {
  _internal_set_emergencystatus(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.emergencyStatus)
}

// uint32 light = 20;
inline void BsmData::clear_light() {
  _impl_.light_ = 0u;
}
inline uint32_t BsmData::_internal_light() const {
  return _impl_.light_;
}
inline uint32_t BsmData::light() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.light)
  return _internal_light();
}
inline void BsmData::_internal_set_light(uint32_t value) {
  
  _impl_.light_ = value;
}
inline void BsmData::set_light(uint32_t value) {
  _internal_set_light(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.light)
}

// .cn.seisys.v2x.pb.BsmData.Wiper wiper = 21;
inline void BsmData::clear_wiper() {
  _impl_.wiper_ = 0;
}
inline ::cn::seisys::v2x::pb::BsmData_Wiper BsmData::_internal_wiper() const {
  return static_cast< ::cn::seisys::v2x::pb::BsmData_Wiper >(_impl_.wiper_);
}
inline ::cn::seisys::v2x::pb::BsmData_Wiper BsmData::wiper() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.wiper)
  return _internal_wiper();
}
inline void BsmData::_internal_set_wiper(::cn::seisys::v2x::pb::BsmData_Wiper value) {
  
  _impl_.wiper_ = value;
}
inline void BsmData::set_wiper(::cn::seisys::v2x::pb::BsmData_Wiper value) {
  _internal_set_wiper(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.wiper)
}

// .cn.seisys.v2x.pb.BsmData.OutofControl outofControl = 22;
inline void BsmData::clear_outofcontrol() {
  _impl_.outofcontrol_ = 0;
}
inline ::cn::seisys::v2x::pb::BsmData_OutofControl BsmData::_internal_outofcontrol() const {
  return static_cast< ::cn::seisys::v2x::pb::BsmData_OutofControl >(_impl_.outofcontrol_);
}
inline ::cn::seisys::v2x::pb::BsmData_OutofControl BsmData::outofcontrol() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.outofControl)
  return _internal_outofcontrol();
}
inline void BsmData::_internal_set_outofcontrol(::cn::seisys::v2x::pb::BsmData_OutofControl value) {
  
  _impl_.outofcontrol_ = value;
}
inline void BsmData::set_outofcontrol(::cn::seisys::v2x::pb::BsmData_OutofControl value) {
  _internal_set_outofcontrol(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.outofControl)
}

// uint32 endurance = 23;
inline void BsmData::clear_endurance() {
  _impl_.endurance_ = 0u;
}
inline uint32_t BsmData::_internal_endurance() const {
  return _impl_.endurance_;
}
inline uint32_t BsmData::endurance() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.BsmData.endurance)
  return _internal_endurance();
}
inline void BsmData::_internal_set_endurance(uint32_t value) {
  
  _impl_.endurance_ = value;
}
inline void BsmData::set_endurance(uint32_t value) {
  _internal_set_endurance(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.BsmData.endurance)
}

// -------------------------------------------------------------------

// PathHistoryPoint

// .cn.seisys.v2x.pb.Position3D pos = 1;
inline bool PathHistoryPoint::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool PathHistoryPoint::has_pos() const {
  return _internal_has_pos();
}
inline void PathHistoryPoint::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& PathHistoryPoint::_internal_pos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& PathHistoryPoint::pos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathHistoryPoint.pos)
  return _internal_pos();
}
inline void PathHistoryPoint::unsafe_arena_set_allocated_pos(
    ::cn::seisys::v2x::pb::Position3D* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PathHistoryPoint.pos)
}
inline ::cn::seisys::v2x::pb::Position3D* PathHistoryPoint::release_pos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* PathHistoryPoint::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PathHistoryPoint.pos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* PathHistoryPoint::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::cn::seisys::v2x::pb::Position3D* PathHistoryPoint::mutable_pos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PathHistoryPoint.pos)
  return _msg;
}
inline void PathHistoryPoint::set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PathHistoryPoint.pos)
}

// uint32 timeOffset = 2;
inline void PathHistoryPoint::clear_timeoffset() {
  _impl_.timeoffset_ = 0u;
}
inline uint32_t PathHistoryPoint::_internal_timeoffset() const {
  return _impl_.timeoffset_;
}
inline uint32_t PathHistoryPoint::timeoffset() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathHistoryPoint.timeOffset)
  return _internal_timeoffset();
}
inline void PathHistoryPoint::_internal_set_timeoffset(uint32_t value) {
  
  _impl_.timeoffset_ = value;
}
inline void PathHistoryPoint::set_timeoffset(uint32_t value) {
  _internal_set_timeoffset(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PathHistoryPoint.timeOffset)
}

// uint32 speed = 3;
inline void PathHistoryPoint::clear_speed() {
  _impl_.speed_ = 0u;
}
inline uint32_t PathHistoryPoint::_internal_speed() const {
  return _impl_.speed_;
}
inline uint32_t PathHistoryPoint::speed() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathHistoryPoint.speed)
  return _internal_speed();
}
inline void PathHistoryPoint::_internal_set_speed(uint32_t value) {
  
  _impl_.speed_ = value;
}
inline void PathHistoryPoint::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PathHistoryPoint.speed)
}

// .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 4;
inline bool PathHistoryPoint::_internal_has_posconfid() const {
  return this != internal_default_instance() && _impl_.posconfid_ != nullptr;
}
inline bool PathHistoryPoint::has_posconfid() const {
  return _internal_has_posconfid();
}
inline void PathHistoryPoint::clear_posconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.posconfid_ != nullptr) {
    delete _impl_.posconfid_;
  }
  _impl_.posconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& PathHistoryPoint::_internal_posconfid() const {
  const ::cn::seisys::v2x::pb::PositionConfidenceSet* p = _impl_.posconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::PositionConfidenceSet&>(
      ::cn::seisys::v2x::pb::_PositionConfidenceSet_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& PathHistoryPoint::posconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathHistoryPoint.posConfid)
  return _internal_posconfid();
}
inline void PathHistoryPoint::unsafe_arena_set_allocated_posconfid(
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posconfid_);
  }
  _impl_.posconfid_ = posconfid;
  if (posconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PathHistoryPoint.posConfid)
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* PathHistoryPoint::release_posconfid() {
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* PathHistoryPoint::unsafe_arena_release_posconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PathHistoryPoint.posConfid)
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* PathHistoryPoint::_internal_mutable_posconfid() {
  
  if (_impl_.posconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::PositionConfidenceSet>(GetArenaForAllocation());
    _impl_.posconfid_ = p;
  }
  return _impl_.posconfid_;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* PathHistoryPoint::mutable_posconfid() {
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _msg = _internal_mutable_posconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PathHistoryPoint.posConfid)
  return _msg;
}
inline void PathHistoryPoint::set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posconfid_;
  }
  if (posconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posconfid);
    if (message_arena != submessage_arena) {
      posconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posconfid_ = posconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PathHistoryPoint.posConfid)
}

// uint32 heading = 5;
inline void PathHistoryPoint::clear_heading() {
  _impl_.heading_ = 0u;
}
inline uint32_t PathHistoryPoint::_internal_heading() const {
  return _impl_.heading_;
}
inline uint32_t PathHistoryPoint::heading() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathHistoryPoint.heading)
  return _internal_heading();
}
inline void PathHistoryPoint::_internal_set_heading(uint32_t value) {
  
  _impl_.heading_ = value;
}
inline void PathHistoryPoint::set_heading(uint32_t value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PathHistoryPoint.heading)
}

// -------------------------------------------------------------------

// ParticipantData

// uint64 ptcId = 1;
inline void ParticipantData::clear_ptcid() {
  _impl_.ptcid_ = uint64_t{0u};
}
inline uint64_t ParticipantData::_internal_ptcid() const {
  return _impl_.ptcid_;
}
inline uint64_t ParticipantData::ptcid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.ptcId)
  return _internal_ptcid();
}
inline void ParticipantData::_internal_set_ptcid(uint64_t value) {
  
  _impl_.ptcid_ = value;
}
inline void ParticipantData::set_ptcid(uint64_t value) {
  _internal_set_ptcid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.ptcId)
}

// .cn.seisys.v2x.pb.ParticipantType ptcType = 2;
inline void ParticipantData::clear_ptctype() {
  _impl_.ptctype_ = 0;
}
inline ::cn::seisys::v2x::pb::ParticipantType ParticipantData::_internal_ptctype() const {
  return static_cast< ::cn::seisys::v2x::pb::ParticipantType >(_impl_.ptctype_);
}
inline ::cn::seisys::v2x::pb::ParticipantType ParticipantData::ptctype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.ptcType)
  return _internal_ptctype();
}
inline void ParticipantData::_internal_set_ptctype(::cn::seisys::v2x::pb::ParticipantType value) {
  
  _impl_.ptctype_ = value;
}
inline void ParticipantData::set_ptctype(::cn::seisys::v2x::pb::ParticipantType value) {
  _internal_set_ptctype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.ptcType)
}

// .cn.seisys.v2x.pb.DataSource dataSource = 3;
inline void ParticipantData::clear_datasource() {
  _impl_.datasource_ = 0;
}
inline ::cn::seisys::v2x::pb::DataSource ParticipantData::_internal_datasource() const {
  return static_cast< ::cn::seisys::v2x::pb::DataSource >(_impl_.datasource_);
}
inline ::cn::seisys::v2x::pb::DataSource ParticipantData::datasource() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.dataSource)
  return _internal_datasource();
}
inline void ParticipantData::_internal_set_datasource(::cn::seisys::v2x::pb::DataSource value) {
  
  _impl_.datasource_ = value;
}
inline void ParticipantData::set_datasource(::cn::seisys::v2x::pb::DataSource value) {
  _internal_set_datasource(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.dataSource)
}

// string deviceIdList = 4;
inline void ParticipantData::clear_deviceidlist() {
  _impl_.deviceidlist_.ClearToEmpty();
}
inline const std::string& ParticipantData::deviceidlist() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.deviceIdList)
  return _internal_deviceidlist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantData::set_deviceidlist(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceidlist_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.deviceIdList)
}
inline std::string* ParticipantData::mutable_deviceidlist() {
  std::string* _s = _internal_mutable_deviceidlist();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.deviceIdList)
  return _s;
}
inline const std::string& ParticipantData::_internal_deviceidlist() const {
  return _impl_.deviceidlist_.Get();
}
inline void ParticipantData::_internal_set_deviceidlist(const std::string& value) {
  
  _impl_.deviceidlist_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantData::_internal_mutable_deviceidlist() {
  
  return _impl_.deviceidlist_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantData::release_deviceidlist() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.deviceIdList)
  return _impl_.deviceidlist_.Release();
}
inline void ParticipantData::set_allocated_deviceidlist(std::string* deviceidlist) {
  if (deviceidlist != nullptr) {
    
  } else {
    
  }
  _impl_.deviceidlist_.SetAllocated(deviceidlist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceidlist_.IsDefault()) {
    _impl_.deviceidlist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.deviceIdList)
}

// uint64 timestamp = 5;
inline void ParticipantData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t ParticipantData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t ParticipantData::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.timestamp)
  return _internal_timestamp();
}
inline void ParticipantData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ParticipantData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.timestamp)
}

// .cn.seisys.v2x.pb.TimeConfidence timeConfidence = 6;
inline void ParticipantData::clear_timeconfidence() {
  _impl_.timeconfidence_ = 0;
}
inline ::cn::seisys::v2x::pb::TimeConfidence ParticipantData::_internal_timeconfidence() const {
  return static_cast< ::cn::seisys::v2x::pb::TimeConfidence >(_impl_.timeconfidence_);
}
inline ::cn::seisys::v2x::pb::TimeConfidence ParticipantData::timeconfidence() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.timeConfidence)
  return _internal_timeconfidence();
}
inline void ParticipantData::_internal_set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  
  _impl_.timeconfidence_ = value;
}
inline void ParticipantData::set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  _internal_set_timeconfidence(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.timeConfidence)
}

// .cn.seisys.v2x.pb.Position3D ptcPos = 7;
inline bool ParticipantData::_internal_has_ptcpos() const {
  return this != internal_default_instance() && _impl_.ptcpos_ != nullptr;
}
inline bool ParticipantData::has_ptcpos() const {
  return _internal_has_ptcpos();
}
inline void ParticipantData::clear_ptcpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.ptcpos_ != nullptr) {
    delete _impl_.ptcpos_;
  }
  _impl_.ptcpos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& ParticipantData::_internal_ptcpos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.ptcpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& ParticipantData::ptcpos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.ptcPos)
  return _internal_ptcpos();
}
inline void ParticipantData::unsafe_arena_set_allocated_ptcpos(
    ::cn::seisys::v2x::pb::Position3D* ptcpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptcpos_);
  }
  _impl_.ptcpos_ = ptcpos;
  if (ptcpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ParticipantData.ptcPos)
}
inline ::cn::seisys::v2x::pb::Position3D* ParticipantData::release_ptcpos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.ptcpos_;
  _impl_.ptcpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* ParticipantData::unsafe_arena_release_ptcpos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.ptcPos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.ptcpos_;
  _impl_.ptcpos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* ParticipantData::_internal_mutable_ptcpos() {
  
  if (_impl_.ptcpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.ptcpos_ = p;
  }
  return _impl_.ptcpos_;
}
inline ::cn::seisys::v2x::pb::Position3D* ParticipantData::mutable_ptcpos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_ptcpos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.ptcPos)
  return _msg;
}
inline void ParticipantData::set_allocated_ptcpos(::cn::seisys::v2x::pb::Position3D* ptcpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ptcpos_;
  }
  if (ptcpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ptcpos);
    if (message_arena != submessage_arena) {
      ptcpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptcpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ptcpos_ = ptcpos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.ptcPos)
}

// .cn.seisys.v2x.pb.MapLocation mapLocation = 8;
inline bool ParticipantData::_internal_has_maplocation() const {
  return this != internal_default_instance() && _impl_.maplocation_ != nullptr;
}
inline bool ParticipantData::has_maplocation() const {
  return _internal_has_maplocation();
}
inline void ParticipantData::clear_maplocation() {
  if (GetArenaForAllocation() == nullptr && _impl_.maplocation_ != nullptr) {
    delete _impl_.maplocation_;
  }
  _impl_.maplocation_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::MapLocation& ParticipantData::_internal_maplocation() const {
  const ::cn::seisys::v2x::pb::MapLocation* p = _impl_.maplocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::MapLocation&>(
      ::cn::seisys::v2x::pb::_MapLocation_default_instance_);
}
inline const ::cn::seisys::v2x::pb::MapLocation& ParticipantData::maplocation() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.mapLocation)
  return _internal_maplocation();
}
inline void ParticipantData::unsafe_arena_set_allocated_maplocation(
    ::cn::seisys::v2x::pb::MapLocation* maplocation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maplocation_);
  }
  _impl_.maplocation_ = maplocation;
  if (maplocation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ParticipantData.mapLocation)
}
inline ::cn::seisys::v2x::pb::MapLocation* ParticipantData::release_maplocation() {
  
  ::cn::seisys::v2x::pb::MapLocation* temp = _impl_.maplocation_;
  _impl_.maplocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::MapLocation* ParticipantData::unsafe_arena_release_maplocation() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.mapLocation)
  
  ::cn::seisys::v2x::pb::MapLocation* temp = _impl_.maplocation_;
  _impl_.maplocation_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::MapLocation* ParticipantData::_internal_mutable_maplocation() {
  
  if (_impl_.maplocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::MapLocation>(GetArenaForAllocation());
    _impl_.maplocation_ = p;
  }
  return _impl_.maplocation_;
}
inline ::cn::seisys::v2x::pb::MapLocation* ParticipantData::mutable_maplocation() {
  ::cn::seisys::v2x::pb::MapLocation* _msg = _internal_mutable_maplocation();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.mapLocation)
  return _msg;
}
inline void ParticipantData::set_allocated_maplocation(::cn::seisys::v2x::pb::MapLocation* maplocation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.maplocation_;
  }
  if (maplocation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maplocation);
    if (message_arena != submessage_arena) {
      maplocation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maplocation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.maplocation_ = maplocation;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.mapLocation)
}

// .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 9;
inline bool ParticipantData::_internal_has_posconfid() const {
  return this != internal_default_instance() && _impl_.posconfid_ != nullptr;
}
inline bool ParticipantData::has_posconfid() const {
  return _internal_has_posconfid();
}
inline void ParticipantData::clear_posconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.posconfid_ != nullptr) {
    delete _impl_.posconfid_;
  }
  _impl_.posconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& ParticipantData::_internal_posconfid() const {
  const ::cn::seisys::v2x::pb::PositionConfidenceSet* p = _impl_.posconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::PositionConfidenceSet&>(
      ::cn::seisys::v2x::pb::_PositionConfidenceSet_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& ParticipantData::posconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.posConfid)
  return _internal_posconfid();
}
inline void ParticipantData::unsafe_arena_set_allocated_posconfid(
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posconfid_);
  }
  _impl_.posconfid_ = posconfid;
  if (posconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ParticipantData.posConfid)
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* ParticipantData::release_posconfid() {
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* ParticipantData::unsafe_arena_release_posconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.posConfid)
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* ParticipantData::_internal_mutable_posconfid() {
  
  if (_impl_.posconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::PositionConfidenceSet>(GetArenaForAllocation());
    _impl_.posconfid_ = p;
  }
  return _impl_.posconfid_;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* ParticipantData::mutable_posconfid() {
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _msg = _internal_mutable_posconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.posConfid)
  return _msg;
}
inline void ParticipantData::set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posconfid_;
  }
  if (posconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posconfid);
    if (message_arena != submessage_arena) {
      posconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posconfid_ = posconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.posConfid)
}

// uint32 speed = 10;
inline void ParticipantData::clear_speed() {
  _impl_.speed_ = 0u;
}
inline uint32_t ParticipantData::_internal_speed() const {
  return _impl_.speed_;
}
inline uint32_t ParticipantData::speed() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.speed)
  return _internal_speed();
}
inline void ParticipantData::_internal_set_speed(uint32_t value) {
  
  _impl_.speed_ = value;
}
inline void ParticipantData::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.speed)
}

// uint32 heading = 11;
inline void ParticipantData::clear_heading() {
  _impl_.heading_ = 0u;
}
inline uint32_t ParticipantData::_internal_heading() const {
  return _impl_.heading_;
}
inline uint32_t ParticipantData::heading() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.heading)
  return _internal_heading();
}
inline void ParticipantData::_internal_set_heading(uint32_t value) {
  
  _impl_.heading_ = value;
}
inline void ParticipantData::set_heading(uint32_t value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.heading)
}

// .cn.seisys.v2x.pb.MotionConfidenceSet motionConfid = 12;
inline bool ParticipantData::_internal_has_motionconfid() const {
  return this != internal_default_instance() && _impl_.motionconfid_ != nullptr;
}
inline bool ParticipantData::has_motionconfid() const {
  return _internal_has_motionconfid();
}
inline void ParticipantData::clear_motionconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.motionconfid_ != nullptr) {
    delete _impl_.motionconfid_;
  }
  _impl_.motionconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::MotionConfidenceSet& ParticipantData::_internal_motionconfid() const {
  const ::cn::seisys::v2x::pb::MotionConfidenceSet* p = _impl_.motionconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::MotionConfidenceSet&>(
      ::cn::seisys::v2x::pb::_MotionConfidenceSet_default_instance_);
}
inline const ::cn::seisys::v2x::pb::MotionConfidenceSet& ParticipantData::motionconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.motionConfid)
  return _internal_motionconfid();
}
inline void ParticipantData::unsafe_arena_set_allocated_motionconfid(
    ::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.motionconfid_);
  }
  _impl_.motionconfid_ = motionconfid;
  if (motionconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ParticipantData.motionConfid)
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* ParticipantData::release_motionconfid() {
  
  ::cn::seisys::v2x::pb::MotionConfidenceSet* temp = _impl_.motionconfid_;
  _impl_.motionconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* ParticipantData::unsafe_arena_release_motionconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.motionConfid)
  
  ::cn::seisys::v2x::pb::MotionConfidenceSet* temp = _impl_.motionconfid_;
  _impl_.motionconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* ParticipantData::_internal_mutable_motionconfid() {
  
  if (_impl_.motionconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::MotionConfidenceSet>(GetArenaForAllocation());
    _impl_.motionconfid_ = p;
  }
  return _impl_.motionconfid_;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* ParticipantData::mutable_motionconfid() {
  ::cn::seisys::v2x::pb::MotionConfidenceSet* _msg = _internal_mutable_motionconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.motionConfid)
  return _msg;
}
inline void ParticipantData::set_allocated_motionconfid(::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.motionconfid_;
  }
  if (motionconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(motionconfid);
    if (message_arena != submessage_arena) {
      motionconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motionconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.motionconfid_ = motionconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.motionConfid)
}

// .cn.seisys.v2x.pb.AccelerationSet4Way accelSet = 13;
inline bool ParticipantData::_internal_has_accelset() const {
  return this != internal_default_instance() && _impl_.accelset_ != nullptr;
}
inline bool ParticipantData::has_accelset() const {
  return _internal_has_accelset();
}
inline void ParticipantData::clear_accelset() {
  if (GetArenaForAllocation() == nullptr && _impl_.accelset_ != nullptr) {
    delete _impl_.accelset_;
  }
  _impl_.accelset_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::AccelerationSet4Way& ParticipantData::_internal_accelset() const {
  const ::cn::seisys::v2x::pb::AccelerationSet4Way* p = _impl_.accelset_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::AccelerationSet4Way&>(
      ::cn::seisys::v2x::pb::_AccelerationSet4Way_default_instance_);
}
inline const ::cn::seisys::v2x::pb::AccelerationSet4Way& ParticipantData::accelset() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.accelSet)
  return _internal_accelset();
}
inline void ParticipantData::unsafe_arena_set_allocated_accelset(
    ::cn::seisys::v2x::pb::AccelerationSet4Way* accelset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accelset_);
  }
  _impl_.accelset_ = accelset;
  if (accelset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ParticipantData.accelSet)
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* ParticipantData::release_accelset() {
  
  ::cn::seisys::v2x::pb::AccelerationSet4Way* temp = _impl_.accelset_;
  _impl_.accelset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* ParticipantData::unsafe_arena_release_accelset() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.accelSet)
  
  ::cn::seisys::v2x::pb::AccelerationSet4Way* temp = _impl_.accelset_;
  _impl_.accelset_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* ParticipantData::_internal_mutable_accelset() {
  
  if (_impl_.accelset_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::AccelerationSet4Way>(GetArenaForAllocation());
    _impl_.accelset_ = p;
  }
  return _impl_.accelset_;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* ParticipantData::mutable_accelset() {
  ::cn::seisys::v2x::pb::AccelerationSet4Way* _msg = _internal_mutable_accelset();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.accelSet)
  return _msg;
}
inline void ParticipantData::set_allocated_accelset(::cn::seisys::v2x::pb::AccelerationSet4Way* accelset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.accelset_;
  }
  if (accelset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(accelset);
    if (message_arena != submessage_arena) {
      accelset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accelset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.accelset_ = accelset;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.accelSet)
}

// .cn.seisys.v2x.pb.AccelerationConfidence accelerationConfid = 14;
inline bool ParticipantData::_internal_has_accelerationconfid() const {
  return this != internal_default_instance() && _impl_.accelerationconfid_ != nullptr;
}
inline bool ParticipantData::has_accelerationconfid() const {
  return _internal_has_accelerationconfid();
}
inline void ParticipantData::clear_accelerationconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.accelerationconfid_ != nullptr) {
    delete _impl_.accelerationconfid_;
  }
  _impl_.accelerationconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::AccelerationConfidence& ParticipantData::_internal_accelerationconfid() const {
  const ::cn::seisys::v2x::pb::AccelerationConfidence* p = _impl_.accelerationconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::AccelerationConfidence&>(
      ::cn::seisys::v2x::pb::_AccelerationConfidence_default_instance_);
}
inline const ::cn::seisys::v2x::pb::AccelerationConfidence& ParticipantData::accelerationconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.accelerationConfid)
  return _internal_accelerationconfid();
}
inline void ParticipantData::unsafe_arena_set_allocated_accelerationconfid(
    ::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accelerationconfid_);
  }
  _impl_.accelerationconfid_ = accelerationconfid;
  if (accelerationconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ParticipantData.accelerationConfid)
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence* ParticipantData::release_accelerationconfid() {
  
  ::cn::seisys::v2x::pb::AccelerationConfidence* temp = _impl_.accelerationconfid_;
  _impl_.accelerationconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence* ParticipantData::unsafe_arena_release_accelerationconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.accelerationConfid)
  
  ::cn::seisys::v2x::pb::AccelerationConfidence* temp = _impl_.accelerationconfid_;
  _impl_.accelerationconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence* ParticipantData::_internal_mutable_accelerationconfid() {
  
  if (_impl_.accelerationconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::AccelerationConfidence>(GetArenaForAllocation());
    _impl_.accelerationconfid_ = p;
  }
  return _impl_.accelerationconfid_;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence* ParticipantData::mutable_accelerationconfid() {
  ::cn::seisys::v2x::pb::AccelerationConfidence* _msg = _internal_mutable_accelerationconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.accelerationConfid)
  return _msg;
}
inline void ParticipantData::set_allocated_accelerationconfid(::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.accelerationconfid_;
  }
  if (accelerationconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(accelerationconfid);
    if (message_arena != submessage_arena) {
      accelerationconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accelerationconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.accelerationconfid_ = accelerationconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.accelerationConfid)
}

// .cn.seisys.v2x.pb.ParticipantSize ptcSize = 15;
inline bool ParticipantData::_internal_has_ptcsize() const {
  return this != internal_default_instance() && _impl_.ptcsize_ != nullptr;
}
inline bool ParticipantData::has_ptcsize() const {
  return _internal_has_ptcsize();
}
inline void ParticipantData::clear_ptcsize() {
  if (GetArenaForAllocation() == nullptr && _impl_.ptcsize_ != nullptr) {
    delete _impl_.ptcsize_;
  }
  _impl_.ptcsize_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ParticipantSize& ParticipantData::_internal_ptcsize() const {
  const ::cn::seisys::v2x::pb::ParticipantSize* p = _impl_.ptcsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ParticipantSize&>(
      ::cn::seisys::v2x::pb::_ParticipantSize_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ParticipantSize& ParticipantData::ptcsize() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.ptcSize)
  return _internal_ptcsize();
}
inline void ParticipantData::unsafe_arena_set_allocated_ptcsize(
    ::cn::seisys::v2x::pb::ParticipantSize* ptcsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptcsize_);
  }
  _impl_.ptcsize_ = ptcsize;
  if (ptcsize) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ParticipantData.ptcSize)
}
inline ::cn::seisys::v2x::pb::ParticipantSize* ParticipantData::release_ptcsize() {
  
  ::cn::seisys::v2x::pb::ParticipantSize* temp = _impl_.ptcsize_;
  _impl_.ptcsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ParticipantSize* ParticipantData::unsafe_arena_release_ptcsize() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.ptcSize)
  
  ::cn::seisys::v2x::pb::ParticipantSize* temp = _impl_.ptcsize_;
  _impl_.ptcsize_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ParticipantSize* ParticipantData::_internal_mutable_ptcsize() {
  
  if (_impl_.ptcsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ParticipantSize>(GetArenaForAllocation());
    _impl_.ptcsize_ = p;
  }
  return _impl_.ptcsize_;
}
inline ::cn::seisys::v2x::pb::ParticipantSize* ParticipantData::mutable_ptcsize() {
  ::cn::seisys::v2x::pb::ParticipantSize* _msg = _internal_mutable_ptcsize();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.ptcSize)
  return _msg;
}
inline void ParticipantData::set_allocated_ptcsize(::cn::seisys::v2x::pb::ParticipantSize* ptcsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ptcsize_;
  }
  if (ptcsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ptcsize);
    if (message_arena != submessage_arena) {
      ptcsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptcsize, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ptcsize_ = ptcsize;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.ptcSize)
}

// string vehicleBand = 16;
inline void ParticipantData::clear_vehicleband() {
  _impl_.vehicleband_.ClearToEmpty();
}
inline const std::string& ParticipantData::vehicleband() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.vehicleBand)
  return _internal_vehicleband();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantData::set_vehicleband(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vehicleband_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.vehicleBand)
}
inline std::string* ParticipantData::mutable_vehicleband() {
  std::string* _s = _internal_mutable_vehicleband();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.vehicleBand)
  return _s;
}
inline const std::string& ParticipantData::_internal_vehicleband() const {
  return _impl_.vehicleband_.Get();
}
inline void ParticipantData::_internal_set_vehicleband(const std::string& value) {
  
  _impl_.vehicleband_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantData::_internal_mutable_vehicleband() {
  
  return _impl_.vehicleband_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantData::release_vehicleband() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.vehicleBand)
  return _impl_.vehicleband_.Release();
}
inline void ParticipantData::set_allocated_vehicleband(std::string* vehicleband) {
  if (vehicleband != nullptr) {
    
  } else {
    
  }
  _impl_.vehicleband_.SetAllocated(vehicleband, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vehicleband_.IsDefault()) {
    _impl_.vehicleband_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.vehicleBand)
}

// .cn.seisys.v2x.pb.VehicleType vehicleType = 17;
inline void ParticipantData::clear_vehicletype() {
  _impl_.vehicletype_ = 0;
}
inline ::cn::seisys::v2x::pb::VehicleType ParticipantData::_internal_vehicletype() const {
  return static_cast< ::cn::seisys::v2x::pb::VehicleType >(_impl_.vehicletype_);
}
inline ::cn::seisys::v2x::pb::VehicleType ParticipantData::vehicletype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.vehicleType)
  return _internal_vehicletype();
}
inline void ParticipantData::_internal_set_vehicletype(::cn::seisys::v2x::pb::VehicleType value) {
  
  _impl_.vehicletype_ = value;
}
inline void ParticipantData::set_vehicletype(::cn::seisys::v2x::pb::VehicleType value) {
  _internal_set_vehicletype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.vehicleType)
}

// string plateNo = 18;
inline void ParticipantData::clear_plateno() {
  _impl_.plateno_.ClearToEmpty();
}
inline const std::string& ParticipantData::plateno() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.plateNo)
  return _internal_plateno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantData::set_plateno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plateno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.plateNo)
}
inline std::string* ParticipantData::mutable_plateno() {
  std::string* _s = _internal_mutable_plateno();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.plateNo)
  return _s;
}
inline const std::string& ParticipantData::_internal_plateno() const {
  return _impl_.plateno_.Get();
}
inline void ParticipantData::_internal_set_plateno(const std::string& value) {
  
  _impl_.plateno_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantData::_internal_mutable_plateno() {
  
  return _impl_.plateno_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantData::release_plateno() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.plateNo)
  return _impl_.plateno_.Release();
}
inline void ParticipantData::set_allocated_plateno(std::string* plateno) {
  if (plateno != nullptr) {
    
  } else {
    
  }
  _impl_.plateno_.SetAllocated(plateno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plateno_.IsDefault()) {
    _impl_.plateno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.plateNo)
}

// .cn.seisys.v2x.pb.PlateType plateType = 19;
inline void ParticipantData::clear_platetype() {
  _impl_.platetype_ = 0;
}
inline ::cn::seisys::v2x::pb::PlateType ParticipantData::_internal_platetype() const {
  return static_cast< ::cn::seisys::v2x::pb::PlateType >(_impl_.platetype_);
}
inline ::cn::seisys::v2x::pb::PlateType ParticipantData::platetype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.plateType)
  return _internal_platetype();
}
inline void ParticipantData::_internal_set_platetype(::cn::seisys::v2x::pb::PlateType value) {
  
  _impl_.platetype_ = value;
}
inline void ParticipantData::set_platetype(::cn::seisys::v2x::pb::PlateType value) {
  _internal_set_platetype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.plateType)
}

// .cn.seisys.v2x.pb.ParticipantData.PlateColor plateColor = 20;
inline void ParticipantData::clear_platecolor() {
  _impl_.platecolor_ = 0;
}
inline ::cn::seisys::v2x::pb::ParticipantData_PlateColor ParticipantData::_internal_platecolor() const {
  return static_cast< ::cn::seisys::v2x::pb::ParticipantData_PlateColor >(_impl_.platecolor_);
}
inline ::cn::seisys::v2x::pb::ParticipantData_PlateColor ParticipantData::platecolor() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.plateColor)
  return _internal_platecolor();
}
inline void ParticipantData::_internal_set_platecolor(::cn::seisys::v2x::pb::ParticipantData_PlateColor value) {
  
  _impl_.platecolor_ = value;
}
inline void ParticipantData::set_platecolor(::cn::seisys::v2x::pb::ParticipantData_PlateColor value) {
  _internal_set_platecolor(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.plateColor)
}

// .cn.seisys.v2x.pb.ParticipantData.VehicleColor vehicleColor = 21;
inline void ParticipantData::clear_vehiclecolor() {
  _impl_.vehiclecolor_ = 0;
}
inline ::cn::seisys::v2x::pb::ParticipantData_VehicleColor ParticipantData::_internal_vehiclecolor() const {
  return static_cast< ::cn::seisys::v2x::pb::ParticipantData_VehicleColor >(_impl_.vehiclecolor_);
}
inline ::cn::seisys::v2x::pb::ParticipantData_VehicleColor ParticipantData::vehiclecolor() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.vehicleColor)
  return _internal_vehiclecolor();
}
inline void ParticipantData::_internal_set_vehiclecolor(::cn::seisys::v2x::pb::ParticipantData_VehicleColor value) {
  
  _impl_.vehiclecolor_ = value;
}
inline void ParticipantData::set_vehiclecolor(::cn::seisys::v2x::pb::ParticipantData_VehicleColor value) {
  _internal_set_vehiclecolor(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.vehicleColor)
}

// .cn.seisys.v2x.pb.ParticipantSizeConfidence ptcSizeConfid = 22;
inline bool ParticipantData::_internal_has_ptcsizeconfid() const {
  return this != internal_default_instance() && _impl_.ptcsizeconfid_ != nullptr;
}
inline bool ParticipantData::has_ptcsizeconfid() const {
  return _internal_has_ptcsizeconfid();
}
inline void ParticipantData::clear_ptcsizeconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.ptcsizeconfid_ != nullptr) {
    delete _impl_.ptcsizeconfid_;
  }
  _impl_.ptcsizeconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ParticipantSizeConfidence& ParticipantData::_internal_ptcsizeconfid() const {
  const ::cn::seisys::v2x::pb::ParticipantSizeConfidence* p = _impl_.ptcsizeconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ParticipantSizeConfidence&>(
      ::cn::seisys::v2x::pb::_ParticipantSizeConfidence_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ParticipantSizeConfidence& ParticipantData::ptcsizeconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.ptcSizeConfid)
  return _internal_ptcsizeconfid();
}
inline void ParticipantData::unsafe_arena_set_allocated_ptcsizeconfid(
    ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ptcsizeconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ptcsizeconfid_);
  }
  _impl_.ptcsizeconfid_ = ptcsizeconfid;
  if (ptcsizeconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ParticipantData.ptcSizeConfid)
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ParticipantData::release_ptcsizeconfid() {
  
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* temp = _impl_.ptcsizeconfid_;
  _impl_.ptcsizeconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ParticipantData::unsafe_arena_release_ptcsizeconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.ptcSizeConfid)
  
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* temp = _impl_.ptcsizeconfid_;
  _impl_.ptcsizeconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ParticipantData::_internal_mutable_ptcsizeconfid() {
  
  if (_impl_.ptcsizeconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ParticipantSizeConfidence>(GetArenaForAllocation());
    _impl_.ptcsizeconfid_ = p;
  }
  return _impl_.ptcsizeconfid_;
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ParticipantData::mutable_ptcsizeconfid() {
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* _msg = _internal_mutable_ptcsizeconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.ptcSizeConfid)
  return _msg;
}
inline void ParticipantData::set_allocated_ptcsizeconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence* ptcsizeconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ptcsizeconfid_;
  }
  if (ptcsizeconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ptcsizeconfid);
    if (message_arena != submessage_arena) {
      ptcsizeconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptcsizeconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ptcsizeconfid_ = ptcsizeconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.ptcSizeConfid)
}

// .cn.seisys.v2x.pb.ParticipantData.ParticipantTypeExt ptcTypeExt = 23;
inline void ParticipantData::clear_ptctypeext() {
  _impl_.ptctypeext_ = 0;
}
inline ::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt ParticipantData::_internal_ptctypeext() const {
  return static_cast< ::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt >(_impl_.ptctypeext_);
}
inline ::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt ParticipantData::ptctypeext() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.ptcTypeExt)
  return _internal_ptctypeext();
}
inline void ParticipantData::_internal_set_ptctypeext(::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt value) {
  
  _impl_.ptctypeext_ = value;
}
inline void ParticipantData::set_ptctypeext(::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt value) {
  _internal_set_ptctypeext(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.ptcTypeExt)
}

// uint32 ptcTypeExtConfid = 24;
inline void ParticipantData::clear_ptctypeextconfid() {
  _impl_.ptctypeextconfid_ = 0u;
}
inline uint32_t ParticipantData::_internal_ptctypeextconfid() const {
  return _impl_.ptctypeextconfid_;
}
inline uint32_t ParticipantData::ptctypeextconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.ptcTypeExtConfid)
  return _internal_ptctypeextconfid();
}
inline void ParticipantData::_internal_set_ptctypeextconfid(uint32_t value) {
  
  _impl_.ptctypeextconfid_ = value;
}
inline void ParticipantData::set_ptctypeextconfid(uint32_t value) {
  _internal_set_ptctypeextconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.ptcTypeExtConfid)
}

// uint32 statusDuration = 25;
inline void ParticipantData::clear_statusduration() {
  _impl_.statusduration_ = 0u;
}
inline uint32_t ParticipantData::_internal_statusduration() const {
  return _impl_.statusduration_;
}
inline uint32_t ParticipantData::statusduration() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.statusDuration)
  return _internal_statusduration();
}
inline void ParticipantData::_internal_set_statusduration(uint32_t value) {
  
  _impl_.statusduration_ = value;
}
inline void ParticipantData::set_statusduration(uint32_t value) {
  _internal_set_statusduration(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.statusDuration)
}

// repeated .cn.seisys.v2x.pb.PathHistoryPoint pathHistory = 26;
inline int ParticipantData::_internal_pathhistory_size() const {
  return _impl_.pathhistory_.size();
}
inline int ParticipantData::pathhistory_size() const {
  return _internal_pathhistory_size();
}
inline void ParticipantData::clear_pathhistory() {
  _impl_.pathhistory_.Clear();
}
inline ::cn::seisys::v2x::pb::PathHistoryPoint* ParticipantData::mutable_pathhistory(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.pathHistory)
  return _impl_.pathhistory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathHistoryPoint >*
ParticipantData::mutable_pathhistory() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.ParticipantData.pathHistory)
  return &_impl_.pathhistory_;
}
inline const ::cn::seisys::v2x::pb::PathHistoryPoint& ParticipantData::_internal_pathhistory(int index) const {
  return _impl_.pathhistory_.Get(index);
}
inline const ::cn::seisys::v2x::pb::PathHistoryPoint& ParticipantData::pathhistory(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.pathHistory)
  return _internal_pathhistory(index);
}
inline ::cn::seisys::v2x::pb::PathHistoryPoint* ParticipantData::_internal_add_pathhistory() {
  return _impl_.pathhistory_.Add();
}
inline ::cn::seisys::v2x::pb::PathHistoryPoint* ParticipantData::add_pathhistory() {
  ::cn::seisys::v2x::pb::PathHistoryPoint* _add = _internal_add_pathhistory();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.ParticipantData.pathHistory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathHistoryPoint >&
ParticipantData::pathhistory() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.ParticipantData.pathHistory)
  return _impl_.pathhistory_;
}

// uint32 tracking = 27;
inline void ParticipantData::clear_tracking() {
  _impl_.tracking_ = 0u;
}
inline uint32_t ParticipantData::_internal_tracking() const {
  return _impl_.tracking_;
}
inline uint32_t ParticipantData::tracking() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.tracking)
  return _internal_tracking();
}
inline void ParticipantData::_internal_set_tracking(uint32_t value) {
  
  _impl_.tracking_ = value;
}
inline void ParticipantData::set_tracking(uint32_t value) {
  _internal_set_tracking(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.tracking)
}

// .cn.seisys.v2x.pb.Polygon polygon = 28;
inline bool ParticipantData::_internal_has_polygon() const {
  return this != internal_default_instance() && _impl_.polygon_ != nullptr;
}
inline bool ParticipantData::has_polygon() const {
  return _internal_has_polygon();
}
inline void ParticipantData::clear_polygon() {
  if (GetArenaForAllocation() == nullptr && _impl_.polygon_ != nullptr) {
    delete _impl_.polygon_;
  }
  _impl_.polygon_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Polygon& ParticipantData::_internal_polygon() const {
  const ::cn::seisys::v2x::pb::Polygon* p = _impl_.polygon_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Polygon&>(
      ::cn::seisys::v2x::pb::_Polygon_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Polygon& ParticipantData::polygon() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.polygon)
  return _internal_polygon();
}
inline void ParticipantData::unsafe_arena_set_allocated_polygon(
    ::cn::seisys::v2x::pb::Polygon* polygon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.polygon_);
  }
  _impl_.polygon_ = polygon;
  if (polygon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ParticipantData.polygon)
}
inline ::cn::seisys::v2x::pb::Polygon* ParticipantData::release_polygon() {
  
  ::cn::seisys::v2x::pb::Polygon* temp = _impl_.polygon_;
  _impl_.polygon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Polygon* ParticipantData::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ParticipantData.polygon)
  
  ::cn::seisys::v2x::pb::Polygon* temp = _impl_.polygon_;
  _impl_.polygon_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Polygon* ParticipantData::_internal_mutable_polygon() {
  
  if (_impl_.polygon_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Polygon>(GetArenaForAllocation());
    _impl_.polygon_ = p;
  }
  return _impl_.polygon_;
}
inline ::cn::seisys::v2x::pb::Polygon* ParticipantData::mutable_polygon() {
  ::cn::seisys::v2x::pb::Polygon* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ParticipantData.polygon)
  return _msg;
}
inline void ParticipantData::set_allocated_polygon(::cn::seisys::v2x::pb::Polygon* polygon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.polygon_;
  }
  if (polygon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(polygon);
    if (message_arena != submessage_arena) {
      polygon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polygon, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.polygon_ = polygon;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ParticipantData.polygon)
}

// uint64 id = 29;
inline void ParticipantData::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t ParticipantData::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t ParticipantData::id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParticipantData.id)
  return _internal_id();
}
inline void ParticipantData::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void ParticipantData::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParticipantData.id)
}

// -------------------------------------------------------------------

// ObstacleData

// uint64 obsId = 1;
inline void ObstacleData::clear_obsid() {
  _impl_.obsid_ = uint64_t{0u};
}
inline uint64_t ObstacleData::_internal_obsid() const {
  return _impl_.obsid_;
}
inline uint64_t ObstacleData::obsid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.obsId)
  return _internal_obsid();
}
inline void ObstacleData::_internal_set_obsid(uint64_t value) {
  
  _impl_.obsid_ = value;
}
inline void ObstacleData::set_obsid(uint64_t value) {
  _internal_set_obsid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.obsId)
}

// .cn.seisys.v2x.pb.ObstaclesType obsType = 2;
inline void ObstacleData::clear_obstype() {
  _impl_.obstype_ = 0;
}
inline ::cn::seisys::v2x::pb::ObstaclesType ObstacleData::_internal_obstype() const {
  return static_cast< ::cn::seisys::v2x::pb::ObstaclesType >(_impl_.obstype_);
}
inline ::cn::seisys::v2x::pb::ObstaclesType ObstacleData::obstype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.obsType)
  return _internal_obstype();
}
inline void ObstacleData::_internal_set_obstype(::cn::seisys::v2x::pb::ObstaclesType value) {
  
  _impl_.obstype_ = value;
}
inline void ObstacleData::set_obstype(::cn::seisys::v2x::pb::ObstaclesType value) {
  _internal_set_obstype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.obsType)
}

// uint32 obstypeCfd = 3;
inline void ObstacleData::clear_obstypecfd() {
  _impl_.obstypecfd_ = 0u;
}
inline uint32_t ObstacleData::_internal_obstypecfd() const {
  return _impl_.obstypecfd_;
}
inline uint32_t ObstacleData::obstypecfd() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.obstypeCfd)
  return _internal_obstypecfd();
}
inline void ObstacleData::_internal_set_obstypecfd(uint32_t value) {
  
  _impl_.obstypecfd_ = value;
}
inline void ObstacleData::set_obstypecfd(uint32_t value) {
  _internal_set_obstypecfd(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.obstypeCfd)
}

// .cn.seisys.v2x.pb.DataSource obsSource = 4;
inline void ObstacleData::clear_obssource() {
  _impl_.obssource_ = 0;
}
inline ::cn::seisys::v2x::pb::DataSource ObstacleData::_internal_obssource() const {
  return static_cast< ::cn::seisys::v2x::pb::DataSource >(_impl_.obssource_);
}
inline ::cn::seisys::v2x::pb::DataSource ObstacleData::obssource() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.obsSource)
  return _internal_obssource();
}
inline void ObstacleData::_internal_set_obssource(::cn::seisys::v2x::pb::DataSource value) {
  
  _impl_.obssource_ = value;
}
inline void ObstacleData::set_obssource(::cn::seisys::v2x::pb::DataSource value) {
  _internal_set_obssource(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.obsSource)
}

// uint64 timestamp = 5;
inline void ObstacleData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t ObstacleData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t ObstacleData::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.timestamp)
  return _internal_timestamp();
}
inline void ObstacleData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ObstacleData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.timestamp)
}

// string deviceIdList = 6;
inline void ObstacleData::clear_deviceidlist() {
  _impl_.deviceidlist_.ClearToEmpty();
}
inline const std::string& ObstacleData::deviceidlist() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.deviceIdList)
  return _internal_deviceidlist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObstacleData::set_deviceidlist(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceidlist_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.deviceIdList)
}
inline std::string* ObstacleData::mutable_deviceidlist() {
  std::string* _s = _internal_mutable_deviceidlist();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ObstacleData.deviceIdList)
  return _s;
}
inline const std::string& ObstacleData::_internal_deviceidlist() const {
  return _impl_.deviceidlist_.Get();
}
inline void ObstacleData::_internal_set_deviceidlist(const std::string& value) {
  
  _impl_.deviceidlist_.Set(value, GetArenaForAllocation());
}
inline std::string* ObstacleData::_internal_mutable_deviceidlist() {
  
  return _impl_.deviceidlist_.Mutable(GetArenaForAllocation());
}
inline std::string* ObstacleData::release_deviceidlist() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ObstacleData.deviceIdList)
  return _impl_.deviceidlist_.Release();
}
inline void ObstacleData::set_allocated_deviceidlist(std::string* deviceidlist) {
  if (deviceidlist != nullptr) {
    
  } else {
    
  }
  _impl_.deviceidlist_.SetAllocated(deviceidlist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceidlist_.IsDefault()) {
    _impl_.deviceidlist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ObstacleData.deviceIdList)
}

// .cn.seisys.v2x.pb.Position3D obsPos = 7;
inline bool ObstacleData::_internal_has_obspos() const {
  return this != internal_default_instance() && _impl_.obspos_ != nullptr;
}
inline bool ObstacleData::has_obspos() const {
  return _internal_has_obspos();
}
inline void ObstacleData::clear_obspos() {
  if (GetArenaForAllocation() == nullptr && _impl_.obspos_ != nullptr) {
    delete _impl_.obspos_;
  }
  _impl_.obspos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& ObstacleData::_internal_obspos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.obspos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& ObstacleData::obspos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.obsPos)
  return _internal_obspos();
}
inline void ObstacleData::unsafe_arena_set_allocated_obspos(
    ::cn::seisys::v2x::pb::Position3D* obspos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obspos_);
  }
  _impl_.obspos_ = obspos;
  if (obspos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ObstacleData.obsPos)
}
inline ::cn::seisys::v2x::pb::Position3D* ObstacleData::release_obspos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.obspos_;
  _impl_.obspos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* ObstacleData::unsafe_arena_release_obspos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ObstacleData.obsPos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.obspos_;
  _impl_.obspos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* ObstacleData::_internal_mutable_obspos() {
  
  if (_impl_.obspos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.obspos_ = p;
  }
  return _impl_.obspos_;
}
inline ::cn::seisys::v2x::pb::Position3D* ObstacleData::mutable_obspos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_obspos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ObstacleData.obsPos)
  return _msg;
}
inline void ObstacleData::set_allocated_obspos(::cn::seisys::v2x::pb::Position3D* obspos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obspos_;
  }
  if (obspos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obspos);
    if (message_arena != submessage_arena) {
      obspos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obspos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.obspos_ = obspos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ObstacleData.obsPos)
}

// .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 8;
inline bool ObstacleData::_internal_has_posconfid() const {
  return this != internal_default_instance() && _impl_.posconfid_ != nullptr;
}
inline bool ObstacleData::has_posconfid() const {
  return _internal_has_posconfid();
}
inline void ObstacleData::clear_posconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.posconfid_ != nullptr) {
    delete _impl_.posconfid_;
  }
  _impl_.posconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& ObstacleData::_internal_posconfid() const {
  const ::cn::seisys::v2x::pb::PositionConfidenceSet* p = _impl_.posconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::PositionConfidenceSet&>(
      ::cn::seisys::v2x::pb::_PositionConfidenceSet_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& ObstacleData::posconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.posConfid)
  return _internal_posconfid();
}
inline void ObstacleData::unsafe_arena_set_allocated_posconfid(
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posconfid_);
  }
  _impl_.posconfid_ = posconfid;
  if (posconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ObstacleData.posConfid)
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* ObstacleData::release_posconfid() {
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* ObstacleData::unsafe_arena_release_posconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ObstacleData.posConfid)
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* ObstacleData::_internal_mutable_posconfid() {
  
  if (_impl_.posconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::PositionConfidenceSet>(GetArenaForAllocation());
    _impl_.posconfid_ = p;
  }
  return _impl_.posconfid_;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* ObstacleData::mutable_posconfid() {
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _msg = _internal_mutable_posconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ObstacleData.posConfid)
  return _msg;
}
inline void ObstacleData::set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posconfid_;
  }
  if (posconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posconfid);
    if (message_arena != submessage_arena) {
      posconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posconfid_ = posconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ObstacleData.posConfid)
}

// .cn.seisys.v2x.pb.MapLocation mapLocation = 9;
inline bool ObstacleData::_internal_has_maplocation() const {
  return this != internal_default_instance() && _impl_.maplocation_ != nullptr;
}
inline bool ObstacleData::has_maplocation() const {
  return _internal_has_maplocation();
}
inline void ObstacleData::clear_maplocation() {
  if (GetArenaForAllocation() == nullptr && _impl_.maplocation_ != nullptr) {
    delete _impl_.maplocation_;
  }
  _impl_.maplocation_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::MapLocation& ObstacleData::_internal_maplocation() const {
  const ::cn::seisys::v2x::pb::MapLocation* p = _impl_.maplocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::MapLocation&>(
      ::cn::seisys::v2x::pb::_MapLocation_default_instance_);
}
inline const ::cn::seisys::v2x::pb::MapLocation& ObstacleData::maplocation() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.mapLocation)
  return _internal_maplocation();
}
inline void ObstacleData::unsafe_arena_set_allocated_maplocation(
    ::cn::seisys::v2x::pb::MapLocation* maplocation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maplocation_);
  }
  _impl_.maplocation_ = maplocation;
  if (maplocation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ObstacleData.mapLocation)
}
inline ::cn::seisys::v2x::pb::MapLocation* ObstacleData::release_maplocation() {
  
  ::cn::seisys::v2x::pb::MapLocation* temp = _impl_.maplocation_;
  _impl_.maplocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::MapLocation* ObstacleData::unsafe_arena_release_maplocation() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ObstacleData.mapLocation)
  
  ::cn::seisys::v2x::pb::MapLocation* temp = _impl_.maplocation_;
  _impl_.maplocation_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::MapLocation* ObstacleData::_internal_mutable_maplocation() {
  
  if (_impl_.maplocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::MapLocation>(GetArenaForAllocation());
    _impl_.maplocation_ = p;
  }
  return _impl_.maplocation_;
}
inline ::cn::seisys::v2x::pb::MapLocation* ObstacleData::mutable_maplocation() {
  ::cn::seisys::v2x::pb::MapLocation* _msg = _internal_mutable_maplocation();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ObstacleData.mapLocation)
  return _msg;
}
inline void ObstacleData::set_allocated_maplocation(::cn::seisys::v2x::pb::MapLocation* maplocation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.maplocation_;
  }
  if (maplocation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maplocation);
    if (message_arena != submessage_arena) {
      maplocation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maplocation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.maplocation_ = maplocation;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ObstacleData.mapLocation)
}

// uint32 speed = 10;
inline void ObstacleData::clear_speed() {
  _impl_.speed_ = 0u;
}
inline uint32_t ObstacleData::_internal_speed() const {
  return _impl_.speed_;
}
inline uint32_t ObstacleData::speed() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.speed)
  return _internal_speed();
}
inline void ObstacleData::_internal_set_speed(uint32_t value) {
  
  _impl_.speed_ = value;
}
inline void ObstacleData::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.speed)
}

// uint32 heading = 11;
inline void ObstacleData::clear_heading() {
  _impl_.heading_ = 0u;
}
inline uint32_t ObstacleData::_internal_heading() const {
  return _impl_.heading_;
}
inline uint32_t ObstacleData::heading() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.heading)
  return _internal_heading();
}
inline void ObstacleData::_internal_set_heading(uint32_t value) {
  
  _impl_.heading_ = value;
}
inline void ObstacleData::set_heading(uint32_t value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.heading)
}

// .cn.seisys.v2x.pb.MotionConfidenceSet motionConfid = 12;
inline bool ObstacleData::_internal_has_motionconfid() const {
  return this != internal_default_instance() && _impl_.motionconfid_ != nullptr;
}
inline bool ObstacleData::has_motionconfid() const {
  return _internal_has_motionconfid();
}
inline void ObstacleData::clear_motionconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.motionconfid_ != nullptr) {
    delete _impl_.motionconfid_;
  }
  _impl_.motionconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::MotionConfidenceSet& ObstacleData::_internal_motionconfid() const {
  const ::cn::seisys::v2x::pb::MotionConfidenceSet* p = _impl_.motionconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::MotionConfidenceSet&>(
      ::cn::seisys::v2x::pb::_MotionConfidenceSet_default_instance_);
}
inline const ::cn::seisys::v2x::pb::MotionConfidenceSet& ObstacleData::motionconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.motionConfid)
  return _internal_motionconfid();
}
inline void ObstacleData::unsafe_arena_set_allocated_motionconfid(
    ::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.motionconfid_);
  }
  _impl_.motionconfid_ = motionconfid;
  if (motionconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ObstacleData.motionConfid)
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* ObstacleData::release_motionconfid() {
  
  ::cn::seisys::v2x::pb::MotionConfidenceSet* temp = _impl_.motionconfid_;
  _impl_.motionconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* ObstacleData::unsafe_arena_release_motionconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ObstacleData.motionConfid)
  
  ::cn::seisys::v2x::pb::MotionConfidenceSet* temp = _impl_.motionconfid_;
  _impl_.motionconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* ObstacleData::_internal_mutable_motionconfid() {
  
  if (_impl_.motionconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::MotionConfidenceSet>(GetArenaForAllocation());
    _impl_.motionconfid_ = p;
  }
  return _impl_.motionconfid_;
}
inline ::cn::seisys::v2x::pb::MotionConfidenceSet* ObstacleData::mutable_motionconfid() {
  ::cn::seisys::v2x::pb::MotionConfidenceSet* _msg = _internal_mutable_motionconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ObstacleData.motionConfid)
  return _msg;
}
inline void ObstacleData::set_allocated_motionconfid(::cn::seisys::v2x::pb::MotionConfidenceSet* motionconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.motionconfid_;
  }
  if (motionconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(motionconfid);
    if (message_arena != submessage_arena) {
      motionconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motionconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.motionconfid_ = motionconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ObstacleData.motionConfid)
}

// uint32 verSpeed = 13;
inline void ObstacleData::clear_verspeed() {
  _impl_.verspeed_ = 0u;
}
inline uint32_t ObstacleData::_internal_verspeed() const {
  return _impl_.verspeed_;
}
inline uint32_t ObstacleData::verspeed() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.verSpeed)
  return _internal_verspeed();
}
inline void ObstacleData::_internal_set_verspeed(uint32_t value) {
  
  _impl_.verspeed_ = value;
}
inline void ObstacleData::set_verspeed(uint32_t value) {
  _internal_set_verspeed(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.verSpeed)
}

// .cn.seisys.v2x.pb.SpeedConfidence verSpeedConfid = 14;
inline void ObstacleData::clear_verspeedconfid() {
  _impl_.verspeedconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::SpeedConfidence ObstacleData::_internal_verspeedconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::SpeedConfidence >(_impl_.verspeedconfid_);
}
inline ::cn::seisys::v2x::pb::SpeedConfidence ObstacleData::verspeedconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.verSpeedConfid)
  return _internal_verspeedconfid();
}
inline void ObstacleData::_internal_set_verspeedconfid(::cn::seisys::v2x::pb::SpeedConfidence value) {
  
  _impl_.verspeedconfid_ = value;
}
inline void ObstacleData::set_verspeedconfid(::cn::seisys::v2x::pb::SpeedConfidence value) {
  _internal_set_verspeedconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.verSpeedConfid)
}

// .cn.seisys.v2x.pb.AccelerationSet4Way acceleration = 15;
inline bool ObstacleData::_internal_has_acceleration() const {
  return this != internal_default_instance() && _impl_.acceleration_ != nullptr;
}
inline bool ObstacleData::has_acceleration() const {
  return _internal_has_acceleration();
}
inline void ObstacleData::clear_acceleration() {
  if (GetArenaForAllocation() == nullptr && _impl_.acceleration_ != nullptr) {
    delete _impl_.acceleration_;
  }
  _impl_.acceleration_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::AccelerationSet4Way& ObstacleData::_internal_acceleration() const {
  const ::cn::seisys::v2x::pb::AccelerationSet4Way* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::AccelerationSet4Way&>(
      ::cn::seisys::v2x::pb::_AccelerationSet4Way_default_instance_);
}
inline const ::cn::seisys::v2x::pb::AccelerationSet4Way& ObstacleData::acceleration() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.acceleration)
  return _internal_acceleration();
}
inline void ObstacleData::unsafe_arena_set_allocated_acceleration(
    ::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ObstacleData.acceleration)
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* ObstacleData::release_acceleration() {
  
  ::cn::seisys::v2x::pb::AccelerationSet4Way* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* ObstacleData::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ObstacleData.acceleration)
  
  ::cn::seisys::v2x::pb::AccelerationSet4Way* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* ObstacleData::_internal_mutable_acceleration() {
  
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::AccelerationSet4Way>(GetArenaForAllocation());
    _impl_.acceleration_ = p;
  }
  return _impl_.acceleration_;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* ObstacleData::mutable_acceleration() {
  ::cn::seisys::v2x::pb::AccelerationSet4Way* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ObstacleData.acceleration)
  return _msg;
}
inline void ObstacleData::set_allocated_acceleration(::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.acceleration_;
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(acceleration);
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ObstacleData.acceleration)
}

// .cn.seisys.v2x.pb.ParticipantSize size = 16;
inline bool ObstacleData::_internal_has_size() const {
  return this != internal_default_instance() && _impl_.size_ != nullptr;
}
inline bool ObstacleData::has_size() const {
  return _internal_has_size();
}
inline void ObstacleData::clear_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.size_ != nullptr) {
    delete _impl_.size_;
  }
  _impl_.size_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ParticipantSize& ObstacleData::_internal_size() const {
  const ::cn::seisys::v2x::pb::ParticipantSize* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ParticipantSize&>(
      ::cn::seisys::v2x::pb::_ParticipantSize_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ParticipantSize& ObstacleData::size() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.size)
  return _internal_size();
}
inline void ObstacleData::unsafe_arena_set_allocated_size(
    ::cn::seisys::v2x::pb::ParticipantSize* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ObstacleData.size)
}
inline ::cn::seisys::v2x::pb::ParticipantSize* ObstacleData::release_size() {
  
  ::cn::seisys::v2x::pb::ParticipantSize* temp = _impl_.size_;
  _impl_.size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ParticipantSize* ObstacleData::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ObstacleData.size)
  
  ::cn::seisys::v2x::pb::ParticipantSize* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ParticipantSize* ObstacleData::_internal_mutable_size() {
  
  if (_impl_.size_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ParticipantSize>(GetArenaForAllocation());
    _impl_.size_ = p;
  }
  return _impl_.size_;
}
inline ::cn::seisys::v2x::pb::ParticipantSize* ObstacleData::mutable_size() {
  ::cn::seisys::v2x::pb::ParticipantSize* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ObstacleData.size)
  return _msg;
}
inline void ObstacleData::set_allocated_size(::cn::seisys::v2x::pb::ParticipantSize* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.size_ = size;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ObstacleData.size)
}

// .cn.seisys.v2x.pb.ParticipantSizeConfidence obsSizeConfid = 17;
inline bool ObstacleData::_internal_has_obssizeconfid() const {
  return this != internal_default_instance() && _impl_.obssizeconfid_ != nullptr;
}
inline bool ObstacleData::has_obssizeconfid() const {
  return _internal_has_obssizeconfid();
}
inline void ObstacleData::clear_obssizeconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.obssizeconfid_ != nullptr) {
    delete _impl_.obssizeconfid_;
  }
  _impl_.obssizeconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ParticipantSizeConfidence& ObstacleData::_internal_obssizeconfid() const {
  const ::cn::seisys::v2x::pb::ParticipantSizeConfidence* p = _impl_.obssizeconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ParticipantSizeConfidence&>(
      ::cn::seisys::v2x::pb::_ParticipantSizeConfidence_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ParticipantSizeConfidence& ObstacleData::obssizeconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.obsSizeConfid)
  return _internal_obssizeconfid();
}
inline void ObstacleData::unsafe_arena_set_allocated_obssizeconfid(
    ::cn::seisys::v2x::pb::ParticipantSizeConfidence* obssizeconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obssizeconfid_);
  }
  _impl_.obssizeconfid_ = obssizeconfid;
  if (obssizeconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ObstacleData.obsSizeConfid)
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ObstacleData::release_obssizeconfid() {
  
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* temp = _impl_.obssizeconfid_;
  _impl_.obssizeconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ObstacleData::unsafe_arena_release_obssizeconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ObstacleData.obsSizeConfid)
  
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* temp = _impl_.obssizeconfid_;
  _impl_.obssizeconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ObstacleData::_internal_mutable_obssizeconfid() {
  
  if (_impl_.obssizeconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ParticipantSizeConfidence>(GetArenaForAllocation());
    _impl_.obssizeconfid_ = p;
  }
  return _impl_.obssizeconfid_;
}
inline ::cn::seisys::v2x::pb::ParticipantSizeConfidence* ObstacleData::mutable_obssizeconfid() {
  ::cn::seisys::v2x::pb::ParticipantSizeConfidence* _msg = _internal_mutable_obssizeconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ObstacleData.obsSizeConfid)
  return _msg;
}
inline void ObstacleData::set_allocated_obssizeconfid(::cn::seisys::v2x::pb::ParticipantSizeConfidence* obssizeconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obssizeconfid_;
  }
  if (obssizeconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obssizeconfid);
    if (message_arena != submessage_arena) {
      obssizeconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obssizeconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.obssizeconfid_ = obssizeconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ObstacleData.obsSizeConfid)
}

// uint32 tracking = 18;
inline void ObstacleData::clear_tracking() {
  _impl_.tracking_ = 0u;
}
inline uint32_t ObstacleData::_internal_tracking() const {
  return _impl_.tracking_;
}
inline uint32_t ObstacleData::tracking() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.tracking)
  return _internal_tracking();
}
inline void ObstacleData::_internal_set_tracking(uint32_t value) {
  
  _impl_.tracking_ = value;
}
inline void ObstacleData::set_tracking(uint32_t value) {
  _internal_set_tracking(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObstacleData.tracking)
}

// .cn.seisys.v2x.pb.Polygon polygon = 19;
inline bool ObstacleData::_internal_has_polygon() const {
  return this != internal_default_instance() && _impl_.polygon_ != nullptr;
}
inline bool ObstacleData::has_polygon() const {
  return _internal_has_polygon();
}
inline void ObstacleData::clear_polygon() {
  if (GetArenaForAllocation() == nullptr && _impl_.polygon_ != nullptr) {
    delete _impl_.polygon_;
  }
  _impl_.polygon_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Polygon& ObstacleData::_internal_polygon() const {
  const ::cn::seisys::v2x::pb::Polygon* p = _impl_.polygon_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Polygon&>(
      ::cn::seisys::v2x::pb::_Polygon_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Polygon& ObstacleData::polygon() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObstacleData.polygon)
  return _internal_polygon();
}
inline void ObstacleData::unsafe_arena_set_allocated_polygon(
    ::cn::seisys::v2x::pb::Polygon* polygon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.polygon_);
  }
  _impl_.polygon_ = polygon;
  if (polygon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ObstacleData.polygon)
}
inline ::cn::seisys::v2x::pb::Polygon* ObstacleData::release_polygon() {
  
  ::cn::seisys::v2x::pb::Polygon* temp = _impl_.polygon_;
  _impl_.polygon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Polygon* ObstacleData::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ObstacleData.polygon)
  
  ::cn::seisys::v2x::pb::Polygon* temp = _impl_.polygon_;
  _impl_.polygon_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Polygon* ObstacleData::_internal_mutable_polygon() {
  
  if (_impl_.polygon_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Polygon>(GetArenaForAllocation());
    _impl_.polygon_ = p;
  }
  return _impl_.polygon_;
}
inline ::cn::seisys::v2x::pb::Polygon* ObstacleData::mutable_polygon() {
  ::cn::seisys::v2x::pb::Polygon* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ObstacleData.polygon)
  return _msg;
}
inline void ObstacleData::set_allocated_polygon(::cn::seisys::v2x::pb::Polygon* polygon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.polygon_;
  }
  if (polygon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(polygon);
    if (message_arena != submessage_arena) {
      polygon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polygon, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.polygon_ = polygon;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ObstacleData.polygon)
}

// -------------------------------------------------------------------

// ObjIdValue

// uint64 ptcId = 1;
inline void ObjIdValue::clear_ptcid() {
  _impl_.ptcid_ = uint64_t{0u};
}
inline uint64_t ObjIdValue::_internal_ptcid() const {
  return _impl_.ptcid_;
}
inline uint64_t ObjIdValue::ptcid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObjIdValue.ptcId)
  return _internal_ptcid();
}
inline void ObjIdValue::_internal_set_ptcid(uint64_t value) {
  
  _impl_.ptcid_ = value;
}
inline void ObjIdValue::set_ptcid(uint64_t value) {
  _internal_set_ptcid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObjIdValue.ptcId)
}

// uint64 obsId = 2;
inline void ObjIdValue::clear_obsid() {
  _impl_.obsid_ = uint64_t{0u};
}
inline uint64_t ObjIdValue::_internal_obsid() const {
  return _impl_.obsid_;
}
inline uint64_t ObjIdValue::obsid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObjIdValue.obsId)
  return _internal_obsid();
}
inline void ObjIdValue::_internal_set_obsid(uint64_t value) {
  
  _impl_.obsid_ = value;
}
inline void ObjIdValue::set_obsid(uint64_t value) {
  _internal_set_obsid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObjIdValue.obsId)
}

// .cn.seisys.v2x.pb.ObjIdValue.Role role = 3;
inline void ObjIdValue::clear_role() {
  _impl_.role_ = 0;
}
inline ::cn::seisys::v2x::pb::ObjIdValue_Role ObjIdValue::_internal_role() const {
  return static_cast< ::cn::seisys::v2x::pb::ObjIdValue_Role >(_impl_.role_);
}
inline ::cn::seisys::v2x::pb::ObjIdValue_Role ObjIdValue::role() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ObjIdValue.role)
  return _internal_role();
}
inline void ObjIdValue::_internal_set_role(::cn::seisys::v2x::pb::ObjIdValue_Role value) {
  
  _impl_.role_ = value;
}
inline void ObjIdValue::set_role(::cn::seisys::v2x::pb::ObjIdValue_Role value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ObjIdValue.role)
}

// -------------------------------------------------------------------

// RteData

// uint32 rteId = 1;
inline void RteData::clear_rteid() {
  _impl_.rteid_ = 0u;
}
inline uint32_t RteData::_internal_rteid() const {
  return _impl_.rteid_;
}
inline uint32_t RteData::rteid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.rteId)
  return _internal_rteid();
}
inline void RteData::_internal_set_rteid(uint32_t value) {
  
  _impl_.rteid_ = value;
}
inline void RteData::set_rteid(uint32_t value) {
  _internal_set_rteid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.rteId)
}

// uint32 rteType = 2;
inline void RteData::clear_rtetype() {
  _impl_.rtetype_ = 0u;
}
inline uint32_t RteData::_internal_rtetype() const {
  return _impl_.rtetype_;
}
inline uint32_t RteData::rtetype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.rteType)
  return _internal_rtetype();
}
inline void RteData::_internal_set_rtetype(uint32_t value) {
  
  _impl_.rtetype_ = value;
}
inline void RteData::set_rtetype(uint32_t value) {
  _internal_set_rtetype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.rteType)
}

// string description = 3;
inline void RteData::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& RteData::description() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RteData::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.description)
}
inline std::string* RteData::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.description)
  return _s;
}
inline const std::string& RteData::_internal_description() const {
  return _impl_.description_.Get();
}
inline void RteData::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* RteData::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* RteData::release_description() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RteData.description)
  return _impl_.description_.Release();
}
inline void RteData::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RteData.description)
}

// .cn.seisys.v2x.pb.RteData.EventSource eventSource = 4;
inline void RteData::clear_eventsource() {
  _impl_.eventsource_ = 0;
}
inline ::cn::seisys::v2x::pb::RteData_EventSource RteData::_internal_eventsource() const {
  return static_cast< ::cn::seisys::v2x::pb::RteData_EventSource >(_impl_.eventsource_);
}
inline ::cn::seisys::v2x::pb::RteData_EventSource RteData::eventsource() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.eventSource)
  return _internal_eventsource();
}
inline void RteData::_internal_set_eventsource(::cn::seisys::v2x::pb::RteData_EventSource value) {
  
  _impl_.eventsource_ = value;
}
inline void RteData::set_eventsource(::cn::seisys::v2x::pb::RteData_EventSource value) {
  _internal_set_eventsource(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.eventSource)
}

// .cn.seisys.v2x.pb.DataSource dataSource = 5;
inline void RteData::clear_datasource() {
  _impl_.datasource_ = 0;
}
inline ::cn::seisys::v2x::pb::DataSource RteData::_internal_datasource() const {
  return static_cast< ::cn::seisys::v2x::pb::DataSource >(_impl_.datasource_);
}
inline ::cn::seisys::v2x::pb::DataSource RteData::datasource() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.dataSource)
  return _internal_datasource();
}
inline void RteData::_internal_set_datasource(::cn::seisys::v2x::pb::DataSource value) {
  
  _impl_.datasource_ = value;
}
inline void RteData::set_datasource(::cn::seisys::v2x::pb::DataSource value) {
  _internal_set_datasource(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.dataSource)
}

// string deviceIdList = 6;
inline void RteData::clear_deviceidlist() {
  _impl_.deviceidlist_.ClearToEmpty();
}
inline const std::string& RteData::deviceidlist() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.deviceIdList)
  return _internal_deviceidlist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RteData::set_deviceidlist(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceidlist_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.deviceIdList)
}
inline std::string* RteData::mutable_deviceidlist() {
  std::string* _s = _internal_mutable_deviceidlist();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.deviceIdList)
  return _s;
}
inline const std::string& RteData::_internal_deviceidlist() const {
  return _impl_.deviceidlist_.Get();
}
inline void RteData::_internal_set_deviceidlist(const std::string& value) {
  
  _impl_.deviceidlist_.Set(value, GetArenaForAllocation());
}
inline std::string* RteData::_internal_mutable_deviceidlist() {
  
  return _impl_.deviceidlist_.Mutable(GetArenaForAllocation());
}
inline std::string* RteData::release_deviceidlist() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RteData.deviceIdList)
  return _impl_.deviceidlist_.Release();
}
inline void RteData::set_allocated_deviceidlist(std::string* deviceidlist) {
  if (deviceidlist != nullptr) {
    
  } else {
    
  }
  _impl_.deviceidlist_.SetAllocated(deviceidlist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceidlist_.IsDefault()) {
    _impl_.deviceidlist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RteData.deviceIdList)
}

// .cn.seisys.v2x.pb.Position3D rtePos = 7;
inline bool RteData::_internal_has_rtepos() const {
  return this != internal_default_instance() && _impl_.rtepos_ != nullptr;
}
inline bool RteData::has_rtepos() const {
  return _internal_has_rtepos();
}
inline void RteData::clear_rtepos() {
  if (GetArenaForAllocation() == nullptr && _impl_.rtepos_ != nullptr) {
    delete _impl_.rtepos_;
  }
  _impl_.rtepos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& RteData::_internal_rtepos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.rtepos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& RteData::rtepos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.rtePos)
  return _internal_rtepos();
}
inline void RteData::unsafe_arena_set_allocated_rtepos(
    ::cn::seisys::v2x::pb::Position3D* rtepos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rtepos_);
  }
  _impl_.rtepos_ = rtepos;
  if (rtepos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.RteData.rtePos)
}
inline ::cn::seisys::v2x::pb::Position3D* RteData::release_rtepos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.rtepos_;
  _impl_.rtepos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* RteData::unsafe_arena_release_rtepos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RteData.rtePos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.rtepos_;
  _impl_.rtepos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* RteData::_internal_mutable_rtepos() {
  
  if (_impl_.rtepos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.rtepos_ = p;
  }
  return _impl_.rtepos_;
}
inline ::cn::seisys::v2x::pb::Position3D* RteData::mutable_rtepos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_rtepos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.rtePos)
  return _msg;
}
inline void RteData::set_allocated_rtepos(::cn::seisys::v2x::pb::Position3D* rtepos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rtepos_;
  }
  if (rtepos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rtepos);
    if (message_arena != submessage_arena) {
      rtepos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtepos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rtepos_ = rtepos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RteData.rtePos)
}

// .cn.seisys.v2x.pb.MapLocation mapLocation = 8;
inline bool RteData::_internal_has_maplocation() const {
  return this != internal_default_instance() && _impl_.maplocation_ != nullptr;
}
inline bool RteData::has_maplocation() const {
  return _internal_has_maplocation();
}
inline void RteData::clear_maplocation() {
  if (GetArenaForAllocation() == nullptr && _impl_.maplocation_ != nullptr) {
    delete _impl_.maplocation_;
  }
  _impl_.maplocation_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::MapLocation& RteData::_internal_maplocation() const {
  const ::cn::seisys::v2x::pb::MapLocation* p = _impl_.maplocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::MapLocation&>(
      ::cn::seisys::v2x::pb::_MapLocation_default_instance_);
}
inline const ::cn::seisys::v2x::pb::MapLocation& RteData::maplocation() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.mapLocation)
  return _internal_maplocation();
}
inline void RteData::unsafe_arena_set_allocated_maplocation(
    ::cn::seisys::v2x::pb::MapLocation* maplocation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maplocation_);
  }
  _impl_.maplocation_ = maplocation;
  if (maplocation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.RteData.mapLocation)
}
inline ::cn::seisys::v2x::pb::MapLocation* RteData::release_maplocation() {
  
  ::cn::seisys::v2x::pb::MapLocation* temp = _impl_.maplocation_;
  _impl_.maplocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::MapLocation* RteData::unsafe_arena_release_maplocation() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RteData.mapLocation)
  
  ::cn::seisys::v2x::pb::MapLocation* temp = _impl_.maplocation_;
  _impl_.maplocation_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::MapLocation* RteData::_internal_mutable_maplocation() {
  
  if (_impl_.maplocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::MapLocation>(GetArenaForAllocation());
    _impl_.maplocation_ = p;
  }
  return _impl_.maplocation_;
}
inline ::cn::seisys::v2x::pb::MapLocation* RteData::mutable_maplocation() {
  ::cn::seisys::v2x::pb::MapLocation* _msg = _internal_mutable_maplocation();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.mapLocation)
  return _msg;
}
inline void RteData::set_allocated_maplocation(::cn::seisys::v2x::pb::MapLocation* maplocation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.maplocation_;
  }
  if (maplocation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maplocation);
    if (message_arena != submessage_arena) {
      maplocation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maplocation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.maplocation_ = maplocation;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RteData.mapLocation)
}

// uint32 eventRadius = 9;
inline void RteData::clear_eventradius() {
  _impl_.eventradius_ = 0u;
}
inline uint32_t RteData::_internal_eventradius() const {
  return _impl_.eventradius_;
}
inline uint32_t RteData::eventradius() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.eventRadius)
  return _internal_eventradius();
}
inline void RteData::_internal_set_eventradius(uint32_t value) {
  
  _impl_.eventradius_ = value;
}
inline void RteData::set_eventradius(uint32_t value) {
  _internal_set_eventradius(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.eventRadius)
}

// .cn.seisys.v2x.pb.RsiTimeDetails timeDetails = 10;
inline bool RteData::_internal_has_timedetails() const {
  return this != internal_default_instance() && _impl_.timedetails_ != nullptr;
}
inline bool RteData::has_timedetails() const {
  return _internal_has_timedetails();
}
inline void RteData::clear_timedetails() {
  if (GetArenaForAllocation() == nullptr && _impl_.timedetails_ != nullptr) {
    delete _impl_.timedetails_;
  }
  _impl_.timedetails_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::RsiTimeDetails& RteData::_internal_timedetails() const {
  const ::cn::seisys::v2x::pb::RsiTimeDetails* p = _impl_.timedetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::RsiTimeDetails&>(
      ::cn::seisys::v2x::pb::_RsiTimeDetails_default_instance_);
}
inline const ::cn::seisys::v2x::pb::RsiTimeDetails& RteData::timedetails() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.timeDetails)
  return _internal_timedetails();
}
inline void RteData::unsafe_arena_set_allocated_timedetails(
    ::cn::seisys::v2x::pb::RsiTimeDetails* timedetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timedetails_);
  }
  _impl_.timedetails_ = timedetails;
  if (timedetails) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.RteData.timeDetails)
}
inline ::cn::seisys::v2x::pb::RsiTimeDetails* RteData::release_timedetails() {
  
  ::cn::seisys::v2x::pb::RsiTimeDetails* temp = _impl_.timedetails_;
  _impl_.timedetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::RsiTimeDetails* RteData::unsafe_arena_release_timedetails() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RteData.timeDetails)
  
  ::cn::seisys::v2x::pb::RsiTimeDetails* temp = _impl_.timedetails_;
  _impl_.timedetails_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::RsiTimeDetails* RteData::_internal_mutable_timedetails() {
  
  if (_impl_.timedetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::RsiTimeDetails>(GetArenaForAllocation());
    _impl_.timedetails_ = p;
  }
  return _impl_.timedetails_;
}
inline ::cn::seisys::v2x::pb::RsiTimeDetails* RteData::mutable_timedetails() {
  ::cn::seisys::v2x::pb::RsiTimeDetails* _msg = _internal_mutable_timedetails();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.timeDetails)
  return _msg;
}
inline void RteData::set_allocated_timedetails(::cn::seisys::v2x::pb::RsiTimeDetails* timedetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timedetails_;
  }
  if (timedetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timedetails);
    if (message_arena != submessage_arena) {
      timedetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timedetails, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timedetails_ = timedetails;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RteData.timeDetails)
}

// string priority = 11;
inline void RteData::clear_priority() {
  _impl_.priority_.ClearToEmpty();
}
inline const std::string& RteData::priority() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.priority)
  return _internal_priority();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RteData::set_priority(ArgT0&& arg0, ArgT... args) {
 
 _impl_.priority_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.priority)
}
inline std::string* RteData::mutable_priority() {
  std::string* _s = _internal_mutable_priority();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.priority)
  return _s;
}
inline const std::string& RteData::_internal_priority() const {
  return _impl_.priority_.Get();
}
inline void RteData::_internal_set_priority(const std::string& value) {
  
  _impl_.priority_.Set(value, GetArenaForAllocation());
}
inline std::string* RteData::_internal_mutable_priority() {
  
  return _impl_.priority_.Mutable(GetArenaForAllocation());
}
inline std::string* RteData::release_priority() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RteData.priority)
  return _impl_.priority_.Release();
}
inline void RteData::set_allocated_priority(std::string* priority) {
  if (priority != nullptr) {
    
  } else {
    
  }
  _impl_.priority_.SetAllocated(priority, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.priority_.IsDefault()) {
    _impl_.priority_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RteData.priority)
}

// repeated .cn.seisys.v2x.pb.ReferencePath referencePath = 12;
inline int RteData::_internal_referencepath_size() const {
  return _impl_.referencepath_.size();
}
inline int RteData::referencepath_size() const {
  return _internal_referencepath_size();
}
inline void RteData::clear_referencepath() {
  _impl_.referencepath_.Clear();
}
inline ::cn::seisys::v2x::pb::ReferencePath* RteData::mutable_referencepath(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.referencePath)
  return _impl_.referencepath_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >*
RteData::mutable_referencepath() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.RteData.referencePath)
  return &_impl_.referencepath_;
}
inline const ::cn::seisys::v2x::pb::ReferencePath& RteData::_internal_referencepath(int index) const {
  return _impl_.referencepath_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ReferencePath& RteData::referencepath(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.referencePath)
  return _internal_referencepath(index);
}
inline ::cn::seisys::v2x::pb::ReferencePath* RteData::_internal_add_referencepath() {
  return _impl_.referencepath_.Add();
}
inline ::cn::seisys::v2x::pb::ReferencePath* RteData::add_referencepath() {
  ::cn::seisys::v2x::pb::ReferencePath* _add = _internal_add_referencepath();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.RteData.referencePath)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >&
RteData::referencepath() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.RteData.referencePath)
  return _impl_.referencepath_;
}

// repeated .cn.seisys.v2x.pb.ReferenceLink referenceLinks = 13;
inline int RteData::_internal_referencelinks_size() const {
  return _impl_.referencelinks_.size();
}
inline int RteData::referencelinks_size() const {
  return _internal_referencelinks_size();
}
inline void RteData::clear_referencelinks() {
  _impl_.referencelinks_.Clear();
}
inline ::cn::seisys::v2x::pb::ReferenceLink* RteData::mutable_referencelinks(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.referenceLinks)
  return _impl_.referencelinks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink >*
RteData::mutable_referencelinks() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.RteData.referenceLinks)
  return &_impl_.referencelinks_;
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& RteData::_internal_referencelinks(int index) const {
  return _impl_.referencelinks_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& RteData::referencelinks(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.referenceLinks)
  return _internal_referencelinks(index);
}
inline ::cn::seisys::v2x::pb::ReferenceLink* RteData::_internal_add_referencelinks() {
  return _impl_.referencelinks_.Add();
}
inline ::cn::seisys::v2x::pb::ReferenceLink* RteData::add_referencelinks() {
  ::cn::seisys::v2x::pb::ReferenceLink* _add = _internal_add_referencelinks();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.RteData.referenceLinks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink >&
RteData::referencelinks() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.RteData.referenceLinks)
  return _impl_.referencelinks_;
}

// repeated .cn.seisys.v2x.pb.ObjIdValue eventObjId = 14;
inline int RteData::_internal_eventobjid_size() const {
  return _impl_.eventobjid_.size();
}
inline int RteData::eventobjid_size() const {
  return _internal_eventobjid_size();
}
inline void RteData::clear_eventobjid() {
  _impl_.eventobjid_.Clear();
}
inline ::cn::seisys::v2x::pb::ObjIdValue* RteData::mutable_eventobjid(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.eventObjId)
  return _impl_.eventobjid_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObjIdValue >*
RteData::mutable_eventobjid() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.RteData.eventObjId)
  return &_impl_.eventobjid_;
}
inline const ::cn::seisys::v2x::pb::ObjIdValue& RteData::_internal_eventobjid(int index) const {
  return _impl_.eventobjid_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ObjIdValue& RteData::eventobjid(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.eventObjId)
  return _internal_eventobjid(index);
}
inline ::cn::seisys::v2x::pb::ObjIdValue* RteData::_internal_add_eventobjid() {
  return _impl_.eventobjid_.Add();
}
inline ::cn::seisys::v2x::pb::ObjIdValue* RteData::add_eventobjid() {
  ::cn::seisys::v2x::pb::ObjIdValue* _add = _internal_add_eventobjid();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.RteData.eventObjId)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObjIdValue >&
RteData::eventobjid() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.RteData.eventObjId)
  return _impl_.eventobjid_;
}

// int32 eventConfid = 15;
inline void RteData::clear_eventconfid() {
  _impl_.eventconfid_ = 0;
}
inline int32_t RteData::_internal_eventconfid() const {
  return _impl_.eventconfid_;
}
inline int32_t RteData::eventconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.eventConfid)
  return _internal_eventconfid();
}
inline void RteData::_internal_set_eventconfid(int32_t value) {
  
  _impl_.eventconfid_ = value;
}
inline void RteData::set_eventconfid(int32_t value) {
  _internal_set_eventconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.eventConfid)
}

// string eventImages = 16;
inline void RteData::clear_eventimages() {
  _impl_.eventimages_.ClearToEmpty();
}
inline const std::string& RteData::eventimages() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.eventImages)
  return _internal_eventimages();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RteData::set_eventimages(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eventimages_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.eventImages)
}
inline std::string* RteData::mutable_eventimages() {
  std::string* _s = _internal_mutable_eventimages();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.eventImages)
  return _s;
}
inline const std::string& RteData::_internal_eventimages() const {
  return _impl_.eventimages_.Get();
}
inline void RteData::_internal_set_eventimages(const std::string& value) {
  
  _impl_.eventimages_.Set(value, GetArenaForAllocation());
}
inline std::string* RteData::_internal_mutable_eventimages() {
  
  return _impl_.eventimages_.Mutable(GetArenaForAllocation());
}
inline std::string* RteData::release_eventimages() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RteData.eventImages)
  return _impl_.eventimages_.Release();
}
inline void RteData::set_allocated_eventimages(std::string* eventimages) {
  if (eventimages != nullptr) {
    
  } else {
    
  }
  _impl_.eventimages_.SetAllocated(eventimages, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventimages_.IsDefault()) {
    _impl_.eventimages_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RteData.eventImages)
}

// string eventVideos = 17;
inline void RteData::clear_eventvideos() {
  _impl_.eventvideos_.ClearToEmpty();
}
inline const std::string& RteData::eventvideos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.eventVideos)
  return _internal_eventvideos();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RteData::set_eventvideos(ArgT0&& arg0, ArgT... args) {
 
 _impl_.eventvideos_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.eventVideos)
}
inline std::string* RteData::mutable_eventvideos() {
  std::string* _s = _internal_mutable_eventvideos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RteData.eventVideos)
  return _s;
}
inline const std::string& RteData::_internal_eventvideos() const {
  return _impl_.eventvideos_.Get();
}
inline void RteData::_internal_set_eventvideos(const std::string& value) {
  
  _impl_.eventvideos_.Set(value, GetArenaForAllocation());
}
inline std::string* RteData::_internal_mutable_eventvideos() {
  
  return _impl_.eventvideos_.Mutable(GetArenaForAllocation());
}
inline std::string* RteData::release_eventvideos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RteData.eventVideos)
  return _impl_.eventvideos_.Release();
}
inline void RteData::set_allocated_eventvideos(std::string* eventvideos) {
  if (eventvideos != nullptr) {
    
  } else {
    
  }
  _impl_.eventvideos_.SetAllocated(eventvideos, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.eventvideos_.IsDefault()) {
    _impl_.eventvideos_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RteData.eventVideos)
}

// uint64 sessionId = 18;
inline void RteData::clear_sessionid() {
  _impl_.sessionid_ = uint64_t{0u};
}
inline uint64_t RteData::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline uint64_t RteData::sessionid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.sessionId)
  return _internal_sessionid();
}
inline void RteData::_internal_set_sessionid(uint64_t value) {
  
  _impl_.sessionid_ = value;
}
inline void RteData::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.sessionId)
}

// uint64 id = 19;
inline void RteData::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t RteData::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t RteData::id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RteData.id)
  return _internal_id();
}
inline void RteData::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void RteData::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RteData.id)
}

// -------------------------------------------------------------------

// RtsData

// int32 rtsId = 1;
inline void RtsData::clear_rtsid() {
  _impl_.rtsid_ = 0;
}
inline int32_t RtsData::_internal_rtsid() const {
  return _impl_.rtsid_;
}
inline int32_t RtsData::rtsid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.rtsId)
  return _internal_rtsid();
}
inline void RtsData::_internal_set_rtsid(int32_t value) {
  
  _impl_.rtsid_ = value;
}
inline void RtsData::set_rtsid(int32_t value) {
  _internal_set_rtsid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RtsData.rtsId)
}

// int32 rtsType = 2;
inline void RtsData::clear_rtstype() {
  _impl_.rtstype_ = 0;
}
inline int32_t RtsData::_internal_rtstype() const {
  return _impl_.rtstype_;
}
inline int32_t RtsData::rtstype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.rtsType)
  return _internal_rtstype();
}
inline void RtsData::_internal_set_rtstype(int32_t value) {
  
  _impl_.rtstype_ = value;
}
inline void RtsData::set_rtstype(int32_t value) {
  _internal_set_rtstype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RtsData.rtsType)
}

// .cn.seisys.v2x.pb.DataSource dataSource = 3;
inline void RtsData::clear_datasource() {
  _impl_.datasource_ = 0;
}
inline ::cn::seisys::v2x::pb::DataSource RtsData::_internal_datasource() const {
  return static_cast< ::cn::seisys::v2x::pb::DataSource >(_impl_.datasource_);
}
inline ::cn::seisys::v2x::pb::DataSource RtsData::datasource() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.dataSource)
  return _internal_datasource();
}
inline void RtsData::_internal_set_datasource(::cn::seisys::v2x::pb::DataSource value) {
  
  _impl_.datasource_ = value;
}
inline void RtsData::set_datasource(::cn::seisys::v2x::pb::DataSource value) {
  _internal_set_datasource(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RtsData.dataSource)
}

// string priority = 4;
inline void RtsData::clear_priority() {
  _impl_.priority_.ClearToEmpty();
}
inline const std::string& RtsData::priority() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.priority)
  return _internal_priority();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtsData::set_priority(ArgT0&& arg0, ArgT... args) {
 
 _impl_.priority_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RtsData.priority)
}
inline std::string* RtsData::mutable_priority() {
  std::string* _s = _internal_mutable_priority();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RtsData.priority)
  return _s;
}
inline const std::string& RtsData::_internal_priority() const {
  return _impl_.priority_.Get();
}
inline void RtsData::_internal_set_priority(const std::string& value) {
  
  _impl_.priority_.Set(value, GetArenaForAllocation());
}
inline std::string* RtsData::_internal_mutable_priority() {
  
  return _impl_.priority_.Mutable(GetArenaForAllocation());
}
inline std::string* RtsData::release_priority() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RtsData.priority)
  return _impl_.priority_.Release();
}
inline void RtsData::set_allocated_priority(std::string* priority) {
  if (priority != nullptr) {
    
  } else {
    
  }
  _impl_.priority_.SetAllocated(priority, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.priority_.IsDefault()) {
    _impl_.priority_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RtsData.priority)
}

// .cn.seisys.v2x.pb.Position3D rtsPos = 5;
inline bool RtsData::_internal_has_rtspos() const {
  return this != internal_default_instance() && _impl_.rtspos_ != nullptr;
}
inline bool RtsData::has_rtspos() const {
  return _internal_has_rtspos();
}
inline void RtsData::clear_rtspos() {
  if (GetArenaForAllocation() == nullptr && _impl_.rtspos_ != nullptr) {
    delete _impl_.rtspos_;
  }
  _impl_.rtspos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& RtsData::_internal_rtspos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.rtspos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& RtsData::rtspos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.rtsPos)
  return _internal_rtspos();
}
inline void RtsData::unsafe_arena_set_allocated_rtspos(
    ::cn::seisys::v2x::pb::Position3D* rtspos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rtspos_);
  }
  _impl_.rtspos_ = rtspos;
  if (rtspos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.RtsData.rtsPos)
}
inline ::cn::seisys::v2x::pb::Position3D* RtsData::release_rtspos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.rtspos_;
  _impl_.rtspos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* RtsData::unsafe_arena_release_rtspos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RtsData.rtsPos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.rtspos_;
  _impl_.rtspos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* RtsData::_internal_mutable_rtspos() {
  
  if (_impl_.rtspos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.rtspos_ = p;
  }
  return _impl_.rtspos_;
}
inline ::cn::seisys::v2x::pb::Position3D* RtsData::mutable_rtspos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_rtspos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RtsData.rtsPos)
  return _msg;
}
inline void RtsData::set_allocated_rtspos(::cn::seisys::v2x::pb::Position3D* rtspos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rtspos_;
  }
  if (rtspos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rtspos);
    if (message_arena != submessage_arena) {
      rtspos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtspos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rtspos_ = rtspos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RtsData.rtsPos)
}

// .cn.seisys.v2x.pb.RsiTimeDetails timeDetails = 6;
inline bool RtsData::_internal_has_timedetails() const {
  return this != internal_default_instance() && _impl_.timedetails_ != nullptr;
}
inline bool RtsData::has_timedetails() const {
  return _internal_has_timedetails();
}
inline void RtsData::clear_timedetails() {
  if (GetArenaForAllocation() == nullptr && _impl_.timedetails_ != nullptr) {
    delete _impl_.timedetails_;
  }
  _impl_.timedetails_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::RsiTimeDetails& RtsData::_internal_timedetails() const {
  const ::cn::seisys::v2x::pb::RsiTimeDetails* p = _impl_.timedetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::RsiTimeDetails&>(
      ::cn::seisys::v2x::pb::_RsiTimeDetails_default_instance_);
}
inline const ::cn::seisys::v2x::pb::RsiTimeDetails& RtsData::timedetails() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.timeDetails)
  return _internal_timedetails();
}
inline void RtsData::unsafe_arena_set_allocated_timedetails(
    ::cn::seisys::v2x::pb::RsiTimeDetails* timedetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timedetails_);
  }
  _impl_.timedetails_ = timedetails;
  if (timedetails) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.RtsData.timeDetails)
}
inline ::cn::seisys::v2x::pb::RsiTimeDetails* RtsData::release_timedetails() {
  
  ::cn::seisys::v2x::pb::RsiTimeDetails* temp = _impl_.timedetails_;
  _impl_.timedetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::RsiTimeDetails* RtsData::unsafe_arena_release_timedetails() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RtsData.timeDetails)
  
  ::cn::seisys::v2x::pb::RsiTimeDetails* temp = _impl_.timedetails_;
  _impl_.timedetails_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::RsiTimeDetails* RtsData::_internal_mutable_timedetails() {
  
  if (_impl_.timedetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::RsiTimeDetails>(GetArenaForAllocation());
    _impl_.timedetails_ = p;
  }
  return _impl_.timedetails_;
}
inline ::cn::seisys::v2x::pb::RsiTimeDetails* RtsData::mutable_timedetails() {
  ::cn::seisys::v2x::pb::RsiTimeDetails* _msg = _internal_mutable_timedetails();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RtsData.timeDetails)
  return _msg;
}
inline void RtsData::set_allocated_timedetails(::cn::seisys::v2x::pb::RsiTimeDetails* timedetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timedetails_;
  }
  if (timedetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timedetails);
    if (message_arena != submessage_arena) {
      timedetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timedetails, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timedetails_ = timedetails;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RtsData.timeDetails)
}

// string description = 7;
inline void RtsData::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& RtsData::description() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtsData::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RtsData.description)
}
inline std::string* RtsData::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RtsData.description)
  return _s;
}
inline const std::string& RtsData::_internal_description() const {
  return _impl_.description_.Get();
}
inline void RtsData::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* RtsData::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* RtsData::release_description() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RtsData.description)
  return _impl_.description_.Release();
}
inline void RtsData::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RtsData.description)
}

// repeated .cn.seisys.v2x.pb.ReferencePath refPathList = 8;
inline int RtsData::_internal_refpathlist_size() const {
  return _impl_.refpathlist_.size();
}
inline int RtsData::refpathlist_size() const {
  return _internal_refpathlist_size();
}
inline void RtsData::clear_refpathlist() {
  _impl_.refpathlist_.Clear();
}
inline ::cn::seisys::v2x::pb::ReferencePath* RtsData::mutable_refpathlist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RtsData.refPathList)
  return _impl_.refpathlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >*
RtsData::mutable_refpathlist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.RtsData.refPathList)
  return &_impl_.refpathlist_;
}
inline const ::cn::seisys::v2x::pb::ReferencePath& RtsData::_internal_refpathlist(int index) const {
  return _impl_.refpathlist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ReferencePath& RtsData::refpathlist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.refPathList)
  return _internal_refpathlist(index);
}
inline ::cn::seisys::v2x::pb::ReferencePath* RtsData::_internal_add_refpathlist() {
  return _impl_.refpathlist_.Add();
}
inline ::cn::seisys::v2x::pb::ReferencePath* RtsData::add_refpathlist() {
  ::cn::seisys::v2x::pb::ReferencePath* _add = _internal_add_refpathlist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.RtsData.refPathList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >&
RtsData::refpathlist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.RtsData.refPathList)
  return _impl_.refpathlist_;
}

// repeated .cn.seisys.v2x.pb.ReferenceLink refLinkList = 9;
inline int RtsData::_internal_reflinklist_size() const {
  return _impl_.reflinklist_.size();
}
inline int RtsData::reflinklist_size() const {
  return _internal_reflinklist_size();
}
inline void RtsData::clear_reflinklist() {
  _impl_.reflinklist_.Clear();
}
inline ::cn::seisys::v2x::pb::ReferenceLink* RtsData::mutable_reflinklist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RtsData.refLinkList)
  return _impl_.reflinklist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink >*
RtsData::mutable_reflinklist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.RtsData.refLinkList)
  return &_impl_.reflinklist_;
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& RtsData::_internal_reflinklist(int index) const {
  return _impl_.reflinklist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& RtsData::reflinklist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.refLinkList)
  return _internal_reflinklist(index);
}
inline ::cn::seisys::v2x::pb::ReferenceLink* RtsData::_internal_add_reflinklist() {
  return _impl_.reflinklist_.Add();
}
inline ::cn::seisys::v2x::pb::ReferenceLink* RtsData::add_reflinklist() {
  ::cn::seisys::v2x::pb::ReferenceLink* _add = _internal_add_reflinklist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.RtsData.refLinkList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferenceLink >&
RtsData::reflinklist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.RtsData.refLinkList)
  return _impl_.reflinklist_;
}

// uint32 pathRadius = 10;
inline void RtsData::clear_pathradius() {
  _impl_.pathradius_ = 0u;
}
inline uint32_t RtsData::_internal_pathradius() const {
  return _impl_.pathradius_;
}
inline uint32_t RtsData::pathradius() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.pathRadius)
  return _internal_pathradius();
}
inline void RtsData::_internal_set_pathradius(uint32_t value) {
  
  _impl_.pathradius_ = value;
}
inline void RtsData::set_pathradius(uint32_t value) {
  _internal_set_pathradius(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RtsData.pathRadius)
}

// uint64 sessionId = 11;
inline void RtsData::clear_sessionid() {
  _impl_.sessionid_ = uint64_t{0u};
}
inline uint64_t RtsData::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline uint64_t RtsData::sessionid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.sessionId)
  return _internal_sessionid();
}
inline void RtsData::_internal_set_sessionid(uint64_t value) {
  
  _impl_.sessionid_ = value;
}
inline void RtsData::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RtsData.sessionId)
}

// uint64 id = 12;
inline void RtsData::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t RtsData::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t RtsData::id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RtsData.id)
  return _internal_id();
}
inline void RtsData::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void RtsData::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RtsData.id)
}

// -------------------------------------------------------------------

// ConnectingLane

// uint32 lane = 1;
inline void ConnectingLane::clear_lane() {
  _impl_.lane_ = 0u;
}
inline uint32_t ConnectingLane::_internal_lane() const {
  return _impl_.lane_;
}
inline uint32_t ConnectingLane::lane() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectingLane.lane)
  return _internal_lane();
}
inline void ConnectingLane::_internal_set_lane(uint32_t value) {
  
  _impl_.lane_ = value;
}
inline void ConnectingLane::set_lane(uint32_t value) {
  _internal_set_lane(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ConnectingLane.lane)
}

// .cn.seisys.v2x.pb.AllowedManeuvers maneuvers = 2;
inline bool ConnectingLane::_internal_has_maneuvers() const {
  return this != internal_default_instance() && _impl_.maneuvers_ != nullptr;
}
inline bool ConnectingLane::has_maneuvers() const {
  return _internal_has_maneuvers();
}
inline void ConnectingLane::clear_maneuvers() {
  if (GetArenaForAllocation() == nullptr && _impl_.maneuvers_ != nullptr) {
    delete _impl_.maneuvers_;
  }
  _impl_.maneuvers_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::AllowedManeuvers& ConnectingLane::_internal_maneuvers() const {
  const ::cn::seisys::v2x::pb::AllowedManeuvers* p = _impl_.maneuvers_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::AllowedManeuvers&>(
      ::cn::seisys::v2x::pb::_AllowedManeuvers_default_instance_);
}
inline const ::cn::seisys::v2x::pb::AllowedManeuvers& ConnectingLane::maneuvers() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectingLane.maneuvers)
  return _internal_maneuvers();
}
inline void ConnectingLane::unsafe_arena_set_allocated_maneuvers(
    ::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maneuvers_);
  }
  _impl_.maneuvers_ = maneuvers;
  if (maneuvers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ConnectingLane.maneuvers)
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* ConnectingLane::release_maneuvers() {
  
  ::cn::seisys::v2x::pb::AllowedManeuvers* temp = _impl_.maneuvers_;
  _impl_.maneuvers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* ConnectingLane::unsafe_arena_release_maneuvers() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ConnectingLane.maneuvers)
  
  ::cn::seisys::v2x::pb::AllowedManeuvers* temp = _impl_.maneuvers_;
  _impl_.maneuvers_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* ConnectingLane::_internal_mutable_maneuvers() {
  
  if (_impl_.maneuvers_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::AllowedManeuvers>(GetArenaForAllocation());
    _impl_.maneuvers_ = p;
  }
  return _impl_.maneuvers_;
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* ConnectingLane::mutable_maneuvers() {
  ::cn::seisys::v2x::pb::AllowedManeuvers* _msg = _internal_mutable_maneuvers();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ConnectingLane.maneuvers)
  return _msg;
}
inline void ConnectingLane::set_allocated_maneuvers(::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.maneuvers_;
  }
  if (maneuvers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maneuvers);
    if (message_arena != submessage_arena) {
      maneuvers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maneuvers, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.maneuvers_ = maneuvers;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ConnectingLane.maneuvers)
}

// -------------------------------------------------------------------

// Connection

// .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
inline bool Connection::_internal_has_remoteintersection() const {
  return this != internal_default_instance() && _impl_.remoteintersection_ != nullptr;
}
inline bool Connection::has_remoteintersection() const {
  return _internal_has_remoteintersection();
}
inline void Connection::clear_remoteintersection() {
  if (GetArenaForAllocation() == nullptr && _impl_.remoteintersection_ != nullptr) {
    delete _impl_.remoteintersection_;
  }
  _impl_.remoteintersection_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& Connection::_internal_remoteintersection() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.remoteintersection_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& Connection::remoteintersection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Connection.remoteIntersection)
  return _internal_remoteintersection();
}
inline void Connection::unsafe_arena_set_allocated_remoteintersection(
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remoteintersection_);
  }
  _impl_.remoteintersection_ = remoteintersection;
  if (remoteintersection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.Connection.remoteIntersection)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Connection::release_remoteintersection() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Connection::unsafe_arena_release_remoteintersection() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Connection.remoteIntersection)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Connection::_internal_mutable_remoteintersection() {
  
  if (_impl_.remoteintersection_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.remoteintersection_ = p;
  }
  return _impl_.remoteintersection_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Connection::mutable_remoteintersection() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_remoteintersection();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Connection.remoteIntersection)
  return _msg;
}
inline void Connection::set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remoteintersection_;
  }
  if (remoteintersection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remoteintersection);
    if (message_arena != submessage_arena) {
      remoteintersection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remoteintersection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remoteintersection_ = remoteintersection;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Connection.remoteIntersection)
}

// .cn.seisys.v2x.pb.ConnectingLane connectingLane = 2;
inline bool Connection::_internal_has_connectinglane() const {
  return this != internal_default_instance() && _impl_.connectinglane_ != nullptr;
}
inline bool Connection::has_connectinglane() const {
  return _internal_has_connectinglane();
}
inline void Connection::clear_connectinglane() {
  if (GetArenaForAllocation() == nullptr && _impl_.connectinglane_ != nullptr) {
    delete _impl_.connectinglane_;
  }
  _impl_.connectinglane_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ConnectingLane& Connection::_internal_connectinglane() const {
  const ::cn::seisys::v2x::pb::ConnectingLane* p = _impl_.connectinglane_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ConnectingLane&>(
      ::cn::seisys::v2x::pb::_ConnectingLane_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ConnectingLane& Connection::connectinglane() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Connection.connectingLane)
  return _internal_connectinglane();
}
inline void Connection::unsafe_arena_set_allocated_connectinglane(
    ::cn::seisys::v2x::pb::ConnectingLane* connectinglane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connectinglane_);
  }
  _impl_.connectinglane_ = connectinglane;
  if (connectinglane) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.Connection.connectingLane)
}
inline ::cn::seisys::v2x::pb::ConnectingLane* Connection::release_connectinglane() {
  
  ::cn::seisys::v2x::pb::ConnectingLane* temp = _impl_.connectinglane_;
  _impl_.connectinglane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ConnectingLane* Connection::unsafe_arena_release_connectinglane() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Connection.connectingLane)
  
  ::cn::seisys::v2x::pb::ConnectingLane* temp = _impl_.connectinglane_;
  _impl_.connectinglane_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ConnectingLane* Connection::_internal_mutable_connectinglane() {
  
  if (_impl_.connectinglane_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ConnectingLane>(GetArenaForAllocation());
    _impl_.connectinglane_ = p;
  }
  return _impl_.connectinglane_;
}
inline ::cn::seisys::v2x::pb::ConnectingLane* Connection::mutable_connectinglane() {
  ::cn::seisys::v2x::pb::ConnectingLane* _msg = _internal_mutable_connectinglane();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Connection.connectingLane)
  return _msg;
}
inline void Connection::set_allocated_connectinglane(::cn::seisys::v2x::pb::ConnectingLane* connectinglane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connectinglane_;
  }
  if (connectinglane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connectinglane);
    if (message_arena != submessage_arena) {
      connectinglane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connectinglane, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.connectinglane_ = connectinglane;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Connection.connectingLane)
}

// uint32 phaseId = 3;
inline void Connection::clear_phaseid() {
  _impl_.phaseid_ = 0u;
}
inline uint32_t Connection::_internal_phaseid() const {
  return _impl_.phaseid_;
}
inline uint32_t Connection::phaseid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Connection.phaseId)
  return _internal_phaseid();
}
inline void Connection::_internal_set_phaseid(uint32_t value) {
  
  _impl_.phaseid_ = value;
}
inline void Connection::set_phaseid(uint32_t value) {
  _internal_set_phaseid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Connection.phaseId)
}

// -------------------------------------------------------------------

// LaneAttributesParking

// uint32 parkingAndStoppingLanes = 1;
inline void LaneAttributesParking::clear_parkingandstoppinglanes() {
  _impl_.parkingandstoppinglanes_ = 0u;
}
inline uint32_t LaneAttributesParking::_internal_parkingandstoppinglanes() const {
  return _impl_.parkingandstoppinglanes_;
}
inline uint32_t LaneAttributesParking::parkingandstoppinglanes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributesParking.parkingAndStoppingLanes)
  return _internal_parkingandstoppinglanes();
}
inline void LaneAttributesParking::_internal_set_parkingandstoppinglanes(uint32_t value) {
  
  _impl_.parkingandstoppinglanes_ = value;
}
inline void LaneAttributesParking::set_parkingandstoppinglanes(uint32_t value) {
  _internal_set_parkingandstoppinglanes(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneAttributesParking.parkingAndStoppingLanes)
}

// -------------------------------------------------------------------

// LaneAttributesCrosswalk

// uint32 pedestrianCrosswalks = 1;
inline void LaneAttributesCrosswalk::clear_pedestriancrosswalks() {
  _impl_.pedestriancrosswalks_ = 0u;
}
inline uint32_t LaneAttributesCrosswalk::_internal_pedestriancrosswalks() const {
  return _impl_.pedestriancrosswalks_;
}
inline uint32_t LaneAttributesCrosswalk::pedestriancrosswalks() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributesCrosswalk.pedestrianCrosswalks)
  return _internal_pedestriancrosswalks();
}
inline void LaneAttributesCrosswalk::_internal_set_pedestriancrosswalks(uint32_t value) {
  
  _impl_.pedestriancrosswalks_ = value;
}
inline void LaneAttributesCrosswalk::set_pedestriancrosswalks(uint32_t value) {
  _internal_set_pedestriancrosswalks(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneAttributesCrosswalk.pedestrianCrosswalks)
}

// -------------------------------------------------------------------

// LaneAttributesBike

// uint32 bikeLanes = 1;
inline void LaneAttributesBike::clear_bikelanes() {
  _impl_.bikelanes_ = 0u;
}
inline uint32_t LaneAttributesBike::_internal_bikelanes() const {
  return _impl_.bikelanes_;
}
inline uint32_t LaneAttributesBike::bikelanes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributesBike.bikeLanes)
  return _internal_bikelanes();
}
inline void LaneAttributesBike::_internal_set_bikelanes(uint32_t value) {
  
  _impl_.bikelanes_ = value;
}
inline void LaneAttributesBike::set_bikelanes(uint32_t value) {
  _internal_set_bikelanes(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneAttributesBike.bikeLanes)
}

// -------------------------------------------------------------------

// LaneAttributesSidewalk

// uint32 pedestrianSidewalkPaths = 1;
inline void LaneAttributesSidewalk::clear_pedestriansidewalkpaths() {
  _impl_.pedestriansidewalkpaths_ = 0u;
}
inline uint32_t LaneAttributesSidewalk::_internal_pedestriansidewalkpaths() const {
  return _impl_.pedestriansidewalkpaths_;
}
inline uint32_t LaneAttributesSidewalk::pedestriansidewalkpaths() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributesSidewalk.pedestrianSidewalkPaths)
  return _internal_pedestriansidewalkpaths();
}
inline void LaneAttributesSidewalk::_internal_set_pedestriansidewalkpaths(uint32_t value) {
  
  _impl_.pedestriansidewalkpaths_ = value;
}
inline void LaneAttributesSidewalk::set_pedestriansidewalkpaths(uint32_t value) {
  _internal_set_pedestriansidewalkpaths(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneAttributesSidewalk.pedestrianSidewalkPaths)
}

// -------------------------------------------------------------------

// LaneAttributesBarrier

// uint32 mediansChannelization = 1;
inline void LaneAttributesBarrier::clear_medianschannelization() {
  _impl_.medianschannelization_ = 0u;
}
inline uint32_t LaneAttributesBarrier::_internal_medianschannelization() const {
  return _impl_.medianschannelization_;
}
inline uint32_t LaneAttributesBarrier::medianschannelization() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributesBarrier.mediansChannelization)
  return _internal_medianschannelization();
}
inline void LaneAttributesBarrier::_internal_set_medianschannelization(uint32_t value) {
  
  _impl_.medianschannelization_ = value;
}
inline void LaneAttributesBarrier::set_medianschannelization(uint32_t value) {
  _internal_set_medianschannelization(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneAttributesBarrier.mediansChannelization)
}

// -------------------------------------------------------------------

// LaneAttributesStriping

// uint32 roadwayMarkings = 1;
inline void LaneAttributesStriping::clear_roadwaymarkings() {
  _impl_.roadwaymarkings_ = 0u;
}
inline uint32_t LaneAttributesStriping::_internal_roadwaymarkings() const {
  return _impl_.roadwaymarkings_;
}
inline uint32_t LaneAttributesStriping::roadwaymarkings() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributesStriping.roadwayMarkings)
  return _internal_roadwaymarkings();
}
inline void LaneAttributesStriping::_internal_set_roadwaymarkings(uint32_t value) {
  
  _impl_.roadwaymarkings_ = value;
}
inline void LaneAttributesStriping::set_roadwaymarkings(uint32_t value) {
  _internal_set_roadwaymarkings(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneAttributesStriping.roadwayMarkings)
}

// -------------------------------------------------------------------

// LaneAttributesTrackedVehicle

// uint32 trainsAndTrolleys = 1;
inline void LaneAttributesTrackedVehicle::clear_trainsandtrolleys() {
  _impl_.trainsandtrolleys_ = 0u;
}
inline uint32_t LaneAttributesTrackedVehicle::_internal_trainsandtrolleys() const {
  return _impl_.trainsandtrolleys_;
}
inline uint32_t LaneAttributesTrackedVehicle::trainsandtrolleys() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributesTrackedVehicle.trainsAndTrolleys)
  return _internal_trainsandtrolleys();
}
inline void LaneAttributesTrackedVehicle::_internal_set_trainsandtrolleys(uint32_t value) {
  
  _impl_.trainsandtrolleys_ = value;
}
inline void LaneAttributesTrackedVehicle::set_trainsandtrolleys(uint32_t value) {
  _internal_set_trainsandtrolleys(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneAttributesTrackedVehicle.trainsAndTrolleys)
}

// -------------------------------------------------------------------

// LaneAttributesVehicle

// uint32 motorVehicleLanes = 1;
inline void LaneAttributesVehicle::clear_motorvehiclelanes() {
  _impl_.motorvehiclelanes_ = 0u;
}
inline uint32_t LaneAttributesVehicle::_internal_motorvehiclelanes() const {
  return _impl_.motorvehiclelanes_;
}
inline uint32_t LaneAttributesVehicle::motorvehiclelanes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributesVehicle.motorVehicleLanes)
  return _internal_motorvehiclelanes();
}
inline void LaneAttributesVehicle::_internal_set_motorvehiclelanes(uint32_t value) {
  
  _impl_.motorvehiclelanes_ = value;
}
inline void LaneAttributesVehicle::set_motorvehiclelanes(uint32_t value) {
  _internal_set_motorvehiclelanes(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneAttributesVehicle.motorVehicleLanes)
}

// -------------------------------------------------------------------

// LaneTypeAttributes

// .cn.seisys.v2x.pb.LaneAttributesVehicle motorVehicleLanes = 1;
inline bool LaneTypeAttributes::_internal_has_motorvehiclelanes() const {
  return LaneTypeAttributesOneOf_case() == kMotorVehicleLanes;
}
inline bool LaneTypeAttributes::has_motorvehiclelanes() const {
  return _internal_has_motorvehiclelanes();
}
inline void LaneTypeAttributes::set_has_motorvehiclelanes() {
  _impl_._oneof_case_[0] = kMotorVehicleLanes;
}
inline void LaneTypeAttributes::clear_motorvehiclelanes() {
  if (_internal_has_motorvehiclelanes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.LaneTypeAttributesOneOf_.motorvehiclelanes_;
    }
    clear_has_LaneTypeAttributesOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LaneAttributesVehicle* LaneTypeAttributes::release_motorvehiclelanes() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneTypeAttributes.motorVehicleLanes)
  if (_internal_has_motorvehiclelanes()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesVehicle* temp = _impl_.LaneTypeAttributesOneOf_.motorvehiclelanes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.LaneTypeAttributesOneOf_.motorvehiclelanes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LaneAttributesVehicle& LaneTypeAttributes::_internal_motorvehiclelanes() const {
  return _internal_has_motorvehiclelanes()
      ? *_impl_.LaneTypeAttributesOneOf_.motorvehiclelanes_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LaneAttributesVehicle&>(::cn::seisys::v2x::pb::_LaneAttributesVehicle_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributesVehicle& LaneTypeAttributes::motorvehiclelanes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneTypeAttributes.motorVehicleLanes)
  return _internal_motorvehiclelanes();
}
inline ::cn::seisys::v2x::pb::LaneAttributesVehicle* LaneTypeAttributes::unsafe_arena_release_motorvehiclelanes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.LaneTypeAttributes.motorVehicleLanes)
  if (_internal_has_motorvehiclelanes()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesVehicle* temp = _impl_.LaneTypeAttributesOneOf_.motorvehiclelanes_;
    _impl_.LaneTypeAttributesOneOf_.motorvehiclelanes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneTypeAttributes::unsafe_arena_set_allocated_motorvehiclelanes(::cn::seisys::v2x::pb::LaneAttributesVehicle* motorvehiclelanes) {
  clear_LaneTypeAttributesOneOf();
  if (motorvehiclelanes) {
    set_has_motorvehiclelanes();
    _impl_.LaneTypeAttributesOneOf_.motorvehiclelanes_ = motorvehiclelanes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneTypeAttributes.motorVehicleLanes)
}
inline ::cn::seisys::v2x::pb::LaneAttributesVehicle* LaneTypeAttributes::_internal_mutable_motorvehiclelanes() {
  if (!_internal_has_motorvehiclelanes()) {
    clear_LaneTypeAttributesOneOf();
    set_has_motorvehiclelanes();
    _impl_.LaneTypeAttributesOneOf_.motorvehiclelanes_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LaneAttributesVehicle >(GetArenaForAllocation());
  }
  return _impl_.LaneTypeAttributesOneOf_.motorvehiclelanes_;
}
inline ::cn::seisys::v2x::pb::LaneAttributesVehicle* LaneTypeAttributes::mutable_motorvehiclelanes() {
  ::cn::seisys::v2x::pb::LaneAttributesVehicle* _msg = _internal_mutable_motorvehiclelanes();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneTypeAttributes.motorVehicleLanes)
  return _msg;
}

// .cn.seisys.v2x.pb.LaneAttributesCrosswalk pedestrianCrosswalks = 2;
inline bool LaneTypeAttributes::_internal_has_pedestriancrosswalks() const {
  return LaneTypeAttributesOneOf_case() == kPedestrianCrosswalks;
}
inline bool LaneTypeAttributes::has_pedestriancrosswalks() const {
  return _internal_has_pedestriancrosswalks();
}
inline void LaneTypeAttributes::set_has_pedestriancrosswalks() {
  _impl_._oneof_case_[0] = kPedestrianCrosswalks;
}
inline void LaneTypeAttributes::clear_pedestriancrosswalks() {
  if (_internal_has_pedestriancrosswalks()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.LaneTypeAttributesOneOf_.pedestriancrosswalks_;
    }
    clear_has_LaneTypeAttributesOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* LaneTypeAttributes::release_pedestriancrosswalks() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianCrosswalks)
  if (_internal_has_pedestriancrosswalks()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* temp = _impl_.LaneTypeAttributesOneOf_.pedestriancrosswalks_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.LaneTypeAttributesOneOf_.pedestriancrosswalks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LaneAttributesCrosswalk& LaneTypeAttributes::_internal_pedestriancrosswalks() const {
  return _internal_has_pedestriancrosswalks()
      ? *_impl_.LaneTypeAttributesOneOf_.pedestriancrosswalks_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LaneAttributesCrosswalk&>(::cn::seisys::v2x::pb::_LaneAttributesCrosswalk_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributesCrosswalk& LaneTypeAttributes::pedestriancrosswalks() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianCrosswalks)
  return _internal_pedestriancrosswalks();
}
inline ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* LaneTypeAttributes::unsafe_arena_release_pedestriancrosswalks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianCrosswalks)
  if (_internal_has_pedestriancrosswalks()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* temp = _impl_.LaneTypeAttributesOneOf_.pedestriancrosswalks_;
    _impl_.LaneTypeAttributesOneOf_.pedestriancrosswalks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneTypeAttributes::unsafe_arena_set_allocated_pedestriancrosswalks(::cn::seisys::v2x::pb::LaneAttributesCrosswalk* pedestriancrosswalks) {
  clear_LaneTypeAttributesOneOf();
  if (pedestriancrosswalks) {
    set_has_pedestriancrosswalks();
    _impl_.LaneTypeAttributesOneOf_.pedestriancrosswalks_ = pedestriancrosswalks;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianCrosswalks)
}
inline ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* LaneTypeAttributes::_internal_mutable_pedestriancrosswalks() {
  if (!_internal_has_pedestriancrosswalks()) {
    clear_LaneTypeAttributesOneOf();
    set_has_pedestriancrosswalks();
    _impl_.LaneTypeAttributesOneOf_.pedestriancrosswalks_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LaneAttributesCrosswalk >(GetArenaForAllocation());
  }
  return _impl_.LaneTypeAttributesOneOf_.pedestriancrosswalks_;
}
inline ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* LaneTypeAttributes::mutable_pedestriancrosswalks() {
  ::cn::seisys::v2x::pb::LaneAttributesCrosswalk* _msg = _internal_mutable_pedestriancrosswalks();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianCrosswalks)
  return _msg;
}

// .cn.seisys.v2x.pb.LaneAttributesBike bikeLanes = 3;
inline bool LaneTypeAttributes::_internal_has_bikelanes() const {
  return LaneTypeAttributesOneOf_case() == kBikeLanes;
}
inline bool LaneTypeAttributes::has_bikelanes() const {
  return _internal_has_bikelanes();
}
inline void LaneTypeAttributes::set_has_bikelanes() {
  _impl_._oneof_case_[0] = kBikeLanes;
}
inline void LaneTypeAttributes::clear_bikelanes() {
  if (_internal_has_bikelanes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.LaneTypeAttributesOneOf_.bikelanes_;
    }
    clear_has_LaneTypeAttributesOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LaneAttributesBike* LaneTypeAttributes::release_bikelanes() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneTypeAttributes.bikeLanes)
  if (_internal_has_bikelanes()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesBike* temp = _impl_.LaneTypeAttributesOneOf_.bikelanes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.LaneTypeAttributesOneOf_.bikelanes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LaneAttributesBike& LaneTypeAttributes::_internal_bikelanes() const {
  return _internal_has_bikelanes()
      ? *_impl_.LaneTypeAttributesOneOf_.bikelanes_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LaneAttributesBike&>(::cn::seisys::v2x::pb::_LaneAttributesBike_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributesBike& LaneTypeAttributes::bikelanes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneTypeAttributes.bikeLanes)
  return _internal_bikelanes();
}
inline ::cn::seisys::v2x::pb::LaneAttributesBike* LaneTypeAttributes::unsafe_arena_release_bikelanes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.LaneTypeAttributes.bikeLanes)
  if (_internal_has_bikelanes()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesBike* temp = _impl_.LaneTypeAttributesOneOf_.bikelanes_;
    _impl_.LaneTypeAttributesOneOf_.bikelanes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneTypeAttributes::unsafe_arena_set_allocated_bikelanes(::cn::seisys::v2x::pb::LaneAttributesBike* bikelanes) {
  clear_LaneTypeAttributesOneOf();
  if (bikelanes) {
    set_has_bikelanes();
    _impl_.LaneTypeAttributesOneOf_.bikelanes_ = bikelanes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneTypeAttributes.bikeLanes)
}
inline ::cn::seisys::v2x::pb::LaneAttributesBike* LaneTypeAttributes::_internal_mutable_bikelanes() {
  if (!_internal_has_bikelanes()) {
    clear_LaneTypeAttributesOneOf();
    set_has_bikelanes();
    _impl_.LaneTypeAttributesOneOf_.bikelanes_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LaneAttributesBike >(GetArenaForAllocation());
  }
  return _impl_.LaneTypeAttributesOneOf_.bikelanes_;
}
inline ::cn::seisys::v2x::pb::LaneAttributesBike* LaneTypeAttributes::mutable_bikelanes() {
  ::cn::seisys::v2x::pb::LaneAttributesBike* _msg = _internal_mutable_bikelanes();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneTypeAttributes.bikeLanes)
  return _msg;
}

// .cn.seisys.v2x.pb.LaneAttributesSidewalk pedestrianSidewalkPaths = 4;
inline bool LaneTypeAttributes::_internal_has_pedestriansidewalkpaths() const {
  return LaneTypeAttributesOneOf_case() == kPedestrianSidewalkPaths;
}
inline bool LaneTypeAttributes::has_pedestriansidewalkpaths() const {
  return _internal_has_pedestriansidewalkpaths();
}
inline void LaneTypeAttributes::set_has_pedestriansidewalkpaths() {
  _impl_._oneof_case_[0] = kPedestrianSidewalkPaths;
}
inline void LaneTypeAttributes::clear_pedestriansidewalkpaths() {
  if (_internal_has_pedestriansidewalkpaths()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.LaneTypeAttributesOneOf_.pedestriansidewalkpaths_;
    }
    clear_has_LaneTypeAttributesOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LaneAttributesSidewalk* LaneTypeAttributes::release_pedestriansidewalkpaths() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianSidewalkPaths)
  if (_internal_has_pedestriansidewalkpaths()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesSidewalk* temp = _impl_.LaneTypeAttributesOneOf_.pedestriansidewalkpaths_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.LaneTypeAttributesOneOf_.pedestriansidewalkpaths_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LaneAttributesSidewalk& LaneTypeAttributes::_internal_pedestriansidewalkpaths() const {
  return _internal_has_pedestriansidewalkpaths()
      ? *_impl_.LaneTypeAttributesOneOf_.pedestriansidewalkpaths_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LaneAttributesSidewalk&>(::cn::seisys::v2x::pb::_LaneAttributesSidewalk_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributesSidewalk& LaneTypeAttributes::pedestriansidewalkpaths() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianSidewalkPaths)
  return _internal_pedestriansidewalkpaths();
}
inline ::cn::seisys::v2x::pb::LaneAttributesSidewalk* LaneTypeAttributes::unsafe_arena_release_pedestriansidewalkpaths() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianSidewalkPaths)
  if (_internal_has_pedestriansidewalkpaths()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesSidewalk* temp = _impl_.LaneTypeAttributesOneOf_.pedestriansidewalkpaths_;
    _impl_.LaneTypeAttributesOneOf_.pedestriansidewalkpaths_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneTypeAttributes::unsafe_arena_set_allocated_pedestriansidewalkpaths(::cn::seisys::v2x::pb::LaneAttributesSidewalk* pedestriansidewalkpaths) {
  clear_LaneTypeAttributesOneOf();
  if (pedestriansidewalkpaths) {
    set_has_pedestriansidewalkpaths();
    _impl_.LaneTypeAttributesOneOf_.pedestriansidewalkpaths_ = pedestriansidewalkpaths;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianSidewalkPaths)
}
inline ::cn::seisys::v2x::pb::LaneAttributesSidewalk* LaneTypeAttributes::_internal_mutable_pedestriansidewalkpaths() {
  if (!_internal_has_pedestriansidewalkpaths()) {
    clear_LaneTypeAttributesOneOf();
    set_has_pedestriansidewalkpaths();
    _impl_.LaneTypeAttributesOneOf_.pedestriansidewalkpaths_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LaneAttributesSidewalk >(GetArenaForAllocation());
  }
  return _impl_.LaneTypeAttributesOneOf_.pedestriansidewalkpaths_;
}
inline ::cn::seisys::v2x::pb::LaneAttributesSidewalk* LaneTypeAttributes::mutable_pedestriansidewalkpaths() {
  ::cn::seisys::v2x::pb::LaneAttributesSidewalk* _msg = _internal_mutable_pedestriansidewalkpaths();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneTypeAttributes.pedestrianSidewalkPaths)
  return _msg;
}

// .cn.seisys.v2x.pb.LaneAttributesBarrier mediansChannelization = 5;
inline bool LaneTypeAttributes::_internal_has_medianschannelization() const {
  return LaneTypeAttributesOneOf_case() == kMediansChannelization;
}
inline bool LaneTypeAttributes::has_medianschannelization() const {
  return _internal_has_medianschannelization();
}
inline void LaneTypeAttributes::set_has_medianschannelization() {
  _impl_._oneof_case_[0] = kMediansChannelization;
}
inline void LaneTypeAttributes::clear_medianschannelization() {
  if (_internal_has_medianschannelization()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.LaneTypeAttributesOneOf_.medianschannelization_;
    }
    clear_has_LaneTypeAttributesOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LaneAttributesBarrier* LaneTypeAttributes::release_medianschannelization() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneTypeAttributes.mediansChannelization)
  if (_internal_has_medianschannelization()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesBarrier* temp = _impl_.LaneTypeAttributesOneOf_.medianschannelization_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.LaneTypeAttributesOneOf_.medianschannelization_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LaneAttributesBarrier& LaneTypeAttributes::_internal_medianschannelization() const {
  return _internal_has_medianschannelization()
      ? *_impl_.LaneTypeAttributesOneOf_.medianschannelization_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LaneAttributesBarrier&>(::cn::seisys::v2x::pb::_LaneAttributesBarrier_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributesBarrier& LaneTypeAttributes::medianschannelization() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneTypeAttributes.mediansChannelization)
  return _internal_medianschannelization();
}
inline ::cn::seisys::v2x::pb::LaneAttributesBarrier* LaneTypeAttributes::unsafe_arena_release_medianschannelization() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.LaneTypeAttributes.mediansChannelization)
  if (_internal_has_medianschannelization()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesBarrier* temp = _impl_.LaneTypeAttributesOneOf_.medianschannelization_;
    _impl_.LaneTypeAttributesOneOf_.medianschannelization_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneTypeAttributes::unsafe_arena_set_allocated_medianschannelization(::cn::seisys::v2x::pb::LaneAttributesBarrier* medianschannelization) {
  clear_LaneTypeAttributesOneOf();
  if (medianschannelization) {
    set_has_medianschannelization();
    _impl_.LaneTypeAttributesOneOf_.medianschannelization_ = medianschannelization;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneTypeAttributes.mediansChannelization)
}
inline ::cn::seisys::v2x::pb::LaneAttributesBarrier* LaneTypeAttributes::_internal_mutable_medianschannelization() {
  if (!_internal_has_medianschannelization()) {
    clear_LaneTypeAttributesOneOf();
    set_has_medianschannelization();
    _impl_.LaneTypeAttributesOneOf_.medianschannelization_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LaneAttributesBarrier >(GetArenaForAllocation());
  }
  return _impl_.LaneTypeAttributesOneOf_.medianschannelization_;
}
inline ::cn::seisys::v2x::pb::LaneAttributesBarrier* LaneTypeAttributes::mutable_medianschannelization() {
  ::cn::seisys::v2x::pb::LaneAttributesBarrier* _msg = _internal_mutable_medianschannelization();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneTypeAttributes.mediansChannelization)
  return _msg;
}

// .cn.seisys.v2x.pb.LaneAttributesStriping roadwayMarkings = 6;
inline bool LaneTypeAttributes::_internal_has_roadwaymarkings() const {
  return LaneTypeAttributesOneOf_case() == kRoadwayMarkings;
}
inline bool LaneTypeAttributes::has_roadwaymarkings() const {
  return _internal_has_roadwaymarkings();
}
inline void LaneTypeAttributes::set_has_roadwaymarkings() {
  _impl_._oneof_case_[0] = kRoadwayMarkings;
}
inline void LaneTypeAttributes::clear_roadwaymarkings() {
  if (_internal_has_roadwaymarkings()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.LaneTypeAttributesOneOf_.roadwaymarkings_;
    }
    clear_has_LaneTypeAttributesOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LaneAttributesStriping* LaneTypeAttributes::release_roadwaymarkings() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneTypeAttributes.roadwayMarkings)
  if (_internal_has_roadwaymarkings()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesStriping* temp = _impl_.LaneTypeAttributesOneOf_.roadwaymarkings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.LaneTypeAttributesOneOf_.roadwaymarkings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LaneAttributesStriping& LaneTypeAttributes::_internal_roadwaymarkings() const {
  return _internal_has_roadwaymarkings()
      ? *_impl_.LaneTypeAttributesOneOf_.roadwaymarkings_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LaneAttributesStriping&>(::cn::seisys::v2x::pb::_LaneAttributesStriping_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributesStriping& LaneTypeAttributes::roadwaymarkings() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneTypeAttributes.roadwayMarkings)
  return _internal_roadwaymarkings();
}
inline ::cn::seisys::v2x::pb::LaneAttributesStriping* LaneTypeAttributes::unsafe_arena_release_roadwaymarkings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.LaneTypeAttributes.roadwayMarkings)
  if (_internal_has_roadwaymarkings()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesStriping* temp = _impl_.LaneTypeAttributesOneOf_.roadwaymarkings_;
    _impl_.LaneTypeAttributesOneOf_.roadwaymarkings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneTypeAttributes::unsafe_arena_set_allocated_roadwaymarkings(::cn::seisys::v2x::pb::LaneAttributesStriping* roadwaymarkings) {
  clear_LaneTypeAttributesOneOf();
  if (roadwaymarkings) {
    set_has_roadwaymarkings();
    _impl_.LaneTypeAttributesOneOf_.roadwaymarkings_ = roadwaymarkings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneTypeAttributes.roadwayMarkings)
}
inline ::cn::seisys::v2x::pb::LaneAttributesStriping* LaneTypeAttributes::_internal_mutable_roadwaymarkings() {
  if (!_internal_has_roadwaymarkings()) {
    clear_LaneTypeAttributesOneOf();
    set_has_roadwaymarkings();
    _impl_.LaneTypeAttributesOneOf_.roadwaymarkings_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LaneAttributesStriping >(GetArenaForAllocation());
  }
  return _impl_.LaneTypeAttributesOneOf_.roadwaymarkings_;
}
inline ::cn::seisys::v2x::pb::LaneAttributesStriping* LaneTypeAttributes::mutable_roadwaymarkings() {
  ::cn::seisys::v2x::pb::LaneAttributesStriping* _msg = _internal_mutable_roadwaymarkings();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneTypeAttributes.roadwayMarkings)
  return _msg;
}

// .cn.seisys.v2x.pb.LaneAttributesTrackedVehicle trainsAndTrolleys = 7;
inline bool LaneTypeAttributes::_internal_has_trainsandtrolleys() const {
  return LaneTypeAttributesOneOf_case() == kTrainsAndTrolleys;
}
inline bool LaneTypeAttributes::has_trainsandtrolleys() const {
  return _internal_has_trainsandtrolleys();
}
inline void LaneTypeAttributes::set_has_trainsandtrolleys() {
  _impl_._oneof_case_[0] = kTrainsAndTrolleys;
}
inline void LaneTypeAttributes::clear_trainsandtrolleys() {
  if (_internal_has_trainsandtrolleys()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.LaneTypeAttributesOneOf_.trainsandtrolleys_;
    }
    clear_has_LaneTypeAttributesOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* LaneTypeAttributes::release_trainsandtrolleys() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneTypeAttributes.trainsAndTrolleys)
  if (_internal_has_trainsandtrolleys()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* temp = _impl_.LaneTypeAttributesOneOf_.trainsandtrolleys_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.LaneTypeAttributesOneOf_.trainsandtrolleys_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle& LaneTypeAttributes::_internal_trainsandtrolleys() const {
  return _internal_has_trainsandtrolleys()
      ? *_impl_.LaneTypeAttributesOneOf_.trainsandtrolleys_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle&>(::cn::seisys::v2x::pb::_LaneAttributesTrackedVehicle_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle& LaneTypeAttributes::trainsandtrolleys() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneTypeAttributes.trainsAndTrolleys)
  return _internal_trainsandtrolleys();
}
inline ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* LaneTypeAttributes::unsafe_arena_release_trainsandtrolleys() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.LaneTypeAttributes.trainsAndTrolleys)
  if (_internal_has_trainsandtrolleys()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* temp = _impl_.LaneTypeAttributesOneOf_.trainsandtrolleys_;
    _impl_.LaneTypeAttributesOneOf_.trainsandtrolleys_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneTypeAttributes::unsafe_arena_set_allocated_trainsandtrolleys(::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* trainsandtrolleys) {
  clear_LaneTypeAttributesOneOf();
  if (trainsandtrolleys) {
    set_has_trainsandtrolleys();
    _impl_.LaneTypeAttributesOneOf_.trainsandtrolleys_ = trainsandtrolleys;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneTypeAttributes.trainsAndTrolleys)
}
inline ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* LaneTypeAttributes::_internal_mutable_trainsandtrolleys() {
  if (!_internal_has_trainsandtrolleys()) {
    clear_LaneTypeAttributesOneOf();
    set_has_trainsandtrolleys();
    _impl_.LaneTypeAttributesOneOf_.trainsandtrolleys_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle >(GetArenaForAllocation());
  }
  return _impl_.LaneTypeAttributesOneOf_.trainsandtrolleys_;
}
inline ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* LaneTypeAttributes::mutable_trainsandtrolleys() {
  ::cn::seisys::v2x::pb::LaneAttributesTrackedVehicle* _msg = _internal_mutable_trainsandtrolleys();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneTypeAttributes.trainsAndTrolleys)
  return _msg;
}

// .cn.seisys.v2x.pb.LaneAttributesParking parkingAndStoppingLanes = 8;
inline bool LaneTypeAttributes::_internal_has_parkingandstoppinglanes() const {
  return LaneTypeAttributesOneOf_case() == kParkingAndStoppingLanes;
}
inline bool LaneTypeAttributes::has_parkingandstoppinglanes() const {
  return _internal_has_parkingandstoppinglanes();
}
inline void LaneTypeAttributes::set_has_parkingandstoppinglanes() {
  _impl_._oneof_case_[0] = kParkingAndStoppingLanes;
}
inline void LaneTypeAttributes::clear_parkingandstoppinglanes() {
  if (_internal_has_parkingandstoppinglanes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.LaneTypeAttributesOneOf_.parkingandstoppinglanes_;
    }
    clear_has_LaneTypeAttributesOneOf();
  }
}
inline ::cn::seisys::v2x::pb::LaneAttributesParking* LaneTypeAttributes::release_parkingandstoppinglanes() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneTypeAttributes.parkingAndStoppingLanes)
  if (_internal_has_parkingandstoppinglanes()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesParking* temp = _impl_.LaneTypeAttributesOneOf_.parkingandstoppinglanes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.LaneTypeAttributesOneOf_.parkingandstoppinglanes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::LaneAttributesParking& LaneTypeAttributes::_internal_parkingandstoppinglanes() const {
  return _internal_has_parkingandstoppinglanes()
      ? *_impl_.LaneTypeAttributesOneOf_.parkingandstoppinglanes_
      : reinterpret_cast< ::cn::seisys::v2x::pb::LaneAttributesParking&>(::cn::seisys::v2x::pb::_LaneAttributesParking_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributesParking& LaneTypeAttributes::parkingandstoppinglanes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneTypeAttributes.parkingAndStoppingLanes)
  return _internal_parkingandstoppinglanes();
}
inline ::cn::seisys::v2x::pb::LaneAttributesParking* LaneTypeAttributes::unsafe_arena_release_parkingandstoppinglanes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.LaneTypeAttributes.parkingAndStoppingLanes)
  if (_internal_has_parkingandstoppinglanes()) {
    clear_has_LaneTypeAttributesOneOf();
    ::cn::seisys::v2x::pb::LaneAttributesParking* temp = _impl_.LaneTypeAttributesOneOf_.parkingandstoppinglanes_;
    _impl_.LaneTypeAttributesOneOf_.parkingandstoppinglanes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneTypeAttributes::unsafe_arena_set_allocated_parkingandstoppinglanes(::cn::seisys::v2x::pb::LaneAttributesParking* parkingandstoppinglanes) {
  clear_LaneTypeAttributesOneOf();
  if (parkingandstoppinglanes) {
    set_has_parkingandstoppinglanes();
    _impl_.LaneTypeAttributesOneOf_.parkingandstoppinglanes_ = parkingandstoppinglanes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneTypeAttributes.parkingAndStoppingLanes)
}
inline ::cn::seisys::v2x::pb::LaneAttributesParking* LaneTypeAttributes::_internal_mutable_parkingandstoppinglanes() {
  if (!_internal_has_parkingandstoppinglanes()) {
    clear_LaneTypeAttributesOneOf();
    set_has_parkingandstoppinglanes();
    _impl_.LaneTypeAttributesOneOf_.parkingandstoppinglanes_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::LaneAttributesParking >(GetArenaForAllocation());
  }
  return _impl_.LaneTypeAttributesOneOf_.parkingandstoppinglanes_;
}
inline ::cn::seisys::v2x::pb::LaneAttributesParking* LaneTypeAttributes::mutable_parkingandstoppinglanes() {
  ::cn::seisys::v2x::pb::LaneAttributesParking* _msg = _internal_mutable_parkingandstoppinglanes();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneTypeAttributes.parkingAndStoppingLanes)
  return _msg;
}

inline bool LaneTypeAttributes::has_LaneTypeAttributesOneOf() const {
  return LaneTypeAttributesOneOf_case() != LANETYPEATTRIBUTESONEOF_NOT_SET;
}
inline void LaneTypeAttributes::clear_has_LaneTypeAttributesOneOf() {
  _impl_._oneof_case_[0] = LANETYPEATTRIBUTESONEOF_NOT_SET;
}
inline LaneTypeAttributes::LaneTypeAttributesOneOfCase LaneTypeAttributes::LaneTypeAttributesOneOf_case() const {
  return LaneTypeAttributes::LaneTypeAttributesOneOfCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LaneSharing

// uint32 shareWith = 1;
inline void LaneSharing::clear_sharewith() {
  _impl_.sharewith_ = 0u;
}
inline uint32_t LaneSharing::_internal_sharewith() const {
  return _impl_.sharewith_;
}
inline uint32_t LaneSharing::sharewith() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneSharing.shareWith)
  return _internal_sharewith();
}
inline void LaneSharing::_internal_set_sharewith(uint32_t value) {
  
  _impl_.sharewith_ = value;
}
inline void LaneSharing::set_sharewith(uint32_t value) {
  _internal_set_sharewith(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneSharing.shareWith)
}

// -------------------------------------------------------------------

// LaneType

// uint32 choiceId = 1;
inline void LaneType::clear_choiceid() {
  _impl_.choiceid_ = 0u;
}
inline uint32_t LaneType::_internal_choiceid() const {
  return _impl_.choiceid_;
}
inline uint32_t LaneType::choiceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneType.choiceId)
  return _internal_choiceid();
}
inline void LaneType::_internal_set_choiceid(uint32_t value) {
  
  _impl_.choiceid_ = value;
}
inline void LaneType::set_choiceid(uint32_t value) {
  _internal_set_choiceid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneType.choiceId)
}

// .cn.seisys.v2x.pb.LaneTypeAttributes value = 2;
inline bool LaneType::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool LaneType::has_value() const {
  return _internal_has_value();
}
inline void LaneType::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LaneTypeAttributes& LaneType::_internal_value() const {
  const ::cn::seisys::v2x::pb::LaneTypeAttributes* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LaneTypeAttributes&>(
      ::cn::seisys::v2x::pb::_LaneTypeAttributes_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneTypeAttributes& LaneType::value() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneType.value)
  return _internal_value();
}
inline void LaneType::unsafe_arena_set_allocated_value(
    ::cn::seisys::v2x::pb::LaneTypeAttributes* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneType.value)
}
inline ::cn::seisys::v2x::pb::LaneTypeAttributes* LaneType::release_value() {
  
  ::cn::seisys::v2x::pb::LaneTypeAttributes* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneTypeAttributes* LaneType::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneType.value)
  
  ::cn::seisys::v2x::pb::LaneTypeAttributes* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneTypeAttributes* LaneType::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LaneTypeAttributes>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::cn::seisys::v2x::pb::LaneTypeAttributes* LaneType::mutable_value() {
  ::cn::seisys::v2x::pb::LaneTypeAttributes* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneType.value)
  return _msg;
}
inline void LaneType::set_allocated_value(::cn::seisys::v2x::pb::LaneTypeAttributes* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneType.value)
}

// -------------------------------------------------------------------

// LaneAttributes

// .cn.seisys.v2x.pb.LaneSharing shareWith = 1;
inline bool LaneAttributes::_internal_has_sharewith() const {
  return this != internal_default_instance() && _impl_.sharewith_ != nullptr;
}
inline bool LaneAttributes::has_sharewith() const {
  return _internal_has_sharewith();
}
inline void LaneAttributes::clear_sharewith() {
  if (GetArenaForAllocation() == nullptr && _impl_.sharewith_ != nullptr) {
    delete _impl_.sharewith_;
  }
  _impl_.sharewith_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LaneSharing& LaneAttributes::_internal_sharewith() const {
  const ::cn::seisys::v2x::pb::LaneSharing* p = _impl_.sharewith_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LaneSharing&>(
      ::cn::seisys::v2x::pb::_LaneSharing_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneSharing& LaneAttributes::sharewith() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributes.shareWith)
  return _internal_sharewith();
}
inline void LaneAttributes::unsafe_arena_set_allocated_sharewith(
    ::cn::seisys::v2x::pb::LaneSharing* sharewith) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sharewith_);
  }
  _impl_.sharewith_ = sharewith;
  if (sharewith) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneAttributes.shareWith)
}
inline ::cn::seisys::v2x::pb::LaneSharing* LaneAttributes::release_sharewith() {
  
  ::cn::seisys::v2x::pb::LaneSharing* temp = _impl_.sharewith_;
  _impl_.sharewith_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneSharing* LaneAttributes::unsafe_arena_release_sharewith() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneAttributes.shareWith)
  
  ::cn::seisys::v2x::pb::LaneSharing* temp = _impl_.sharewith_;
  _impl_.sharewith_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneSharing* LaneAttributes::_internal_mutable_sharewith() {
  
  if (_impl_.sharewith_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LaneSharing>(GetArenaForAllocation());
    _impl_.sharewith_ = p;
  }
  return _impl_.sharewith_;
}
inline ::cn::seisys::v2x::pb::LaneSharing* LaneAttributes::mutable_sharewith() {
  ::cn::seisys::v2x::pb::LaneSharing* _msg = _internal_mutable_sharewith();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneAttributes.shareWith)
  return _msg;
}
inline void LaneAttributes::set_allocated_sharewith(::cn::seisys::v2x::pb::LaneSharing* sharewith) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sharewith_;
  }
  if (sharewith) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sharewith);
    if (message_arena != submessage_arena) {
      sharewith = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sharewith, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sharewith_ = sharewith;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneAttributes.shareWith)
}

// .cn.seisys.v2x.pb.LaneType laneType = 2;
inline bool LaneAttributes::_internal_has_lanetype() const {
  return this != internal_default_instance() && _impl_.lanetype_ != nullptr;
}
inline bool LaneAttributes::has_lanetype() const {
  return _internal_has_lanetype();
}
inline void LaneAttributes::clear_lanetype() {
  if (GetArenaForAllocation() == nullptr && _impl_.lanetype_ != nullptr) {
    delete _impl_.lanetype_;
  }
  _impl_.lanetype_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LaneType& LaneAttributes::_internal_lanetype() const {
  const ::cn::seisys::v2x::pb::LaneType* p = _impl_.lanetype_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LaneType&>(
      ::cn::seisys::v2x::pb::_LaneType_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneType& LaneAttributes::lanetype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneAttributes.laneType)
  return _internal_lanetype();
}
inline void LaneAttributes::unsafe_arena_set_allocated_lanetype(
    ::cn::seisys::v2x::pb::LaneType* lanetype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lanetype_);
  }
  _impl_.lanetype_ = lanetype;
  if (lanetype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneAttributes.laneType)
}
inline ::cn::seisys::v2x::pb::LaneType* LaneAttributes::release_lanetype() {
  
  ::cn::seisys::v2x::pb::LaneType* temp = _impl_.lanetype_;
  _impl_.lanetype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneType* LaneAttributes::unsafe_arena_release_lanetype() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneAttributes.laneType)
  
  ::cn::seisys::v2x::pb::LaneType* temp = _impl_.lanetype_;
  _impl_.lanetype_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneType* LaneAttributes::_internal_mutable_lanetype() {
  
  if (_impl_.lanetype_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LaneType>(GetArenaForAllocation());
    _impl_.lanetype_ = p;
  }
  return _impl_.lanetype_;
}
inline ::cn::seisys::v2x::pb::LaneType* LaneAttributes::mutable_lanetype() {
  ::cn::seisys::v2x::pb::LaneType* _msg = _internal_mutable_lanetype();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneAttributes.laneType)
  return _msg;
}
inline void LaneAttributes::set_allocated_lanetype(::cn::seisys::v2x::pb::LaneType* lanetype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lanetype_;
  }
  if (lanetype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lanetype);
    if (message_arena != submessage_arena) {
      lanetype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lanetype, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lanetype_ = lanetype;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneAttributes.laneType)
}

// -------------------------------------------------------------------

// LaneBoundary

// uint32 laneBoundaryType = 1;
inline void LaneBoundary::clear_laneboundarytype() {
  _impl_.laneboundarytype_ = 0u;
}
inline uint32_t LaneBoundary::_internal_laneboundarytype() const {
  return _impl_.laneboundarytype_;
}
inline uint32_t LaneBoundary::laneboundarytype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneBoundary.laneBoundaryType)
  return _internal_laneboundarytype();
}
inline void LaneBoundary::_internal_set_laneboundarytype(uint32_t value) {
  
  _impl_.laneboundarytype_ = value;
}
inline void LaneBoundary::set_laneboundarytype(uint32_t value) {
  _internal_set_laneboundarytype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneBoundary.laneBoundaryType)
}

// repeated .cn.seisys.v2x.pb.Position3D laneBoundaryPoints = 2;
inline int LaneBoundary::_internal_laneboundarypoints_size() const {
  return _impl_.laneboundarypoints_.size();
}
inline int LaneBoundary::laneboundarypoints_size() const {
  return _internal_laneboundarypoints_size();
}
inline void LaneBoundary::clear_laneboundarypoints() {
  _impl_.laneboundarypoints_.Clear();
}
inline ::cn::seisys::v2x::pb::Position3D* LaneBoundary::mutable_laneboundarypoints(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneBoundary.laneBoundaryPoints)
  return _impl_.laneboundarypoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
LaneBoundary::mutable_laneboundarypoints() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LaneBoundary.laneBoundaryPoints)
  return &_impl_.laneboundarypoints_;
}
inline const ::cn::seisys::v2x::pb::Position3D& LaneBoundary::_internal_laneboundarypoints(int index) const {
  return _impl_.laneboundarypoints_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Position3D& LaneBoundary::laneboundarypoints(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneBoundary.laneBoundaryPoints)
  return _internal_laneboundarypoints(index);
}
inline ::cn::seisys::v2x::pb::Position3D* LaneBoundary::_internal_add_laneboundarypoints() {
  return _impl_.laneboundarypoints_.Add();
}
inline ::cn::seisys::v2x::pb::Position3D* LaneBoundary::add_laneboundarypoints() {
  ::cn::seisys::v2x::pb::Position3D* _add = _internal_add_laneboundarypoints();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LaneBoundary.laneBoundaryPoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
LaneBoundary::laneboundarypoints() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LaneBoundary.laneBoundaryPoints)
  return _impl_.laneboundarypoints_;
}

// -------------------------------------------------------------------

// Lane

// uint32 laneId = 1;
inline void Lane::clear_laneid() {
  _impl_.laneid_ = 0u;
}
inline uint32_t Lane::_internal_laneid() const {
  return _impl_.laneid_;
}
inline uint32_t Lane::laneid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Lane.laneId)
  return _internal_laneid();
}
inline void Lane::_internal_set_laneid(uint32_t value) {
  
  _impl_.laneid_ = value;
}
inline void Lane::set_laneid(uint32_t value) {
  _internal_set_laneid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Lane.laneId)
}

// uint32 laneWidth = 2;
inline void Lane::clear_lanewidth() {
  _impl_.lanewidth_ = 0u;
}
inline uint32_t Lane::_internal_lanewidth() const {
  return _impl_.lanewidth_;
}
inline uint32_t Lane::lanewidth() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Lane.laneWidth)
  return _internal_lanewidth();
}
inline void Lane::_internal_set_lanewidth(uint32_t value) {
  
  _impl_.lanewidth_ = value;
}
inline void Lane::set_lanewidth(uint32_t value) {
  _internal_set_lanewidth(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Lane.laneWidth)
}

// .cn.seisys.v2x.pb.LaneAttributes laneAttributes = 3;
inline bool Lane::_internal_has_laneattributes() const {
  return this != internal_default_instance() && _impl_.laneattributes_ != nullptr;
}
inline bool Lane::has_laneattributes() const {
  return _internal_has_laneattributes();
}
inline void Lane::clear_laneattributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.laneattributes_ != nullptr) {
    delete _impl_.laneattributes_;
  }
  _impl_.laneattributes_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LaneAttributes& Lane::_internal_laneattributes() const {
  const ::cn::seisys::v2x::pb::LaneAttributes* p = _impl_.laneattributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LaneAttributes&>(
      ::cn::seisys::v2x::pb::_LaneAttributes_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributes& Lane::laneattributes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Lane.laneAttributes)
  return _internal_laneattributes();
}
inline void Lane::unsafe_arena_set_allocated_laneattributes(
    ::cn::seisys::v2x::pb::LaneAttributes* laneattributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.laneattributes_);
  }
  _impl_.laneattributes_ = laneattributes;
  if (laneattributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.Lane.laneAttributes)
}
inline ::cn::seisys::v2x::pb::LaneAttributes* Lane::release_laneattributes() {
  
  ::cn::seisys::v2x::pb::LaneAttributes* temp = _impl_.laneattributes_;
  _impl_.laneattributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneAttributes* Lane::unsafe_arena_release_laneattributes() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Lane.laneAttributes)
  
  ::cn::seisys::v2x::pb::LaneAttributes* temp = _impl_.laneattributes_;
  _impl_.laneattributes_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneAttributes* Lane::_internal_mutable_laneattributes() {
  
  if (_impl_.laneattributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributes>(GetArenaForAllocation());
    _impl_.laneattributes_ = p;
  }
  return _impl_.laneattributes_;
}
inline ::cn::seisys::v2x::pb::LaneAttributes* Lane::mutable_laneattributes() {
  ::cn::seisys::v2x::pb::LaneAttributes* _msg = _internal_mutable_laneattributes();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Lane.laneAttributes)
  return _msg;
}
inline void Lane::set_allocated_laneattributes(::cn::seisys::v2x::pb::LaneAttributes* laneattributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.laneattributes_;
  }
  if (laneattributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(laneattributes);
    if (message_arena != submessage_arena) {
      laneattributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, laneattributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.laneattributes_ = laneattributes;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Lane.laneAttributes)
}

// .cn.seisys.v2x.pb.AllowedManeuvers maneuvers = 4;
inline bool Lane::_internal_has_maneuvers() const {
  return this != internal_default_instance() && _impl_.maneuvers_ != nullptr;
}
inline bool Lane::has_maneuvers() const {
  return _internal_has_maneuvers();
}
inline void Lane::clear_maneuvers() {
  if (GetArenaForAllocation() == nullptr && _impl_.maneuvers_ != nullptr) {
    delete _impl_.maneuvers_;
  }
  _impl_.maneuvers_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::AllowedManeuvers& Lane::_internal_maneuvers() const {
  const ::cn::seisys::v2x::pb::AllowedManeuvers* p = _impl_.maneuvers_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::AllowedManeuvers&>(
      ::cn::seisys::v2x::pb::_AllowedManeuvers_default_instance_);
}
inline const ::cn::seisys::v2x::pb::AllowedManeuvers& Lane::maneuvers() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Lane.maneuvers)
  return _internal_maneuvers();
}
inline void Lane::unsafe_arena_set_allocated_maneuvers(
    ::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maneuvers_);
  }
  _impl_.maneuvers_ = maneuvers;
  if (maneuvers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.Lane.maneuvers)
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* Lane::release_maneuvers() {
  
  ::cn::seisys::v2x::pb::AllowedManeuvers* temp = _impl_.maneuvers_;
  _impl_.maneuvers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* Lane::unsafe_arena_release_maneuvers() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Lane.maneuvers)
  
  ::cn::seisys::v2x::pb::AllowedManeuvers* temp = _impl_.maneuvers_;
  _impl_.maneuvers_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* Lane::_internal_mutable_maneuvers() {
  
  if (_impl_.maneuvers_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::AllowedManeuvers>(GetArenaForAllocation());
    _impl_.maneuvers_ = p;
  }
  return _impl_.maneuvers_;
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* Lane::mutable_maneuvers() {
  ::cn::seisys::v2x::pb::AllowedManeuvers* _msg = _internal_mutable_maneuvers();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Lane.maneuvers)
  return _msg;
}
inline void Lane::set_allocated_maneuvers(::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.maneuvers_;
  }
  if (maneuvers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maneuvers);
    if (message_arena != submessage_arena) {
      maneuvers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maneuvers, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.maneuvers_ = maneuvers;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Lane.maneuvers)
}

// repeated .cn.seisys.v2x.pb.Connection connectsTo = 5;
inline int Lane::_internal_connectsto_size() const {
  return _impl_.connectsto_.size();
}
inline int Lane::connectsto_size() const {
  return _internal_connectsto_size();
}
inline void Lane::clear_connectsto() {
  _impl_.connectsto_.Clear();
}
inline ::cn::seisys::v2x::pb::Connection* Lane::mutable_connectsto(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Lane.connectsTo)
  return _impl_.connectsto_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Connection >*
Lane::mutable_connectsto() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Lane.connectsTo)
  return &_impl_.connectsto_;
}
inline const ::cn::seisys::v2x::pb::Connection& Lane::_internal_connectsto(int index) const {
  return _impl_.connectsto_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Connection& Lane::connectsto(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Lane.connectsTo)
  return _internal_connectsto(index);
}
inline ::cn::seisys::v2x::pb::Connection* Lane::_internal_add_connectsto() {
  return _impl_.connectsto_.Add();
}
inline ::cn::seisys::v2x::pb::Connection* Lane::add_connectsto() {
  ::cn::seisys::v2x::pb::Connection* _add = _internal_add_connectsto();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Lane.connectsTo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Connection >&
Lane::connectsto() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Lane.connectsTo)
  return _impl_.connectsto_;
}

// repeated .cn.seisys.v2x.pb.RegulatorySpeedLimit speedLimits = 6;
inline int Lane::_internal_speedlimits_size() const {
  return _impl_.speedlimits_.size();
}
inline int Lane::speedlimits_size() const {
  return _internal_speedlimits_size();
}
inline void Lane::clear_speedlimits() {
  _impl_.speedlimits_.Clear();
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* Lane::mutable_speedlimits(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Lane.speedLimits)
  return _impl_.speedlimits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >*
Lane::mutable_speedlimits() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Lane.speedLimits)
  return &_impl_.speedlimits_;
}
inline const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& Lane::_internal_speedlimits(int index) const {
  return _impl_.speedlimits_.Get(index);
}
inline const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& Lane::speedlimits(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Lane.speedLimits)
  return _internal_speedlimits(index);
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* Lane::_internal_add_speedlimits() {
  return _impl_.speedlimits_.Add();
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* Lane::add_speedlimits() {
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* _add = _internal_add_speedlimits();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Lane.speedLimits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >&
Lane::speedlimits() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Lane.speedLimits)
  return _impl_.speedlimits_;
}

// repeated .cn.seisys.v2x.pb.Position3D points = 7;
inline int Lane::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int Lane::points_size() const {
  return _internal_points_size();
}
inline void Lane::clear_points() {
  _impl_.points_.Clear();
}
inline ::cn::seisys::v2x::pb::Position3D* Lane::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Lane.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
Lane::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Lane.points)
  return &_impl_.points_;
}
inline const ::cn::seisys::v2x::pb::Position3D& Lane::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Position3D& Lane::points(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Lane.points)
  return _internal_points(index);
}
inline ::cn::seisys::v2x::pb::Position3D* Lane::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::cn::seisys::v2x::pb::Position3D* Lane::add_points() {
  ::cn::seisys::v2x::pb::Position3D* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Lane.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
Lane::points() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Lane.points)
  return _impl_.points_;
}

// repeated .cn.seisys.v2x.pb.LaneBoundary leftBoundary = 8;
inline int Lane::_internal_leftboundary_size() const {
  return _impl_.leftboundary_.size();
}
inline int Lane::leftboundary_size() const {
  return _internal_leftboundary_size();
}
inline void Lane::clear_leftboundary() {
  _impl_.leftboundary_.Clear();
}
inline ::cn::seisys::v2x::pb::LaneBoundary* Lane::mutable_leftboundary(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Lane.leftBoundary)
  return _impl_.leftboundary_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >*
Lane::mutable_leftboundary() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Lane.leftBoundary)
  return &_impl_.leftboundary_;
}
inline const ::cn::seisys::v2x::pb::LaneBoundary& Lane::_internal_leftboundary(int index) const {
  return _impl_.leftboundary_.Get(index);
}
inline const ::cn::seisys::v2x::pb::LaneBoundary& Lane::leftboundary(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Lane.leftBoundary)
  return _internal_leftboundary(index);
}
inline ::cn::seisys::v2x::pb::LaneBoundary* Lane::_internal_add_leftboundary() {
  return _impl_.leftboundary_.Add();
}
inline ::cn::seisys::v2x::pb::LaneBoundary* Lane::add_leftboundary() {
  ::cn::seisys::v2x::pb::LaneBoundary* _add = _internal_add_leftboundary();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Lane.leftBoundary)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >&
Lane::leftboundary() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Lane.leftBoundary)
  return _impl_.leftboundary_;
}

// repeated .cn.seisys.v2x.pb.LaneBoundary rightBoundary = 9;
inline int Lane::_internal_rightboundary_size() const {
  return _impl_.rightboundary_.size();
}
inline int Lane::rightboundary_size() const {
  return _internal_rightboundary_size();
}
inline void Lane::clear_rightboundary() {
  _impl_.rightboundary_.Clear();
}
inline ::cn::seisys::v2x::pb::LaneBoundary* Lane::mutable_rightboundary(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Lane.rightBoundary)
  return _impl_.rightboundary_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >*
Lane::mutable_rightboundary() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Lane.rightBoundary)
  return &_impl_.rightboundary_;
}
inline const ::cn::seisys::v2x::pb::LaneBoundary& Lane::_internal_rightboundary(int index) const {
  return _impl_.rightboundary_.Get(index);
}
inline const ::cn::seisys::v2x::pb::LaneBoundary& Lane::rightboundary(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Lane.rightBoundary)
  return _internal_rightboundary(index);
}
inline ::cn::seisys::v2x::pb::LaneBoundary* Lane::_internal_add_rightboundary() {
  return _impl_.rightboundary_.Add();
}
inline ::cn::seisys::v2x::pb::LaneBoundary* Lane::add_rightboundary() {
  ::cn::seisys::v2x::pb::LaneBoundary* _add = _internal_add_rightboundary();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Lane.rightBoundary)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >&
Lane::rightboundary() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Lane.rightBoundary)
  return _impl_.rightboundary_;
}

// -------------------------------------------------------------------

// SignalWaitingLane

// int32 laneWidth = 1;
inline void SignalWaitingLane::clear_lanewidth() {
  _impl_.lanewidth_ = 0;
}
inline int32_t SignalWaitingLane::_internal_lanewidth() const {
  return _impl_.lanewidth_;
}
inline int32_t SignalWaitingLane::lanewidth() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalWaitingLane.laneWidth)
  return _internal_lanewidth();
}
inline void SignalWaitingLane::_internal_set_lanewidth(int32_t value) {
  
  _impl_.lanewidth_ = value;
}
inline void SignalWaitingLane::set_lanewidth(int32_t value) {
  _internal_set_lanewidth(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.SignalWaitingLane.laneWidth)
}

// .cn.seisys.v2x.pb.Position3D points = 2;
inline bool SignalWaitingLane::_internal_has_points() const {
  return this != internal_default_instance() && _impl_.points_ != nullptr;
}
inline bool SignalWaitingLane::has_points() const {
  return _internal_has_points();
}
inline void SignalWaitingLane::clear_points() {
  if (GetArenaForAllocation() == nullptr && _impl_.points_ != nullptr) {
    delete _impl_.points_;
  }
  _impl_.points_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& SignalWaitingLane::_internal_points() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& SignalWaitingLane::points() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalWaitingLane.points)
  return _internal_points();
}
inline void SignalWaitingLane::unsafe_arena_set_allocated_points(
    ::cn::seisys::v2x::pb::Position3D* points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = points;
  if (points) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.SignalWaitingLane.points)
}
inline ::cn::seisys::v2x::pb::Position3D* SignalWaitingLane::release_points() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.points_;
  _impl_.points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* SignalWaitingLane::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.SignalWaitingLane.points)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* SignalWaitingLane::_internal_mutable_points() {
  
  if (_impl_.points_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.points_ = p;
  }
  return _impl_.points_;
}
inline ::cn::seisys::v2x::pb::Position3D* SignalWaitingLane::mutable_points() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.SignalWaitingLane.points)
  return _msg;
}
inline void SignalWaitingLane::set_allocated_points(::cn::seisys::v2x::pb::Position3D* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.points_;
  }
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(points);
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.points_ = points;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.SignalWaitingLane.points)
}

// repeated .cn.seisys.v2x.pb.PhaseId allowedPhaseIds = 3;
inline int SignalWaitingLane::_internal_allowedphaseids_size() const {
  return _impl_.allowedphaseids_.size();
}
inline int SignalWaitingLane::allowedphaseids_size() const {
  return _internal_allowedphaseids_size();
}
inline void SignalWaitingLane::clear_allowedphaseids() {
  _impl_.allowedphaseids_.Clear();
}
inline ::cn::seisys::v2x::pb::PhaseId* SignalWaitingLane::mutable_allowedphaseids(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.SignalWaitingLane.allowedPhaseIds)
  return _impl_.allowedphaseids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseId >*
SignalWaitingLane::mutable_allowedphaseids() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.SignalWaitingLane.allowedPhaseIds)
  return &_impl_.allowedphaseids_;
}
inline const ::cn::seisys::v2x::pb::PhaseId& SignalWaitingLane::_internal_allowedphaseids(int index) const {
  return _impl_.allowedphaseids_.Get(index);
}
inline const ::cn::seisys::v2x::pb::PhaseId& SignalWaitingLane::allowedphaseids(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.SignalWaitingLane.allowedPhaseIds)
  return _internal_allowedphaseids(index);
}
inline ::cn::seisys::v2x::pb::PhaseId* SignalWaitingLane::_internal_add_allowedphaseids() {
  return _impl_.allowedphaseids_.Add();
}
inline ::cn::seisys::v2x::pb::PhaseId* SignalWaitingLane::add_allowedphaseids() {
  ::cn::seisys::v2x::pb::PhaseId* _add = _internal_add_allowedphaseids();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.SignalWaitingLane.allowedPhaseIds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PhaseId >&
SignalWaitingLane::allowedphaseids() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.SignalWaitingLane.allowedPhaseIds)
  return _impl_.allowedphaseids_;
}

// -------------------------------------------------------------------

// ConnectingLaneEx

// int32 targetSection = 1;
inline void ConnectingLaneEx::clear_targetsection() {
  _impl_.targetsection_ = 0;
}
inline int32_t ConnectingLaneEx::_internal_targetsection() const {
  return _impl_.targetsection_;
}
inline int32_t ConnectingLaneEx::targetsection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectingLaneEx.targetSection)
  return _internal_targetsection();
}
inline void ConnectingLaneEx::_internal_set_targetsection(int32_t value) {
  
  _impl_.targetsection_ = value;
}
inline void ConnectingLaneEx::set_targetsection(int32_t value) {
  _internal_set_targetsection(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ConnectingLaneEx.targetSection)
}

// int32 targetLane = 2;
inline void ConnectingLaneEx::clear_targetlane() {
  _impl_.targetlane_ = 0;
}
inline int32_t ConnectingLaneEx::_internal_targetlane() const {
  return _impl_.targetlane_;
}
inline int32_t ConnectingLaneEx::targetlane() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectingLaneEx.targetLane)
  return _internal_targetlane();
}
inline void ConnectingLaneEx::_internal_set_targetlane(int32_t value) {
  
  _impl_.targetlane_ = value;
}
inline void ConnectingLaneEx::set_targetlane(int32_t value) {
  _internal_set_targetlane(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ConnectingLaneEx.targetLane)
}

// int32 connectingLaneWidth = 3;
inline void ConnectingLaneEx::clear_connectinglanewidth() {
  _impl_.connectinglanewidth_ = 0;
}
inline int32_t ConnectingLaneEx::_internal_connectinglanewidth() const {
  return _impl_.connectinglanewidth_;
}
inline int32_t ConnectingLaneEx::connectinglanewidth() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectingLaneEx.connectingLaneWidth)
  return _internal_connectinglanewidth();
}
inline void ConnectingLaneEx::_internal_set_connectinglanewidth(int32_t value) {
  
  _impl_.connectinglanewidth_ = value;
}
inline void ConnectingLaneEx::set_connectinglanewidth(int32_t value) {
  _internal_set_connectinglanewidth(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ConnectingLaneEx.connectingLaneWidth)
}

// .cn.seisys.v2x.pb.Position3D connectingLanePoints = 4;
inline bool ConnectingLaneEx::_internal_has_connectinglanepoints() const {
  return this != internal_default_instance() && _impl_.connectinglanepoints_ != nullptr;
}
inline bool ConnectingLaneEx::has_connectinglanepoints() const {
  return _internal_has_connectinglanepoints();
}
inline void ConnectingLaneEx::clear_connectinglanepoints() {
  if (GetArenaForAllocation() == nullptr && _impl_.connectinglanepoints_ != nullptr) {
    delete _impl_.connectinglanepoints_;
  }
  _impl_.connectinglanepoints_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& ConnectingLaneEx::_internal_connectinglanepoints() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.connectinglanepoints_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& ConnectingLaneEx::connectinglanepoints() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectingLaneEx.connectingLanePoints)
  return _internal_connectinglanepoints();
}
inline void ConnectingLaneEx::unsafe_arena_set_allocated_connectinglanepoints(
    ::cn::seisys::v2x::pb::Position3D* connectinglanepoints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connectinglanepoints_);
  }
  _impl_.connectinglanepoints_ = connectinglanepoints;
  if (connectinglanepoints) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ConnectingLaneEx.connectingLanePoints)
}
inline ::cn::seisys::v2x::pb::Position3D* ConnectingLaneEx::release_connectinglanepoints() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.connectinglanepoints_;
  _impl_.connectinglanepoints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* ConnectingLaneEx::unsafe_arena_release_connectinglanepoints() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ConnectingLaneEx.connectingLanePoints)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.connectinglanepoints_;
  _impl_.connectinglanepoints_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* ConnectingLaneEx::_internal_mutable_connectinglanepoints() {
  
  if (_impl_.connectinglanepoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.connectinglanepoints_ = p;
  }
  return _impl_.connectinglanepoints_;
}
inline ::cn::seisys::v2x::pb::Position3D* ConnectingLaneEx::mutable_connectinglanepoints() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_connectinglanepoints();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ConnectingLaneEx.connectingLanePoints)
  return _msg;
}
inline void ConnectingLaneEx::set_allocated_connectinglanepoints(::cn::seisys::v2x::pb::Position3D* connectinglanepoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connectinglanepoints_;
  }
  if (connectinglanepoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connectinglanepoints);
    if (message_arena != submessage_arena) {
      connectinglanepoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connectinglanepoints, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.connectinglanepoints_ = connectinglanepoints;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ConnectingLaneEx.connectingLanePoints)
}

// bool isolatedConnectingLane = 5;
inline void ConnectingLaneEx::clear_isolatedconnectinglane() {
  _impl_.isolatedconnectinglane_ = false;
}
inline bool ConnectingLaneEx::_internal_isolatedconnectinglane() const {
  return _impl_.isolatedconnectinglane_;
}
inline bool ConnectingLaneEx::isolatedconnectinglane() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectingLaneEx.isolatedConnectingLane)
  return _internal_isolatedconnectinglane();
}
inline void ConnectingLaneEx::_internal_set_isolatedconnectinglane(bool value) {
  
  _impl_.isolatedconnectinglane_ = value;
}
inline void ConnectingLaneEx::set_isolatedconnectinglane(bool value) {
  _internal_set_isolatedconnectinglane(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ConnectingLaneEx.isolatedConnectingLane)
}

// -------------------------------------------------------------------

// ConnectionEx

// .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
inline bool ConnectionEx::_internal_has_remoteintersection() const {
  return this != internal_default_instance() && _impl_.remoteintersection_ != nullptr;
}
inline bool ConnectionEx::has_remoteintersection() const {
  return _internal_has_remoteintersection();
}
inline void ConnectionEx::clear_remoteintersection() {
  if (GetArenaForAllocation() == nullptr && _impl_.remoteintersection_ != nullptr) {
    delete _impl_.remoteintersection_;
  }
  _impl_.remoteintersection_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ConnectionEx::_internal_remoteintersection() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.remoteintersection_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ConnectionEx::remoteintersection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectionEx.remoteIntersection)
  return _internal_remoteintersection();
}
inline void ConnectionEx::unsafe_arena_set_allocated_remoteintersection(
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remoteintersection_);
  }
  _impl_.remoteintersection_ = remoteintersection;
  if (remoteintersection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ConnectionEx.remoteIntersection)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ConnectionEx::release_remoteintersection() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ConnectionEx::unsafe_arena_release_remoteintersection() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ConnectionEx.remoteIntersection)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ConnectionEx::_internal_mutable_remoteintersection() {
  
  if (_impl_.remoteintersection_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.remoteintersection_ = p;
  }
  return _impl_.remoteintersection_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ConnectionEx::mutable_remoteintersection() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_remoteintersection();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ConnectionEx.remoteIntersection)
  return _msg;
}
inline void ConnectionEx::set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remoteintersection_;
  }
  if (remoteintersection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remoteintersection);
    if (message_arena != submessage_arena) {
      remoteintersection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remoteintersection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remoteintersection_ = remoteintersection;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ConnectionEx.remoteIntersection)
}

// .cn.seisys.v2x.pb.SignalWaitingLane swl = 2;
inline bool ConnectionEx::_internal_has_swl() const {
  return this != internal_default_instance() && _impl_.swl_ != nullptr;
}
inline bool ConnectionEx::has_swl() const {
  return _internal_has_swl();
}
inline void ConnectionEx::clear_swl() {
  if (GetArenaForAllocation() == nullptr && _impl_.swl_ != nullptr) {
    delete _impl_.swl_;
  }
  _impl_.swl_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::SignalWaitingLane& ConnectionEx::_internal_swl() const {
  const ::cn::seisys::v2x::pb::SignalWaitingLane* p = _impl_.swl_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::SignalWaitingLane&>(
      ::cn::seisys::v2x::pb::_SignalWaitingLane_default_instance_);
}
inline const ::cn::seisys::v2x::pb::SignalWaitingLane& ConnectionEx::swl() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectionEx.swl)
  return _internal_swl();
}
inline void ConnectionEx::unsafe_arena_set_allocated_swl(
    ::cn::seisys::v2x::pb::SignalWaitingLane* swl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.swl_);
  }
  _impl_.swl_ = swl;
  if (swl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ConnectionEx.swl)
}
inline ::cn::seisys::v2x::pb::SignalWaitingLane* ConnectionEx::release_swl() {
  
  ::cn::seisys::v2x::pb::SignalWaitingLane* temp = _impl_.swl_;
  _impl_.swl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::SignalWaitingLane* ConnectionEx::unsafe_arena_release_swl() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ConnectionEx.swl)
  
  ::cn::seisys::v2x::pb::SignalWaitingLane* temp = _impl_.swl_;
  _impl_.swl_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::SignalWaitingLane* ConnectionEx::_internal_mutable_swl() {
  
  if (_impl_.swl_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::SignalWaitingLane>(GetArenaForAllocation());
    _impl_.swl_ = p;
  }
  return _impl_.swl_;
}
inline ::cn::seisys::v2x::pb::SignalWaitingLane* ConnectionEx::mutable_swl() {
  ::cn::seisys::v2x::pb::SignalWaitingLane* _msg = _internal_mutable_swl();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ConnectionEx.swl)
  return _msg;
}
inline void ConnectionEx::set_allocated_swl(::cn::seisys::v2x::pb::SignalWaitingLane* swl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.swl_;
  }
  if (swl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(swl);
    if (message_arena != submessage_arena) {
      swl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, swl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.swl_ = swl;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ConnectionEx.swl)
}

// repeated .cn.seisys.v2x.pb.ConnectingLaneEx connectionLane = 3;
inline int ConnectionEx::_internal_connectionlane_size() const {
  return _impl_.connectionlane_.size();
}
inline int ConnectionEx::connectionlane_size() const {
  return _internal_connectionlane_size();
}
inline void ConnectionEx::clear_connectionlane() {
  _impl_.connectionlane_.Clear();
}
inline ::cn::seisys::v2x::pb::ConnectingLaneEx* ConnectionEx::mutable_connectionlane(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ConnectionEx.connectionLane)
  return _impl_.connectionlane_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectingLaneEx >*
ConnectionEx::mutable_connectionlane() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.ConnectionEx.connectionLane)
  return &_impl_.connectionlane_;
}
inline const ::cn::seisys::v2x::pb::ConnectingLaneEx& ConnectionEx::_internal_connectionlane(int index) const {
  return _impl_.connectionlane_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ConnectingLaneEx& ConnectionEx::connectionlane(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectionEx.connectionLane)
  return _internal_connectionlane(index);
}
inline ::cn::seisys::v2x::pb::ConnectingLaneEx* ConnectionEx::_internal_add_connectionlane() {
  return _impl_.connectionlane_.Add();
}
inline ::cn::seisys::v2x::pb::ConnectingLaneEx* ConnectionEx::add_connectionlane() {
  ::cn::seisys::v2x::pb::ConnectingLaneEx* _add = _internal_add_connectionlane();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.ConnectionEx.connectionLane)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectingLaneEx >&
ConnectionEx::connectionlane() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.ConnectionEx.connectionLane)
  return _impl_.connectionlane_;
}

// uint32 phaseId = 4;
inline void ConnectionEx::clear_phaseid() {
  _impl_.phaseid_ = 0u;
}
inline uint32_t ConnectionEx::_internal_phaseid() const {
  return _impl_.phaseid_;
}
inline uint32_t ConnectionEx::phaseid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectionEx.phaseId)
  return _internal_phaseid();
}
inline void ConnectionEx::_internal_set_phaseid(uint32_t value) {
  
  _impl_.phaseid_ = value;
}
inline void ConnectionEx::set_phaseid(uint32_t value) {
  _internal_set_phaseid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ConnectionEx.phaseId)
}

// .cn.seisys.v2x.pb.Maneuver turnDirection = 5;
inline void ConnectionEx::clear_turndirection() {
  _impl_.turndirection_ = 0;
}
inline ::cn::seisys::v2x::pb::Maneuver ConnectionEx::_internal_turndirection() const {
  return static_cast< ::cn::seisys::v2x::pb::Maneuver >(_impl_.turndirection_);
}
inline ::cn::seisys::v2x::pb::Maneuver ConnectionEx::turndirection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ConnectionEx.turnDirection)
  return _internal_turndirection();
}
inline void ConnectionEx::_internal_set_turndirection(::cn::seisys::v2x::pb::Maneuver value) {
  
  _impl_.turndirection_ = value;
}
inline void ConnectionEx::set_turndirection(::cn::seisys::v2x::pb::Maneuver value) {
  _internal_set_turndirection(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ConnectionEx.turnDirection)
}

// -------------------------------------------------------------------

// STPoint

// int32 sAxis = 1;
inline void STPoint::clear_saxis() {
  _impl_.saxis_ = 0;
}
inline int32_t STPoint::_internal_saxis() const {
  return _impl_.saxis_;
}
inline int32_t STPoint::saxis() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.STPoint.sAxis)
  return _internal_saxis();
}
inline void STPoint::_internal_set_saxis(int32_t value) {
  
  _impl_.saxis_ = value;
}
inline void STPoint::set_saxis(int32_t value) {
  _internal_set_saxis(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.STPoint.sAxis)
}

// int32 tAxis = 2;
inline void STPoint::clear_taxis() {
  _impl_.taxis_ = 0;
}
inline int32_t STPoint::_internal_taxis() const {
  return _impl_.taxis_;
}
inline int32_t STPoint::taxis() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.STPoint.tAxis)
  return _internal_taxis();
}
inline void STPoint::_internal_set_taxis(int32_t value) {
  
  _impl_.taxis_ = value;
}
inline void STPoint::set_taxis(int32_t value) {
  _internal_set_taxis(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.STPoint.tAxis)
}

// -------------------------------------------------------------------

// LaneEx

// int32 laneRefId = 1;
inline void LaneEx::clear_lanerefid() {
  _impl_.lanerefid_ = 0;
}
inline int32_t LaneEx::_internal_lanerefid() const {
  return _impl_.lanerefid_;
}
inline int32_t LaneEx::lanerefid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneEx.laneRefId)
  return _internal_lanerefid();
}
inline void LaneEx::_internal_set_lanerefid(int32_t value) {
  
  _impl_.lanerefid_ = value;
}
inline void LaneEx::set_lanerefid(int32_t value) {
  _internal_set_lanerefid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneEx.laneRefId)
}

// uint32 laneWidth = 2;
inline void LaneEx::clear_lanewidth() {
  _impl_.lanewidth_ = 0u;
}
inline uint32_t LaneEx::_internal_lanewidth() const {
  return _impl_.lanewidth_;
}
inline uint32_t LaneEx::lanewidth() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneEx.laneWidth)
  return _internal_lanewidth();
}
inline void LaneEx::_internal_set_lanewidth(uint32_t value) {
  
  _impl_.lanewidth_ = value;
}
inline void LaneEx::set_lanewidth(uint32_t value) {
  _internal_set_lanewidth(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneEx.laneWidth)
}

// .cn.seisys.v2x.pb.LaneAttributes laneAttributes = 3;
inline bool LaneEx::_internal_has_laneattributes() const {
  return this != internal_default_instance() && _impl_.laneattributes_ != nullptr;
}
inline bool LaneEx::has_laneattributes() const {
  return _internal_has_laneattributes();
}
inline void LaneEx::clear_laneattributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.laneattributes_ != nullptr) {
    delete _impl_.laneattributes_;
  }
  _impl_.laneattributes_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LaneAttributes& LaneEx::_internal_laneattributes() const {
  const ::cn::seisys::v2x::pb::LaneAttributes* p = _impl_.laneattributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LaneAttributes&>(
      ::cn::seisys::v2x::pb::_LaneAttributes_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneAttributes& LaneEx::laneattributes() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneEx.laneAttributes)
  return _internal_laneattributes();
}
inline void LaneEx::unsafe_arena_set_allocated_laneattributes(
    ::cn::seisys::v2x::pb::LaneAttributes* laneattributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.laneattributes_);
  }
  _impl_.laneattributes_ = laneattributes;
  if (laneattributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneEx.laneAttributes)
}
inline ::cn::seisys::v2x::pb::LaneAttributes* LaneEx::release_laneattributes() {
  
  ::cn::seisys::v2x::pb::LaneAttributes* temp = _impl_.laneattributes_;
  _impl_.laneattributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneAttributes* LaneEx::unsafe_arena_release_laneattributes() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneEx.laneAttributes)
  
  ::cn::seisys::v2x::pb::LaneAttributes* temp = _impl_.laneattributes_;
  _impl_.laneattributes_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneAttributes* LaneEx::_internal_mutable_laneattributes() {
  
  if (_impl_.laneattributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LaneAttributes>(GetArenaForAllocation());
    _impl_.laneattributes_ = p;
  }
  return _impl_.laneattributes_;
}
inline ::cn::seisys::v2x::pb::LaneAttributes* LaneEx::mutable_laneattributes() {
  ::cn::seisys::v2x::pb::LaneAttributes* _msg = _internal_mutable_laneattributes();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneEx.laneAttributes)
  return _msg;
}
inline void LaneEx::set_allocated_laneattributes(::cn::seisys::v2x::pb::LaneAttributes* laneattributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.laneattributes_;
  }
  if (laneattributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(laneattributes);
    if (message_arena != submessage_arena) {
      laneattributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, laneattributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.laneattributes_ = laneattributes;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneEx.laneAttributes)
}

// .cn.seisys.v2x.pb.AllowedManeuvers maneuvers = 4;
inline bool LaneEx::_internal_has_maneuvers() const {
  return this != internal_default_instance() && _impl_.maneuvers_ != nullptr;
}
inline bool LaneEx::has_maneuvers() const {
  return _internal_has_maneuvers();
}
inline void LaneEx::clear_maneuvers() {
  if (GetArenaForAllocation() == nullptr && _impl_.maneuvers_ != nullptr) {
    delete _impl_.maneuvers_;
  }
  _impl_.maneuvers_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::AllowedManeuvers& LaneEx::_internal_maneuvers() const {
  const ::cn::seisys::v2x::pb::AllowedManeuvers* p = _impl_.maneuvers_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::AllowedManeuvers&>(
      ::cn::seisys::v2x::pb::_AllowedManeuvers_default_instance_);
}
inline const ::cn::seisys::v2x::pb::AllowedManeuvers& LaneEx::maneuvers() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneEx.maneuvers)
  return _internal_maneuvers();
}
inline void LaneEx::unsafe_arena_set_allocated_maneuvers(
    ::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maneuvers_);
  }
  _impl_.maneuvers_ = maneuvers;
  if (maneuvers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneEx.maneuvers)
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* LaneEx::release_maneuvers() {
  
  ::cn::seisys::v2x::pb::AllowedManeuvers* temp = _impl_.maneuvers_;
  _impl_.maneuvers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* LaneEx::unsafe_arena_release_maneuvers() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneEx.maneuvers)
  
  ::cn::seisys::v2x::pb::AllowedManeuvers* temp = _impl_.maneuvers_;
  _impl_.maneuvers_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* LaneEx::_internal_mutable_maneuvers() {
  
  if (_impl_.maneuvers_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::AllowedManeuvers>(GetArenaForAllocation());
    _impl_.maneuvers_ = p;
  }
  return _impl_.maneuvers_;
}
inline ::cn::seisys::v2x::pb::AllowedManeuvers* LaneEx::mutable_maneuvers() {
  ::cn::seisys::v2x::pb::AllowedManeuvers* _msg = _internal_mutable_maneuvers();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneEx.maneuvers)
  return _msg;
}
inline void LaneEx::set_allocated_maneuvers(::cn::seisys::v2x::pb::AllowedManeuvers* maneuvers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.maneuvers_;
  }
  if (maneuvers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maneuvers);
    if (message_arena != submessage_arena) {
      maneuvers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maneuvers, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.maneuvers_ = maneuvers;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneEx.maneuvers)
}

// repeated .cn.seisys.v2x.pb.ConnectionEx connectsToEx = 5;
inline int LaneEx::_internal_connectstoex_size() const {
  return _impl_.connectstoex_.size();
}
inline int LaneEx::connectstoex_size() const {
  return _internal_connectstoex_size();
}
inline void LaneEx::clear_connectstoex() {
  _impl_.connectstoex_.Clear();
}
inline ::cn::seisys::v2x::pb::ConnectionEx* LaneEx::mutable_connectstoex(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneEx.connectsToEx)
  return _impl_.connectstoex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectionEx >*
LaneEx::mutable_connectstoex() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LaneEx.connectsToEx)
  return &_impl_.connectstoex_;
}
inline const ::cn::seisys::v2x::pb::ConnectionEx& LaneEx::_internal_connectstoex(int index) const {
  return _impl_.connectstoex_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ConnectionEx& LaneEx::connectstoex(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneEx.connectsToEx)
  return _internal_connectstoex(index);
}
inline ::cn::seisys::v2x::pb::ConnectionEx* LaneEx::_internal_add_connectstoex() {
  return _impl_.connectstoex_.Add();
}
inline ::cn::seisys::v2x::pb::ConnectionEx* LaneEx::add_connectstoex() {
  ::cn::seisys::v2x::pb::ConnectionEx* _add = _internal_add_connectstoex();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LaneEx.connectsToEx)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ConnectionEx >&
LaneEx::connectstoex() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LaneEx.connectsToEx)
  return _impl_.connectstoex_;
}

// repeated .cn.seisys.v2x.pb.RegulatorySpeedLimit speedLimits = 6;
inline int LaneEx::_internal_speedlimits_size() const {
  return _impl_.speedlimits_.size();
}
inline int LaneEx::speedlimits_size() const {
  return _internal_speedlimits_size();
}
inline void LaneEx::clear_speedlimits() {
  _impl_.speedlimits_.Clear();
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* LaneEx::mutable_speedlimits(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneEx.speedLimits)
  return _impl_.speedlimits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >*
LaneEx::mutable_speedlimits() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LaneEx.speedLimits)
  return &_impl_.speedlimits_;
}
inline const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& LaneEx::_internal_speedlimits(int index) const {
  return _impl_.speedlimits_.Get(index);
}
inline const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& LaneEx::speedlimits(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneEx.speedLimits)
  return _internal_speedlimits(index);
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* LaneEx::_internal_add_speedlimits() {
  return _impl_.speedlimits_.Add();
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* LaneEx::add_speedlimits() {
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* _add = _internal_add_speedlimits();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LaneEx.speedLimits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >&
LaneEx::speedlimits() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LaneEx.speedLimits)
  return _impl_.speedlimits_;
}

// repeated .cn.seisys.v2x.pb.STPoint stPoints = 7;
inline int LaneEx::_internal_stpoints_size() const {
  return _impl_.stpoints_.size();
}
inline int LaneEx::stpoints_size() const {
  return _internal_stpoints_size();
}
inline void LaneEx::clear_stpoints() {
  _impl_.stpoints_.Clear();
}
inline ::cn::seisys::v2x::pb::STPoint* LaneEx::mutable_stpoints(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneEx.stPoints)
  return _impl_.stpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::STPoint >*
LaneEx::mutable_stpoints() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LaneEx.stPoints)
  return &_impl_.stpoints_;
}
inline const ::cn::seisys::v2x::pb::STPoint& LaneEx::_internal_stpoints(int index) const {
  return _impl_.stpoints_.Get(index);
}
inline const ::cn::seisys::v2x::pb::STPoint& LaneEx::stpoints(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneEx.stPoints)
  return _internal_stpoints(index);
}
inline ::cn::seisys::v2x::pb::STPoint* LaneEx::_internal_add_stpoints() {
  return _impl_.stpoints_.Add();
}
inline ::cn::seisys::v2x::pb::STPoint* LaneEx::add_stpoints() {
  ::cn::seisys::v2x::pb::STPoint* _add = _internal_add_stpoints();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LaneEx.stPoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::STPoint >&
LaneEx::stpoints() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LaneEx.stPoints)
  return _impl_.stpoints_;
}

// repeated .cn.seisys.v2x.pb.LaneBoundary leftBoundary = 8;
inline int LaneEx::_internal_leftboundary_size() const {
  return _impl_.leftboundary_.size();
}
inline int LaneEx::leftboundary_size() const {
  return _internal_leftboundary_size();
}
inline void LaneEx::clear_leftboundary() {
  _impl_.leftboundary_.Clear();
}
inline ::cn::seisys::v2x::pb::LaneBoundary* LaneEx::mutable_leftboundary(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneEx.leftBoundary)
  return _impl_.leftboundary_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >*
LaneEx::mutable_leftboundary() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LaneEx.leftBoundary)
  return &_impl_.leftboundary_;
}
inline const ::cn::seisys::v2x::pb::LaneBoundary& LaneEx::_internal_leftboundary(int index) const {
  return _impl_.leftboundary_.Get(index);
}
inline const ::cn::seisys::v2x::pb::LaneBoundary& LaneEx::leftboundary(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneEx.leftBoundary)
  return _internal_leftboundary(index);
}
inline ::cn::seisys::v2x::pb::LaneBoundary* LaneEx::_internal_add_leftboundary() {
  return _impl_.leftboundary_.Add();
}
inline ::cn::seisys::v2x::pb::LaneBoundary* LaneEx::add_leftboundary() {
  ::cn::seisys::v2x::pb::LaneBoundary* _add = _internal_add_leftboundary();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LaneEx.leftBoundary)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >&
LaneEx::leftboundary() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LaneEx.leftBoundary)
  return _impl_.leftboundary_;
}

// repeated .cn.seisys.v2x.pb.LaneBoundary rightBoundary = 9;
inline int LaneEx::_internal_rightboundary_size() const {
  return _impl_.rightboundary_.size();
}
inline int LaneEx::rightboundary_size() const {
  return _internal_rightboundary_size();
}
inline void LaneEx::clear_rightboundary() {
  _impl_.rightboundary_.Clear();
}
inline ::cn::seisys::v2x::pb::LaneBoundary* LaneEx::mutable_rightboundary(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneEx.rightBoundary)
  return _impl_.rightboundary_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >*
LaneEx::mutable_rightboundary() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LaneEx.rightBoundary)
  return &_impl_.rightboundary_;
}
inline const ::cn::seisys::v2x::pb::LaneBoundary& LaneEx::_internal_rightboundary(int index) const {
  return _impl_.rightboundary_.Get(index);
}
inline const ::cn::seisys::v2x::pb::LaneBoundary& LaneEx::rightboundary(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneEx.rightBoundary)
  return _internal_rightboundary(index);
}
inline ::cn::seisys::v2x::pb::LaneBoundary* LaneEx::_internal_add_rightboundary() {
  return _impl_.rightboundary_.Add();
}
inline ::cn::seisys::v2x::pb::LaneBoundary* LaneEx::add_rightboundary() {
  ::cn::seisys::v2x::pb::LaneBoundary* _add = _internal_add_rightboundary();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LaneEx.rightBoundary)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneBoundary >&
LaneEx::rightboundary() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LaneEx.rightBoundary)
  return _impl_.rightboundary_;
}

// -------------------------------------------------------------------

// Movement

// .cn.seisys.v2x.pb.NodeReferenceId remoteIntersection = 1;
inline bool Movement::_internal_has_remoteintersection() const {
  return this != internal_default_instance() && _impl_.remoteintersection_ != nullptr;
}
inline bool Movement::has_remoteintersection() const {
  return _internal_has_remoteintersection();
}
inline void Movement::clear_remoteintersection() {
  if (GetArenaForAllocation() == nullptr && _impl_.remoteintersection_ != nullptr) {
    delete _impl_.remoteintersection_;
  }
  _impl_.remoteintersection_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& Movement::_internal_remoteintersection() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.remoteintersection_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& Movement::remoteintersection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Movement.remoteIntersection)
  return _internal_remoteintersection();
}
inline void Movement::unsafe_arena_set_allocated_remoteintersection(
    ::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remoteintersection_);
  }
  _impl_.remoteintersection_ = remoteintersection;
  if (remoteintersection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.Movement.remoteIntersection)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Movement::release_remoteintersection() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Movement::unsafe_arena_release_remoteintersection() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Movement.remoteIntersection)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.remoteintersection_;
  _impl_.remoteintersection_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Movement::_internal_mutable_remoteintersection() {
  
  if (_impl_.remoteintersection_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.remoteintersection_ = p;
  }
  return _impl_.remoteintersection_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Movement::mutable_remoteintersection() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_remoteintersection();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Movement.remoteIntersection)
  return _msg;
}
inline void Movement::set_allocated_remoteintersection(::cn::seisys::v2x::pb::NodeReferenceId* remoteintersection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remoteintersection_;
  }
  if (remoteintersection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remoteintersection);
    if (message_arena != submessage_arena) {
      remoteintersection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remoteintersection, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remoteintersection_ = remoteintersection;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Movement.remoteIntersection)
}

// uint32 phaseId = 2;
inline void Movement::clear_phaseid() {
  _impl_.phaseid_ = 0u;
}
inline uint32_t Movement::_internal_phaseid() const {
  return _impl_.phaseid_;
}
inline uint32_t Movement::phaseid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Movement.phaseId)
  return _internal_phaseid();
}
inline void Movement::_internal_set_phaseid(uint32_t value) {
  
  _impl_.phaseid_ = value;
}
inline void Movement::set_phaseid(uint32_t value) {
  _internal_set_phaseid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Movement.phaseId)
}

// -------------------------------------------------------------------

// Section

// uint32 SecId = 1;
inline void Section::clear_secid() {
  _impl_.secid_ = 0u;
}
inline uint32_t Section::_internal_secid() const {
  return _impl_.secid_;
}
inline uint32_t Section::secid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Section.SecId)
  return _internal_secid();
}
inline void Section::_internal_set_secid(uint32_t value) {
  
  _impl_.secid_ = value;
}
inline void Section::set_secid(uint32_t value) {
  _internal_set_secid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Section.SecId)
}

// repeated .cn.seisys.v2x.pb.LaneEx lanes = 2;
inline int Section::_internal_lanes_size() const {
  return _impl_.lanes_.size();
}
inline int Section::lanes_size() const {
  return _internal_lanes_size();
}
inline void Section::clear_lanes() {
  _impl_.lanes_.Clear();
}
inline ::cn::seisys::v2x::pb::LaneEx* Section::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Section.lanes)
  return _impl_.lanes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneEx >*
Section::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Section.lanes)
  return &_impl_.lanes_;
}
inline const ::cn::seisys::v2x::pb::LaneEx& Section::_internal_lanes(int index) const {
  return _impl_.lanes_.Get(index);
}
inline const ::cn::seisys::v2x::pb::LaneEx& Section::lanes(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Section.lanes)
  return _internal_lanes(index);
}
inline ::cn::seisys::v2x::pb::LaneEx* Section::_internal_add_lanes() {
  return _impl_.lanes_.Add();
}
inline ::cn::seisys::v2x::pb::LaneEx* Section::add_lanes() {
  ::cn::seisys::v2x::pb::LaneEx* _add = _internal_add_lanes();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Section.lanes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LaneEx >&
Section::lanes() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Section.lanes)
  return _impl_.lanes_;
}

// -------------------------------------------------------------------

// LinkEx

// string name = 1;
inline void LinkEx::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LinkEx::name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkEx.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinkEx::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkEx.name)
}
inline std::string* LinkEx::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkEx.name)
  return _s;
}
inline const std::string& LinkEx::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LinkEx::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LinkEx::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LinkEx::release_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LinkEx.name)
  return _impl_.name_.Release();
}
inline void LinkEx::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LinkEx.name)
}

// .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 2;
inline bool LinkEx::_internal_has_upstreamnodeid() const {
  return this != internal_default_instance() && _impl_.upstreamnodeid_ != nullptr;
}
inline bool LinkEx::has_upstreamnodeid() const {
  return _internal_has_upstreamnodeid();
}
inline void LinkEx::clear_upstreamnodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.upstreamnodeid_ != nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  _impl_.upstreamnodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& LinkEx::_internal_upstreamnodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.upstreamnodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& LinkEx::upstreamnodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkEx.upstreamNodeId)
  return _internal_upstreamnodeid();
}
inline void LinkEx::unsafe_arena_set_allocated_upstreamnodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upstreamnodeid_);
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  if (upstreamnodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LinkEx.upstreamNodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* LinkEx::release_upstreamnodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* LinkEx::unsafe_arena_release_upstreamnodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LinkEx.upstreamNodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* LinkEx::_internal_mutable_upstreamnodeid() {
  
  if (_impl_.upstreamnodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.upstreamnodeid_ = p;
  }
  return _impl_.upstreamnodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* LinkEx::mutable_upstreamnodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_upstreamnodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkEx.upstreamNodeId)
  return _msg;
}
inline void LinkEx::set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  if (upstreamnodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upstreamnodeid);
    if (message_arena != submessage_arena) {
      upstreamnodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upstreamnodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LinkEx.upstreamNodeId)
}

// repeated .cn.seisys.v2x.pb.RegulatorySpeedLimit speedLimits = 3;
inline int LinkEx::_internal_speedlimits_size() const {
  return _impl_.speedlimits_.size();
}
inline int LinkEx::speedlimits_size() const {
  return _internal_speedlimits_size();
}
inline void LinkEx::clear_speedlimits() {
  _impl_.speedlimits_.Clear();
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* LinkEx::mutable_speedlimits(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkEx.speedLimits)
  return _impl_.speedlimits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >*
LinkEx::mutable_speedlimits() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LinkEx.speedLimits)
  return &_impl_.speedlimits_;
}
inline const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& LinkEx::_internal_speedlimits(int index) const {
  return _impl_.speedlimits_.Get(index);
}
inline const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& LinkEx::speedlimits(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkEx.speedLimits)
  return _internal_speedlimits(index);
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* LinkEx::_internal_add_speedlimits() {
  return _impl_.speedlimits_.Add();
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* LinkEx::add_speedlimits() {
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* _add = _internal_add_speedlimits();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LinkEx.speedLimits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >&
LinkEx::speedlimits() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LinkEx.speedLimits)
  return _impl_.speedlimits_;
}

// uint32 linkWidth = 4;
inline void LinkEx::clear_linkwidth() {
  _impl_.linkwidth_ = 0u;
}
inline uint32_t LinkEx::_internal_linkwidth() const {
  return _impl_.linkwidth_;
}
inline uint32_t LinkEx::linkwidth() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkEx.linkWidth)
  return _internal_linkwidth();
}
inline void LinkEx::_internal_set_linkwidth(uint32_t value) {
  
  _impl_.linkwidth_ = value;
}
inline void LinkEx::set_linkwidth(uint32_t value) {
  _internal_set_linkwidth(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LinkEx.linkWidth)
}

// repeated .cn.seisys.v2x.pb.Position3D refLine = 5;
inline int LinkEx::_internal_refline_size() const {
  return _impl_.refline_.size();
}
inline int LinkEx::refline_size() const {
  return _internal_refline_size();
}
inline void LinkEx::clear_refline() {
  _impl_.refline_.Clear();
}
inline ::cn::seisys::v2x::pb::Position3D* LinkEx::mutable_refline(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkEx.refLine)
  return _impl_.refline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
LinkEx::mutable_refline() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LinkEx.refLine)
  return &_impl_.refline_;
}
inline const ::cn::seisys::v2x::pb::Position3D& LinkEx::_internal_refline(int index) const {
  return _impl_.refline_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Position3D& LinkEx::refline(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkEx.refLine)
  return _internal_refline(index);
}
inline ::cn::seisys::v2x::pb::Position3D* LinkEx::_internal_add_refline() {
  return _impl_.refline_.Add();
}
inline ::cn::seisys::v2x::pb::Position3D* LinkEx::add_refline() {
  ::cn::seisys::v2x::pb::Position3D* _add = _internal_add_refline();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LinkEx.refLine)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
LinkEx::refline() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LinkEx.refLine)
  return _impl_.refline_;
}

// repeated .cn.seisys.v2x.pb.MovementEx movementsEx = 6;
inline int LinkEx::_internal_movementsex_size() const {
  return _impl_.movementsex_.size();
}
inline int LinkEx::movementsex_size() const {
  return _internal_movementsex_size();
}
inline void LinkEx::clear_movementsex() {
  _impl_.movementsex_.Clear();
}
inline ::cn::seisys::v2x::pb::MovementEx* LinkEx::mutable_movementsex(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkEx.movementsEx)
  return _impl_.movementsex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx >*
LinkEx::mutable_movementsex() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LinkEx.movementsEx)
  return &_impl_.movementsex_;
}
inline const ::cn::seisys::v2x::pb::MovementEx& LinkEx::_internal_movementsex(int index) const {
  return _impl_.movementsex_.Get(index);
}
inline const ::cn::seisys::v2x::pb::MovementEx& LinkEx::movementsex(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkEx.movementsEx)
  return _internal_movementsex(index);
}
inline ::cn::seisys::v2x::pb::MovementEx* LinkEx::_internal_add_movementsex() {
  return _impl_.movementsex_.Add();
}
inline ::cn::seisys::v2x::pb::MovementEx* LinkEx::add_movementsex() {
  ::cn::seisys::v2x::pb::MovementEx* _add = _internal_add_movementsex();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LinkEx.movementsEx)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::MovementEx >&
LinkEx::movementsex() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LinkEx.movementsEx)
  return _impl_.movementsex_;
}

// repeated .cn.seisys.v2x.pb.Section sections = 7;
inline int LinkEx::_internal_sections_size() const {
  return _impl_.sections_.size();
}
inline int LinkEx::sections_size() const {
  return _internal_sections_size();
}
inline void LinkEx::clear_sections() {
  _impl_.sections_.Clear();
}
inline ::cn::seisys::v2x::pb::Section* LinkEx::mutable_sections(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LinkEx.sections)
  return _impl_.sections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Section >*
LinkEx::mutable_sections() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.LinkEx.sections)
  return &_impl_.sections_;
}
inline const ::cn::seisys::v2x::pb::Section& LinkEx::_internal_sections(int index) const {
  return _impl_.sections_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Section& LinkEx::sections(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LinkEx.sections)
  return _internal_sections(index);
}
inline ::cn::seisys::v2x::pb::Section* LinkEx::_internal_add_sections() {
  return _impl_.sections_.Add();
}
inline ::cn::seisys::v2x::pb::Section* LinkEx::add_sections() {
  ::cn::seisys::v2x::pb::Section* _add = _internal_add_sections();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.LinkEx.sections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Section >&
LinkEx::sections() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.LinkEx.sections)
  return _impl_.sections_;
}

// -------------------------------------------------------------------

// Link

// string name = 1;
inline void Link::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Link::name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Link.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Link.name)
}
inline std::string* Link::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Link.name)
  return _s;
}
inline const std::string& Link::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Link::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Link.name)
  return _impl_.name_.Release();
}
inline void Link::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Link.name)
}

// .cn.seisys.v2x.pb.NodeReferenceId upstreamNodeId = 2;
inline bool Link::_internal_has_upstreamnodeid() const {
  return this != internal_default_instance() && _impl_.upstreamnodeid_ != nullptr;
}
inline bool Link::has_upstreamnodeid() const {
  return _internal_has_upstreamnodeid();
}
inline void Link::clear_upstreamnodeid() {
  if (GetArenaForAllocation() == nullptr && _impl_.upstreamnodeid_ != nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  _impl_.upstreamnodeid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& Link::_internal_upstreamnodeid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.upstreamnodeid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& Link::upstreamnodeid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Link.upstreamNodeId)
  return _internal_upstreamnodeid();
}
inline void Link::unsafe_arena_set_allocated_upstreamnodeid(
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upstreamnodeid_);
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  if (upstreamnodeid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.Link.upstreamNodeId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Link::release_upstreamnodeid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Link::unsafe_arena_release_upstreamnodeid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Link.upstreamNodeId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnodeid_;
  _impl_.upstreamnodeid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Link::_internal_mutable_upstreamnodeid() {
  
  if (_impl_.upstreamnodeid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.upstreamnodeid_ = p;
  }
  return _impl_.upstreamnodeid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Link::mutable_upstreamnodeid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_upstreamnodeid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Link.upstreamNodeId)
  return _msg;
}
inline void Link::set_allocated_upstreamnodeid(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnodeid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upstreamnodeid_;
  }
  if (upstreamnodeid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upstreamnodeid);
    if (message_arena != submessage_arena) {
      upstreamnodeid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upstreamnodeid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.upstreamnodeid_ = upstreamnodeid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Link.upstreamNodeId)
}

// repeated .cn.seisys.v2x.pb.RegulatorySpeedLimit speedLimits = 3;
inline int Link::_internal_speedlimits_size() const {
  return _impl_.speedlimits_.size();
}
inline int Link::speedlimits_size() const {
  return _internal_speedlimits_size();
}
inline void Link::clear_speedlimits() {
  _impl_.speedlimits_.Clear();
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* Link::mutable_speedlimits(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Link.speedLimits)
  return _impl_.speedlimits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >*
Link::mutable_speedlimits() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Link.speedLimits)
  return &_impl_.speedlimits_;
}
inline const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& Link::_internal_speedlimits(int index) const {
  return _impl_.speedlimits_.Get(index);
}
inline const ::cn::seisys::v2x::pb::RegulatorySpeedLimit& Link::speedlimits(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Link.speedLimits)
  return _internal_speedlimits(index);
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* Link::_internal_add_speedlimits() {
  return _impl_.speedlimits_.Add();
}
inline ::cn::seisys::v2x::pb::RegulatorySpeedLimit* Link::add_speedlimits() {
  ::cn::seisys::v2x::pb::RegulatorySpeedLimit* _add = _internal_add_speedlimits();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Link.speedLimits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RegulatorySpeedLimit >&
Link::speedlimits() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Link.speedLimits)
  return _impl_.speedlimits_;
}

// uint32 linkWidth = 4;
inline void Link::clear_linkwidth() {
  _impl_.linkwidth_ = 0u;
}
inline uint32_t Link::_internal_linkwidth() const {
  return _impl_.linkwidth_;
}
inline uint32_t Link::linkwidth() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Link.linkWidth)
  return _internal_linkwidth();
}
inline void Link::_internal_set_linkwidth(uint32_t value) {
  
  _impl_.linkwidth_ = value;
}
inline void Link::set_linkwidth(uint32_t value) {
  _internal_set_linkwidth(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Link.linkWidth)
}

// repeated .cn.seisys.v2x.pb.Position3D points = 5;
inline int Link::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int Link::points_size() const {
  return _internal_points_size();
}
inline void Link::clear_points() {
  _impl_.points_.Clear();
}
inline ::cn::seisys::v2x::pb::Position3D* Link::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Link.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >*
Link::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Link.points)
  return &_impl_.points_;
}
inline const ::cn::seisys::v2x::pb::Position3D& Link::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Position3D& Link::points(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Link.points)
  return _internal_points(index);
}
inline ::cn::seisys::v2x::pb::Position3D* Link::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::cn::seisys::v2x::pb::Position3D* Link::add_points() {
  ::cn::seisys::v2x::pb::Position3D* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Link.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Position3D >&
Link::points() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Link.points)
  return _impl_.points_;
}

// repeated .cn.seisys.v2x.pb.Movement movements = 6;
inline int Link::_internal_movements_size() const {
  return _impl_.movements_.size();
}
inline int Link::movements_size() const {
  return _internal_movements_size();
}
inline void Link::clear_movements() {
  _impl_.movements_.Clear();
}
inline ::cn::seisys::v2x::pb::Movement* Link::mutable_movements(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Link.movements)
  return _impl_.movements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Movement >*
Link::mutable_movements() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Link.movements)
  return &_impl_.movements_;
}
inline const ::cn::seisys::v2x::pb::Movement& Link::_internal_movements(int index) const {
  return _impl_.movements_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Movement& Link::movements(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Link.movements)
  return _internal_movements(index);
}
inline ::cn::seisys::v2x::pb::Movement* Link::_internal_add_movements() {
  return _impl_.movements_.Add();
}
inline ::cn::seisys::v2x::pb::Movement* Link::add_movements() {
  ::cn::seisys::v2x::pb::Movement* _add = _internal_add_movements();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Link.movements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Movement >&
Link::movements() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Link.movements)
  return _impl_.movements_;
}

// repeated .cn.seisys.v2x.pb.Lane lanes = 7;
inline int Link::_internal_lanes_size() const {
  return _impl_.lanes_.size();
}
inline int Link::lanes_size() const {
  return _internal_lanes_size();
}
inline void Link::clear_lanes() {
  _impl_.lanes_.Clear();
}
inline ::cn::seisys::v2x::pb::Lane* Link::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Link.lanes)
  return _impl_.lanes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Lane >*
Link::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Link.lanes)
  return &_impl_.lanes_;
}
inline const ::cn::seisys::v2x::pb::Lane& Link::_internal_lanes(int index) const {
  return _impl_.lanes_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Lane& Link::lanes(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Link.lanes)
  return _internal_lanes(index);
}
inline ::cn::seisys::v2x::pb::Lane* Link::_internal_add_lanes() {
  return _impl_.lanes_.Add();
}
inline ::cn::seisys::v2x::pb::Lane* Link::add_lanes() {
  ::cn::seisys::v2x::pb::Lane* _add = _internal_add_lanes();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Link.lanes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Lane >&
Link::lanes() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Link.lanes)
  return _impl_.lanes_;
}

// -------------------------------------------------------------------

// ProhibitedZone

// .cn.seisys.v2x.pb.Polygon centralCircleProhibitedZone = 1;
inline bool ProhibitedZone::_internal_has_centralcircleprohibitedzone() const {
  return this != internal_default_instance() && _impl_.centralcircleprohibitedzone_ != nullptr;
}
inline bool ProhibitedZone::has_centralcircleprohibitedzone() const {
  return _internal_has_centralcircleprohibitedzone();
}
inline void ProhibitedZone::clear_centralcircleprohibitedzone() {
  if (GetArenaForAllocation() == nullptr && _impl_.centralcircleprohibitedzone_ != nullptr) {
    delete _impl_.centralcircleprohibitedzone_;
  }
  _impl_.centralcircleprohibitedzone_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Polygon& ProhibitedZone::_internal_centralcircleprohibitedzone() const {
  const ::cn::seisys::v2x::pb::Polygon* p = _impl_.centralcircleprohibitedzone_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Polygon&>(
      ::cn::seisys::v2x::pb::_Polygon_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Polygon& ProhibitedZone::centralcircleprohibitedzone() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ProhibitedZone.centralCircleProhibitedZone)
  return _internal_centralcircleprohibitedzone();
}
inline void ProhibitedZone::unsafe_arena_set_allocated_centralcircleprohibitedzone(
    ::cn::seisys::v2x::pb::Polygon* centralcircleprohibitedzone) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.centralcircleprohibitedzone_);
  }
  _impl_.centralcircleprohibitedzone_ = centralcircleprohibitedzone;
  if (centralcircleprohibitedzone) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ProhibitedZone.centralCircleProhibitedZone)
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::release_centralcircleprohibitedzone() {
  
  ::cn::seisys::v2x::pb::Polygon* temp = _impl_.centralcircleprohibitedzone_;
  _impl_.centralcircleprohibitedzone_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::unsafe_arena_release_centralcircleprohibitedzone() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ProhibitedZone.centralCircleProhibitedZone)
  
  ::cn::seisys::v2x::pb::Polygon* temp = _impl_.centralcircleprohibitedzone_;
  _impl_.centralcircleprohibitedzone_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::_internal_mutable_centralcircleprohibitedzone() {
  
  if (_impl_.centralcircleprohibitedzone_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Polygon>(GetArenaForAllocation());
    _impl_.centralcircleprohibitedzone_ = p;
  }
  return _impl_.centralcircleprohibitedzone_;
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::mutable_centralcircleprohibitedzone() {
  ::cn::seisys::v2x::pb::Polygon* _msg = _internal_mutable_centralcircleprohibitedzone();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ProhibitedZone.centralCircleProhibitedZone)
  return _msg;
}
inline void ProhibitedZone::set_allocated_centralcircleprohibitedzone(::cn::seisys::v2x::pb::Polygon* centralcircleprohibitedzone) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.centralcircleprohibitedzone_;
  }
  if (centralcircleprohibitedzone) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(centralcircleprohibitedzone);
    if (message_arena != submessage_arena) {
      centralcircleprohibitedzone = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, centralcircleprohibitedzone, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.centralcircleprohibitedzone_ = centralcircleprohibitedzone;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ProhibitedZone.centralCircleProhibitedZone)
}

// repeated .cn.seisys.v2x.pb.Polygon nonMotorVehicleProhibitedZones = 2;
inline int ProhibitedZone::_internal_nonmotorvehicleprohibitedzones_size() const {
  return _impl_.nonmotorvehicleprohibitedzones_.size();
}
inline int ProhibitedZone::nonmotorvehicleprohibitedzones_size() const {
  return _internal_nonmotorvehicleprohibitedzones_size();
}
inline void ProhibitedZone::clear_nonmotorvehicleprohibitedzones() {
  _impl_.nonmotorvehicleprohibitedzones_.Clear();
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::mutable_nonmotorvehicleprohibitedzones(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ProhibitedZone.nonMotorVehicleProhibitedZones)
  return _impl_.nonmotorvehicleprohibitedzones_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >*
ProhibitedZone::mutable_nonmotorvehicleprohibitedzones() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.ProhibitedZone.nonMotorVehicleProhibitedZones)
  return &_impl_.nonmotorvehicleprohibitedzones_;
}
inline const ::cn::seisys::v2x::pb::Polygon& ProhibitedZone::_internal_nonmotorvehicleprohibitedzones(int index) const {
  return _impl_.nonmotorvehicleprohibitedzones_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Polygon& ProhibitedZone::nonmotorvehicleprohibitedzones(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ProhibitedZone.nonMotorVehicleProhibitedZones)
  return _internal_nonmotorvehicleprohibitedzones(index);
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::_internal_add_nonmotorvehicleprohibitedzones() {
  return _impl_.nonmotorvehicleprohibitedzones_.Add();
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::add_nonmotorvehicleprohibitedzones() {
  ::cn::seisys::v2x::pb::Polygon* _add = _internal_add_nonmotorvehicleprohibitedzones();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.ProhibitedZone.nonMotorVehicleProhibitedZones)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >&
ProhibitedZone::nonmotorvehicleprohibitedzones() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.ProhibitedZone.nonMotorVehicleProhibitedZones)
  return _impl_.nonmotorvehicleprohibitedzones_;
}

// repeated .cn.seisys.v2x.pb.Polygon gridLineMarkingProhibitedZones = 3;
inline int ProhibitedZone::_internal_gridlinemarkingprohibitedzones_size() const {
  return _impl_.gridlinemarkingprohibitedzones_.size();
}
inline int ProhibitedZone::gridlinemarkingprohibitedzones_size() const {
  return _internal_gridlinemarkingprohibitedzones_size();
}
inline void ProhibitedZone::clear_gridlinemarkingprohibitedzones() {
  _impl_.gridlinemarkingprohibitedzones_.Clear();
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::mutable_gridlinemarkingprohibitedzones(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ProhibitedZone.gridLineMarkingProhibitedZones)
  return _impl_.gridlinemarkingprohibitedzones_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >*
ProhibitedZone::mutable_gridlinemarkingprohibitedzones() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.ProhibitedZone.gridLineMarkingProhibitedZones)
  return &_impl_.gridlinemarkingprohibitedzones_;
}
inline const ::cn::seisys::v2x::pb::Polygon& ProhibitedZone::_internal_gridlinemarkingprohibitedzones(int index) const {
  return _impl_.gridlinemarkingprohibitedzones_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Polygon& ProhibitedZone::gridlinemarkingprohibitedzones(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ProhibitedZone.gridLineMarkingProhibitedZones)
  return _internal_gridlinemarkingprohibitedzones(index);
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::_internal_add_gridlinemarkingprohibitedzones() {
  return _impl_.gridlinemarkingprohibitedzones_.Add();
}
inline ::cn::seisys::v2x::pb::Polygon* ProhibitedZone::add_gridlinemarkingprohibitedzones() {
  ::cn::seisys::v2x::pb::Polygon* _add = _internal_add_gridlinemarkingprohibitedzones();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.ProhibitedZone.gridLineMarkingProhibitedZones)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >&
ProhibitedZone::gridlinemarkingprohibitedzones() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.ProhibitedZone.gridLineMarkingProhibitedZones)
  return _impl_.gridlinemarkingprohibitedzones_;
}

// -------------------------------------------------------------------

// Node

// string name = 1;
inline void Node::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Node.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.Node.name)
}
inline std::string* Node::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Node.name)
  return _s;
}
inline const std::string& Node::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Node::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Node.name)
  return _impl_.name_.Release();
}
inline void Node::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Node.name)
}

// .cn.seisys.v2x.pb.NodeReferenceId id = 2;
inline bool Node::_internal_has_id() const {
  return this != internal_default_instance() && _impl_.id_ != nullptr;
}
inline bool Node::has_id() const {
  return _internal_has_id();
}
inline void Node::clear_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.id_ != nullptr) {
    delete _impl_.id_;
  }
  _impl_.id_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& Node::_internal_id() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& Node::id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Node.id)
  return _internal_id();
}
inline void Node::unsafe_arena_set_allocated_id(
    ::cn::seisys::v2x::pb::NodeReferenceId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.Node.id)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Node::release_id() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Node::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Node.id)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Node::_internal_mutable_id() {
  
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* Node::mutable_id() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Node.id)
  return _msg;
}
inline void Node::set_allocated_id(::cn::seisys::v2x::pb::NodeReferenceId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Node.id)
}

// .cn.seisys.v2x.pb.Position3D refPos = 3;
inline bool Node::_internal_has_refpos() const {
  return this != internal_default_instance() && _impl_.refpos_ != nullptr;
}
inline bool Node::has_refpos() const {
  return _internal_has_refpos();
}
inline void Node::clear_refpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.refpos_ != nullptr) {
    delete _impl_.refpos_;
  }
  _impl_.refpos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& Node::_internal_refpos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.refpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& Node::refpos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Node.refPos)
  return _internal_refpos();
}
inline void Node::unsafe_arena_set_allocated_refpos(
    ::cn::seisys::v2x::pb::Position3D* refpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.refpos_);
  }
  _impl_.refpos_ = refpos;
  if (refpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.Node.refPos)
}
inline ::cn::seisys::v2x::pb::Position3D* Node::release_refpos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.refpos_;
  _impl_.refpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* Node::unsafe_arena_release_refpos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Node.refPos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.refpos_;
  _impl_.refpos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* Node::_internal_mutable_refpos() {
  
  if (_impl_.refpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.refpos_ = p;
  }
  return _impl_.refpos_;
}
inline ::cn::seisys::v2x::pb::Position3D* Node::mutable_refpos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_refpos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Node.refPos)
  return _msg;
}
inline void Node::set_allocated_refpos(::cn::seisys::v2x::pb::Position3D* refpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.refpos_;
  }
  if (refpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(refpos);
    if (message_arena != submessage_arena) {
      refpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, refpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.refpos_ = refpos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Node.refPos)
}

// repeated .cn.seisys.v2x.pb.Link inLinks = 4;
inline int Node::_internal_inlinks_size() const {
  return _impl_.inlinks_.size();
}
inline int Node::inlinks_size() const {
  return _internal_inlinks_size();
}
inline void Node::clear_inlinks() {
  _impl_.inlinks_.Clear();
}
inline ::cn::seisys::v2x::pb::Link* Node::mutable_inlinks(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Node.inLinks)
  return _impl_.inlinks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Link >*
Node::mutable_inlinks() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Node.inLinks)
  return &_impl_.inlinks_;
}
inline const ::cn::seisys::v2x::pb::Link& Node::_internal_inlinks(int index) const {
  return _impl_.inlinks_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Link& Node::inlinks(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Node.inLinks)
  return _internal_inlinks(index);
}
inline ::cn::seisys::v2x::pb::Link* Node::_internal_add_inlinks() {
  return _impl_.inlinks_.Add();
}
inline ::cn::seisys::v2x::pb::Link* Node::add_inlinks() {
  ::cn::seisys::v2x::pb::Link* _add = _internal_add_inlinks();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Node.inLinks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Link >&
Node::inlinks() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Node.inLinks)
  return _impl_.inlinks_;
}

// repeated .cn.seisys.v2x.pb.LinkEx inLinksEx = 5;
inline int Node::_internal_inlinksex_size() const {
  return _impl_.inlinksex_.size();
}
inline int Node::inlinksex_size() const {
  return _internal_inlinksex_size();
}
inline void Node::clear_inlinksex() {
  _impl_.inlinksex_.Clear();
}
inline ::cn::seisys::v2x::pb::LinkEx* Node::mutable_inlinksex(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Node.inLinksEx)
  return _impl_.inlinksex_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkEx >*
Node::mutable_inlinksex() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.Node.inLinksEx)
  return &_impl_.inlinksex_;
}
inline const ::cn::seisys::v2x::pb::LinkEx& Node::_internal_inlinksex(int index) const {
  return _impl_.inlinksex_.Get(index);
}
inline const ::cn::seisys::v2x::pb::LinkEx& Node::inlinksex(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Node.inLinksEx)
  return _internal_inlinksex(index);
}
inline ::cn::seisys::v2x::pb::LinkEx* Node::_internal_add_inlinksex() {
  return _impl_.inlinksex_.Add();
}
inline ::cn::seisys::v2x::pb::LinkEx* Node::add_inlinksex() {
  ::cn::seisys::v2x::pb::LinkEx* _add = _internal_add_inlinksex();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.Node.inLinksEx)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::LinkEx >&
Node::inlinksex() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.Node.inLinksEx)
  return _impl_.inlinksex_;
}

// .cn.seisys.v2x.pb.ProhibitedZone prohibitedZone = 6;
inline bool Node::_internal_has_prohibitedzone() const {
  return this != internal_default_instance() && _impl_.prohibitedzone_ != nullptr;
}
inline bool Node::has_prohibitedzone() const {
  return _internal_has_prohibitedzone();
}
inline void Node::clear_prohibitedzone() {
  if (GetArenaForAllocation() == nullptr && _impl_.prohibitedzone_ != nullptr) {
    delete _impl_.prohibitedzone_;
  }
  _impl_.prohibitedzone_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ProhibitedZone& Node::_internal_prohibitedzone() const {
  const ::cn::seisys::v2x::pb::ProhibitedZone* p = _impl_.prohibitedzone_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ProhibitedZone&>(
      ::cn::seisys::v2x::pb::_ProhibitedZone_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ProhibitedZone& Node::prohibitedzone() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.Node.prohibitedZone)
  return _internal_prohibitedzone();
}
inline void Node::unsafe_arena_set_allocated_prohibitedzone(
    ::cn::seisys::v2x::pb::ProhibitedZone* prohibitedzone) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prohibitedzone_);
  }
  _impl_.prohibitedzone_ = prohibitedzone;
  if (prohibitedzone) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.Node.prohibitedZone)
}
inline ::cn::seisys::v2x::pb::ProhibitedZone* Node::release_prohibitedzone() {
  
  ::cn::seisys::v2x::pb::ProhibitedZone* temp = _impl_.prohibitedzone_;
  _impl_.prohibitedzone_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ProhibitedZone* Node::unsafe_arena_release_prohibitedzone() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.Node.prohibitedZone)
  
  ::cn::seisys::v2x::pb::ProhibitedZone* temp = _impl_.prohibitedzone_;
  _impl_.prohibitedzone_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ProhibitedZone* Node::_internal_mutable_prohibitedzone() {
  
  if (_impl_.prohibitedzone_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ProhibitedZone>(GetArenaForAllocation());
    _impl_.prohibitedzone_ = p;
  }
  return _impl_.prohibitedzone_;
}
inline ::cn::seisys::v2x::pb::ProhibitedZone* Node::mutable_prohibitedzone() {
  ::cn::seisys::v2x::pb::ProhibitedZone* _msg = _internal_mutable_prohibitedzone();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.Node.prohibitedZone)
  return _msg;
}
inline void Node::set_allocated_prohibitedzone(::cn::seisys::v2x::pb::ProhibitedZone* prohibitedzone) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prohibitedzone_;
  }
  if (prohibitedzone) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prohibitedzone);
    if (message_arena != submessage_arena) {
      prohibitedzone = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prohibitedzone, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prohibitedzone_ = prohibitedzone;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.Node.prohibitedZone)
}

// -------------------------------------------------------------------

// MAP

// uint32 timestamp = 1;
inline void MAP::clear_timestamp() {
  _impl_.timestamp_ = 0u;
}
inline uint32_t MAP::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint32_t MAP::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MAP.timestamp)
  return _internal_timestamp();
}
inline void MAP::_internal_set_timestamp(uint32_t value) {
  
  _impl_.timestamp_ = value;
}
inline void MAP::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MAP.timestamp)
}

// repeated .cn.seisys.v2x.pb.Node nodes = 2;
inline int MAP::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int MAP::nodes_size() const {
  return _internal_nodes_size();
}
inline void MAP::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::cn::seisys::v2x::pb::Node* MAP::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MAP.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Node >*
MAP::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.MAP.nodes)
  return &_impl_.nodes_;
}
inline const ::cn::seisys::v2x::pb::Node& MAP::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Node& MAP::nodes(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MAP.nodes)
  return _internal_nodes(index);
}
inline ::cn::seisys::v2x::pb::Node* MAP::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::cn::seisys::v2x::pb::Node* MAP::add_nodes() {
  ::cn::seisys::v2x::pb::Node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.MAP.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Node >&
MAP::nodes() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.MAP.nodes)
  return _impl_.nodes_;
}

// uint32 msgCnt = 3;
inline void MAP::clear_msgcnt() {
  _impl_.msgcnt_ = 0u;
}
inline uint32_t MAP::_internal_msgcnt() const {
  return _impl_.msgcnt_;
}
inline uint32_t MAP::msgcnt() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MAP.msgCnt)
  return _internal_msgcnt();
}
inline void MAP::_internal_set_msgcnt(uint32_t value) {
  
  _impl_.msgcnt_ = value;
}
inline void MAP::set_msgcnt(uint32_t value) {
  _internal_set_msgcnt(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MAP.msgCnt)
}

// -------------------------------------------------------------------

// MapData

// string mapSlice = 1;
inline void MapData::clear_mapslice() {
  _impl_.mapslice_.ClearToEmpty();
}
inline const std::string& MapData::mapslice() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapData.mapSlice)
  return _internal_mapslice();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapData::set_mapslice(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapslice_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MapData.mapSlice)
}
inline std::string* MapData::mutable_mapslice() {
  std::string* _s = _internal_mutable_mapslice();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MapData.mapSlice)
  return _s;
}
inline const std::string& MapData::_internal_mapslice() const {
  return _impl_.mapslice_.Get();
}
inline void MapData::_internal_set_mapslice(const std::string& value) {
  
  _impl_.mapslice_.Set(value, GetArenaForAllocation());
}
inline std::string* MapData::_internal_mutable_mapslice() {
  
  return _impl_.mapslice_.Mutable(GetArenaForAllocation());
}
inline std::string* MapData::release_mapslice() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MapData.mapSlice)
  return _impl_.mapslice_.Release();
}
inline void MapData::set_allocated_mapslice(std::string* mapslice) {
  if (mapslice != nullptr) {
    
  } else {
    
  }
  _impl_.mapslice_.SetAllocated(mapslice, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapslice_.IsDefault()) {
    _impl_.mapslice_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MapData.mapSlice)
}

// .cn.seisys.v2x.pb.MAP map = 2;
inline bool MapData::_internal_has_map() const {
  return this != internal_default_instance() && _impl_.map_ != nullptr;
}
inline bool MapData::has_map() const {
  return _internal_has_map();
}
inline void MapData::clear_map() {
  if (GetArenaForAllocation() == nullptr && _impl_.map_ != nullptr) {
    delete _impl_.map_;
  }
  _impl_.map_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::MAP& MapData::_internal_map() const {
  const ::cn::seisys::v2x::pb::MAP* p = _impl_.map_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::MAP&>(
      ::cn::seisys::v2x::pb::_MAP_default_instance_);
}
inline const ::cn::seisys::v2x::pb::MAP& MapData::map() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapData.map)
  return _internal_map();
}
inline void MapData::unsafe_arena_set_allocated_map(
    ::cn::seisys::v2x::pb::MAP* map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_);
  }
  _impl_.map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.MapData.map)
}
inline ::cn::seisys::v2x::pb::MAP* MapData::release_map() {
  
  ::cn::seisys::v2x::pb::MAP* temp = _impl_.map_;
  _impl_.map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::MAP* MapData::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MapData.map)
  
  ::cn::seisys::v2x::pb::MAP* temp = _impl_.map_;
  _impl_.map_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::MAP* MapData::_internal_mutable_map() {
  
  if (_impl_.map_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::MAP>(GetArenaForAllocation());
    _impl_.map_ = p;
  }
  return _impl_.map_;
}
inline ::cn::seisys::v2x::pb::MAP* MapData::mutable_map() {
  ::cn::seisys::v2x::pb::MAP* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MapData.map)
  return _msg;
}
inline void MapData::set_allocated_map(::cn::seisys::v2x::pb::MAP* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.map_;
  }
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(map);
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.map_ = map;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MapData.map)
}

// string eTag = 3;
inline void MapData::clear_etag() {
  _impl_.etag_.ClearToEmpty();
}
inline const std::string& MapData::etag() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapData.eTag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapData::set_etag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MapData.eTag)
}
inline std::string* MapData::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MapData.eTag)
  return _s;
}
inline const std::string& MapData::_internal_etag() const {
  return _impl_.etag_.Get();
}
inline void MapData::_internal_set_etag(const std::string& value) {
  
  _impl_.etag_.Set(value, GetArenaForAllocation());
}
inline std::string* MapData::_internal_mutable_etag() {
  
  return _impl_.etag_.Mutable(GetArenaForAllocation());
}
inline std::string* MapData::release_etag() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MapData.eTag)
  return _impl_.etag_.Release();
}
inline void MapData::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  _impl_.etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MapData.eTag)
}

// bool ack = 4;
inline void MapData::clear_ack() {
  _impl_.ack_ = false;
}
inline bool MapData::_internal_ack() const {
  return _impl_.ack_;
}
inline bool MapData::ack() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapData.ack)
  return _internal_ack();
}
inline void MapData::_internal_set_ack(bool value) {
  
  _impl_.ack_ = value;
}
inline void MapData::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MapData.ack)
}

// string seqNum = 5;
inline void MapData::clear_seqnum() {
  _impl_.seqnum_.ClearToEmpty();
}
inline const std::string& MapData::seqnum() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MapData.seqNum)
  return _internal_seqnum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapData::set_seqnum(ArgT0&& arg0, ArgT... args) {
 
 _impl_.seqnum_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MapData.seqNum)
}
inline std::string* MapData::mutable_seqnum() {
  std::string* _s = _internal_mutable_seqnum();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MapData.seqNum)
  return _s;
}
inline const std::string& MapData::_internal_seqnum() const {
  return _impl_.seqnum_.Get();
}
inline void MapData::_internal_set_seqnum(const std::string& value) {
  
  _impl_.seqnum_.Set(value, GetArenaForAllocation());
}
inline std::string* MapData::_internal_mutable_seqnum() {
  
  return _impl_.seqnum_.Mutable(GetArenaForAllocation());
}
inline std::string* MapData::release_seqnum() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MapData.seqNum)
  return _impl_.seqnum_.Release();
}
inline void MapData::set_allocated_seqnum(std::string* seqnum) {
  if (seqnum != nullptr) {
    
  } else {
    
  }
  _impl_.seqnum_.SetAllocated(seqnum, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seqnum_.IsDefault()) {
    _impl_.seqnum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MapData.seqNum)
}

// -------------------------------------------------------------------

// ReqLaneChange

// .cn.seisys.v2x.pb.NodeReferenceId upStreamNode = 1;
inline bool ReqLaneChange::_internal_has_upstreamnode() const {
  return this != internal_default_instance() && _impl_.upstreamnode_ != nullptr;
}
inline bool ReqLaneChange::has_upstreamnode() const {
  return _internal_has_upstreamnode();
}
inline void ReqLaneChange::clear_upstreamnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.upstreamnode_ != nullptr) {
    delete _impl_.upstreamnode_;
  }
  _impl_.upstreamnode_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqLaneChange::_internal_upstreamnode() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.upstreamnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqLaneChange::upstreamnode() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqLaneChange.upStreamNode)
  return _internal_upstreamnode();
}
inline void ReqLaneChange::unsafe_arena_set_allocated_upstreamnode(
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upstreamnode_);
  }
  _impl_.upstreamnode_ = upstreamnode;
  if (upstreamnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqLaneChange.upStreamNode)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqLaneChange::release_upstreamnode() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnode_;
  _impl_.upstreamnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqLaneChange::unsafe_arena_release_upstreamnode() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqLaneChange.upStreamNode)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnode_;
  _impl_.upstreamnode_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqLaneChange::_internal_mutable_upstreamnode() {
  
  if (_impl_.upstreamnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.upstreamnode_ = p;
  }
  return _impl_.upstreamnode_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqLaneChange::mutable_upstreamnode() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_upstreamnode();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqLaneChange.upStreamNode)
  return _msg;
}
inline void ReqLaneChange::set_allocated_upstreamnode(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upstreamnode_;
  }
  if (upstreamnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upstreamnode);
    if (message_arena != submessage_arena) {
      upstreamnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upstreamnode, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.upstreamnode_ = upstreamnode;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReqLaneChange.upStreamNode)
}

// .cn.seisys.v2x.pb.NodeReferenceId downStreamNode = 2;
inline bool ReqLaneChange::_internal_has_downstreamnode() const {
  return this != internal_default_instance() && _impl_.downstreamnode_ != nullptr;
}
inline bool ReqLaneChange::has_downstreamnode() const {
  return _internal_has_downstreamnode();
}
inline void ReqLaneChange::clear_downstreamnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.downstreamnode_ != nullptr) {
    delete _impl_.downstreamnode_;
  }
  _impl_.downstreamnode_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqLaneChange::_internal_downstreamnode() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.downstreamnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqLaneChange::downstreamnode() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqLaneChange.downStreamNode)
  return _internal_downstreamnode();
}
inline void ReqLaneChange::unsafe_arena_set_allocated_downstreamnode(
    ::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.downstreamnode_);
  }
  _impl_.downstreamnode_ = downstreamnode;
  if (downstreamnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqLaneChange.downStreamNode)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqLaneChange::release_downstreamnode() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.downstreamnode_;
  _impl_.downstreamnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqLaneChange::unsafe_arena_release_downstreamnode() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqLaneChange.downStreamNode)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.downstreamnode_;
  _impl_.downstreamnode_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqLaneChange::_internal_mutable_downstreamnode() {
  
  if (_impl_.downstreamnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.downstreamnode_ = p;
  }
  return _impl_.downstreamnode_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqLaneChange::mutable_downstreamnode() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_downstreamnode();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqLaneChange.downStreamNode)
  return _msg;
}
inline void ReqLaneChange::set_allocated_downstreamnode(::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.downstreamnode_;
  }
  if (downstreamnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(downstreamnode);
    if (message_arena != submessage_arena) {
      downstreamnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, downstreamnode, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.downstreamnode_ = downstreamnode;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReqLaneChange.downStreamNode)
}

// uint32 targetLane = 3;
inline void ReqLaneChange::clear_targetlane() {
  _impl_.targetlane_ = 0u;
}
inline uint32_t ReqLaneChange::_internal_targetlane() const {
  return _impl_.targetlane_;
}
inline uint32_t ReqLaneChange::targetlane() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqLaneChange.targetLane)
  return _internal_targetlane();
}
inline void ReqLaneChange::_internal_set_targetlane(uint32_t value) {
  
  _impl_.targetlane_ = value;
}
inline void ReqLaneChange::set_targetlane(uint32_t value) {
  _internal_set_targetlane(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ReqLaneChange.targetLane)
}

// -------------------------------------------------------------------

// ReqClearTheWay

// .cn.seisys.v2x.pb.NodeReferenceId upStreamNode = 1;
inline bool ReqClearTheWay::_internal_has_upstreamnode() const {
  return this != internal_default_instance() && _impl_.upstreamnode_ != nullptr;
}
inline bool ReqClearTheWay::has_upstreamnode() const {
  return _internal_has_upstreamnode();
}
inline void ReqClearTheWay::clear_upstreamnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.upstreamnode_ != nullptr) {
    delete _impl_.upstreamnode_;
  }
  _impl_.upstreamnode_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqClearTheWay::_internal_upstreamnode() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.upstreamnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqClearTheWay::upstreamnode() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqClearTheWay.upStreamNode)
  return _internal_upstreamnode();
}
inline void ReqClearTheWay::unsafe_arena_set_allocated_upstreamnode(
    ::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upstreamnode_);
  }
  _impl_.upstreamnode_ = upstreamnode;
  if (upstreamnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqClearTheWay.upStreamNode)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqClearTheWay::release_upstreamnode() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnode_;
  _impl_.upstreamnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqClearTheWay::unsafe_arena_release_upstreamnode() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqClearTheWay.upStreamNode)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.upstreamnode_;
  _impl_.upstreamnode_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqClearTheWay::_internal_mutable_upstreamnode() {
  
  if (_impl_.upstreamnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.upstreamnode_ = p;
  }
  return _impl_.upstreamnode_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqClearTheWay::mutable_upstreamnode() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_upstreamnode();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqClearTheWay.upStreamNode)
  return _msg;
}
inline void ReqClearTheWay::set_allocated_upstreamnode(::cn::seisys::v2x::pb::NodeReferenceId* upstreamnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upstreamnode_;
  }
  if (upstreamnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upstreamnode);
    if (message_arena != submessage_arena) {
      upstreamnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upstreamnode, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.upstreamnode_ = upstreamnode;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReqClearTheWay.upStreamNode)
}

// .cn.seisys.v2x.pb.NodeReferenceId downStreamNode = 2;
inline bool ReqClearTheWay::_internal_has_downstreamnode() const {
  return this != internal_default_instance() && _impl_.downstreamnode_ != nullptr;
}
inline bool ReqClearTheWay::has_downstreamnode() const {
  return _internal_has_downstreamnode();
}
inline void ReqClearTheWay::clear_downstreamnode() {
  if (GetArenaForAllocation() == nullptr && _impl_.downstreamnode_ != nullptr) {
    delete _impl_.downstreamnode_;
  }
  _impl_.downstreamnode_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqClearTheWay::_internal_downstreamnode() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.downstreamnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqClearTheWay::downstreamnode() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqClearTheWay.downStreamNode)
  return _internal_downstreamnode();
}
inline void ReqClearTheWay::unsafe_arena_set_allocated_downstreamnode(
    ::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.downstreamnode_);
  }
  _impl_.downstreamnode_ = downstreamnode;
  if (downstreamnode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqClearTheWay.downStreamNode)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqClearTheWay::release_downstreamnode() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.downstreamnode_;
  _impl_.downstreamnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqClearTheWay::unsafe_arena_release_downstreamnode() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqClearTheWay.downStreamNode)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.downstreamnode_;
  _impl_.downstreamnode_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqClearTheWay::_internal_mutable_downstreamnode() {
  
  if (_impl_.downstreamnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.downstreamnode_ = p;
  }
  return _impl_.downstreamnode_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqClearTheWay::mutable_downstreamnode() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_downstreamnode();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqClearTheWay.downStreamNode)
  return _msg;
}
inline void ReqClearTheWay::set_allocated_downstreamnode(::cn::seisys::v2x::pb::NodeReferenceId* downstreamnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.downstreamnode_;
  }
  if (downstreamnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(downstreamnode);
    if (message_arena != submessage_arena) {
      downstreamnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, downstreamnode, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.downstreamnode_ = downstreamnode;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReqClearTheWay.downStreamNode)
}

// uint32 targetLane = 3;
inline void ReqClearTheWay::clear_targetlane() {
  _impl_.targetlane_ = 0u;
}
inline uint32_t ReqClearTheWay::_internal_targetlane() const {
  return _impl_.targetlane_;
}
inline uint32_t ReqClearTheWay::targetlane() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqClearTheWay.targetLane)
  return _internal_targetlane();
}
inline void ReqClearTheWay::_internal_set_targetlane(uint32_t value) {
  
  _impl_.targetlane_ = value;
}
inline void ReqClearTheWay::set_targetlane(uint32_t value) {
  _internal_set_targetlane(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ReqClearTheWay.targetLane)
}

// -------------------------------------------------------------------

// ReqSignalPriority

// .cn.seisys.v2x.pb.NodeReferenceId intersectionId = 1;
inline bool ReqSignalPriority::_internal_has_intersectionid() const {
  return this != internal_default_instance() && _impl_.intersectionid_ != nullptr;
}
inline bool ReqSignalPriority::has_intersectionid() const {
  return _internal_has_intersectionid();
}
inline void ReqSignalPriority::clear_intersectionid() {
  if (GetArenaForAllocation() == nullptr && _impl_.intersectionid_ != nullptr) {
    delete _impl_.intersectionid_;
  }
  _impl_.intersectionid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqSignalPriority::_internal_intersectionid() const {
  const ::cn::seisys::v2x::pb::NodeReferenceId* p = _impl_.intersectionid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::NodeReferenceId&>(
      ::cn::seisys::v2x::pb::_NodeReferenceId_default_instance_);
}
inline const ::cn::seisys::v2x::pb::NodeReferenceId& ReqSignalPriority::intersectionid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqSignalPriority.intersectionId)
  return _internal_intersectionid();
}
inline void ReqSignalPriority::unsafe_arena_set_allocated_intersectionid(
    ::cn::seisys::v2x::pb::NodeReferenceId* intersectionid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intersectionid_);
  }
  _impl_.intersectionid_ = intersectionid;
  if (intersectionid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqSignalPriority.intersectionId)
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqSignalPriority::release_intersectionid() {
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.intersectionid_;
  _impl_.intersectionid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqSignalPriority::unsafe_arena_release_intersectionid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqSignalPriority.intersectionId)
  
  ::cn::seisys::v2x::pb::NodeReferenceId* temp = _impl_.intersectionid_;
  _impl_.intersectionid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqSignalPriority::_internal_mutable_intersectionid() {
  
  if (_impl_.intersectionid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::NodeReferenceId>(GetArenaForAllocation());
    _impl_.intersectionid_ = p;
  }
  return _impl_.intersectionid_;
}
inline ::cn::seisys::v2x::pb::NodeReferenceId* ReqSignalPriority::mutable_intersectionid() {
  ::cn::seisys::v2x::pb::NodeReferenceId* _msg = _internal_mutable_intersectionid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqSignalPriority.intersectionId)
  return _msg;
}
inline void ReqSignalPriority::set_allocated_intersectionid(::cn::seisys::v2x::pb::NodeReferenceId* intersectionid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.intersectionid_;
  }
  if (intersectionid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intersectionid);
    if (message_arena != submessage_arena) {
      intersectionid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intersectionid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.intersectionid_ = intersectionid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReqSignalPriority.intersectionId)
}

// .cn.seisys.v2x.pb.MovementStatInfo requiredMove = 2;
inline bool ReqSignalPriority::_internal_has_requiredmove() const {
  return this != internal_default_instance() && _impl_.requiredmove_ != nullptr;
}
inline bool ReqSignalPriority::has_requiredmove() const {
  return _internal_has_requiredmove();
}
inline void ReqSignalPriority::clear_requiredmove() {
  if (GetArenaForAllocation() == nullptr && _impl_.requiredmove_ != nullptr) {
    delete _impl_.requiredmove_;
  }
  _impl_.requiredmove_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::MovementStatInfo& ReqSignalPriority::_internal_requiredmove() const {
  const ::cn::seisys::v2x::pb::MovementStatInfo* p = _impl_.requiredmove_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::MovementStatInfo&>(
      ::cn::seisys::v2x::pb::_MovementStatInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::MovementStatInfo& ReqSignalPriority::requiredmove() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqSignalPriority.requiredMove)
  return _internal_requiredmove();
}
inline void ReqSignalPriority::unsafe_arena_set_allocated_requiredmove(
    ::cn::seisys::v2x::pb::MovementStatInfo* requiredmove) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requiredmove_);
  }
  _impl_.requiredmove_ = requiredmove;
  if (requiredmove) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqSignalPriority.requiredMove)
}
inline ::cn::seisys::v2x::pb::MovementStatInfo* ReqSignalPriority::release_requiredmove() {
  
  ::cn::seisys::v2x::pb::MovementStatInfo* temp = _impl_.requiredmove_;
  _impl_.requiredmove_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::MovementStatInfo* ReqSignalPriority::unsafe_arena_release_requiredmove() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqSignalPriority.requiredMove)
  
  ::cn::seisys::v2x::pb::MovementStatInfo* temp = _impl_.requiredmove_;
  _impl_.requiredmove_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::MovementStatInfo* ReqSignalPriority::_internal_mutable_requiredmove() {
  
  if (_impl_.requiredmove_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::MovementStatInfo>(GetArenaForAllocation());
    _impl_.requiredmove_ = p;
  }
  return _impl_.requiredmove_;
}
inline ::cn::seisys::v2x::pb::MovementStatInfo* ReqSignalPriority::mutable_requiredmove() {
  ::cn::seisys::v2x::pb::MovementStatInfo* _msg = _internal_mutable_requiredmove();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqSignalPriority.requiredMove)
  return _msg;
}
inline void ReqSignalPriority::set_allocated_requiredmove(::cn::seisys::v2x::pb::MovementStatInfo* requiredmove) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.requiredmove_;
  }
  if (requiredmove) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(requiredmove);
    if (message_arena != submessage_arena) {
      requiredmove = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requiredmove, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.requiredmove_ = requiredmove;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReqSignalPriority.requiredMove)
}

// uint32 estimatedArrivalTime = 3;
inline void ReqSignalPriority::clear_estimatedarrivaltime() {
  _impl_.estimatedarrivaltime_ = 0u;
}
inline uint32_t ReqSignalPriority::_internal_estimatedarrivaltime() const {
  return _impl_.estimatedarrivaltime_;
}
inline uint32_t ReqSignalPriority::estimatedarrivaltime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqSignalPriority.estimatedArrivalTime)
  return _internal_estimatedarrivaltime();
}
inline void ReqSignalPriority::_internal_set_estimatedarrivaltime(uint32_t value) {
  
  _impl_.estimatedarrivaltime_ = value;
}
inline void ReqSignalPriority::set_estimatedarrivaltime(uint32_t value) {
  _internal_set_estimatedarrivaltime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ReqSignalPriority.estimatedArrivalTime)
}

// uint32 distance2Intersection = 4;
inline void ReqSignalPriority::clear_distance2intersection() {
  _impl_.distance2intersection_ = 0u;
}
inline uint32_t ReqSignalPriority::_internal_distance2intersection() const {
  return _impl_.distance2intersection_;
}
inline uint32_t ReqSignalPriority::distance2intersection() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqSignalPriority.distance2Intersection)
  return _internal_distance2intersection();
}
inline void ReqSignalPriority::_internal_set_distance2intersection(uint32_t value) {
  
  _impl_.distance2intersection_ = value;
}
inline void ReqSignalPriority::set_distance2intersection(uint32_t value) {
  _internal_set_distance2intersection(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ReqSignalPriority.distance2Intersection)
}

// -------------------------------------------------------------------

// ReqSensorSharing

// repeated .cn.seisys.v2x.pb.ReferencePath detectorArea = 1;
inline int ReqSensorSharing::_internal_detectorarea_size() const {
  return _impl_.detectorarea_.size();
}
inline int ReqSensorSharing::detectorarea_size() const {
  return _internal_detectorarea_size();
}
inline void ReqSensorSharing::clear_detectorarea() {
  _impl_.detectorarea_.Clear();
}
inline ::cn::seisys::v2x::pb::ReferencePath* ReqSensorSharing::mutable_detectorarea(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqSensorSharing.detectorArea)
  return _impl_.detectorarea_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >*
ReqSensorSharing::mutable_detectorarea() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.ReqSensorSharing.detectorArea)
  return &_impl_.detectorarea_;
}
inline const ::cn::seisys::v2x::pb::ReferencePath& ReqSensorSharing::_internal_detectorarea(int index) const {
  return _impl_.detectorarea_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ReferencePath& ReqSensorSharing::detectorarea(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqSensorSharing.detectorArea)
  return _internal_detectorarea(index);
}
inline ::cn::seisys::v2x::pb::ReferencePath* ReqSensorSharing::_internal_add_detectorarea() {
  return _impl_.detectorarea_.Add();
}
inline ::cn::seisys::v2x::pb::ReferencePath* ReqSensorSharing::add_detectorarea() {
  ::cn::seisys::v2x::pb::ReferencePath* _add = _internal_add_detectorarea();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.ReqSensorSharing.detectorArea)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ReferencePath >&
ReqSensorSharing::detectorarea() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.ReqSensorSharing.detectorArea)
  return _impl_.detectorarea_;
}

// -------------------------------------------------------------------

// ParkingRequest

// uint32 req = 1;
inline void ParkingRequest::clear_req() {
  _impl_.req_ = 0u;
}
inline uint32_t ParkingRequest::_internal_req() const {
  return _impl_.req_;
}
inline uint32_t ParkingRequest::req() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParkingRequest.req)
  return _internal_req();
}
inline void ParkingRequest::_internal_set_req(uint32_t value) {
  
  _impl_.req_ = value;
}
inline void ParkingRequest::set_req(uint32_t value) {
  _internal_set_req(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParkingRequest.req)
}

// -------------------------------------------------------------------

// ParkingType

// uint32 parkingType = 1;
inline void ParkingType::clear_parkingtype() {
  _impl_.parkingtype_ = 0u;
}
inline uint32_t ParkingType::_internal_parkingtype() const {
  return _impl_.parkingtype_;
}
inline uint32_t ParkingType::parkingtype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ParkingType.parkingType)
  return _internal_parkingtype();
}
inline void ParkingType::_internal_set_parkingtype(uint32_t value) {
  
  _impl_.parkingtype_ = value;
}
inline void ParkingType::set_parkingtype(uint32_t value) {
  _internal_set_parkingtype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ParkingType.parkingType)
}

// -------------------------------------------------------------------

// ReqParkingArea

// .cn.seisys.v2x.pb.VehicleType vehicleType = 1;
inline void ReqParkingArea::clear_vehicletype() {
  _impl_.vehicletype_ = 0;
}
inline ::cn::seisys::v2x::pb::VehicleType ReqParkingArea::_internal_vehicletype() const {
  return static_cast< ::cn::seisys::v2x::pb::VehicleType >(_impl_.vehicletype_);
}
inline ::cn::seisys::v2x::pb::VehicleType ReqParkingArea::vehicletype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqParkingArea.vehicleType)
  return _internal_vehicletype();
}
inline void ReqParkingArea::_internal_set_vehicletype(::cn::seisys::v2x::pb::VehicleType value) {
  
  _impl_.vehicletype_ = value;
}
inline void ReqParkingArea::set_vehicletype(::cn::seisys::v2x::pb::VehicleType value) {
  _internal_set_vehicletype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ReqParkingArea.vehicleType)
}

// .cn.seisys.v2x.pb.ParkingRequest req = 2;
inline bool ReqParkingArea::_internal_has_req() const {
  return this != internal_default_instance() && _impl_.req_ != nullptr;
}
inline bool ReqParkingArea::has_req() const {
  return _internal_has_req();
}
inline void ReqParkingArea::clear_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.req_ != nullptr) {
    delete _impl_.req_;
  }
  _impl_.req_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ParkingRequest& ReqParkingArea::_internal_req() const {
  const ::cn::seisys::v2x::pb::ParkingRequest* p = _impl_.req_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ParkingRequest&>(
      ::cn::seisys::v2x::pb::_ParkingRequest_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ParkingRequest& ReqParkingArea::req() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqParkingArea.req)
  return _internal_req();
}
inline void ReqParkingArea::unsafe_arena_set_allocated_req(
    ::cn::seisys::v2x::pb::ParkingRequest* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.req_);
  }
  _impl_.req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqParkingArea.req)
}
inline ::cn::seisys::v2x::pb::ParkingRequest* ReqParkingArea::release_req() {
  
  ::cn::seisys::v2x::pb::ParkingRequest* temp = _impl_.req_;
  _impl_.req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ParkingRequest* ReqParkingArea::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqParkingArea.req)
  
  ::cn::seisys::v2x::pb::ParkingRequest* temp = _impl_.req_;
  _impl_.req_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ParkingRequest* ReqParkingArea::_internal_mutable_req() {
  
  if (_impl_.req_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ParkingRequest>(GetArenaForAllocation());
    _impl_.req_ = p;
  }
  return _impl_.req_;
}
inline ::cn::seisys::v2x::pb::ParkingRequest* ReqParkingArea::mutable_req() {
  ::cn::seisys::v2x::pb::ParkingRequest* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqParkingArea.req)
  return _msg;
}
inline void ReqParkingArea::set_allocated_req(::cn::seisys::v2x::pb::ParkingRequest* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.req_ = req;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReqParkingArea.req)
}

// .cn.seisys.v2x.pb.ParkingType parkingType = 3;
inline bool ReqParkingArea::_internal_has_parkingtype() const {
  return this != internal_default_instance() && _impl_.parkingtype_ != nullptr;
}
inline bool ReqParkingArea::has_parkingtype() const {
  return _internal_has_parkingtype();
}
inline void ReqParkingArea::clear_parkingtype() {
  if (GetArenaForAllocation() == nullptr && _impl_.parkingtype_ != nullptr) {
    delete _impl_.parkingtype_;
  }
  _impl_.parkingtype_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ParkingType& ReqParkingArea::_internal_parkingtype() const {
  const ::cn::seisys::v2x::pb::ParkingType* p = _impl_.parkingtype_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ParkingType&>(
      ::cn::seisys::v2x::pb::_ParkingType_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ParkingType& ReqParkingArea::parkingtype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqParkingArea.parkingType)
  return _internal_parkingtype();
}
inline void ReqParkingArea::unsafe_arena_set_allocated_parkingtype(
    ::cn::seisys::v2x::pb::ParkingType* parkingtype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parkingtype_);
  }
  _impl_.parkingtype_ = parkingtype;
  if (parkingtype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqParkingArea.parkingType)
}
inline ::cn::seisys::v2x::pb::ParkingType* ReqParkingArea::release_parkingtype() {
  
  ::cn::seisys::v2x::pb::ParkingType* temp = _impl_.parkingtype_;
  _impl_.parkingtype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ParkingType* ReqParkingArea::unsafe_arena_release_parkingtype() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqParkingArea.parkingType)
  
  ::cn::seisys::v2x::pb::ParkingType* temp = _impl_.parkingtype_;
  _impl_.parkingtype_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ParkingType* ReqParkingArea::_internal_mutable_parkingtype() {
  
  if (_impl_.parkingtype_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ParkingType>(GetArenaForAllocation());
    _impl_.parkingtype_ = p;
  }
  return _impl_.parkingtype_;
}
inline ::cn::seisys::v2x::pb::ParkingType* ReqParkingArea::mutable_parkingtype() {
  ::cn::seisys::v2x::pb::ParkingType* _msg = _internal_mutable_parkingtype();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqParkingArea.parkingType)
  return _msg;
}
inline void ReqParkingArea::set_allocated_parkingtype(::cn::seisys::v2x::pb::ParkingType* parkingtype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parkingtype_;
  }
  if (parkingtype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parkingtype);
    if (message_arena != submessage_arena) {
      parkingtype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parkingtype, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parkingtype_ = parkingtype;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.ReqParkingArea.parkingType)
}

// uint32 expectedParkingSlotId = 4;
inline void ReqParkingArea::clear_expectedparkingslotid() {
  _impl_.expectedparkingslotid_ = 0u;
}
inline uint32_t ReqParkingArea::_internal_expectedparkingslotid() const {
  return _impl_.expectedparkingslotid_;
}
inline uint32_t ReqParkingArea::expectedparkingslotid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqParkingArea.expectedParkingSlotId)
  return _internal_expectedparkingslotid();
}
inline void ReqParkingArea::_internal_set_expectedparkingslotid(uint32_t value) {
  
  _impl_.expectedparkingslotid_ = value;
}
inline void ReqParkingArea::set_expectedparkingslotid(uint32_t value) {
  _internal_set_expectedparkingslotid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.ReqParkingArea.expectedParkingSlotId)
}

// -------------------------------------------------------------------

// ReqInfo

// .cn.seisys.v2x.pb.ReqLaneChange laneChange = 1;
inline bool ReqInfo::_internal_has_lanechange() const {
  return ReqInfoOneOf_case() == kLaneChange;
}
inline bool ReqInfo::has_lanechange() const {
  return _internal_has_lanechange();
}
inline void ReqInfo::set_has_lanechange() {
  _impl_._oneof_case_[0] = kLaneChange;
}
inline void ReqInfo::clear_lanechange() {
  if (_internal_has_lanechange()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ReqInfoOneOf_.lanechange_;
    }
    clear_has_ReqInfoOneOf();
  }
}
inline ::cn::seisys::v2x::pb::ReqLaneChange* ReqInfo::release_lanechange() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqInfo.laneChange)
  if (_internal_has_lanechange()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqLaneChange* temp = _impl_.ReqInfoOneOf_.lanechange_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ReqInfoOneOf_.lanechange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::ReqLaneChange& ReqInfo::_internal_lanechange() const {
  return _internal_has_lanechange()
      ? *_impl_.ReqInfoOneOf_.lanechange_
      : reinterpret_cast< ::cn::seisys::v2x::pb::ReqLaneChange&>(::cn::seisys::v2x::pb::_ReqLaneChange_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReqLaneChange& ReqInfo::lanechange() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqInfo.laneChange)
  return _internal_lanechange();
}
inline ::cn::seisys::v2x::pb::ReqLaneChange* ReqInfo::unsafe_arena_release_lanechange() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.ReqInfo.laneChange)
  if (_internal_has_lanechange()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqLaneChange* temp = _impl_.ReqInfoOneOf_.lanechange_;
    _impl_.ReqInfoOneOf_.lanechange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReqInfo::unsafe_arena_set_allocated_lanechange(::cn::seisys::v2x::pb::ReqLaneChange* lanechange) {
  clear_ReqInfoOneOf();
  if (lanechange) {
    set_has_lanechange();
    _impl_.ReqInfoOneOf_.lanechange_ = lanechange;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqInfo.laneChange)
}
inline ::cn::seisys::v2x::pb::ReqLaneChange* ReqInfo::_internal_mutable_lanechange() {
  if (!_internal_has_lanechange()) {
    clear_ReqInfoOneOf();
    set_has_lanechange();
    _impl_.ReqInfoOneOf_.lanechange_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::ReqLaneChange >(GetArenaForAllocation());
  }
  return _impl_.ReqInfoOneOf_.lanechange_;
}
inline ::cn::seisys::v2x::pb::ReqLaneChange* ReqInfo::mutable_lanechange() {
  ::cn::seisys::v2x::pb::ReqLaneChange* _msg = _internal_mutable_lanechange();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqInfo.laneChange)
  return _msg;
}

// .cn.seisys.v2x.pb.ReqClearTheWay clearTheWay = 2;
inline bool ReqInfo::_internal_has_cleartheway() const {
  return ReqInfoOneOf_case() == kClearTheWay;
}
inline bool ReqInfo::has_cleartheway() const {
  return _internal_has_cleartheway();
}
inline void ReqInfo::set_has_cleartheway() {
  _impl_._oneof_case_[0] = kClearTheWay;
}
inline void ReqInfo::clear_cleartheway() {
  if (_internal_has_cleartheway()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ReqInfoOneOf_.cleartheway_;
    }
    clear_has_ReqInfoOneOf();
  }
}
inline ::cn::seisys::v2x::pb::ReqClearTheWay* ReqInfo::release_cleartheway() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqInfo.clearTheWay)
  if (_internal_has_cleartheway()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqClearTheWay* temp = _impl_.ReqInfoOneOf_.cleartheway_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ReqInfoOneOf_.cleartheway_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::ReqClearTheWay& ReqInfo::_internal_cleartheway() const {
  return _internal_has_cleartheway()
      ? *_impl_.ReqInfoOneOf_.cleartheway_
      : reinterpret_cast< ::cn::seisys::v2x::pb::ReqClearTheWay&>(::cn::seisys::v2x::pb::_ReqClearTheWay_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReqClearTheWay& ReqInfo::cleartheway() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqInfo.clearTheWay)
  return _internal_cleartheway();
}
inline ::cn::seisys::v2x::pb::ReqClearTheWay* ReqInfo::unsafe_arena_release_cleartheway() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.ReqInfo.clearTheWay)
  if (_internal_has_cleartheway()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqClearTheWay* temp = _impl_.ReqInfoOneOf_.cleartheway_;
    _impl_.ReqInfoOneOf_.cleartheway_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReqInfo::unsafe_arena_set_allocated_cleartheway(::cn::seisys::v2x::pb::ReqClearTheWay* cleartheway) {
  clear_ReqInfoOneOf();
  if (cleartheway) {
    set_has_cleartheway();
    _impl_.ReqInfoOneOf_.cleartheway_ = cleartheway;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqInfo.clearTheWay)
}
inline ::cn::seisys::v2x::pb::ReqClearTheWay* ReqInfo::_internal_mutable_cleartheway() {
  if (!_internal_has_cleartheway()) {
    clear_ReqInfoOneOf();
    set_has_cleartheway();
    _impl_.ReqInfoOneOf_.cleartheway_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::ReqClearTheWay >(GetArenaForAllocation());
  }
  return _impl_.ReqInfoOneOf_.cleartheway_;
}
inline ::cn::seisys::v2x::pb::ReqClearTheWay* ReqInfo::mutable_cleartheway() {
  ::cn::seisys::v2x::pb::ReqClearTheWay* _msg = _internal_mutable_cleartheway();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqInfo.clearTheWay)
  return _msg;
}

// .cn.seisys.v2x.pb.ReqSignalPriority signalPriority = 3;
inline bool ReqInfo::_internal_has_signalpriority() const {
  return ReqInfoOneOf_case() == kSignalPriority;
}
inline bool ReqInfo::has_signalpriority() const {
  return _internal_has_signalpriority();
}
inline void ReqInfo::set_has_signalpriority() {
  _impl_._oneof_case_[0] = kSignalPriority;
}
inline void ReqInfo::clear_signalpriority() {
  if (_internal_has_signalpriority()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ReqInfoOneOf_.signalpriority_;
    }
    clear_has_ReqInfoOneOf();
  }
}
inline ::cn::seisys::v2x::pb::ReqSignalPriority* ReqInfo::release_signalpriority() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqInfo.signalPriority)
  if (_internal_has_signalpriority()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqSignalPriority* temp = _impl_.ReqInfoOneOf_.signalpriority_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ReqInfoOneOf_.signalpriority_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::ReqSignalPriority& ReqInfo::_internal_signalpriority() const {
  return _internal_has_signalpriority()
      ? *_impl_.ReqInfoOneOf_.signalpriority_
      : reinterpret_cast< ::cn::seisys::v2x::pb::ReqSignalPriority&>(::cn::seisys::v2x::pb::_ReqSignalPriority_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReqSignalPriority& ReqInfo::signalpriority() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqInfo.signalPriority)
  return _internal_signalpriority();
}
inline ::cn::seisys::v2x::pb::ReqSignalPriority* ReqInfo::unsafe_arena_release_signalpriority() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.ReqInfo.signalPriority)
  if (_internal_has_signalpriority()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqSignalPriority* temp = _impl_.ReqInfoOneOf_.signalpriority_;
    _impl_.ReqInfoOneOf_.signalpriority_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReqInfo::unsafe_arena_set_allocated_signalpriority(::cn::seisys::v2x::pb::ReqSignalPriority* signalpriority) {
  clear_ReqInfoOneOf();
  if (signalpriority) {
    set_has_signalpriority();
    _impl_.ReqInfoOneOf_.signalpriority_ = signalpriority;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqInfo.signalPriority)
}
inline ::cn::seisys::v2x::pb::ReqSignalPriority* ReqInfo::_internal_mutable_signalpriority() {
  if (!_internal_has_signalpriority()) {
    clear_ReqInfoOneOf();
    set_has_signalpriority();
    _impl_.ReqInfoOneOf_.signalpriority_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::ReqSignalPriority >(GetArenaForAllocation());
  }
  return _impl_.ReqInfoOneOf_.signalpriority_;
}
inline ::cn::seisys::v2x::pb::ReqSignalPriority* ReqInfo::mutable_signalpriority() {
  ::cn::seisys::v2x::pb::ReqSignalPriority* _msg = _internal_mutable_signalpriority();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqInfo.signalPriority)
  return _msg;
}

// .cn.seisys.v2x.pb.ReqSensorSharing sensorSharing = 4;
inline bool ReqInfo::_internal_has_sensorsharing() const {
  return ReqInfoOneOf_case() == kSensorSharing;
}
inline bool ReqInfo::has_sensorsharing() const {
  return _internal_has_sensorsharing();
}
inline void ReqInfo::set_has_sensorsharing() {
  _impl_._oneof_case_[0] = kSensorSharing;
}
inline void ReqInfo::clear_sensorsharing() {
  if (_internal_has_sensorsharing()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ReqInfoOneOf_.sensorsharing_;
    }
    clear_has_ReqInfoOneOf();
  }
}
inline ::cn::seisys::v2x::pb::ReqSensorSharing* ReqInfo::release_sensorsharing() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqInfo.sensorSharing)
  if (_internal_has_sensorsharing()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqSensorSharing* temp = _impl_.ReqInfoOneOf_.sensorsharing_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ReqInfoOneOf_.sensorsharing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::ReqSensorSharing& ReqInfo::_internal_sensorsharing() const {
  return _internal_has_sensorsharing()
      ? *_impl_.ReqInfoOneOf_.sensorsharing_
      : reinterpret_cast< ::cn::seisys::v2x::pb::ReqSensorSharing&>(::cn::seisys::v2x::pb::_ReqSensorSharing_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReqSensorSharing& ReqInfo::sensorsharing() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqInfo.sensorSharing)
  return _internal_sensorsharing();
}
inline ::cn::seisys::v2x::pb::ReqSensorSharing* ReqInfo::unsafe_arena_release_sensorsharing() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.ReqInfo.sensorSharing)
  if (_internal_has_sensorsharing()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqSensorSharing* temp = _impl_.ReqInfoOneOf_.sensorsharing_;
    _impl_.ReqInfoOneOf_.sensorsharing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReqInfo::unsafe_arena_set_allocated_sensorsharing(::cn::seisys::v2x::pb::ReqSensorSharing* sensorsharing) {
  clear_ReqInfoOneOf();
  if (sensorsharing) {
    set_has_sensorsharing();
    _impl_.ReqInfoOneOf_.sensorsharing_ = sensorsharing;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqInfo.sensorSharing)
}
inline ::cn::seisys::v2x::pb::ReqSensorSharing* ReqInfo::_internal_mutable_sensorsharing() {
  if (!_internal_has_sensorsharing()) {
    clear_ReqInfoOneOf();
    set_has_sensorsharing();
    _impl_.ReqInfoOneOf_.sensorsharing_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::ReqSensorSharing >(GetArenaForAllocation());
  }
  return _impl_.ReqInfoOneOf_.sensorsharing_;
}
inline ::cn::seisys::v2x::pb::ReqSensorSharing* ReqInfo::mutable_sensorsharing() {
  ::cn::seisys::v2x::pb::ReqSensorSharing* _msg = _internal_mutable_sensorsharing();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqInfo.sensorSharing)
  return _msg;
}

// .cn.seisys.v2x.pb.ReqParkingArea parking = 5;
inline bool ReqInfo::_internal_has_parking() const {
  return ReqInfoOneOf_case() == kParking;
}
inline bool ReqInfo::has_parking() const {
  return _internal_has_parking();
}
inline void ReqInfo::set_has_parking() {
  _impl_._oneof_case_[0] = kParking;
}
inline void ReqInfo::clear_parking() {
  if (_internal_has_parking()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ReqInfoOneOf_.parking_;
    }
    clear_has_ReqInfoOneOf();
  }
}
inline ::cn::seisys::v2x::pb::ReqParkingArea* ReqInfo::release_parking() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.ReqInfo.parking)
  if (_internal_has_parking()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqParkingArea* temp = _impl_.ReqInfoOneOf_.parking_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ReqInfoOneOf_.parking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cn::seisys::v2x::pb::ReqParkingArea& ReqInfo::_internal_parking() const {
  return _internal_has_parking()
      ? *_impl_.ReqInfoOneOf_.parking_
      : reinterpret_cast< ::cn::seisys::v2x::pb::ReqParkingArea&>(::cn::seisys::v2x::pb::_ReqParkingArea_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReqParkingArea& ReqInfo::parking() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.ReqInfo.parking)
  return _internal_parking();
}
inline ::cn::seisys::v2x::pb::ReqParkingArea* ReqInfo::unsafe_arena_release_parking() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cn.seisys.v2x.pb.ReqInfo.parking)
  if (_internal_has_parking()) {
    clear_has_ReqInfoOneOf();
    ::cn::seisys::v2x::pb::ReqParkingArea* temp = _impl_.ReqInfoOneOf_.parking_;
    _impl_.ReqInfoOneOf_.parking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReqInfo::unsafe_arena_set_allocated_parking(::cn::seisys::v2x::pb::ReqParkingArea* parking) {
  clear_ReqInfoOneOf();
  if (parking) {
    set_has_parking();
    _impl_.ReqInfoOneOf_.parking_ = parking;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.ReqInfo.parking)
}
inline ::cn::seisys::v2x::pb::ReqParkingArea* ReqInfo::_internal_mutable_parking() {
  if (!_internal_has_parking()) {
    clear_ReqInfoOneOf();
    set_has_parking();
    _impl_.ReqInfoOneOf_.parking_ = CreateMaybeMessage< ::cn::seisys::v2x::pb::ReqParkingArea >(GetArenaForAllocation());
  }
  return _impl_.ReqInfoOneOf_.parking_;
}
inline ::cn::seisys::v2x::pb::ReqParkingArea* ReqInfo::mutable_parking() {
  ::cn::seisys::v2x::pb::ReqParkingArea* _msg = _internal_mutable_parking();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.ReqInfo.parking)
  return _msg;
}

inline bool ReqInfo::has_ReqInfoOneOf() const {
  return ReqInfoOneOf_case() != REQINFOONEOF_NOT_SET;
}
inline void ReqInfo::clear_has_ReqInfoOneOf() {
  _impl_._oneof_case_[0] = REQINFOONEOF_NOT_SET;
}
inline ReqInfo::ReqInfoOneOfCase ReqInfo::ReqInfoOneOf_case() const {
  return ReqInfo::ReqInfoOneOfCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DriveRequest

// uint32 reqId = 1;
inline void DriveRequest::clear_reqid() {
  _impl_.reqid_ = 0u;
}
inline uint32_t DriveRequest::_internal_reqid() const {
  return _impl_.reqid_;
}
inline uint32_t DriveRequest::reqid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveRequest.reqId)
  return _internal_reqid();
}
inline void DriveRequest::_internal_set_reqid(uint32_t value) {
  
  _impl_.reqid_ = value;
}
inline void DriveRequest::set_reqid(uint32_t value) {
  _internal_set_reqid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DriveRequest.reqId)
}

// .cn.seisys.v2x.pb.DriveRequest.ReqStatus status = 2;
inline void DriveRequest::clear_status() {
  _impl_.status_ = 0;
}
inline ::cn::seisys::v2x::pb::DriveRequest_ReqStatus DriveRequest::_internal_status() const {
  return static_cast< ::cn::seisys::v2x::pb::DriveRequest_ReqStatus >(_impl_.status_);
}
inline ::cn::seisys::v2x::pb::DriveRequest_ReqStatus DriveRequest::status() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveRequest.status)
  return _internal_status();
}
inline void DriveRequest::_internal_set_status(::cn::seisys::v2x::pb::DriveRequest_ReqStatus value) {
  
  _impl_.status_ = value;
}
inline void DriveRequest::set_status(::cn::seisys::v2x::pb::DriveRequest_ReqStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DriveRequest.status)
}

// string reqPriority = 3;
inline void DriveRequest::clear_reqpriority() {
  _impl_.reqpriority_.ClearToEmpty();
}
inline const std::string& DriveRequest::reqpriority() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveRequest.reqPriority)
  return _internal_reqpriority();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DriveRequest::set_reqpriority(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reqpriority_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DriveRequest.reqPriority)
}
inline std::string* DriveRequest::mutable_reqpriority() {
  std::string* _s = _internal_mutable_reqpriority();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DriveRequest.reqPriority)
  return _s;
}
inline const std::string& DriveRequest::_internal_reqpriority() const {
  return _impl_.reqpriority_.Get();
}
inline void DriveRequest::_internal_set_reqpriority(const std::string& value) {
  
  _impl_.reqpriority_.Set(value, GetArenaForAllocation());
}
inline std::string* DriveRequest::_internal_mutable_reqpriority() {
  
  return _impl_.reqpriority_.Mutable(GetArenaForAllocation());
}
inline std::string* DriveRequest::release_reqpriority() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DriveRequest.reqPriority)
  return _impl_.reqpriority_.Release();
}
inline void DriveRequest::set_allocated_reqpriority(std::string* reqpriority) {
  if (reqpriority != nullptr) {
    
  } else {
    
  }
  _impl_.reqpriority_.SetAllocated(reqpriority, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reqpriority_.IsDefault()) {
    _impl_.reqpriority_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DriveRequest.reqPriority)
}

// string targetVeh = 4;
inline void DriveRequest::clear_targetveh() {
  _impl_.targetveh_.ClearToEmpty();
}
inline const std::string& DriveRequest::targetveh() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveRequest.targetVeh)
  return _internal_targetveh();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DriveRequest::set_targetveh(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targetveh_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DriveRequest.targetVeh)
}
inline std::string* DriveRequest::mutable_targetveh() {
  std::string* _s = _internal_mutable_targetveh();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DriveRequest.targetVeh)
  return _s;
}
inline const std::string& DriveRequest::_internal_targetveh() const {
  return _impl_.targetveh_.Get();
}
inline void DriveRequest::_internal_set_targetveh(const std::string& value) {
  
  _impl_.targetveh_.Set(value, GetArenaForAllocation());
}
inline std::string* DriveRequest::_internal_mutable_targetveh() {
  
  return _impl_.targetveh_.Mutable(GetArenaForAllocation());
}
inline std::string* DriveRequest::release_targetveh() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DriveRequest.targetVeh)
  return _impl_.targetveh_.Release();
}
inline void DriveRequest::set_allocated_targetveh(std::string* targetveh) {
  if (targetveh != nullptr) {
    
  } else {
    
  }
  _impl_.targetveh_.SetAllocated(targetveh, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targetveh_.IsDefault()) {
    _impl_.targetveh_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DriveRequest.targetVeh)
}

// string targetRsu = 5;
inline void DriveRequest::clear_targetrsu() {
  _impl_.targetrsu_.ClearToEmpty();
}
inline const std::string& DriveRequest::targetrsu() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveRequest.targetRsu)
  return _internal_targetrsu();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DriveRequest::set_targetrsu(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targetrsu_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DriveRequest.targetRsu)
}
inline std::string* DriveRequest::mutable_targetrsu() {
  std::string* _s = _internal_mutable_targetrsu();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DriveRequest.targetRsu)
  return _s;
}
inline const std::string& DriveRequest::_internal_targetrsu() const {
  return _impl_.targetrsu_.Get();
}
inline void DriveRequest::_internal_set_targetrsu(const std::string& value) {
  
  _impl_.targetrsu_.Set(value, GetArenaForAllocation());
}
inline std::string* DriveRequest::_internal_mutable_targetrsu() {
  
  return _impl_.targetrsu_.Mutable(GetArenaForAllocation());
}
inline std::string* DriveRequest::release_targetrsu() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DriveRequest.targetRsu)
  return _impl_.targetrsu_.Release();
}
inline void DriveRequest::set_allocated_targetrsu(std::string* targetrsu) {
  if (targetrsu != nullptr) {
    
  } else {
    
  }
  _impl_.targetrsu_.SetAllocated(targetrsu, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targetrsu_.IsDefault()) {
    _impl_.targetrsu_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DriveRequest.targetRsu)
}

// .cn.seisys.v2x.pb.ReqInfo info = 6;
inline bool DriveRequest::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool DriveRequest::has_info() const {
  return _internal_has_info();
}
inline void DriveRequest::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ReqInfo& DriveRequest::_internal_info() const {
  const ::cn::seisys::v2x::pb::ReqInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ReqInfo&>(
      ::cn::seisys::v2x::pb::_ReqInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReqInfo& DriveRequest::info() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveRequest.info)
  return _internal_info();
}
inline void DriveRequest::unsafe_arena_set_allocated_info(
    ::cn::seisys::v2x::pb::ReqInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.DriveRequest.info)
}
inline ::cn::seisys::v2x::pb::ReqInfo* DriveRequest::release_info() {
  
  ::cn::seisys::v2x::pb::ReqInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ReqInfo* DriveRequest::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DriveRequest.info)
  
  ::cn::seisys::v2x::pb::ReqInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ReqInfo* DriveRequest::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ReqInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::cn::seisys::v2x::pb::ReqInfo* DriveRequest::mutable_info() {
  ::cn::seisys::v2x::pb::ReqInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DriveRequest.info)
  return _msg;
}
inline void DriveRequest::set_allocated_info(::cn::seisys::v2x::pb::ReqInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DriveRequest.info)
}

// uint32 lifeTime = 7;
inline void DriveRequest::clear_lifetime() {
  _impl_.lifetime_ = 0u;
}
inline uint32_t DriveRequest::_internal_lifetime() const {
  return _impl_.lifetime_;
}
inline uint32_t DriveRequest::lifetime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveRequest.lifeTime)
  return _internal_lifetime();
}
inline void DriveRequest::_internal_set_lifetime(uint32_t value) {
  
  _impl_.lifetime_ = value;
}
inline void DriveRequest::set_lifetime(uint32_t value) {
  _internal_set_lifetime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DriveRequest.lifeTime)
}

// -------------------------------------------------------------------

// DriveBehavior

// int32 driveBehavior = 1;
inline void DriveBehavior::clear_drivebehavior() {
  _impl_.drivebehavior_ = 0;
}
inline int32_t DriveBehavior::_internal_drivebehavior() const {
  return _impl_.drivebehavior_;
}
inline int32_t DriveBehavior::drivebehavior() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveBehavior.driveBehavior)
  return _internal_drivebehavior();
}
inline void DriveBehavior::_internal_set_drivebehavior(int32_t value) {
  
  _impl_.drivebehavior_ = value;
}
inline void DriveBehavior::set_drivebehavior(int32_t value) {
  _internal_set_drivebehavior(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DriveBehavior.driveBehavior)
}

// -------------------------------------------------------------------

// PathPlanningPoint

// .cn.seisys.v2x.pb.Position3D pos = 1;
inline bool PathPlanningPoint::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool PathPlanningPoint::has_pos() const {
  return _internal_has_pos();
}
inline void PathPlanningPoint::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& PathPlanningPoint::_internal_pos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& PathPlanningPoint::pos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.pos)
  return _internal_pos();
}
inline void PathPlanningPoint::unsafe_arena_set_allocated_pos(
    ::cn::seisys::v2x::pb::Position3D* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.pos)
}
inline ::cn::seisys::v2x::pb::Position3D* PathPlanningPoint::release_pos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* PathPlanningPoint::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PathPlanningPoint.pos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* PathPlanningPoint::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::cn::seisys::v2x::pb::Position3D* PathPlanningPoint::mutable_pos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PathPlanningPoint.pos)
  return _msg;
}
inline void PathPlanningPoint::set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.pos)
}

// .cn.seisys.v2x.pb.PositionConfidenceSet posConfid = 2;
inline bool PathPlanningPoint::_internal_has_posconfid() const {
  return this != internal_default_instance() && _impl_.posconfid_ != nullptr;
}
inline bool PathPlanningPoint::has_posconfid() const {
  return _internal_has_posconfid();
}
inline void PathPlanningPoint::clear_posconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.posconfid_ != nullptr) {
    delete _impl_.posconfid_;
  }
  _impl_.posconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& PathPlanningPoint::_internal_posconfid() const {
  const ::cn::seisys::v2x::pb::PositionConfidenceSet* p = _impl_.posconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::PositionConfidenceSet&>(
      ::cn::seisys::v2x::pb::_PositionConfidenceSet_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PositionConfidenceSet& PathPlanningPoint::posconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.posConfid)
  return _internal_posconfid();
}
inline void PathPlanningPoint::unsafe_arena_set_allocated_posconfid(
    ::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posconfid_);
  }
  _impl_.posconfid_ = posconfid;
  if (posconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.posConfid)
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* PathPlanningPoint::release_posconfid() {
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* PathPlanningPoint::unsafe_arena_release_posconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PathPlanningPoint.posConfid)
  
  ::cn::seisys::v2x::pb::PositionConfidenceSet* temp = _impl_.posconfid_;
  _impl_.posconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* PathPlanningPoint::_internal_mutable_posconfid() {
  
  if (_impl_.posconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::PositionConfidenceSet>(GetArenaForAllocation());
    _impl_.posconfid_ = p;
  }
  return _impl_.posconfid_;
}
inline ::cn::seisys::v2x::pb::PositionConfidenceSet* PathPlanningPoint::mutable_posconfid() {
  ::cn::seisys::v2x::pb::PositionConfidenceSet* _msg = _internal_mutable_posconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PathPlanningPoint.posConfid)
  return _msg;
}
inline void PathPlanningPoint::set_allocated_posconfid(::cn::seisys::v2x::pb::PositionConfidenceSet* posconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posconfid_;
  }
  if (posconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posconfid);
    if (message_arena != submessage_arena) {
      posconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posconfid_ = posconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.posConfid)
}

// uint32 speed = 3;
inline void PathPlanningPoint::clear_speed() {
  _impl_.speed_ = 0u;
}
inline uint32_t PathPlanningPoint::_internal_speed() const {
  return _impl_.speed_;
}
inline uint32_t PathPlanningPoint::speed() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.speed)
  return _internal_speed();
}
inline void PathPlanningPoint::_internal_set_speed(uint32_t value) {
  
  _impl_.speed_ = value;
}
inline void PathPlanningPoint::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PathPlanningPoint.speed)
}

// uint32 heading = 4;
inline void PathPlanningPoint::clear_heading() {
  _impl_.heading_ = 0u;
}
inline uint32_t PathPlanningPoint::_internal_heading() const {
  return _impl_.heading_;
}
inline uint32_t PathPlanningPoint::heading() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.heading)
  return _internal_heading();
}
inline void PathPlanningPoint::_internal_set_heading(uint32_t value) {
  
  _impl_.heading_ = value;
}
inline void PathPlanningPoint::set_heading(uint32_t value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PathPlanningPoint.heading)
}

// .cn.seisys.v2x.pb.SpeedConfidence speedConfid = 5;
inline void PathPlanningPoint::clear_speedconfid() {
  _impl_.speedconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::SpeedConfidence PathPlanningPoint::_internal_speedconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::SpeedConfidence >(_impl_.speedconfid_);
}
inline ::cn::seisys::v2x::pb::SpeedConfidence PathPlanningPoint::speedconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.speedConfid)
  return _internal_speedconfid();
}
inline void PathPlanningPoint::_internal_set_speedconfid(::cn::seisys::v2x::pb::SpeedConfidence value) {
  
  _impl_.speedconfid_ = value;
}
inline void PathPlanningPoint::set_speedconfid(::cn::seisys::v2x::pb::SpeedConfidence value) {
  _internal_set_speedconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PathPlanningPoint.speedConfid)
}

// .cn.seisys.v2x.pb.HeadingConfidence headingConfid = 6;
inline void PathPlanningPoint::clear_headingconfid() {
  _impl_.headingconfid_ = 0;
}
inline ::cn::seisys::v2x::pb::HeadingConfidence PathPlanningPoint::_internal_headingconfid() const {
  return static_cast< ::cn::seisys::v2x::pb::HeadingConfidence >(_impl_.headingconfid_);
}
inline ::cn::seisys::v2x::pb::HeadingConfidence PathPlanningPoint::headingconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.headingConfid)
  return _internal_headingconfid();
}
inline void PathPlanningPoint::_internal_set_headingconfid(::cn::seisys::v2x::pb::HeadingConfidence value) {
  
  _impl_.headingconfid_ = value;
}
inline void PathPlanningPoint::set_headingconfid(::cn::seisys::v2x::pb::HeadingConfidence value) {
  _internal_set_headingconfid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PathPlanningPoint.headingConfid)
}

// .cn.seisys.v2x.pb.AccelerationSet4Way acceleration = 7;
inline bool PathPlanningPoint::_internal_has_acceleration() const {
  return this != internal_default_instance() && _impl_.acceleration_ != nullptr;
}
inline bool PathPlanningPoint::has_acceleration() const {
  return _internal_has_acceleration();
}
inline void PathPlanningPoint::clear_acceleration() {
  if (GetArenaForAllocation() == nullptr && _impl_.acceleration_ != nullptr) {
    delete _impl_.acceleration_;
  }
  _impl_.acceleration_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::AccelerationSet4Way& PathPlanningPoint::_internal_acceleration() const {
  const ::cn::seisys::v2x::pb::AccelerationSet4Way* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::AccelerationSet4Way&>(
      ::cn::seisys::v2x::pb::_AccelerationSet4Way_default_instance_);
}
inline const ::cn::seisys::v2x::pb::AccelerationSet4Way& PathPlanningPoint::acceleration() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.acceleration)
  return _internal_acceleration();
}
inline void PathPlanningPoint::unsafe_arena_set_allocated_acceleration(
    ::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.acceleration)
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* PathPlanningPoint::release_acceleration() {
  
  ::cn::seisys::v2x::pb::AccelerationSet4Way* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* PathPlanningPoint::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PathPlanningPoint.acceleration)
  
  ::cn::seisys::v2x::pb::AccelerationSet4Way* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* PathPlanningPoint::_internal_mutable_acceleration() {
  
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::AccelerationSet4Way>(GetArenaForAllocation());
    _impl_.acceleration_ = p;
  }
  return _impl_.acceleration_;
}
inline ::cn::seisys::v2x::pb::AccelerationSet4Way* PathPlanningPoint::mutable_acceleration() {
  ::cn::seisys::v2x::pb::AccelerationSet4Way* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PathPlanningPoint.acceleration)
  return _msg;
}
inline void PathPlanningPoint::set_allocated_acceleration(::cn::seisys::v2x::pb::AccelerationSet4Way* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.acceleration_;
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(acceleration);
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.acceleration)
}

// .cn.seisys.v2x.pb.AccelerationConfidence accelerationConfid = 8;
inline bool PathPlanningPoint::_internal_has_accelerationconfid() const {
  return this != internal_default_instance() && _impl_.accelerationconfid_ != nullptr;
}
inline bool PathPlanningPoint::has_accelerationconfid() const {
  return _internal_has_accelerationconfid();
}
inline void PathPlanningPoint::clear_accelerationconfid() {
  if (GetArenaForAllocation() == nullptr && _impl_.accelerationconfid_ != nullptr) {
    delete _impl_.accelerationconfid_;
  }
  _impl_.accelerationconfid_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::AccelerationConfidence& PathPlanningPoint::_internal_accelerationconfid() const {
  const ::cn::seisys::v2x::pb::AccelerationConfidence* p = _impl_.accelerationconfid_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::AccelerationConfidence&>(
      ::cn::seisys::v2x::pb::_AccelerationConfidence_default_instance_);
}
inline const ::cn::seisys::v2x::pb::AccelerationConfidence& PathPlanningPoint::accelerationconfid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.accelerationConfid)
  return _internal_accelerationconfid();
}
inline void PathPlanningPoint::unsafe_arena_set_allocated_accelerationconfid(
    ::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accelerationconfid_);
  }
  _impl_.accelerationconfid_ = accelerationconfid;
  if (accelerationconfid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.accelerationConfid)
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence* PathPlanningPoint::release_accelerationconfid() {
  
  ::cn::seisys::v2x::pb::AccelerationConfidence* temp = _impl_.accelerationconfid_;
  _impl_.accelerationconfid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence* PathPlanningPoint::unsafe_arena_release_accelerationconfid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PathPlanningPoint.accelerationConfid)
  
  ::cn::seisys::v2x::pb::AccelerationConfidence* temp = _impl_.accelerationconfid_;
  _impl_.accelerationconfid_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence* PathPlanningPoint::_internal_mutable_accelerationconfid() {
  
  if (_impl_.accelerationconfid_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::AccelerationConfidence>(GetArenaForAllocation());
    _impl_.accelerationconfid_ = p;
  }
  return _impl_.accelerationconfid_;
}
inline ::cn::seisys::v2x::pb::AccelerationConfidence* PathPlanningPoint::mutable_accelerationconfid() {
  ::cn::seisys::v2x::pb::AccelerationConfidence* _msg = _internal_mutable_accelerationconfid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PathPlanningPoint.accelerationConfid)
  return _msg;
}
inline void PathPlanningPoint::set_allocated_accelerationconfid(::cn::seisys::v2x::pb::AccelerationConfidence* accelerationconfid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.accelerationconfid_;
  }
  if (accelerationconfid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(accelerationconfid);
    if (message_arena != submessage_arena) {
      accelerationconfid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accelerationconfid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.accelerationconfid_ = accelerationconfid;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.accelerationConfid)
}

// uint32 estimatedTime = 9;
inline void PathPlanningPoint::clear_estimatedtime() {
  _impl_.estimatedtime_ = 0u;
}
inline uint32_t PathPlanningPoint::_internal_estimatedtime() const {
  return _impl_.estimatedtime_;
}
inline uint32_t PathPlanningPoint::estimatedtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.estimatedTime)
  return _internal_estimatedtime();
}
inline void PathPlanningPoint::_internal_set_estimatedtime(uint32_t value) {
  
  _impl_.estimatedtime_ = value;
}
inline void PathPlanningPoint::set_estimatedtime(uint32_t value) {
  _internal_set_estimatedtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PathPlanningPoint.estimatedTime)
}

// .cn.seisys.v2x.pb.TimeConfidence timeConfidence = 10;
inline void PathPlanningPoint::clear_timeconfidence() {
  _impl_.timeconfidence_ = 0;
}
inline ::cn::seisys::v2x::pb::TimeConfidence PathPlanningPoint::_internal_timeconfidence() const {
  return static_cast< ::cn::seisys::v2x::pb::TimeConfidence >(_impl_.timeconfidence_);
}
inline ::cn::seisys::v2x::pb::TimeConfidence PathPlanningPoint::timeconfidence() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.timeConfidence)
  return _internal_timeconfidence();
}
inline void PathPlanningPoint::_internal_set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  
  _impl_.timeconfidence_ = value;
}
inline void PathPlanningPoint::set_timeconfidence(::cn::seisys::v2x::pb::TimeConfidence value) {
  _internal_set_timeconfidence(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.PathPlanningPoint.timeConfidence)
}

// .cn.seisys.v2x.pb.ReferenceLink posInMap = 11;
inline bool PathPlanningPoint::_internal_has_posinmap() const {
  return this != internal_default_instance() && _impl_.posinmap_ != nullptr;
}
inline bool PathPlanningPoint::has_posinmap() const {
  return _internal_has_posinmap();
}
inline void PathPlanningPoint::clear_posinmap() {
  if (GetArenaForAllocation() == nullptr && _impl_.posinmap_ != nullptr) {
    delete _impl_.posinmap_;
  }
  _impl_.posinmap_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& PathPlanningPoint::_internal_posinmap() const {
  const ::cn::seisys::v2x::pb::ReferenceLink* p = _impl_.posinmap_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ReferenceLink&>(
      ::cn::seisys::v2x::pb::_ReferenceLink_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& PathPlanningPoint::posinmap() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanningPoint.posInMap)
  return _internal_posinmap();
}
inline void PathPlanningPoint::unsafe_arena_set_allocated_posinmap(
    ::cn::seisys::v2x::pb::ReferenceLink* posinmap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posinmap_);
  }
  _impl_.posinmap_ = posinmap;
  if (posinmap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.posInMap)
}
inline ::cn::seisys::v2x::pb::ReferenceLink* PathPlanningPoint::release_posinmap() {
  
  ::cn::seisys::v2x::pb::ReferenceLink* temp = _impl_.posinmap_;
  _impl_.posinmap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferenceLink* PathPlanningPoint::unsafe_arena_release_posinmap() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.PathPlanningPoint.posInMap)
  
  ::cn::seisys::v2x::pb::ReferenceLink* temp = _impl_.posinmap_;
  _impl_.posinmap_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferenceLink* PathPlanningPoint::_internal_mutable_posinmap() {
  
  if (_impl_.posinmap_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ReferenceLink>(GetArenaForAllocation());
    _impl_.posinmap_ = p;
  }
  return _impl_.posinmap_;
}
inline ::cn::seisys::v2x::pb::ReferenceLink* PathPlanningPoint::mutable_posinmap() {
  ::cn::seisys::v2x::pb::ReferenceLink* _msg = _internal_mutable_posinmap();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PathPlanningPoint.posInMap)
  return _msg;
}
inline void PathPlanningPoint::set_allocated_posinmap(::cn::seisys::v2x::pb::ReferenceLink* posinmap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posinmap_;
  }
  if (posinmap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posinmap);
    if (message_arena != submessage_arena) {
      posinmap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinmap, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posinmap_ = posinmap;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.PathPlanningPoint.posInMap)
}

// -------------------------------------------------------------------

// PathPlanning

// repeated .cn.seisys.v2x.pb.PathPlanningPoint pathPlanning = 1;
inline int PathPlanning::_internal_pathplanning_size() const {
  return _impl_.pathplanning_.size();
}
inline int PathPlanning::pathplanning_size() const {
  return _internal_pathplanning_size();
}
inline void PathPlanning::clear_pathplanning() {
  _impl_.pathplanning_.Clear();
}
inline ::cn::seisys::v2x::pb::PathPlanningPoint* PathPlanning::mutable_pathplanning(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.PathPlanning.pathPlanning)
  return _impl_.pathplanning_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathPlanningPoint >*
PathPlanning::mutable_pathplanning() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.PathPlanning.pathPlanning)
  return &_impl_.pathplanning_;
}
inline const ::cn::seisys::v2x::pb::PathPlanningPoint& PathPlanning::_internal_pathplanning(int index) const {
  return _impl_.pathplanning_.Get(index);
}
inline const ::cn::seisys::v2x::pb::PathPlanningPoint& PathPlanning::pathplanning(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.PathPlanning.pathPlanning)
  return _internal_pathplanning(index);
}
inline ::cn::seisys::v2x::pb::PathPlanningPoint* PathPlanning::_internal_add_pathplanning() {
  return _impl_.pathplanning_.Add();
}
inline ::cn::seisys::v2x::pb::PathPlanningPoint* PathPlanning::add_pathplanning() {
  ::cn::seisys::v2x::pb::PathPlanningPoint* _add = _internal_add_pathplanning();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.PathPlanning.pathPlanning)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::PathPlanningPoint >&
PathPlanning::pathplanning() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.PathPlanning.pathPlanning)
  return _impl_.pathplanning_;
}

// -------------------------------------------------------------------

// IarData

// .cn.seisys.v2x.pb.PathPlanningPoint currentPos = 1;
inline bool IarData::_internal_has_currentpos() const {
  return this != internal_default_instance() && _impl_.currentpos_ != nullptr;
}
inline bool IarData::has_currentpos() const {
  return _internal_has_currentpos();
}
inline void IarData::clear_currentpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.currentpos_ != nullptr) {
    delete _impl_.currentpos_;
  }
  _impl_.currentpos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::PathPlanningPoint& IarData::_internal_currentpos() const {
  const ::cn::seisys::v2x::pb::PathPlanningPoint* p = _impl_.currentpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::PathPlanningPoint&>(
      ::cn::seisys::v2x::pb::_PathPlanningPoint_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PathPlanningPoint& IarData::currentpos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.IarData.currentPos)
  return _internal_currentpos();
}
inline void IarData::unsafe_arena_set_allocated_currentpos(
    ::cn::seisys::v2x::pb::PathPlanningPoint* currentpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.currentpos_);
  }
  _impl_.currentpos_ = currentpos;
  if (currentpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.IarData.currentPos)
}
inline ::cn::seisys::v2x::pb::PathPlanningPoint* IarData::release_currentpos() {
  
  ::cn::seisys::v2x::pb::PathPlanningPoint* temp = _impl_.currentpos_;
  _impl_.currentpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::PathPlanningPoint* IarData::unsafe_arena_release_currentpos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.IarData.currentPos)
  
  ::cn::seisys::v2x::pb::PathPlanningPoint* temp = _impl_.currentpos_;
  _impl_.currentpos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::PathPlanningPoint* IarData::_internal_mutable_currentpos() {
  
  if (_impl_.currentpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::PathPlanningPoint>(GetArenaForAllocation());
    _impl_.currentpos_ = p;
  }
  return _impl_.currentpos_;
}
inline ::cn::seisys::v2x::pb::PathPlanningPoint* IarData::mutable_currentpos() {
  ::cn::seisys::v2x::pb::PathPlanningPoint* _msg = _internal_mutable_currentpos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.IarData.currentPos)
  return _msg;
}
inline void IarData::set_allocated_currentpos(::cn::seisys::v2x::pb::PathPlanningPoint* currentpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.currentpos_;
  }
  if (currentpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(currentpos);
    if (message_arena != submessage_arena) {
      currentpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.currentpos_ = currentpos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.IarData.currentPos)
}

// .cn.seisys.v2x.pb.PathPlanning pathPlanning = 2;
inline bool IarData::_internal_has_pathplanning() const {
  return this != internal_default_instance() && _impl_.pathplanning_ != nullptr;
}
inline bool IarData::has_pathplanning() const {
  return _internal_has_pathplanning();
}
inline void IarData::clear_pathplanning() {
  if (GetArenaForAllocation() == nullptr && _impl_.pathplanning_ != nullptr) {
    delete _impl_.pathplanning_;
  }
  _impl_.pathplanning_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::PathPlanning& IarData::_internal_pathplanning() const {
  const ::cn::seisys::v2x::pb::PathPlanning* p = _impl_.pathplanning_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::PathPlanning&>(
      ::cn::seisys::v2x::pb::_PathPlanning_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PathPlanning& IarData::pathplanning() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.IarData.pathPlanning)
  return _internal_pathplanning();
}
inline void IarData::unsafe_arena_set_allocated_pathplanning(
    ::cn::seisys::v2x::pb::PathPlanning* pathplanning) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathplanning_);
  }
  _impl_.pathplanning_ = pathplanning;
  if (pathplanning) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.IarData.pathPlanning)
}
inline ::cn::seisys::v2x::pb::PathPlanning* IarData::release_pathplanning() {
  
  ::cn::seisys::v2x::pb::PathPlanning* temp = _impl_.pathplanning_;
  _impl_.pathplanning_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::PathPlanning* IarData::unsafe_arena_release_pathplanning() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.IarData.pathPlanning)
  
  ::cn::seisys::v2x::pb::PathPlanning* temp = _impl_.pathplanning_;
  _impl_.pathplanning_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::PathPlanning* IarData::_internal_mutable_pathplanning() {
  
  if (_impl_.pathplanning_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::PathPlanning>(GetArenaForAllocation());
    _impl_.pathplanning_ = p;
  }
  return _impl_.pathplanning_;
}
inline ::cn::seisys::v2x::pb::PathPlanning* IarData::mutable_pathplanning() {
  ::cn::seisys::v2x::pb::PathPlanning* _msg = _internal_mutable_pathplanning();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.IarData.pathPlanning)
  return _msg;
}
inline void IarData::set_allocated_pathplanning(::cn::seisys::v2x::pb::PathPlanning* pathplanning) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pathplanning_;
  }
  if (pathplanning) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pathplanning);
    if (message_arena != submessage_arena) {
      pathplanning = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathplanning, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pathplanning_ = pathplanning;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.IarData.pathPlanning)
}

// .cn.seisys.v2x.pb.DriveBehavior currentBehavior = 3;
inline bool IarData::_internal_has_currentbehavior() const {
  return this != internal_default_instance() && _impl_.currentbehavior_ != nullptr;
}
inline bool IarData::has_currentbehavior() const {
  return _internal_has_currentbehavior();
}
inline void IarData::clear_currentbehavior() {
  if (GetArenaForAllocation() == nullptr && _impl_.currentbehavior_ != nullptr) {
    delete _impl_.currentbehavior_;
  }
  _impl_.currentbehavior_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::DriveBehavior& IarData::_internal_currentbehavior() const {
  const ::cn::seisys::v2x::pb::DriveBehavior* p = _impl_.currentbehavior_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::DriveBehavior&>(
      ::cn::seisys::v2x::pb::_DriveBehavior_default_instance_);
}
inline const ::cn::seisys::v2x::pb::DriveBehavior& IarData::currentbehavior() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.IarData.currentBehavior)
  return _internal_currentbehavior();
}
inline void IarData::unsafe_arena_set_allocated_currentbehavior(
    ::cn::seisys::v2x::pb::DriveBehavior* currentbehavior) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.currentbehavior_);
  }
  _impl_.currentbehavior_ = currentbehavior;
  if (currentbehavior) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.IarData.currentBehavior)
}
inline ::cn::seisys::v2x::pb::DriveBehavior* IarData::release_currentbehavior() {
  
  ::cn::seisys::v2x::pb::DriveBehavior* temp = _impl_.currentbehavior_;
  _impl_.currentbehavior_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::DriveBehavior* IarData::unsafe_arena_release_currentbehavior() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.IarData.currentBehavior)
  
  ::cn::seisys::v2x::pb::DriveBehavior* temp = _impl_.currentbehavior_;
  _impl_.currentbehavior_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::DriveBehavior* IarData::_internal_mutable_currentbehavior() {
  
  if (_impl_.currentbehavior_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::DriveBehavior>(GetArenaForAllocation());
    _impl_.currentbehavior_ = p;
  }
  return _impl_.currentbehavior_;
}
inline ::cn::seisys::v2x::pb::DriveBehavior* IarData::mutable_currentbehavior() {
  ::cn::seisys::v2x::pb::DriveBehavior* _msg = _internal_mutable_currentbehavior();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.IarData.currentBehavior)
  return _msg;
}
inline void IarData::set_allocated_currentbehavior(::cn::seisys::v2x::pb::DriveBehavior* currentbehavior) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.currentbehavior_;
  }
  if (currentbehavior) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(currentbehavior);
    if (message_arena != submessage_arena) {
      currentbehavior = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentbehavior, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.currentbehavior_ = currentbehavior;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.IarData.currentBehavior)
}

// repeated .cn.seisys.v2x.pb.DriveRequest reqs = 4;
inline int IarData::_internal_reqs_size() const {
  return _impl_.reqs_.size();
}
inline int IarData::reqs_size() const {
  return _internal_reqs_size();
}
inline void IarData::clear_reqs() {
  _impl_.reqs_.Clear();
}
inline ::cn::seisys::v2x::pb::DriveRequest* IarData::mutable_reqs(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.IarData.reqs)
  return _impl_.reqs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::DriveRequest >*
IarData::mutable_reqs() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.IarData.reqs)
  return &_impl_.reqs_;
}
inline const ::cn::seisys::v2x::pb::DriveRequest& IarData::_internal_reqs(int index) const {
  return _impl_.reqs_.Get(index);
}
inline const ::cn::seisys::v2x::pb::DriveRequest& IarData::reqs(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.IarData.reqs)
  return _internal_reqs(index);
}
inline ::cn::seisys::v2x::pb::DriveRequest* IarData::_internal_add_reqs() {
  return _impl_.reqs_.Add();
}
inline ::cn::seisys::v2x::pb::DriveRequest* IarData::add_reqs() {
  ::cn::seisys::v2x::pb::DriveRequest* _add = _internal_add_reqs();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.IarData.reqs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::DriveRequest >&
IarData::reqs() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.IarData.reqs)
  return _impl_.reqs_;
}

// -------------------------------------------------------------------

// VirData

// uint32 msgCnt = 1;
inline void VirData::clear_msgcnt() {
  _impl_.msgcnt_ = 0u;
}
inline uint32_t VirData::_internal_msgcnt() const {
  return _impl_.msgcnt_;
}
inline uint32_t VirData::msgcnt() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VirData.msgCnt)
  return _internal_msgcnt();
}
inline void VirData::_internal_set_msgcnt(uint32_t value) {
  
  _impl_.msgcnt_ = value;
}
inline void VirData::set_msgcnt(uint32_t value) {
  _internal_set_msgcnt(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.VirData.msgCnt)
}

// string vehicleId = 2;
inline void VirData::clear_vehicleid() {
  _impl_.vehicleid_.ClearToEmpty();
}
inline const std::string& VirData::vehicleid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VirData.vehicleId)
  return _internal_vehicleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirData::set_vehicleid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vehicleid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.VirData.vehicleId)
}
inline std::string* VirData::mutable_vehicleid() {
  std::string* _s = _internal_mutable_vehicleid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.VirData.vehicleId)
  return _s;
}
inline const std::string& VirData::_internal_vehicleid() const {
  return _impl_.vehicleid_.Get();
}
inline void VirData::_internal_set_vehicleid(const std::string& value) {
  
  _impl_.vehicleid_.Set(value, GetArenaForAllocation());
}
inline std::string* VirData::_internal_mutable_vehicleid() {
  
  return _impl_.vehicleid_.Mutable(GetArenaForAllocation());
}
inline std::string* VirData::release_vehicleid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.VirData.vehicleId)
  return _impl_.vehicleid_.Release();
}
inline void VirData::set_allocated_vehicleid(std::string* vehicleid) {
  if (vehicleid != nullptr) {
    
  } else {
    
  }
  _impl_.vehicleid_.SetAllocated(vehicleid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vehicleid_.IsDefault()) {
    _impl_.vehicleid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.VirData.vehicleId)
}

// uint64 timestamp = 3;
inline void VirData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t VirData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t VirData::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VirData.timestamp)
  return _internal_timestamp();
}
inline void VirData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void VirData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.VirData.timestamp)
}

// .cn.seisys.v2x.pb.Position3D pos = 4;
inline bool VirData::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool VirData::has_pos() const {
  return _internal_has_pos();
}
inline void VirData::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& VirData::_internal_pos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& VirData::pos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VirData.pos)
  return _internal_pos();
}
inline void VirData::unsafe_arena_set_allocated_pos(
    ::cn::seisys::v2x::pb::Position3D* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.VirData.pos)
}
inline ::cn::seisys::v2x::pb::Position3D* VirData::release_pos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* VirData::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.VirData.pos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* VirData::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::cn::seisys::v2x::pb::Position3D* VirData::mutable_pos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.VirData.pos)
  return _msg;
}
inline void VirData::set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.VirData.pos)
}

// .cn.seisys.v2x.pb.IarData intAndReq = 5;
inline bool VirData::_internal_has_intandreq() const {
  return this != internal_default_instance() && _impl_.intandreq_ != nullptr;
}
inline bool VirData::has_intandreq() const {
  return _internal_has_intandreq();
}
inline void VirData::clear_intandreq() {
  if (GetArenaForAllocation() == nullptr && _impl_.intandreq_ != nullptr) {
    delete _impl_.intandreq_;
  }
  _impl_.intandreq_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::IarData& VirData::_internal_intandreq() const {
  const ::cn::seisys::v2x::pb::IarData* p = _impl_.intandreq_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::IarData&>(
      ::cn::seisys::v2x::pb::_IarData_default_instance_);
}
inline const ::cn::seisys::v2x::pb::IarData& VirData::intandreq() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VirData.intAndReq)
  return _internal_intandreq();
}
inline void VirData::unsafe_arena_set_allocated_intandreq(
    ::cn::seisys::v2x::pb::IarData* intandreq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intandreq_);
  }
  _impl_.intandreq_ = intandreq;
  if (intandreq) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.VirData.intAndReq)
}
inline ::cn::seisys::v2x::pb::IarData* VirData::release_intandreq() {
  
  ::cn::seisys::v2x::pb::IarData* temp = _impl_.intandreq_;
  _impl_.intandreq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::IarData* VirData::unsafe_arena_release_intandreq() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.VirData.intAndReq)
  
  ::cn::seisys::v2x::pb::IarData* temp = _impl_.intandreq_;
  _impl_.intandreq_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::IarData* VirData::_internal_mutable_intandreq() {
  
  if (_impl_.intandreq_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::IarData>(GetArenaForAllocation());
    _impl_.intandreq_ = p;
  }
  return _impl_.intandreq_;
}
inline ::cn::seisys::v2x::pb::IarData* VirData::mutable_intandreq() {
  ::cn::seisys::v2x::pb::IarData* _msg = _internal_mutable_intandreq();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.VirData.intAndReq)
  return _msg;
}
inline void VirData::set_allocated_intandreq(::cn::seisys::v2x::pb::IarData* intandreq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.intandreq_;
  }
  if (intandreq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intandreq);
    if (message_arena != submessage_arena) {
      intandreq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intandreq, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.intandreq_ = intandreq;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.VirData.intAndReq)
}

// -------------------------------------------------------------------

// DriveSuggestion

// .cn.seisys.v2x.pb.DriveBehavior suggestion = 1;
inline bool DriveSuggestion::_internal_has_suggestion() const {
  return this != internal_default_instance() && _impl_.suggestion_ != nullptr;
}
inline bool DriveSuggestion::has_suggestion() const {
  return _internal_has_suggestion();
}
inline void DriveSuggestion::clear_suggestion() {
  if (GetArenaForAllocation() == nullptr && _impl_.suggestion_ != nullptr) {
    delete _impl_.suggestion_;
  }
  _impl_.suggestion_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::DriveBehavior& DriveSuggestion::_internal_suggestion() const {
  const ::cn::seisys::v2x::pb::DriveBehavior* p = _impl_.suggestion_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::DriveBehavior&>(
      ::cn::seisys::v2x::pb::_DriveBehavior_default_instance_);
}
inline const ::cn::seisys::v2x::pb::DriveBehavior& DriveSuggestion::suggestion() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveSuggestion.suggestion)
  return _internal_suggestion();
}
inline void DriveSuggestion::unsafe_arena_set_allocated_suggestion(
    ::cn::seisys::v2x::pb::DriveBehavior* suggestion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.suggestion_);
  }
  _impl_.suggestion_ = suggestion;
  if (suggestion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.DriveSuggestion.suggestion)
}
inline ::cn::seisys::v2x::pb::DriveBehavior* DriveSuggestion::release_suggestion() {
  
  ::cn::seisys::v2x::pb::DriveBehavior* temp = _impl_.suggestion_;
  _impl_.suggestion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::DriveBehavior* DriveSuggestion::unsafe_arena_release_suggestion() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DriveSuggestion.suggestion)
  
  ::cn::seisys::v2x::pb::DriveBehavior* temp = _impl_.suggestion_;
  _impl_.suggestion_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::DriveBehavior* DriveSuggestion::_internal_mutable_suggestion() {
  
  if (_impl_.suggestion_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::DriveBehavior>(GetArenaForAllocation());
    _impl_.suggestion_ = p;
  }
  return _impl_.suggestion_;
}
inline ::cn::seisys::v2x::pb::DriveBehavior* DriveSuggestion::mutable_suggestion() {
  ::cn::seisys::v2x::pb::DriveBehavior* _msg = _internal_mutable_suggestion();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DriveSuggestion.suggestion)
  return _msg;
}
inline void DriveSuggestion::set_allocated_suggestion(::cn::seisys::v2x::pb::DriveBehavior* suggestion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.suggestion_;
  }
  if (suggestion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(suggestion);
    if (message_arena != submessage_arena) {
      suggestion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, suggestion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.suggestion_ = suggestion;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DriveSuggestion.suggestion)
}

// uint32 timeOffset = 2;
inline void DriveSuggestion::clear_timeoffset() {
  _impl_.timeoffset_ = 0u;
}
inline uint32_t DriveSuggestion::_internal_timeoffset() const {
  return _impl_.timeoffset_;
}
inline uint32_t DriveSuggestion::timeoffset() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveSuggestion.timeOffset)
  return _internal_timeoffset();
}
inline void DriveSuggestion::_internal_set_timeoffset(uint32_t value) {
  
  _impl_.timeoffset_ = value;
}
inline void DriveSuggestion::set_timeoffset(uint32_t value) {
  _internal_set_timeoffset(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DriveSuggestion.timeOffset)
}

// .cn.seisys.v2x.pb.ReferenceLink relatedLink = 3;
inline bool DriveSuggestion::_internal_has_relatedlink() const {
  return this != internal_default_instance() && _impl_.relatedlink_ != nullptr;
}
inline bool DriveSuggestion::has_relatedlink() const {
  return _internal_has_relatedlink();
}
inline void DriveSuggestion::clear_relatedlink() {
  if (GetArenaForAllocation() == nullptr && _impl_.relatedlink_ != nullptr) {
    delete _impl_.relatedlink_;
  }
  _impl_.relatedlink_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& DriveSuggestion::_internal_relatedlink() const {
  const ::cn::seisys::v2x::pb::ReferenceLink* p = _impl_.relatedlink_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ReferenceLink&>(
      ::cn::seisys::v2x::pb::_ReferenceLink_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& DriveSuggestion::relatedlink() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveSuggestion.relatedLink)
  return _internal_relatedlink();
}
inline void DriveSuggestion::unsafe_arena_set_allocated_relatedlink(
    ::cn::seisys::v2x::pb::ReferenceLink* relatedlink) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relatedlink_);
  }
  _impl_.relatedlink_ = relatedlink;
  if (relatedlink) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.DriveSuggestion.relatedLink)
}
inline ::cn::seisys::v2x::pb::ReferenceLink* DriveSuggestion::release_relatedlink() {
  
  ::cn::seisys::v2x::pb::ReferenceLink* temp = _impl_.relatedlink_;
  _impl_.relatedlink_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferenceLink* DriveSuggestion::unsafe_arena_release_relatedlink() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DriveSuggestion.relatedLink)
  
  ::cn::seisys::v2x::pb::ReferenceLink* temp = _impl_.relatedlink_;
  _impl_.relatedlink_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferenceLink* DriveSuggestion::_internal_mutable_relatedlink() {
  
  if (_impl_.relatedlink_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ReferenceLink>(GetArenaForAllocation());
    _impl_.relatedlink_ = p;
  }
  return _impl_.relatedlink_;
}
inline ::cn::seisys::v2x::pb::ReferenceLink* DriveSuggestion::mutable_relatedlink() {
  ::cn::seisys::v2x::pb::ReferenceLink* _msg = _internal_mutable_relatedlink();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DriveSuggestion.relatedLink)
  return _msg;
}
inline void DriveSuggestion::set_allocated_relatedlink(::cn::seisys::v2x::pb::ReferenceLink* relatedlink) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relatedlink_;
  }
  if (relatedlink) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relatedlink);
    if (message_arena != submessage_arena) {
      relatedlink = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relatedlink, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relatedlink_ = relatedlink;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DriveSuggestion.relatedLink)
}

// .cn.seisys.v2x.pb.ReferencePath relatedPath = 4;
inline bool DriveSuggestion::_internal_has_relatedpath() const {
  return this != internal_default_instance() && _impl_.relatedpath_ != nullptr;
}
inline bool DriveSuggestion::has_relatedpath() const {
  return _internal_has_relatedpath();
}
inline void DriveSuggestion::clear_relatedpath() {
  if (GetArenaForAllocation() == nullptr && _impl_.relatedpath_ != nullptr) {
    delete _impl_.relatedpath_;
  }
  _impl_.relatedpath_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ReferencePath& DriveSuggestion::_internal_relatedpath() const {
  const ::cn::seisys::v2x::pb::ReferencePath* p = _impl_.relatedpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ReferencePath&>(
      ::cn::seisys::v2x::pb::_ReferencePath_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReferencePath& DriveSuggestion::relatedpath() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DriveSuggestion.relatedPath)
  return _internal_relatedpath();
}
inline void DriveSuggestion::unsafe_arena_set_allocated_relatedpath(
    ::cn::seisys::v2x::pb::ReferencePath* relatedpath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relatedpath_);
  }
  _impl_.relatedpath_ = relatedpath;
  if (relatedpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.DriveSuggestion.relatedPath)
}
inline ::cn::seisys::v2x::pb::ReferencePath* DriveSuggestion::release_relatedpath() {
  
  ::cn::seisys::v2x::pb::ReferencePath* temp = _impl_.relatedpath_;
  _impl_.relatedpath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferencePath* DriveSuggestion::unsafe_arena_release_relatedpath() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DriveSuggestion.relatedPath)
  
  ::cn::seisys::v2x::pb::ReferencePath* temp = _impl_.relatedpath_;
  _impl_.relatedpath_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferencePath* DriveSuggestion::_internal_mutable_relatedpath() {
  
  if (_impl_.relatedpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ReferencePath>(GetArenaForAllocation());
    _impl_.relatedpath_ = p;
  }
  return _impl_.relatedpath_;
}
inline ::cn::seisys::v2x::pb::ReferencePath* DriveSuggestion::mutable_relatedpath() {
  ::cn::seisys::v2x::pb::ReferencePath* _msg = _internal_mutable_relatedpath();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DriveSuggestion.relatedPath)
  return _msg;
}
inline void DriveSuggestion::set_allocated_relatedpath(::cn::seisys::v2x::pb::ReferencePath* relatedpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relatedpath_;
  }
  if (relatedpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relatedpath);
    if (message_arena != submessage_arena) {
      relatedpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relatedpath, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relatedpath_ = relatedpath;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DriveSuggestion.relatedPath)
}

// -------------------------------------------------------------------

// CoordinationInfo

// int32 coordinationInfo = 1;
inline void CoordinationInfo::clear_coordinationinfo() {
  _impl_.coordinationinfo_ = 0;
}
inline int32_t CoordinationInfo::_internal_coordinationinfo() const {
  return _impl_.coordinationinfo_;
}
inline int32_t CoordinationInfo::coordinationinfo() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CoordinationInfo.coordinationInfo)
  return _internal_coordinationinfo();
}
inline void CoordinationInfo::_internal_set_coordinationinfo(int32_t value) {
  
  _impl_.coordinationinfo_ = value;
}
inline void CoordinationInfo::set_coordinationinfo(int32_t value) {
  _internal_set_coordinationinfo(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CoordinationInfo.coordinationInfo)
}

// -------------------------------------------------------------------

// VehicleCoordination

// string vehId = 1;
inline void VehicleCoordination::clear_vehid() {
  _impl_.vehid_.ClearToEmpty();
}
inline const std::string& VehicleCoordination::vehid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VehicleCoordination.vehId)
  return _internal_vehid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VehicleCoordination::set_vehid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vehid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.VehicleCoordination.vehId)
}
inline std::string* VehicleCoordination::mutable_vehid() {
  std::string* _s = _internal_mutable_vehid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.VehicleCoordination.vehId)
  return _s;
}
inline const std::string& VehicleCoordination::_internal_vehid() const {
  return _impl_.vehid_.Get();
}
inline void VehicleCoordination::_internal_set_vehid(const std::string& value) {
  
  _impl_.vehid_.Set(value, GetArenaForAllocation());
}
inline std::string* VehicleCoordination::_internal_mutable_vehid() {
  
  return _impl_.vehid_.Mutable(GetArenaForAllocation());
}
inline std::string* VehicleCoordination::release_vehid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.VehicleCoordination.vehId)
  return _impl_.vehid_.Release();
}
inline void VehicleCoordination::set_allocated_vehid(std::string* vehid) {
  if (vehid != nullptr) {
    
  } else {
    
  }
  _impl_.vehid_.SetAllocated(vehid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vehid_.IsDefault()) {
    _impl_.vehid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.VehicleCoordination.vehId)
}

// .cn.seisys.v2x.pb.DriveSuggestion driveSuggestion = 2;
inline bool VehicleCoordination::_internal_has_drivesuggestion() const {
  return this != internal_default_instance() && _impl_.drivesuggestion_ != nullptr;
}
inline bool VehicleCoordination::has_drivesuggestion() const {
  return _internal_has_drivesuggestion();
}
inline void VehicleCoordination::clear_drivesuggestion() {
  if (GetArenaForAllocation() == nullptr && _impl_.drivesuggestion_ != nullptr) {
    delete _impl_.drivesuggestion_;
  }
  _impl_.drivesuggestion_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::DriveSuggestion& VehicleCoordination::_internal_drivesuggestion() const {
  const ::cn::seisys::v2x::pb::DriveSuggestion* p = _impl_.drivesuggestion_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::DriveSuggestion&>(
      ::cn::seisys::v2x::pb::_DriveSuggestion_default_instance_);
}
inline const ::cn::seisys::v2x::pb::DriveSuggestion& VehicleCoordination::drivesuggestion() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VehicleCoordination.driveSuggestion)
  return _internal_drivesuggestion();
}
inline void VehicleCoordination::unsafe_arena_set_allocated_drivesuggestion(
    ::cn::seisys::v2x::pb::DriveSuggestion* drivesuggestion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drivesuggestion_);
  }
  _impl_.drivesuggestion_ = drivesuggestion;
  if (drivesuggestion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.VehicleCoordination.driveSuggestion)
}
inline ::cn::seisys::v2x::pb::DriveSuggestion* VehicleCoordination::release_drivesuggestion() {
  
  ::cn::seisys::v2x::pb::DriveSuggestion* temp = _impl_.drivesuggestion_;
  _impl_.drivesuggestion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::DriveSuggestion* VehicleCoordination::unsafe_arena_release_drivesuggestion() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.VehicleCoordination.driveSuggestion)
  
  ::cn::seisys::v2x::pb::DriveSuggestion* temp = _impl_.drivesuggestion_;
  _impl_.drivesuggestion_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::DriveSuggestion* VehicleCoordination::_internal_mutable_drivesuggestion() {
  
  if (_impl_.drivesuggestion_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::DriveSuggestion>(GetArenaForAllocation());
    _impl_.drivesuggestion_ = p;
  }
  return _impl_.drivesuggestion_;
}
inline ::cn::seisys::v2x::pb::DriveSuggestion* VehicleCoordination::mutable_drivesuggestion() {
  ::cn::seisys::v2x::pb::DriveSuggestion* _msg = _internal_mutable_drivesuggestion();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.VehicleCoordination.driveSuggestion)
  return _msg;
}
inline void VehicleCoordination::set_allocated_drivesuggestion(::cn::seisys::v2x::pb::DriveSuggestion* drivesuggestion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.drivesuggestion_;
  }
  if (drivesuggestion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(drivesuggestion);
    if (message_arena != submessage_arena) {
      drivesuggestion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drivesuggestion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.drivesuggestion_ = drivesuggestion;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.VehicleCoordination.driveSuggestion)
}

// .cn.seisys.v2x.pb.PathPlanning pathGuidance = 3;
inline bool VehicleCoordination::_internal_has_pathguidance() const {
  return this != internal_default_instance() && _impl_.pathguidance_ != nullptr;
}
inline bool VehicleCoordination::has_pathguidance() const {
  return _internal_has_pathguidance();
}
inline void VehicleCoordination::clear_pathguidance() {
  if (GetArenaForAllocation() == nullptr && _impl_.pathguidance_ != nullptr) {
    delete _impl_.pathguidance_;
  }
  _impl_.pathguidance_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::PathPlanning& VehicleCoordination::_internal_pathguidance() const {
  const ::cn::seisys::v2x::pb::PathPlanning* p = _impl_.pathguidance_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::PathPlanning&>(
      ::cn::seisys::v2x::pb::_PathPlanning_default_instance_);
}
inline const ::cn::seisys::v2x::pb::PathPlanning& VehicleCoordination::pathguidance() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VehicleCoordination.pathGuidance)
  return _internal_pathguidance();
}
inline void VehicleCoordination::unsafe_arena_set_allocated_pathguidance(
    ::cn::seisys::v2x::pb::PathPlanning* pathguidance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathguidance_);
  }
  _impl_.pathguidance_ = pathguidance;
  if (pathguidance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.VehicleCoordination.pathGuidance)
}
inline ::cn::seisys::v2x::pb::PathPlanning* VehicleCoordination::release_pathguidance() {
  
  ::cn::seisys::v2x::pb::PathPlanning* temp = _impl_.pathguidance_;
  _impl_.pathguidance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::PathPlanning* VehicleCoordination::unsafe_arena_release_pathguidance() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.VehicleCoordination.pathGuidance)
  
  ::cn::seisys::v2x::pb::PathPlanning* temp = _impl_.pathguidance_;
  _impl_.pathguidance_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::PathPlanning* VehicleCoordination::_internal_mutable_pathguidance() {
  
  if (_impl_.pathguidance_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::PathPlanning>(GetArenaForAllocation());
    _impl_.pathguidance_ = p;
  }
  return _impl_.pathguidance_;
}
inline ::cn::seisys::v2x::pb::PathPlanning* VehicleCoordination::mutable_pathguidance() {
  ::cn::seisys::v2x::pb::PathPlanning* _msg = _internal_mutable_pathguidance();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.VehicleCoordination.pathGuidance)
  return _msg;
}
inline void VehicleCoordination::set_allocated_pathguidance(::cn::seisys::v2x::pb::PathPlanning* pathguidance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pathguidance_;
  }
  if (pathguidance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pathguidance);
    if (message_arena != submessage_arena) {
      pathguidance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathguidance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pathguidance_ = pathguidance;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.VehicleCoordination.pathGuidance)
}

// .cn.seisys.v2x.pb.CoordinationInfo info = 4;
inline bool VehicleCoordination::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool VehicleCoordination::has_info() const {
  return _internal_has_info();
}
inline void VehicleCoordination::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::CoordinationInfo& VehicleCoordination::_internal_info() const {
  const ::cn::seisys::v2x::pb::CoordinationInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::CoordinationInfo&>(
      ::cn::seisys::v2x::pb::_CoordinationInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::CoordinationInfo& VehicleCoordination::info() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.VehicleCoordination.info)
  return _internal_info();
}
inline void VehicleCoordination::unsafe_arena_set_allocated_info(
    ::cn::seisys::v2x::pb::CoordinationInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.VehicleCoordination.info)
}
inline ::cn::seisys::v2x::pb::CoordinationInfo* VehicleCoordination::release_info() {
  
  ::cn::seisys::v2x::pb::CoordinationInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::CoordinationInfo* VehicleCoordination::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.VehicleCoordination.info)
  
  ::cn::seisys::v2x::pb::CoordinationInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::CoordinationInfo* VehicleCoordination::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::CoordinationInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::cn::seisys::v2x::pb::CoordinationInfo* VehicleCoordination::mutable_info() {
  ::cn::seisys::v2x::pb::CoordinationInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.VehicleCoordination.info)
  return _msg;
}
inline void VehicleCoordination::set_allocated_info(::cn::seisys::v2x::pb::CoordinationInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.VehicleCoordination.info)
}

// -------------------------------------------------------------------

// LaneCoordination

// .cn.seisys.v2x.pb.ReferenceLink targetLane = 1;
inline bool LaneCoordination::_internal_has_targetlane() const {
  return this != internal_default_instance() && _impl_.targetlane_ != nullptr;
}
inline bool LaneCoordination::has_targetlane() const {
  return _internal_has_targetlane();
}
inline void LaneCoordination::clear_targetlane() {
  if (GetArenaForAllocation() == nullptr && _impl_.targetlane_ != nullptr) {
    delete _impl_.targetlane_;
  }
  _impl_.targetlane_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& LaneCoordination::_internal_targetlane() const {
  const ::cn::seisys::v2x::pb::ReferenceLink* p = _impl_.targetlane_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ReferenceLink&>(
      ::cn::seisys::v2x::pb::_ReferenceLink_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReferenceLink& LaneCoordination::targetlane() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneCoordination.targetLane)
  return _internal_targetlane();
}
inline void LaneCoordination::unsafe_arena_set_allocated_targetlane(
    ::cn::seisys::v2x::pb::ReferenceLink* targetlane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.targetlane_);
  }
  _impl_.targetlane_ = targetlane;
  if (targetlane) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneCoordination.targetLane)
}
inline ::cn::seisys::v2x::pb::ReferenceLink* LaneCoordination::release_targetlane() {
  
  ::cn::seisys::v2x::pb::ReferenceLink* temp = _impl_.targetlane_;
  _impl_.targetlane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferenceLink* LaneCoordination::unsafe_arena_release_targetlane() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneCoordination.targetLane)
  
  ::cn::seisys::v2x::pb::ReferenceLink* temp = _impl_.targetlane_;
  _impl_.targetlane_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferenceLink* LaneCoordination::_internal_mutable_targetlane() {
  
  if (_impl_.targetlane_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ReferenceLink>(GetArenaForAllocation());
    _impl_.targetlane_ = p;
  }
  return _impl_.targetlane_;
}
inline ::cn::seisys::v2x::pb::ReferenceLink* LaneCoordination::mutable_targetlane() {
  ::cn::seisys::v2x::pb::ReferenceLink* _msg = _internal_mutable_targetlane();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneCoordination.targetLane)
  return _msg;
}
inline void LaneCoordination::set_allocated_targetlane(::cn::seisys::v2x::pb::ReferenceLink* targetlane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.targetlane_;
  }
  if (targetlane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(targetlane);
    if (message_arena != submessage_arena) {
      targetlane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, targetlane, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.targetlane_ = targetlane;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneCoordination.targetLane)
}

// .cn.seisys.v2x.pb.ReferencePath relatedPath = 2;
inline bool LaneCoordination::_internal_has_relatedpath() const {
  return this != internal_default_instance() && _impl_.relatedpath_ != nullptr;
}
inline bool LaneCoordination::has_relatedpath() const {
  return _internal_has_relatedpath();
}
inline void LaneCoordination::clear_relatedpath() {
  if (GetArenaForAllocation() == nullptr && _impl_.relatedpath_ != nullptr) {
    delete _impl_.relatedpath_;
  }
  _impl_.relatedpath_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::ReferencePath& LaneCoordination::_internal_relatedpath() const {
  const ::cn::seisys::v2x::pb::ReferencePath* p = _impl_.relatedpath_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::ReferencePath&>(
      ::cn::seisys::v2x::pb::_ReferencePath_default_instance_);
}
inline const ::cn::seisys::v2x::pb::ReferencePath& LaneCoordination::relatedpath() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneCoordination.relatedPath)
  return _internal_relatedpath();
}
inline void LaneCoordination::unsafe_arena_set_allocated_relatedpath(
    ::cn::seisys::v2x::pb::ReferencePath* relatedpath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relatedpath_);
  }
  _impl_.relatedpath_ = relatedpath;
  if (relatedpath) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneCoordination.relatedPath)
}
inline ::cn::seisys::v2x::pb::ReferencePath* LaneCoordination::release_relatedpath() {
  
  ::cn::seisys::v2x::pb::ReferencePath* temp = _impl_.relatedpath_;
  _impl_.relatedpath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferencePath* LaneCoordination::unsafe_arena_release_relatedpath() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneCoordination.relatedPath)
  
  ::cn::seisys::v2x::pb::ReferencePath* temp = _impl_.relatedpath_;
  _impl_.relatedpath_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::ReferencePath* LaneCoordination::_internal_mutable_relatedpath() {
  
  if (_impl_.relatedpath_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::ReferencePath>(GetArenaForAllocation());
    _impl_.relatedpath_ = p;
  }
  return _impl_.relatedpath_;
}
inline ::cn::seisys::v2x::pb::ReferencePath* LaneCoordination::mutable_relatedpath() {
  ::cn::seisys::v2x::pb::ReferencePath* _msg = _internal_mutable_relatedpath();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneCoordination.relatedPath)
  return _msg;
}
inline void LaneCoordination::set_allocated_relatedpath(::cn::seisys::v2x::pb::ReferencePath* relatedpath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.relatedpath_;
  }
  if (relatedpath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relatedpath);
    if (message_arena != submessage_arena) {
      relatedpath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relatedpath, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.relatedpath_ = relatedpath;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneCoordination.relatedPath)
}

// uint64 tBegin = 3;
inline void LaneCoordination::clear_tbegin() {
  _impl_.tbegin_ = uint64_t{0u};
}
inline uint64_t LaneCoordination::_internal_tbegin() const {
  return _impl_.tbegin_;
}
inline uint64_t LaneCoordination::tbegin() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneCoordination.tBegin)
  return _internal_tbegin();
}
inline void LaneCoordination::_internal_set_tbegin(uint64_t value) {
  
  _impl_.tbegin_ = value;
}
inline void LaneCoordination::set_tbegin(uint64_t value) {
  _internal_set_tbegin(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneCoordination.tBegin)
}

// uint64 tEnd = 4;
inline void LaneCoordination::clear_tend() {
  _impl_.tend_ = uint64_t{0u};
}
inline uint64_t LaneCoordination::_internal_tend() const {
  return _impl_.tend_;
}
inline uint64_t LaneCoordination::tend() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneCoordination.tEnd)
  return _internal_tend();
}
inline void LaneCoordination::_internal_set_tend(uint64_t value) {
  
  _impl_.tend_ = value;
}
inline void LaneCoordination::set_tend(uint64_t value) {
  _internal_set_tend(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneCoordination.tEnd)
}

// uint32 recommendedSpeed = 5;
inline void LaneCoordination::clear_recommendedspeed() {
  _impl_.recommendedspeed_ = 0u;
}
inline uint32_t LaneCoordination::_internal_recommendedspeed() const {
  return _impl_.recommendedspeed_;
}
inline uint32_t LaneCoordination::recommendedspeed() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneCoordination.recommendedSpeed)
  return _internal_recommendedspeed();
}
inline void LaneCoordination::_internal_set_recommendedspeed(uint32_t value) {
  
  _impl_.recommendedspeed_ = value;
}
inline void LaneCoordination::set_recommendedspeed(uint32_t value) {
  _internal_set_recommendedspeed(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneCoordination.recommendedSpeed)
}

// .cn.seisys.v2x.pb.DriveBehavior recommendedBehavior = 6;
inline bool LaneCoordination::_internal_has_recommendedbehavior() const {
  return this != internal_default_instance() && _impl_.recommendedbehavior_ != nullptr;
}
inline bool LaneCoordination::has_recommendedbehavior() const {
  return _internal_has_recommendedbehavior();
}
inline void LaneCoordination::clear_recommendedbehavior() {
  if (GetArenaForAllocation() == nullptr && _impl_.recommendedbehavior_ != nullptr) {
    delete _impl_.recommendedbehavior_;
  }
  _impl_.recommendedbehavior_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::DriveBehavior& LaneCoordination::_internal_recommendedbehavior() const {
  const ::cn::seisys::v2x::pb::DriveBehavior* p = _impl_.recommendedbehavior_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::DriveBehavior&>(
      ::cn::seisys::v2x::pb::_DriveBehavior_default_instance_);
}
inline const ::cn::seisys::v2x::pb::DriveBehavior& LaneCoordination::recommendedbehavior() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneCoordination.recommendedBehavior)
  return _internal_recommendedbehavior();
}
inline void LaneCoordination::unsafe_arena_set_allocated_recommendedbehavior(
    ::cn::seisys::v2x::pb::DriveBehavior* recommendedbehavior) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recommendedbehavior_);
  }
  _impl_.recommendedbehavior_ = recommendedbehavior;
  if (recommendedbehavior) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneCoordination.recommendedBehavior)
}
inline ::cn::seisys::v2x::pb::DriveBehavior* LaneCoordination::release_recommendedbehavior() {
  
  ::cn::seisys::v2x::pb::DriveBehavior* temp = _impl_.recommendedbehavior_;
  _impl_.recommendedbehavior_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::DriveBehavior* LaneCoordination::unsafe_arena_release_recommendedbehavior() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneCoordination.recommendedBehavior)
  
  ::cn::seisys::v2x::pb::DriveBehavior* temp = _impl_.recommendedbehavior_;
  _impl_.recommendedbehavior_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::DriveBehavior* LaneCoordination::_internal_mutable_recommendedbehavior() {
  
  if (_impl_.recommendedbehavior_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::DriveBehavior>(GetArenaForAllocation());
    _impl_.recommendedbehavior_ = p;
  }
  return _impl_.recommendedbehavior_;
}
inline ::cn::seisys::v2x::pb::DriveBehavior* LaneCoordination::mutable_recommendedbehavior() {
  ::cn::seisys::v2x::pb::DriveBehavior* _msg = _internal_mutable_recommendedbehavior();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneCoordination.recommendedBehavior)
  return _msg;
}
inline void LaneCoordination::set_allocated_recommendedbehavior(::cn::seisys::v2x::pb::DriveBehavior* recommendedbehavior) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recommendedbehavior_;
  }
  if (recommendedbehavior) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recommendedbehavior);
    if (message_arena != submessage_arena) {
      recommendedbehavior = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recommendedbehavior, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recommendedbehavior_ = recommendedbehavior;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneCoordination.recommendedBehavior)
}

// .cn.seisys.v2x.pb.CoordinationInfo info = 7;
inline bool LaneCoordination::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool LaneCoordination::has_info() const {
  return _internal_has_info();
}
inline void LaneCoordination::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::CoordinationInfo& LaneCoordination::_internal_info() const {
  const ::cn::seisys::v2x::pb::CoordinationInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::CoordinationInfo&>(
      ::cn::seisys::v2x::pb::_CoordinationInfo_default_instance_);
}
inline const ::cn::seisys::v2x::pb::CoordinationInfo& LaneCoordination::info() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneCoordination.info)
  return _internal_info();
}
inline void LaneCoordination::unsafe_arena_set_allocated_info(
    ::cn::seisys::v2x::pb::CoordinationInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.LaneCoordination.info)
}
inline ::cn::seisys::v2x::pb::CoordinationInfo* LaneCoordination::release_info() {
  
  ::cn::seisys::v2x::pb::CoordinationInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::CoordinationInfo* LaneCoordination::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneCoordination.info)
  
  ::cn::seisys::v2x::pb::CoordinationInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::CoordinationInfo* LaneCoordination::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::CoordinationInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::cn::seisys::v2x::pb::CoordinationInfo* LaneCoordination::mutable_info() {
  ::cn::seisys::v2x::pb::CoordinationInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneCoordination.info)
  return _msg;
}
inline void LaneCoordination::set_allocated_info(::cn::seisys::v2x::pb::CoordinationInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneCoordination.info)
}

// string description = 8;
inline void LaneCoordination::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& LaneCoordination::description() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.LaneCoordination.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LaneCoordination::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.LaneCoordination.description)
}
inline std::string* LaneCoordination::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.LaneCoordination.description)
  return _s;
}
inline const std::string& LaneCoordination::_internal_description() const {
  return _impl_.description_.Get();
}
inline void LaneCoordination::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* LaneCoordination::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* LaneCoordination::release_description() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.LaneCoordination.description)
  return _impl_.description_.Release();
}
inline void LaneCoordination::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.LaneCoordination.description)
}

// -------------------------------------------------------------------

// RscData

// uint32 msgCnt = 1;
inline void RscData::clear_msgcnt() {
  _impl_.msgcnt_ = 0u;
}
inline uint32_t RscData::_internal_msgcnt() const {
  return _impl_.msgcnt_;
}
inline uint32_t RscData::msgcnt() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RscData.msgCnt)
  return _internal_msgcnt();
}
inline void RscData::_internal_set_msgcnt(uint32_t value) {
  
  _impl_.msgcnt_ = value;
}
inline void RscData::set_msgcnt(uint32_t value) {
  _internal_set_msgcnt(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RscData.msgCnt)
}

// string rsuId = 2;
inline void RscData::clear_rsuid() {
  _impl_.rsuid_.ClearToEmpty();
}
inline const std::string& RscData::rsuid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RscData.rsuId)
  return _internal_rsuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RscData::set_rsuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rsuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RscData.rsuId)
}
inline std::string* RscData::mutable_rsuid() {
  std::string* _s = _internal_mutable_rsuid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RscData.rsuId)
  return _s;
}
inline const std::string& RscData::_internal_rsuid() const {
  return _impl_.rsuid_.Get();
}
inline void RscData::_internal_set_rsuid(const std::string& value) {
  
  _impl_.rsuid_.Set(value, GetArenaForAllocation());
}
inline std::string* RscData::_internal_mutable_rsuid() {
  
  return _impl_.rsuid_.Mutable(GetArenaForAllocation());
}
inline std::string* RscData::release_rsuid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RscData.rsuId)
  return _impl_.rsuid_.Release();
}
inline void RscData::set_allocated_rsuid(std::string* rsuid) {
  if (rsuid != nullptr) {
    
  } else {
    
  }
  _impl_.rsuid_.SetAllocated(rsuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rsuid_.IsDefault()) {
    _impl_.rsuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RscData.rsuId)
}

// uint64 timestamp = 3;
inline void RscData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t RscData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t RscData::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RscData.timestamp)
  return _internal_timestamp();
}
inline void RscData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void RscData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RscData.timestamp)
}

// .cn.seisys.v2x.pb.Position3D pos = 4;
inline bool RscData::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool RscData::has_pos() const {
  return _internal_has_pos();
}
inline void RscData::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& RscData::_internal_pos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& RscData::pos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RscData.pos)
  return _internal_pos();
}
inline void RscData::unsafe_arena_set_allocated_pos(
    ::cn::seisys::v2x::pb::Position3D* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.RscData.pos)
}
inline ::cn::seisys::v2x::pb::Position3D* RscData::release_pos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* RscData::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RscData.pos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* RscData::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::cn::seisys::v2x::pb::Position3D* RscData::mutable_pos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RscData.pos)
  return _msg;
}
inline void RscData::set_allocated_pos(::cn::seisys::v2x::pb::Position3D* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RscData.pos)
}

// .cn.seisys.v2x.pb.VehicleCoordination coordinates = 5;
inline bool RscData::_internal_has_coordinates() const {
  return this != internal_default_instance() && _impl_.coordinates_ != nullptr;
}
inline bool RscData::has_coordinates() const {
  return _internal_has_coordinates();
}
inline void RscData::clear_coordinates() {
  if (GetArenaForAllocation() == nullptr && _impl_.coordinates_ != nullptr) {
    delete _impl_.coordinates_;
  }
  _impl_.coordinates_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::VehicleCoordination& RscData::_internal_coordinates() const {
  const ::cn::seisys::v2x::pb::VehicleCoordination* p = _impl_.coordinates_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::VehicleCoordination&>(
      ::cn::seisys::v2x::pb::_VehicleCoordination_default_instance_);
}
inline const ::cn::seisys::v2x::pb::VehicleCoordination& RscData::coordinates() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RscData.coordinates)
  return _internal_coordinates();
}
inline void RscData::unsafe_arena_set_allocated_coordinates(
    ::cn::seisys::v2x::pb::VehicleCoordination* coordinates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.coordinates_);
  }
  _impl_.coordinates_ = coordinates;
  if (coordinates) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.RscData.coordinates)
}
inline ::cn::seisys::v2x::pb::VehicleCoordination* RscData::release_coordinates() {
  
  ::cn::seisys::v2x::pb::VehicleCoordination* temp = _impl_.coordinates_;
  _impl_.coordinates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::VehicleCoordination* RscData::unsafe_arena_release_coordinates() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RscData.coordinates)
  
  ::cn::seisys::v2x::pb::VehicleCoordination* temp = _impl_.coordinates_;
  _impl_.coordinates_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::VehicleCoordination* RscData::_internal_mutable_coordinates() {
  
  if (_impl_.coordinates_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::VehicleCoordination>(GetArenaForAllocation());
    _impl_.coordinates_ = p;
  }
  return _impl_.coordinates_;
}
inline ::cn::seisys::v2x::pb::VehicleCoordination* RscData::mutable_coordinates() {
  ::cn::seisys::v2x::pb::VehicleCoordination* _msg = _internal_mutable_coordinates();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RscData.coordinates)
  return _msg;
}
inline void RscData::set_allocated_coordinates(::cn::seisys::v2x::pb::VehicleCoordination* coordinates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.coordinates_;
  }
  if (coordinates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coordinates);
    if (message_arena != submessage_arena) {
      coordinates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coordinates, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.coordinates_ = coordinates;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RscData.coordinates)
}

// .cn.seisys.v2x.pb.LaneCoordination laneCoordinates = 6;
inline bool RscData::_internal_has_lanecoordinates() const {
  return this != internal_default_instance() && _impl_.lanecoordinates_ != nullptr;
}
inline bool RscData::has_lanecoordinates() const {
  return _internal_has_lanecoordinates();
}
inline void RscData::clear_lanecoordinates() {
  if (GetArenaForAllocation() == nullptr && _impl_.lanecoordinates_ != nullptr) {
    delete _impl_.lanecoordinates_;
  }
  _impl_.lanecoordinates_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::LaneCoordination& RscData::_internal_lanecoordinates() const {
  const ::cn::seisys::v2x::pb::LaneCoordination* p = _impl_.lanecoordinates_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::LaneCoordination&>(
      ::cn::seisys::v2x::pb::_LaneCoordination_default_instance_);
}
inline const ::cn::seisys::v2x::pb::LaneCoordination& RscData::lanecoordinates() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RscData.laneCoordinates)
  return _internal_lanecoordinates();
}
inline void RscData::unsafe_arena_set_allocated_lanecoordinates(
    ::cn::seisys::v2x::pb::LaneCoordination* lanecoordinates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lanecoordinates_);
  }
  _impl_.lanecoordinates_ = lanecoordinates;
  if (lanecoordinates) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.RscData.laneCoordinates)
}
inline ::cn::seisys::v2x::pb::LaneCoordination* RscData::release_lanecoordinates() {
  
  ::cn::seisys::v2x::pb::LaneCoordination* temp = _impl_.lanecoordinates_;
  _impl_.lanecoordinates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneCoordination* RscData::unsafe_arena_release_lanecoordinates() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RscData.laneCoordinates)
  
  ::cn::seisys::v2x::pb::LaneCoordination* temp = _impl_.lanecoordinates_;
  _impl_.lanecoordinates_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::LaneCoordination* RscData::_internal_mutable_lanecoordinates() {
  
  if (_impl_.lanecoordinates_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::LaneCoordination>(GetArenaForAllocation());
    _impl_.lanecoordinates_ = p;
  }
  return _impl_.lanecoordinates_;
}
inline ::cn::seisys::v2x::pb::LaneCoordination* RscData::mutable_lanecoordinates() {
  ::cn::seisys::v2x::pb::LaneCoordination* _msg = _internal_mutable_lanecoordinates();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RscData.laneCoordinates)
  return _msg;
}
inline void RscData::set_allocated_lanecoordinates(::cn::seisys::v2x::pb::LaneCoordination* lanecoordinates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lanecoordinates_;
  }
  if (lanecoordinates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lanecoordinates);
    if (message_arena != submessage_arena) {
      lanecoordinates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lanecoordinates, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lanecoordinates_ = lanecoordinates;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RscData.laneCoordinates)
}

// -------------------------------------------------------------------

// CamData

// uint32 type = 1;
inline void CamData::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CamData::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CamData::type() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.type)
  return _internal_type();
}
inline void CamData::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CamData::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.type)
}

// string ver = 2;
inline void CamData::clear_ver() {
  _impl_.ver_.ClearToEmpty();
}
inline const std::string& CamData::ver() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.ver)
  return _internal_ver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CamData::set_ver(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.ver)
}
inline std::string* CamData::mutable_ver() {
  std::string* _s = _internal_mutable_ver();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.ver)
  return _s;
}
inline const std::string& CamData::_internal_ver() const {
  return _impl_.ver_.Get();
}
inline void CamData::_internal_set_ver(const std::string& value) {
  
  _impl_.ver_.Set(value, GetArenaForAllocation());
}
inline std::string* CamData::_internal_mutable_ver() {
  
  return _impl_.ver_.Mutable(GetArenaForAllocation());
}
inline std::string* CamData::release_ver() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.CamData.ver)
  return _impl_.ver_.Release();
}
inline void CamData::set_allocated_ver(std::string* ver) {
  if (ver != nullptr) {
    
  } else {
    
  }
  _impl_.ver_.SetAllocated(ver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ver_.IsDefault()) {
    _impl_.ver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.CamData.ver)
}

// uint32 msgCnt = 3;
inline void CamData::clear_msgcnt() {
  _impl_.msgcnt_ = 0u;
}
inline uint32_t CamData::_internal_msgcnt() const {
  return _impl_.msgcnt_;
}
inline uint32_t CamData::msgcnt() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.msgCnt)
  return _internal_msgcnt();
}
inline void CamData::_internal_set_msgcnt(uint32_t value) {
  
  _impl_.msgcnt_ = value;
}
inline void CamData::set_msgcnt(uint32_t value) {
  _internal_set_msgcnt(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.msgCnt)
}

// uint64 timestamp = 4;
inline void CamData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t CamData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t CamData::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.timestamp)
  return _internal_timestamp();
}
inline void CamData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void CamData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.timestamp)
}

// string deviceId = 5;
inline void CamData::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
}
inline const std::string& CamData::deviceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CamData::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.deviceId)
}
inline std::string* CamData::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.deviceId)
  return _s;
}
inline const std::string& CamData::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void CamData::_internal_set_deviceid(const std::string& value) {
  
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* CamData::_internal_mutable_deviceid() {
  
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* CamData::release_deviceid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.CamData.deviceId)
  return _impl_.deviceid_.Release();
}
inline void CamData::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.CamData.deviceId)
}

// string mapDeviceId = 6;
inline void CamData::clear_mapdeviceid() {
  _impl_.mapdeviceid_.ClearToEmpty();
}
inline const std::string& CamData::mapdeviceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.mapDeviceId)
  return _internal_mapdeviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CamData::set_mapdeviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapdeviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.mapDeviceId)
}
inline std::string* CamData::mutable_mapdeviceid() {
  std::string* _s = _internal_mutable_mapdeviceid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.mapDeviceId)
  return _s;
}
inline const std::string& CamData::_internal_mapdeviceid() const {
  return _impl_.mapdeviceid_.Get();
}
inline void CamData::_internal_set_mapdeviceid(const std::string& value) {
  
  _impl_.mapdeviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* CamData::_internal_mutable_mapdeviceid() {
  
  return _impl_.mapdeviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* CamData::release_mapdeviceid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.CamData.mapDeviceId)
  return _impl_.mapdeviceid_.Release();
}
inline void CamData::set_allocated_mapdeviceid(std::string* mapdeviceid) {
  if (mapdeviceid != nullptr) {
    
  } else {
    
  }
  _impl_.mapdeviceid_.SetAllocated(mapdeviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapdeviceid_.IsDefault()) {
    _impl_.mapdeviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.CamData.mapDeviceId)
}

// .cn.seisys.v2x.pb.Position3D refPos = 7;
inline bool CamData::_internal_has_refpos() const {
  return this != internal_default_instance() && _impl_.refpos_ != nullptr;
}
inline bool CamData::has_refpos() const {
  return _internal_has_refpos();
}
inline void CamData::clear_refpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.refpos_ != nullptr) {
    delete _impl_.refpos_;
  }
  _impl_.refpos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& CamData::_internal_refpos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.refpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& CamData::refpos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.refPos)
  return _internal_refpos();
}
inline void CamData::unsafe_arena_set_allocated_refpos(
    ::cn::seisys::v2x::pb::Position3D* refpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.refpos_);
  }
  _impl_.refpos_ = refpos;
  if (refpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.CamData.refPos)
}
inline ::cn::seisys::v2x::pb::Position3D* CamData::release_refpos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.refpos_;
  _impl_.refpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* CamData::unsafe_arena_release_refpos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.CamData.refPos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.refpos_;
  _impl_.refpos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* CamData::_internal_mutable_refpos() {
  
  if (_impl_.refpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.refpos_ = p;
  }
  return _impl_.refpos_;
}
inline ::cn::seisys::v2x::pb::Position3D* CamData::mutable_refpos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_refpos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.refPos)
  return _msg;
}
inline void CamData::set_allocated_refpos(::cn::seisys::v2x::pb::Position3D* refpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.refpos_;
  }
  if (refpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(refpos);
    if (message_arena != submessage_arena) {
      refpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, refpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.refpos_ = refpos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.CamData.refPos)
}

// .cn.seisys.v2x.pb.SceneType sceneType = 8;
inline void CamData::clear_scenetype() {
  _impl_.scenetype_ = 0;
}
inline ::cn::seisys::v2x::pb::SceneType CamData::_internal_scenetype() const {
  return static_cast< ::cn::seisys::v2x::pb::SceneType >(_impl_.scenetype_);
}
inline ::cn::seisys::v2x::pb::SceneType CamData::scenetype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.sceneType)
  return _internal_scenetype();
}
inline void CamData::_internal_set_scenetype(::cn::seisys::v2x::pb::SceneType value) {
  
  _impl_.scenetype_ = value;
}
inline void CamData::set_scenetype(::cn::seisys::v2x::pb::SceneType value) {
  _internal_set_scenetype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.sceneType)
}

// repeated .cn.seisys.v2x.pb.ParticipantData ptcList = 9;
inline int CamData::_internal_ptclist_size() const {
  return _impl_.ptclist_.size();
}
inline int CamData::ptclist_size() const {
  return _internal_ptclist_size();
}
inline void CamData::clear_ptclist() {
  _impl_.ptclist_.Clear();
}
inline ::cn::seisys::v2x::pb::ParticipantData* CamData::mutable_ptclist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.ptcList)
  return _impl_.ptclist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ParticipantData >*
CamData::mutable_ptclist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.ptcList)
  return &_impl_.ptclist_;
}
inline const ::cn::seisys::v2x::pb::ParticipantData& CamData::_internal_ptclist(int index) const {
  return _impl_.ptclist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ParticipantData& CamData::ptclist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.ptcList)
  return _internal_ptclist(index);
}
inline ::cn::seisys::v2x::pb::ParticipantData* CamData::_internal_add_ptclist() {
  return _impl_.ptclist_.Add();
}
inline ::cn::seisys::v2x::pb::ParticipantData* CamData::add_ptclist() {
  ::cn::seisys::v2x::pb::ParticipantData* _add = _internal_add_ptclist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.ptcList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ParticipantData >&
CamData::ptclist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.ptcList)
  return _impl_.ptclist_;
}

// repeated .cn.seisys.v2x.pb.ObstacleData obstacleList = 10;
inline int CamData::_internal_obstaclelist_size() const {
  return _impl_.obstaclelist_.size();
}
inline int CamData::obstaclelist_size() const {
  return _internal_obstaclelist_size();
}
inline void CamData::clear_obstaclelist() {
  _impl_.obstaclelist_.Clear();
}
inline ::cn::seisys::v2x::pb::ObstacleData* CamData::mutable_obstaclelist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.obstacleList)
  return _impl_.obstaclelist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObstacleData >*
CamData::mutable_obstaclelist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.obstacleList)
  return &_impl_.obstaclelist_;
}
inline const ::cn::seisys::v2x::pb::ObstacleData& CamData::_internal_obstaclelist(int index) const {
  return _impl_.obstaclelist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::ObstacleData& CamData::obstaclelist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.obstacleList)
  return _internal_obstaclelist(index);
}
inline ::cn::seisys::v2x::pb::ObstacleData* CamData::_internal_add_obstaclelist() {
  return _impl_.obstaclelist_.Add();
}
inline ::cn::seisys::v2x::pb::ObstacleData* CamData::add_obstaclelist() {
  ::cn::seisys::v2x::pb::ObstacleData* _add = _internal_add_obstaclelist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.obstacleList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::ObstacleData >&
CamData::obstaclelist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.obstacleList)
  return _impl_.obstaclelist_;
}

// repeated .cn.seisys.v2x.pb.RteData rteList = 11;
inline int CamData::_internal_rtelist_size() const {
  return _impl_.rtelist_.size();
}
inline int CamData::rtelist_size() const {
  return _internal_rtelist_size();
}
inline void CamData::clear_rtelist() {
  _impl_.rtelist_.Clear();
}
inline ::cn::seisys::v2x::pb::RteData* CamData::mutable_rtelist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.rteList)
  return _impl_.rtelist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RteData >*
CamData::mutable_rtelist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.rteList)
  return &_impl_.rtelist_;
}
inline const ::cn::seisys::v2x::pb::RteData& CamData::_internal_rtelist(int index) const {
  return _impl_.rtelist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::RteData& CamData::rtelist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.rteList)
  return _internal_rtelist(index);
}
inline ::cn::seisys::v2x::pb::RteData* CamData::_internal_add_rtelist() {
  return _impl_.rtelist_.Add();
}
inline ::cn::seisys::v2x::pb::RteData* CamData::add_rtelist() {
  ::cn::seisys::v2x::pb::RteData* _add = _internal_add_rtelist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.rteList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RteData >&
CamData::rtelist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.rteList)
  return _impl_.rtelist_;
}

// repeated .cn.seisys.v2x.pb.RtsData rtsList = 12;
inline int CamData::_internal_rtslist_size() const {
  return _impl_.rtslist_.size();
}
inline int CamData::rtslist_size() const {
  return _internal_rtslist_size();
}
inline void CamData::clear_rtslist() {
  _impl_.rtslist_.Clear();
}
inline ::cn::seisys::v2x::pb::RtsData* CamData::mutable_rtslist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.rtsList)
  return _impl_.rtslist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RtsData >*
CamData::mutable_rtslist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.rtsList)
  return &_impl_.rtslist_;
}
inline const ::cn::seisys::v2x::pb::RtsData& CamData::_internal_rtslist(int index) const {
  return _impl_.rtslist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::RtsData& CamData::rtslist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.rtsList)
  return _internal_rtslist(index);
}
inline ::cn::seisys::v2x::pb::RtsData* CamData::_internal_add_rtslist() {
  return _impl_.rtslist_.Add();
}
inline ::cn::seisys::v2x::pb::RtsData* CamData::add_rtslist() {
  ::cn::seisys::v2x::pb::RtsData* _add = _internal_add_rtslist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.rtsList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RtsData >&
CamData::rtslist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.rtsList)
  return _impl_.rtslist_;
}

// repeated .cn.seisys.v2x.pb.BsmData bsmList = 13;
inline int CamData::_internal_bsmlist_size() const {
  return _impl_.bsmlist_.size();
}
inline int CamData::bsmlist_size() const {
  return _internal_bsmlist_size();
}
inline void CamData::clear_bsmlist() {
  _impl_.bsmlist_.Clear();
}
inline ::cn::seisys::v2x::pb::BsmData* CamData::mutable_bsmlist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.bsmList)
  return _impl_.bsmlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::BsmData >*
CamData::mutable_bsmlist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.bsmList)
  return &_impl_.bsmlist_;
}
inline const ::cn::seisys::v2x::pb::BsmData& CamData::_internal_bsmlist(int index) const {
  return _impl_.bsmlist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::BsmData& CamData::bsmlist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.bsmList)
  return _internal_bsmlist(index);
}
inline ::cn::seisys::v2x::pb::BsmData* CamData::_internal_add_bsmlist() {
  return _impl_.bsmlist_.Add();
}
inline ::cn::seisys::v2x::pb::BsmData* CamData::add_bsmlist() {
  ::cn::seisys::v2x::pb::BsmData* _add = _internal_add_bsmlist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.bsmList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::BsmData >&
CamData::bsmlist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.bsmList)
  return _impl_.bsmlist_;
}

// repeated .cn.seisys.v2x.pb.VirData virList = 14;
inline int CamData::_internal_virlist_size() const {
  return _impl_.virlist_.size();
}
inline int CamData::virlist_size() const {
  return _internal_virlist_size();
}
inline void CamData::clear_virlist() {
  _impl_.virlist_.Clear();
}
inline ::cn::seisys::v2x::pb::VirData* CamData::mutable_virlist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.virList)
  return _impl_.virlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::VirData >*
CamData::mutable_virlist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.virList)
  return &_impl_.virlist_;
}
inline const ::cn::seisys::v2x::pb::VirData& CamData::_internal_virlist(int index) const {
  return _impl_.virlist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::VirData& CamData::virlist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.virList)
  return _internal_virlist(index);
}
inline ::cn::seisys::v2x::pb::VirData* CamData::_internal_add_virlist() {
  return _impl_.virlist_.Add();
}
inline ::cn::seisys::v2x::pb::VirData* CamData::add_virlist() {
  ::cn::seisys::v2x::pb::VirData* _add = _internal_add_virlist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.virList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::VirData >&
CamData::virlist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.virList)
  return _impl_.virlist_;
}

// repeated .cn.seisys.v2x.pb.RscData rscList = 15;
inline int CamData::_internal_rsclist_size() const {
  return _impl_.rsclist_.size();
}
inline int CamData::rsclist_size() const {
  return _internal_rsclist_size();
}
inline void CamData::clear_rsclist() {
  _impl_.rsclist_.Clear();
}
inline ::cn::seisys::v2x::pb::RscData* CamData::mutable_rsclist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.rscList)
  return _impl_.rsclist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RscData >*
CamData::mutable_rsclist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.rscList)
  return &_impl_.rsclist_;
}
inline const ::cn::seisys::v2x::pb::RscData& CamData::_internal_rsclist(int index) const {
  return _impl_.rsclist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::RscData& CamData::rsclist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.rscList)
  return _internal_rsclist(index);
}
inline ::cn::seisys::v2x::pb::RscData* CamData::_internal_add_rsclist() {
  return _impl_.rsclist_.Add();
}
inline ::cn::seisys::v2x::pb::RscData* CamData::add_rsclist() {
  ::cn::seisys::v2x::pb::RscData* _add = _internal_add_rsclist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.rscList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RscData >&
CamData::rsclist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.rscList)
  return _impl_.rsclist_;
}

// .cn.seisys.v2x.pb.SpatData roadSignalState = 16;
inline bool CamData::_internal_has_roadsignalstate() const {
  return this != internal_default_instance() && _impl_.roadsignalstate_ != nullptr;
}
inline bool CamData::has_roadsignalstate() const {
  return _internal_has_roadsignalstate();
}
inline void CamData::clear_roadsignalstate() {
  if (GetArenaForAllocation() == nullptr && _impl_.roadsignalstate_ != nullptr) {
    delete _impl_.roadsignalstate_;
  }
  _impl_.roadsignalstate_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::SpatData& CamData::_internal_roadsignalstate() const {
  const ::cn::seisys::v2x::pb::SpatData* p = _impl_.roadsignalstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::SpatData&>(
      ::cn::seisys::v2x::pb::_SpatData_default_instance_);
}
inline const ::cn::seisys::v2x::pb::SpatData& CamData::roadsignalstate() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.roadSignalState)
  return _internal_roadsignalstate();
}
inline void CamData::unsafe_arena_set_allocated_roadsignalstate(
    ::cn::seisys::v2x::pb::SpatData* roadsignalstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.roadsignalstate_);
  }
  _impl_.roadsignalstate_ = roadsignalstate;
  if (roadsignalstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.CamData.roadSignalState)
}
inline ::cn::seisys::v2x::pb::SpatData* CamData::release_roadsignalstate() {
  
  ::cn::seisys::v2x::pb::SpatData* temp = _impl_.roadsignalstate_;
  _impl_.roadsignalstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::SpatData* CamData::unsafe_arena_release_roadsignalstate() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.CamData.roadSignalState)
  
  ::cn::seisys::v2x::pb::SpatData* temp = _impl_.roadsignalstate_;
  _impl_.roadsignalstate_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::SpatData* CamData::_internal_mutable_roadsignalstate() {
  
  if (_impl_.roadsignalstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::SpatData>(GetArenaForAllocation());
    _impl_.roadsignalstate_ = p;
  }
  return _impl_.roadsignalstate_;
}
inline ::cn::seisys::v2x::pb::SpatData* CamData::mutable_roadsignalstate() {
  ::cn::seisys::v2x::pb::SpatData* _msg = _internal_mutable_roadsignalstate();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.roadSignalState)
  return _msg;
}
inline void CamData::set_allocated_roadsignalstate(::cn::seisys::v2x::pb::SpatData* roadsignalstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.roadsignalstate_;
  }
  if (roadsignalstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(roadsignalstate);
    if (message_arena != submessage_arena) {
      roadsignalstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roadsignalstate, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.roadsignalstate_ = roadsignalstate;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.CamData.roadSignalState)
}

// repeated .cn.seisys.v2x.pb.TrafficFlow trafficFlow = 17;
inline int CamData::_internal_trafficflow_size() const {
  return _impl_.trafficflow_.size();
}
inline int CamData::trafficflow_size() const {
  return _internal_trafficflow_size();
}
inline void CamData::clear_trafficflow() {
  _impl_.trafficflow_.Clear();
}
inline ::cn::seisys::v2x::pb::TrafficFlow* CamData::mutable_trafficflow(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.trafficFlow)
  return _impl_.trafficflow_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlow >*
CamData::mutable_trafficflow() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.trafficFlow)
  return &_impl_.trafficflow_;
}
inline const ::cn::seisys::v2x::pb::TrafficFlow& CamData::_internal_trafficflow(int index) const {
  return _impl_.trafficflow_.Get(index);
}
inline const ::cn::seisys::v2x::pb::TrafficFlow& CamData::trafficflow(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.trafficFlow)
  return _internal_trafficflow(index);
}
inline ::cn::seisys::v2x::pb::TrafficFlow* CamData::_internal_add_trafficflow() {
  return _impl_.trafficflow_.Add();
}
inline ::cn::seisys::v2x::pb::TrafficFlow* CamData::add_trafficflow() {
  ::cn::seisys::v2x::pb::TrafficFlow* _add = _internal_add_trafficflow();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.trafficFlow)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::TrafficFlow >&
CamData::trafficflow() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.trafficFlow)
  return _impl_.trafficflow_;
}

// repeated .cn.seisys.v2x.pb.SignalScheme signalSchemeList = 18;
inline int CamData::_internal_signalschemelist_size() const {
  return _impl_.signalschemelist_.size();
}
inline int CamData::signalschemelist_size() const {
  return _internal_signalschemelist_size();
}
inline void CamData::clear_signalschemelist() {
  _impl_.signalschemelist_.Clear();
}
inline ::cn::seisys::v2x::pb::SignalScheme* CamData::mutable_signalschemelist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.signalSchemeList)
  return _impl_.signalschemelist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalScheme >*
CamData::mutable_signalschemelist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.signalSchemeList)
  return &_impl_.signalschemelist_;
}
inline const ::cn::seisys::v2x::pb::SignalScheme& CamData::_internal_signalschemelist(int index) const {
  return _impl_.signalschemelist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::SignalScheme& CamData::signalschemelist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.signalSchemeList)
  return _internal_signalschemelist(index);
}
inline ::cn::seisys::v2x::pb::SignalScheme* CamData::_internal_add_signalschemelist() {
  return _impl_.signalschemelist_.Add();
}
inline ::cn::seisys::v2x::pb::SignalScheme* CamData::add_signalschemelist() {
  ::cn::seisys::v2x::pb::SignalScheme* _add = _internal_add_signalschemelist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.signalSchemeList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::SignalScheme >&
CamData::signalschemelist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.signalSchemeList)
  return _impl_.signalschemelist_;
}

// repeated .cn.seisys.v2x.pb.Polygon detectedRegion = 19;
inline int CamData::_internal_detectedregion_size() const {
  return _impl_.detectedregion_.size();
}
inline int CamData::detectedregion_size() const {
  return _internal_detectedregion_size();
}
inline void CamData::clear_detectedregion() {
  _impl_.detectedregion_.Clear();
}
inline ::cn::seisys::v2x::pb::Polygon* CamData::mutable_detectedregion(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.CamData.detectedRegion)
  return _impl_.detectedregion_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >*
CamData::mutable_detectedregion() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.CamData.detectedRegion)
  return &_impl_.detectedregion_;
}
inline const ::cn::seisys::v2x::pb::Polygon& CamData::_internal_detectedregion(int index) const {
  return _impl_.detectedregion_.Get(index);
}
inline const ::cn::seisys::v2x::pb::Polygon& CamData::detectedregion(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.detectedRegion)
  return _internal_detectedregion(index);
}
inline ::cn::seisys::v2x::pb::Polygon* CamData::_internal_add_detectedregion() {
  return _impl_.detectedregion_.Add();
}
inline ::cn::seisys::v2x::pb::Polygon* CamData::add_detectedregion() {
  ::cn::seisys::v2x::pb::Polygon* _add = _internal_add_detectedregion();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.CamData.detectedRegion)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::Polygon >&
CamData::detectedregion() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.CamData.detectedRegion)
  return _impl_.detectedregion_;
}

// uint64 toAlgorithmTime = 20;
inline void CamData::clear_toalgorithmtime() {
  _impl_.toalgorithmtime_ = uint64_t{0u};
}
inline uint64_t CamData::_internal_toalgorithmtime() const {
  return _impl_.toalgorithmtime_;
}
inline uint64_t CamData::toalgorithmtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.toAlgorithmTime)
  return _internal_toalgorithmtime();
}
inline void CamData::_internal_set_toalgorithmtime(uint64_t value) {
  
  _impl_.toalgorithmtime_ = value;
}
inline void CamData::set_toalgorithmtime(uint64_t value) {
  _internal_set_toalgorithmtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.toAlgorithmTime)
}

// uint64 toDatabusTime = 21;
inline void CamData::clear_todatabustime() {
  _impl_.todatabustime_ = uint64_t{0u};
}
inline uint64_t CamData::_internal_todatabustime() const {
  return _impl_.todatabustime_;
}
inline uint64_t CamData::todatabustime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.toDatabusTime)
  return _internal_todatabustime();
}
inline void CamData::_internal_set_todatabustime(uint64_t value) {
  
  _impl_.todatabustime_ = value;
}
inline void CamData::set_todatabustime(uint64_t value) {
  _internal_set_todatabustime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.toDatabusTime)
}

// uint64 toCloudTime = 22;
inline void CamData::clear_tocloudtime() {
  _impl_.tocloudtime_ = uint64_t{0u};
}
inline uint64_t CamData::_internal_tocloudtime() const {
  return _impl_.tocloudtime_;
}
inline uint64_t CamData::tocloudtime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.toCloudTime)
  return _internal_tocloudtime();
}
inline void CamData::_internal_set_tocloudtime(uint64_t value) {
  
  _impl_.tocloudtime_ = value;
}
inline void CamData::set_tocloudtime(uint64_t value) {
  _internal_set_tocloudtime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.toCloudTime)
}

// uint64 id = 23;
inline void CamData::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t CamData::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t CamData::id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.CamData.id)
  return _internal_id();
}
inline void CamData::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void CamData::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.CamData.id)
}

// -------------------------------------------------------------------

// StatusData

// string deviceId = 1;
inline void StatusData::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
}
inline const std::string& StatusData::deviceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.StatusData.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusData::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.StatusData.deviceId)
}
inline std::string* StatusData::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.StatusData.deviceId)
  return _s;
}
inline const std::string& StatusData::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void StatusData::_internal_set_deviceid(const std::string& value) {
  
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusData::_internal_mutable_deviceid() {
  
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusData::release_deviceid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.StatusData.deviceId)
  return _impl_.deviceid_.Release();
}
inline void StatusData::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.StatusData.deviceId)
}

// string mapDeviceId = 2;
inline void StatusData::clear_mapdeviceid() {
  _impl_.mapdeviceid_.ClearToEmpty();
}
inline const std::string& StatusData::mapdeviceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.StatusData.mapDeviceId)
  return _internal_mapdeviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatusData::set_mapdeviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapdeviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.StatusData.mapDeviceId)
}
inline std::string* StatusData::mutable_mapdeviceid() {
  std::string* _s = _internal_mutable_mapdeviceid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.StatusData.mapDeviceId)
  return _s;
}
inline const std::string& StatusData::_internal_mapdeviceid() const {
  return _impl_.mapdeviceid_.Get();
}
inline void StatusData::_internal_set_mapdeviceid(const std::string& value) {
  
  _impl_.mapdeviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* StatusData::_internal_mutable_mapdeviceid() {
  
  return _impl_.mapdeviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* StatusData::release_mapdeviceid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.StatusData.mapDeviceId)
  return _impl_.mapdeviceid_.Release();
}
inline void StatusData::set_allocated_mapdeviceid(std::string* mapdeviceid) {
  if (mapdeviceid != nullptr) {
    
  } else {
    
  }
  _impl_.mapdeviceid_.SetAllocated(mapdeviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapdeviceid_.IsDefault()) {
    _impl_.mapdeviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.StatusData.mapDeviceId)
}

// .cn.seisys.v2x.pb.DeviceType deviceType = 3;
inline void StatusData::clear_devicetype() {
  _impl_.devicetype_ = 0;
}
inline ::cn::seisys::v2x::pb::DeviceType StatusData::_internal_devicetype() const {
  return static_cast< ::cn::seisys::v2x::pb::DeviceType >(_impl_.devicetype_);
}
inline ::cn::seisys::v2x::pb::DeviceType StatusData::devicetype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.StatusData.deviceType)
  return _internal_devicetype();
}
inline void StatusData::_internal_set_devicetype(::cn::seisys::v2x::pb::DeviceType value) {
  
  _impl_.devicetype_ = value;
}
inline void StatusData::set_devicetype(::cn::seisys::v2x::pb::DeviceType value) {
  _internal_set_devicetype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.StatusData.deviceType)
}

// .cn.seisys.v2x.pb.StatusData.StatusType statusType = 4;
inline void StatusData::clear_statustype() {
  _impl_.statustype_ = 0;
}
inline ::cn::seisys::v2x::pb::StatusData_StatusType StatusData::_internal_statustype() const {
  return static_cast< ::cn::seisys::v2x::pb::StatusData_StatusType >(_impl_.statustype_);
}
inline ::cn::seisys::v2x::pb::StatusData_StatusType StatusData::statustype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.StatusData.statusType)
  return _internal_statustype();
}
inline void StatusData::_internal_set_statustype(::cn::seisys::v2x::pb::StatusData_StatusType value) {
  
  _impl_.statustype_ = value;
}
inline void StatusData::set_statustype(::cn::seisys::v2x::pb::StatusData_StatusType value) {
  _internal_set_statustype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.StatusData.statusType)
}

// .cn.seisys.v2x.pb.Position3D posDevice = 5;
inline bool StatusData::_internal_has_posdevice() const {
  return this != internal_default_instance() && _impl_.posdevice_ != nullptr;
}
inline bool StatusData::has_posdevice() const {
  return _internal_has_posdevice();
}
inline void StatusData::clear_posdevice() {
  if (GetArenaForAllocation() == nullptr && _impl_.posdevice_ != nullptr) {
    delete _impl_.posdevice_;
  }
  _impl_.posdevice_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& StatusData::_internal_posdevice() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.posdevice_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& StatusData::posdevice() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.StatusData.posDevice)
  return _internal_posdevice();
}
inline void StatusData::unsafe_arena_set_allocated_posdevice(
    ::cn::seisys::v2x::pb::Position3D* posdevice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posdevice_);
  }
  _impl_.posdevice_ = posdevice;
  if (posdevice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.StatusData.posDevice)
}
inline ::cn::seisys::v2x::pb::Position3D* StatusData::release_posdevice() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.posdevice_;
  _impl_.posdevice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* StatusData::unsafe_arena_release_posdevice() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.StatusData.posDevice)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.posdevice_;
  _impl_.posdevice_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* StatusData::_internal_mutable_posdevice() {
  
  if (_impl_.posdevice_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.posdevice_ = p;
  }
  return _impl_.posdevice_;
}
inline ::cn::seisys::v2x::pb::Position3D* StatusData::mutable_posdevice() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_posdevice();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.StatusData.posDevice)
  return _msg;
}
inline void StatusData::set_allocated_posdevice(::cn::seisys::v2x::pb::Position3D* posdevice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posdevice_;
  }
  if (posdevice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posdevice);
    if (message_arena != submessage_arena) {
      posdevice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posdevice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.posdevice_ = posdevice;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.StatusData.posDevice)
}

// -------------------------------------------------------------------

// DenmData

// uint32 type = 1;
inline void DenmData::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t DenmData::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t DenmData::type() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DenmData.type)
  return _internal_type();
}
inline void DenmData::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void DenmData::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DenmData.type)
}

// string ver = 2;
inline void DenmData::clear_ver() {
  _impl_.ver_.ClearToEmpty();
}
inline const std::string& DenmData::ver() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DenmData.ver)
  return _internal_ver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DenmData::set_ver(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DenmData.ver)
}
inline std::string* DenmData::mutable_ver() {
  std::string* _s = _internal_mutable_ver();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DenmData.ver)
  return _s;
}
inline const std::string& DenmData::_internal_ver() const {
  return _impl_.ver_.Get();
}
inline void DenmData::_internal_set_ver(const std::string& value) {
  
  _impl_.ver_.Set(value, GetArenaForAllocation());
}
inline std::string* DenmData::_internal_mutable_ver() {
  
  return _impl_.ver_.Mutable(GetArenaForAllocation());
}
inline std::string* DenmData::release_ver() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DenmData.ver)
  return _impl_.ver_.Release();
}
inline void DenmData::set_allocated_ver(std::string* ver) {
  if (ver != nullptr) {
    
  } else {
    
  }
  _impl_.ver_.SetAllocated(ver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ver_.IsDefault()) {
    _impl_.ver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DenmData.ver)
}

// uint32 msgCnt = 3;
inline void DenmData::clear_msgcnt() {
  _impl_.msgcnt_ = 0u;
}
inline uint32_t DenmData::_internal_msgcnt() const {
  return _impl_.msgcnt_;
}
inline uint32_t DenmData::msgcnt() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DenmData.msgCnt)
  return _internal_msgcnt();
}
inline void DenmData::_internal_set_msgcnt(uint32_t value) {
  
  _impl_.msgcnt_ = value;
}
inline void DenmData::set_msgcnt(uint32_t value) {
  _internal_set_msgcnt(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DenmData.msgCnt)
}

// uint64 timestamp = 4;
inline void DenmData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t DenmData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t DenmData::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DenmData.timestamp)
  return _internal_timestamp();
}
inline void DenmData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void DenmData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DenmData.timestamp)
}

// string address = 5;
inline void DenmData::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& DenmData::address() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DenmData.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DenmData::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DenmData.address)
}
inline std::string* DenmData::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DenmData.address)
  return _s;
}
inline const std::string& DenmData::_internal_address() const {
  return _impl_.address_.Get();
}
inline void DenmData::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* DenmData::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* DenmData::release_address() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DenmData.address)
  return _impl_.address_.Release();
}
inline void DenmData::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DenmData.address)
}

// .cn.seisys.v2x.pb.Position3D refPos = 6;
inline bool DenmData::_internal_has_refpos() const {
  return this != internal_default_instance() && _impl_.refpos_ != nullptr;
}
inline bool DenmData::has_refpos() const {
  return _internal_has_refpos();
}
inline void DenmData::clear_refpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.refpos_ != nullptr) {
    delete _impl_.refpos_;
  }
  _impl_.refpos_ = nullptr;
}
inline const ::cn::seisys::v2x::pb::Position3D& DenmData::_internal_refpos() const {
  const ::cn::seisys::v2x::pb::Position3D* p = _impl_.refpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::v2x::pb::Position3D&>(
      ::cn::seisys::v2x::pb::_Position3D_default_instance_);
}
inline const ::cn::seisys::v2x::pb::Position3D& DenmData::refpos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DenmData.refPos)
  return _internal_refpos();
}
inline void DenmData::unsafe_arena_set_allocated_refpos(
    ::cn::seisys::v2x::pb::Position3D* refpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.refpos_);
  }
  _impl_.refpos_ = refpos;
  if (refpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.v2x.pb.DenmData.refPos)
}
inline ::cn::seisys::v2x::pb::Position3D* DenmData::release_refpos() {
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.refpos_;
  _impl_.refpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* DenmData::unsafe_arena_release_refpos() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.DenmData.refPos)
  
  ::cn::seisys::v2x::pb::Position3D* temp = _impl_.refpos_;
  _impl_.refpos_ = nullptr;
  return temp;
}
inline ::cn::seisys::v2x::pb::Position3D* DenmData::_internal_mutable_refpos() {
  
  if (_impl_.refpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::v2x::pb::Position3D>(GetArenaForAllocation());
    _impl_.refpos_ = p;
  }
  return _impl_.refpos_;
}
inline ::cn::seisys::v2x::pb::Position3D* DenmData::mutable_refpos() {
  ::cn::seisys::v2x::pb::Position3D* _msg = _internal_mutable_refpos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DenmData.refPos)
  return _msg;
}
inline void DenmData::set_allocated_refpos(::cn::seisys::v2x::pb::Position3D* refpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.refpos_;
  }
  if (refpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(refpos);
    if (message_arena != submessage_arena) {
      refpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, refpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.refpos_ = refpos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.DenmData.refPos)
}

// .cn.seisys.v2x.pb.SceneType sceneType = 7;
inline void DenmData::clear_scenetype() {
  _impl_.scenetype_ = 0;
}
inline ::cn::seisys::v2x::pb::SceneType DenmData::_internal_scenetype() const {
  return static_cast< ::cn::seisys::v2x::pb::SceneType >(_impl_.scenetype_);
}
inline ::cn::seisys::v2x::pb::SceneType DenmData::scenetype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DenmData.sceneType)
  return _internal_scenetype();
}
inline void DenmData::_internal_set_scenetype(::cn::seisys::v2x::pb::SceneType value) {
  
  _impl_.scenetype_ = value;
}
inline void DenmData::set_scenetype(::cn::seisys::v2x::pb::SceneType value) {
  _internal_set_scenetype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.DenmData.sceneType)
}

// repeated .cn.seisys.v2x.pb.StatusData statusList = 8;
inline int DenmData::_internal_statuslist_size() const {
  return _impl_.statuslist_.size();
}
inline int DenmData::statuslist_size() const {
  return _internal_statuslist_size();
}
inline void DenmData::clear_statuslist() {
  _impl_.statuslist_.Clear();
}
inline ::cn::seisys::v2x::pb::StatusData* DenmData::mutable_statuslist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.DenmData.statusList)
  return _impl_.statuslist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::StatusData >*
DenmData::mutable_statuslist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.DenmData.statusList)
  return &_impl_.statuslist_;
}
inline const ::cn::seisys::v2x::pb::StatusData& DenmData::_internal_statuslist(int index) const {
  return _impl_.statuslist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::StatusData& DenmData::statuslist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.DenmData.statusList)
  return _internal_statuslist(index);
}
inline ::cn::seisys::v2x::pb::StatusData* DenmData::_internal_add_statuslist() {
  return _impl_.statuslist_.Add();
}
inline ::cn::seisys::v2x::pb::StatusData* DenmData::add_statuslist() {
  ::cn::seisys::v2x::pb::StatusData* _add = _internal_add_statuslist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.DenmData.statusList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::StatusData >&
DenmData::statuslist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.DenmData.statusList)
  return _impl_.statuslist_;
}

// -------------------------------------------------------------------

// RsiReply

// uint64 id = 1;
inline void RsiReply::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t RsiReply::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t RsiReply::id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.id)
  return _internal_id();
}
inline void RsiReply::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void RsiReply::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.id)
}

// uint32 eventType = 2;
inline void RsiReply::clear_eventtype() {
  _impl_.eventtype_ = 0u;
}
inline uint32_t RsiReply::_internal_eventtype() const {
  return _impl_.eventtype_;
}
inline uint32_t RsiReply::eventtype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.eventType)
  return _internal_eventtype();
}
inline void RsiReply::_internal_set_eventtype(uint32_t value) {
  
  _impl_.eventtype_ = value;
}
inline void RsiReply::set_eventtype(uint32_t value) {
  _internal_set_eventtype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.eventType)
}

// string sourceDeviceId = 3;
inline void RsiReply::clear_sourcedeviceid() {
  _impl_.sourcedeviceid_.ClearToEmpty();
}
inline const std::string& RsiReply::sourcedeviceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.sourceDeviceId)
  return _internal_sourcedeviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsiReply::set_sourcedeviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sourcedeviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.sourceDeviceId)
}
inline std::string* RsiReply::mutable_sourcedeviceid() {
  std::string* _s = _internal_mutable_sourcedeviceid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsiReply.sourceDeviceId)
  return _s;
}
inline const std::string& RsiReply::_internal_sourcedeviceid() const {
  return _impl_.sourcedeviceid_.Get();
}
inline void RsiReply::_internal_set_sourcedeviceid(const std::string& value) {
  
  _impl_.sourcedeviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* RsiReply::_internal_mutable_sourcedeviceid() {
  
  return _impl_.sourcedeviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* RsiReply::release_sourcedeviceid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsiReply.sourceDeviceId)
  return _impl_.sourcedeviceid_.Release();
}
inline void RsiReply::set_allocated_sourcedeviceid(std::string* sourcedeviceid) {
  if (sourcedeviceid != nullptr) {
    
  } else {
    
  }
  _impl_.sourcedeviceid_.SetAllocated(sourcedeviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcedeviceid_.IsDefault()) {
    _impl_.sourcedeviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsiReply.sourceDeviceId)
}

// string targetDeviceId = 4;
inline void RsiReply::clear_targetdeviceid() {
  _impl_.targetdeviceid_.ClearToEmpty();
}
inline const std::string& RsiReply::targetdeviceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.targetDeviceId)
  return _internal_targetdeviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsiReply::set_targetdeviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targetdeviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.targetDeviceId)
}
inline std::string* RsiReply::mutable_targetdeviceid() {
  std::string* _s = _internal_mutable_targetdeviceid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsiReply.targetDeviceId)
  return _s;
}
inline const std::string& RsiReply::_internal_targetdeviceid() const {
  return _impl_.targetdeviceid_.Get();
}
inline void RsiReply::_internal_set_targetdeviceid(const std::string& value) {
  
  _impl_.targetdeviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* RsiReply::_internal_mutable_targetdeviceid() {
  
  return _impl_.targetdeviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* RsiReply::release_targetdeviceid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsiReply.targetDeviceId)
  return _impl_.targetdeviceid_.Release();
}
inline void RsiReply::set_allocated_targetdeviceid(std::string* targetdeviceid) {
  if (targetdeviceid != nullptr) {
    
  } else {
    
  }
  _impl_.targetdeviceid_.SetAllocated(targetdeviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targetdeviceid_.IsDefault()) {
    _impl_.targetdeviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsiReply.targetDeviceId)
}

// string creatTime = 5;
inline void RsiReply::clear_creattime() {
  _impl_.creattime_.ClearToEmpty();
}
inline const std::string& RsiReply::creattime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.creatTime)
  return _internal_creattime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsiReply::set_creattime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creattime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.creatTime)
}
inline std::string* RsiReply::mutable_creattime() {
  std::string* _s = _internal_mutable_creattime();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsiReply.creatTime)
  return _s;
}
inline const std::string& RsiReply::_internal_creattime() const {
  return _impl_.creattime_.Get();
}
inline void RsiReply::_internal_set_creattime(const std::string& value) {
  
  _impl_.creattime_.Set(value, GetArenaForAllocation());
}
inline std::string* RsiReply::_internal_mutable_creattime() {
  
  return _impl_.creattime_.Mutable(GetArenaForAllocation());
}
inline std::string* RsiReply::release_creattime() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsiReply.creatTime)
  return _impl_.creattime_.Release();
}
inline void RsiReply::set_allocated_creattime(std::string* creattime) {
  if (creattime != nullptr) {
    
  } else {
    
  }
  _impl_.creattime_.SetAllocated(creattime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creattime_.IsDefault()) {
    _impl_.creattime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsiReply.creatTime)
}

// string distributionTime = 6;
inline void RsiReply::clear_distributiontime() {
  _impl_.distributiontime_.ClearToEmpty();
}
inline const std::string& RsiReply::distributiontime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.distributionTime)
  return _internal_distributiontime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsiReply::set_distributiontime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.distributiontime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.distributionTime)
}
inline std::string* RsiReply::mutable_distributiontime() {
  std::string* _s = _internal_mutable_distributiontime();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsiReply.distributionTime)
  return _s;
}
inline const std::string& RsiReply::_internal_distributiontime() const {
  return _impl_.distributiontime_.Get();
}
inline void RsiReply::_internal_set_distributiontime(const std::string& value) {
  
  _impl_.distributiontime_.Set(value, GetArenaForAllocation());
}
inline std::string* RsiReply::_internal_mutable_distributiontime() {
  
  return _impl_.distributiontime_.Mutable(GetArenaForAllocation());
}
inline std::string* RsiReply::release_distributiontime() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsiReply.distributionTime)
  return _impl_.distributiontime_.Release();
}
inline void RsiReply::set_allocated_distributiontime(std::string* distributiontime) {
  if (distributiontime != nullptr) {
    
  } else {
    
  }
  _impl_.distributiontime_.SetAllocated(distributiontime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.distributiontime_.IsDefault()) {
    _impl_.distributiontime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsiReply.distributionTime)
}

// string completionTime = 7;
inline void RsiReply::clear_completiontime() {
  _impl_.completiontime_.ClearToEmpty();
}
inline const std::string& RsiReply::completiontime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.completionTime)
  return _internal_completiontime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsiReply::set_completiontime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.completiontime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.completionTime)
}
inline std::string* RsiReply::mutable_completiontime() {
  std::string* _s = _internal_mutable_completiontime();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsiReply.completionTime)
  return _s;
}
inline const std::string& RsiReply::_internal_completiontime() const {
  return _impl_.completiontime_.Get();
}
inline void RsiReply::_internal_set_completiontime(const std::string& value) {
  
  _impl_.completiontime_.Set(value, GetArenaForAllocation());
}
inline std::string* RsiReply::_internal_mutable_completiontime() {
  
  return _impl_.completiontime_.Mutable(GetArenaForAllocation());
}
inline std::string* RsiReply::release_completiontime() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsiReply.completionTime)
  return _impl_.completiontime_.Release();
}
inline void RsiReply::set_allocated_completiontime(std::string* completiontime) {
  if (completiontime != nullptr) {
    
  } else {
    
  }
  _impl_.completiontime_.SetAllocated(completiontime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.completiontime_.IsDefault()) {
    _impl_.completiontime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsiReply.completionTime)
}

// string updateTime = 8;
inline void RsiReply::clear_updatetime() {
  _impl_.updatetime_.ClearToEmpty();
}
inline const std::string& RsiReply::updatetime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.updateTime)
  return _internal_updatetime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsiReply::set_updatetime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.updatetime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.updateTime)
}
inline std::string* RsiReply::mutable_updatetime() {
  std::string* _s = _internal_mutable_updatetime();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsiReply.updateTime)
  return _s;
}
inline const std::string& RsiReply::_internal_updatetime() const {
  return _impl_.updatetime_.Get();
}
inline void RsiReply::_internal_set_updatetime(const std::string& value) {
  
  _impl_.updatetime_.Set(value, GetArenaForAllocation());
}
inline std::string* RsiReply::_internal_mutable_updatetime() {
  
  return _impl_.updatetime_.Mutable(GetArenaForAllocation());
}
inline std::string* RsiReply::release_updatetime() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsiReply.updateTime)
  return _impl_.updatetime_.Release();
}
inline void RsiReply::set_allocated_updatetime(std::string* updatetime) {
  if (updatetime != nullptr) {
    
  } else {
    
  }
  _impl_.updatetime_.SetAllocated(updatetime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.updatetime_.IsDefault()) {
    _impl_.updatetime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsiReply.updateTime)
}

// uint32 operationType = 9;
inline void RsiReply::clear_operationtype() {
  _impl_.operationtype_ = 0u;
}
inline uint32_t RsiReply::_internal_operationtype() const {
  return _impl_.operationtype_;
}
inline uint32_t RsiReply::operationtype() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.operationType)
  return _internal_operationtype();
}
inline void RsiReply::_internal_set_operationtype(uint32_t value) {
  
  _impl_.operationtype_ = value;
}
inline void RsiReply::set_operationtype(uint32_t value) {
  _internal_set_operationtype(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.operationType)
}

// uint64 camDataId = 10;
inline void RsiReply::clear_camdataid() {
  _impl_.camdataid_ = uint64_t{0u};
}
inline uint64_t RsiReply::_internal_camdataid() const {
  return _impl_.camdataid_;
}
inline uint64_t RsiReply::camdataid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.camDataId)
  return _internal_camdataid();
}
inline void RsiReply::_internal_set_camdataid(uint64_t value) {
  
  _impl_.camdataid_ = value;
}
inline void RsiReply::set_camdataid(uint64_t value) {
  _internal_set_camdataid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.camDataId)
}

// uint64 dataId = 11;
inline void RsiReply::clear_dataid() {
  _impl_.dataid_ = uint64_t{0u};
}
inline uint64_t RsiReply::_internal_dataid() const {
  return _impl_.dataid_;
}
inline uint64_t RsiReply::dataid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.dataId)
  return _internal_dataid();
}
inline void RsiReply::_internal_set_dataid(uint64_t value) {
  
  _impl_.dataid_ = value;
}
inline void RsiReply::set_dataid(uint64_t value) {
  _internal_set_dataid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.dataId)
}

// uint64 eventSourceId = 12;
inline void RsiReply::clear_eventsourceid() {
  _impl_.eventsourceid_ = uint64_t{0u};
}
inline uint64_t RsiReply::_internal_eventsourceid() const {
  return _impl_.eventsourceid_;
}
inline uint64_t RsiReply::eventsourceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.eventSourceId)
  return _internal_eventsourceid();
}
inline void RsiReply::_internal_set_eventsourceid(uint64_t value) {
  
  _impl_.eventsourceid_ = value;
}
inline void RsiReply::set_eventsourceid(uint64_t value) {
  _internal_set_eventsourceid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.eventSourceId)
}

// uint32 distributionStatusId = 13;
inline void RsiReply::clear_distributionstatusid() {
  _impl_.distributionstatusid_ = 0u;
}
inline uint32_t RsiReply::_internal_distributionstatusid() const {
  return _impl_.distributionstatusid_;
}
inline uint32_t RsiReply::distributionstatusid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.distributionStatusId)
  return _internal_distributionstatusid();
}
inline void RsiReply::_internal_set_distributionstatusid(uint32_t value) {
  
  _impl_.distributionstatusid_ = value;
}
inline void RsiReply::set_distributionstatusid(uint32_t value) {
  _internal_set_distributionstatusid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.distributionStatusId)
}

// string description = 14;
inline void RsiReply::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& RsiReply::description() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsiReply::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.description)
}
inline std::string* RsiReply::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsiReply.description)
  return _s;
}
inline const std::string& RsiReply::_internal_description() const {
  return _impl_.description_.Get();
}
inline void RsiReply::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* RsiReply::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* RsiReply::release_description() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsiReply.description)
  return _impl_.description_.Release();
}
inline void RsiReply::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsiReply.description)
}

// string sourceTopic = 15;
inline void RsiReply::clear_sourcetopic() {
  _impl_.sourcetopic_.ClearToEmpty();
}
inline const std::string& RsiReply::sourcetopic() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.sourceTopic)
  return _internal_sourcetopic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsiReply::set_sourcetopic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sourcetopic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.sourceTopic)
}
inline std::string* RsiReply::mutable_sourcetopic() {
  std::string* _s = _internal_mutable_sourcetopic();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsiReply.sourceTopic)
  return _s;
}
inline const std::string& RsiReply::_internal_sourcetopic() const {
  return _impl_.sourcetopic_.Get();
}
inline void RsiReply::_internal_set_sourcetopic(const std::string& value) {
  
  _impl_.sourcetopic_.Set(value, GetArenaForAllocation());
}
inline std::string* RsiReply::_internal_mutable_sourcetopic() {
  
  return _impl_.sourcetopic_.Mutable(GetArenaForAllocation());
}
inline std::string* RsiReply::release_sourcetopic() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsiReply.sourceTopic)
  return _impl_.sourcetopic_.Release();
}
inline void RsiReply::set_allocated_sourcetopic(std::string* sourcetopic) {
  if (sourcetopic != nullptr) {
    
  } else {
    
  }
  _impl_.sourcetopic_.SetAllocated(sourcetopic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcetopic_.IsDefault()) {
    _impl_.sourcetopic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsiReply.sourceTopic)
}

// string targetTopic = 16;
inline void RsiReply::clear_targettopic() {
  _impl_.targettopic_.ClearToEmpty();
}
inline const std::string& RsiReply::targettopic() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsiReply.targetTopic)
  return _internal_targettopic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsiReply::set_targettopic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targettopic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsiReply.targetTopic)
}
inline std::string* RsiReply::mutable_targettopic() {
  std::string* _s = _internal_mutable_targettopic();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsiReply.targetTopic)
  return _s;
}
inline const std::string& RsiReply::_internal_targettopic() const {
  return _impl_.targettopic_.Get();
}
inline void RsiReply::_internal_set_targettopic(const std::string& value) {
  
  _impl_.targettopic_.Set(value, GetArenaForAllocation());
}
inline std::string* RsiReply::_internal_mutable_targettopic() {
  
  return _impl_.targettopic_.Mutable(GetArenaForAllocation());
}
inline std::string* RsiReply::release_targettopic() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsiReply.targetTopic)
  return _impl_.targettopic_.Release();
}
inline void RsiReply::set_allocated_targettopic(std::string* targettopic) {
  if (targettopic != nullptr) {
    
  } else {
    
  }
  _impl_.targettopic_.SetAllocated(targettopic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targettopic_.IsDefault()) {
    _impl_.targettopic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsiReply.targetTopic)
}

// -------------------------------------------------------------------

// RsuRsmReply

// string sourceDeviceId = 1;
inline void RsuRsmReply::clear_sourcedeviceid() {
  _impl_.sourcedeviceid_.ClearToEmpty();
}
inline const std::string& RsuRsmReply::sourcedeviceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsuRsmReply.sourceDeviceId)
  return _internal_sourcedeviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsuRsmReply::set_sourcedeviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sourcedeviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsuRsmReply.sourceDeviceId)
}
inline std::string* RsuRsmReply::mutable_sourcedeviceid() {
  std::string* _s = _internal_mutable_sourcedeviceid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsuRsmReply.sourceDeviceId)
  return _s;
}
inline const std::string& RsuRsmReply::_internal_sourcedeviceid() const {
  return _impl_.sourcedeviceid_.Get();
}
inline void RsuRsmReply::_internal_set_sourcedeviceid(const std::string& value) {
  
  _impl_.sourcedeviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* RsuRsmReply::_internal_mutable_sourcedeviceid() {
  
  return _impl_.sourcedeviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* RsuRsmReply::release_sourcedeviceid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsuRsmReply.sourceDeviceId)
  return _impl_.sourcedeviceid_.Release();
}
inline void RsuRsmReply::set_allocated_sourcedeviceid(std::string* sourcedeviceid) {
  if (sourcedeviceid != nullptr) {
    
  } else {
    
  }
  _impl_.sourcedeviceid_.SetAllocated(sourcedeviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcedeviceid_.IsDefault()) {
    _impl_.sourcedeviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsuRsmReply.sourceDeviceId)
}

// string targetDeviceId = 2;
inline void RsuRsmReply::clear_targetdeviceid() {
  _impl_.targetdeviceid_.ClearToEmpty();
}
inline const std::string& RsuRsmReply::targetdeviceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsuRsmReply.targetDeviceId)
  return _internal_targetdeviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsuRsmReply::set_targetdeviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targetdeviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsuRsmReply.targetDeviceId)
}
inline std::string* RsuRsmReply::mutable_targetdeviceid() {
  std::string* _s = _internal_mutable_targetdeviceid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsuRsmReply.targetDeviceId)
  return _s;
}
inline const std::string& RsuRsmReply::_internal_targetdeviceid() const {
  return _impl_.targetdeviceid_.Get();
}
inline void RsuRsmReply::_internal_set_targetdeviceid(const std::string& value) {
  
  _impl_.targetdeviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* RsuRsmReply::_internal_mutable_targetdeviceid() {
  
  return _impl_.targetdeviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* RsuRsmReply::release_targetdeviceid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsuRsmReply.targetDeviceId)
  return _impl_.targetdeviceid_.Release();
}
inline void RsuRsmReply::set_allocated_targetdeviceid(std::string* targetdeviceid) {
  if (targetdeviceid != nullptr) {
    
  } else {
    
  }
  _impl_.targetdeviceid_.SetAllocated(targetdeviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targetdeviceid_.IsDefault()) {
    _impl_.targetdeviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsuRsmReply.targetDeviceId)
}

// uint64 camDataId = 3;
inline void RsuRsmReply::clear_camdataid() {
  _impl_.camdataid_ = uint64_t{0u};
}
inline uint64_t RsuRsmReply::_internal_camdataid() const {
  return _impl_.camdataid_;
}
inline uint64_t RsuRsmReply::camdataid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsuRsmReply.camDataId)
  return _internal_camdataid();
}
inline void RsuRsmReply::_internal_set_camdataid(uint64_t value) {
  
  _impl_.camdataid_ = value;
}
inline void RsuRsmReply::set_camdataid(uint64_t value) {
  _internal_set_camdataid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsuRsmReply.camDataId)
}

// repeated .cn.seisys.v2x.pb.RsmReply rsmReplyList = 4;
inline int RsuRsmReply::_internal_rsmreplylist_size() const {
  return _impl_.rsmreplylist_.size();
}
inline int RsuRsmReply::rsmreplylist_size() const {
  return _internal_rsmreplylist_size();
}
inline void RsuRsmReply::clear_rsmreplylist() {
  _impl_.rsmreplylist_.Clear();
}
inline ::cn::seisys::v2x::pb::RsmReply* RsuRsmReply::mutable_rsmreplylist(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsuRsmReply.rsmReplyList)
  return _impl_.rsmreplylist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RsmReply >*
RsuRsmReply::mutable_rsmreplylist() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.v2x.pb.RsuRsmReply.rsmReplyList)
  return &_impl_.rsmreplylist_;
}
inline const ::cn::seisys::v2x::pb::RsmReply& RsuRsmReply::_internal_rsmreplylist(int index) const {
  return _impl_.rsmreplylist_.Get(index);
}
inline const ::cn::seisys::v2x::pb::RsmReply& RsuRsmReply::rsmreplylist(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsuRsmReply.rsmReplyList)
  return _internal_rsmreplylist(index);
}
inline ::cn::seisys::v2x::pb::RsmReply* RsuRsmReply::_internal_add_rsmreplylist() {
  return _impl_.rsmreplylist_.Add();
}
inline ::cn::seisys::v2x::pb::RsmReply* RsuRsmReply::add_rsmreplylist() {
  ::cn::seisys::v2x::pb::RsmReply* _add = _internal_add_rsmreplylist();
  // @@protoc_insertion_point(field_add:cn.seisys.v2x.pb.RsuRsmReply.rsmReplyList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::v2x::pb::RsmReply >&
RsuRsmReply::rsmreplylist() const {
  // @@protoc_insertion_point(field_list:cn.seisys.v2x.pb.RsuRsmReply.rsmReplyList)
  return _impl_.rsmreplylist_;
}

// string targetTopic = 5;
inline void RsuRsmReply::clear_targettopic() {
  _impl_.targettopic_.ClearToEmpty();
}
inline const std::string& RsuRsmReply::targettopic() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsuRsmReply.targetTopic)
  return _internal_targettopic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsuRsmReply::set_targettopic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targettopic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsuRsmReply.targetTopic)
}
inline std::string* RsuRsmReply::mutable_targettopic() {
  std::string* _s = _internal_mutable_targettopic();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsuRsmReply.targetTopic)
  return _s;
}
inline const std::string& RsuRsmReply::_internal_targettopic() const {
  return _impl_.targettopic_.Get();
}
inline void RsuRsmReply::_internal_set_targettopic(const std::string& value) {
  
  _impl_.targettopic_.Set(value, GetArenaForAllocation());
}
inline std::string* RsuRsmReply::_internal_mutable_targettopic() {
  
  return _impl_.targettopic_.Mutable(GetArenaForAllocation());
}
inline std::string* RsuRsmReply::release_targettopic() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsuRsmReply.targetTopic)
  return _impl_.targettopic_.Release();
}
inline void RsuRsmReply::set_allocated_targettopic(std::string* targettopic) {
  if (targettopic != nullptr) {
    
  } else {
    
  }
  _impl_.targettopic_.SetAllocated(targettopic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targettopic_.IsDefault()) {
    _impl_.targettopic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsuRsmReply.targetTopic)
}

// uint64 timestamp = 6;
inline void RsuRsmReply::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t RsuRsmReply::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t RsuRsmReply::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsuRsmReply.timestamp)
  return _internal_timestamp();
}
inline void RsuRsmReply::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void RsuRsmReply::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsuRsmReply.timestamp)
}

// -------------------------------------------------------------------

// RsmReply

// uint64 dataId = 1;
inline void RsmReply::clear_dataid() {
  _impl_.dataid_ = uint64_t{0u};
}
inline uint64_t RsmReply::_internal_dataid() const {
  return _impl_.dataid_;
}
inline uint64_t RsmReply::dataid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsmReply.dataId)
  return _internal_dataid();
}
inline void RsmReply::_internal_set_dataid(uint64_t value) {
  
  _impl_.dataid_ = value;
}
inline void RsmReply::set_dataid(uint64_t value) {
  _internal_set_dataid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsmReply.dataId)
}

// uint32 distributionStatusId = 2;
inline void RsmReply::clear_distributionstatusid() {
  _impl_.distributionstatusid_ = 0u;
}
inline uint32_t RsmReply::_internal_distributionstatusid() const {
  return _impl_.distributionstatusid_;
}
inline uint32_t RsmReply::distributionstatusid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsmReply.distributionStatusId)
  return _internal_distributionstatusid();
}
inline void RsmReply::_internal_set_distributionstatusid(uint32_t value) {
  
  _impl_.distributionstatusid_ = value;
}
inline void RsmReply::set_distributionstatusid(uint32_t value) {
  _internal_set_distributionstatusid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsmReply.distributionStatusId)
}

// string description = 3;
inline void RsmReply::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& RsmReply::description() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.RsmReply.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsmReply::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.RsmReply.description)
}
inline std::string* RsmReply::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.RsmReply.description)
  return _s;
}
inline const std::string& RsmReply::_internal_description() const {
  return _impl_.description_.Get();
}
inline void RsmReply::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* RsmReply::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* RsmReply::release_description() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.RsmReply.description)
  return _impl_.description_.Release();
}
inline void RsmReply::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.RsmReply.description)
}

// -------------------------------------------------------------------

// MonitorStatsData

// uint64 timestamp = 1;
inline void MonitorStatsData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t MonitorStatsData::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.timestamp)
  return _internal_timestamp();
}
inline void MonitorStatsData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void MonitorStatsData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.timestamp)
}

// string deviceId = 2;
inline void MonitorStatsData::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
}
inline const std::string& MonitorStatsData::deviceid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MonitorStatsData::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.deviceId)
}
inline std::string* MonitorStatsData::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.v2x.pb.MonitorStatsData.deviceId)
  return _s;
}
inline const std::string& MonitorStatsData::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void MonitorStatsData::_internal_set_deviceid(const std::string& value) {
  
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* MonitorStatsData::_internal_mutable_deviceid() {
  
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* MonitorStatsData::release_deviceid() {
  // @@protoc_insertion_point(field_release:cn.seisys.v2x.pb.MonitorStatsData.deviceId)
  return _impl_.deviceid_.Release();
}
inline void MonitorStatsData::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.v2x.pb.MonitorStatsData.deviceId)
}

// uint64 camNums = 3;
inline void MonitorStatsData::clear_camnums() {
  _impl_.camnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_camnums() const {
  return _impl_.camnums_;
}
inline uint64_t MonitorStatsData::camnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.camNums)
  return _internal_camnums();
}
inline void MonitorStatsData::_internal_set_camnums(uint64_t value) {
  
  _impl_.camnums_ = value;
}
inline void MonitorStatsData::set_camnums(uint64_t value) {
  _internal_set_camnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.camNums)
}

// uint64 participantNums = 4;
inline void MonitorStatsData::clear_participantnums() {
  _impl_.participantnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_participantnums() const {
  return _impl_.participantnums_;
}
inline uint64_t MonitorStatsData::participantnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.participantNums)
  return _internal_participantnums();
}
inline void MonitorStatsData::_internal_set_participantnums(uint64_t value) {
  
  _impl_.participantnums_ = value;
}
inline void MonitorStatsData::set_participantnums(uint64_t value) {
  _internal_set_participantnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.participantNums)
}

// uint64 rteNums = 5;
inline void MonitorStatsData::clear_rtenums() {
  _impl_.rtenums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_rtenums() const {
  return _impl_.rtenums_;
}
inline uint64_t MonitorStatsData::rtenums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.rteNums)
  return _internal_rtenums();
}
inline void MonitorStatsData::_internal_set_rtenums(uint64_t value) {
  
  _impl_.rtenums_ = value;
}
inline void MonitorStatsData::set_rtenums(uint64_t value) {
  _internal_set_rtenums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.rteNums)
}

// uint64 trafficflowNums = 6;
inline void MonitorStatsData::clear_trafficflownums() {
  _impl_.trafficflownums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_trafficflownums() const {
  return _impl_.trafficflownums_;
}
inline uint64_t MonitorStatsData::trafficflownums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.trafficflowNums)
  return _internal_trafficflownums();
}
inline void MonitorStatsData::_internal_set_trafficflownums(uint64_t value) {
  
  _impl_.trafficflownums_ = value;
}
inline void MonitorStatsData::set_trafficflownums(uint64_t value) {
  _internal_set_trafficflownums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.trafficflowNums)
}

// uint64 trafficflowStatNums = 7;
inline void MonitorStatsData::clear_trafficflowstatnums() {
  _impl_.trafficflowstatnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_trafficflowstatnums() const {
  return _impl_.trafficflowstatnums_;
}
inline uint64_t MonitorStatsData::trafficflowstatnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.trafficflowStatNums)
  return _internal_trafficflowstatnums();
}
inline void MonitorStatsData::_internal_set_trafficflowstatnums(uint64_t value) {
  
  _impl_.trafficflowstatnums_ = value;
}
inline void MonitorStatsData::set_trafficflowstatnums(uint64_t value) {
  _internal_set_trafficflowstatnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.trafficflowStatNums)
}

// uint64 intersectionStatNums = 8;
inline void MonitorStatsData::clear_intersectionstatnums() {
  _impl_.intersectionstatnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_intersectionstatnums() const {
  return _impl_.intersectionstatnums_;
}
inline uint64_t MonitorStatsData::intersectionstatnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.intersectionStatNums)
  return _internal_intersectionstatnums();
}
inline void MonitorStatsData::_internal_set_intersectionstatnums(uint64_t value) {
  
  _impl_.intersectionstatnums_ = value;
}
inline void MonitorStatsData::set_intersectionstatnums(uint64_t value) {
  _internal_set_intersectionstatnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.intersectionStatNums)
}

// uint64 phaseStatNums = 9;
inline void MonitorStatsData::clear_phasestatnums() {
  _impl_.phasestatnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_phasestatnums() const {
  return _impl_.phasestatnums_;
}
inline uint64_t MonitorStatsData::phasestatnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.phaseStatNums)
  return _internal_phasestatnums();
}
inline void MonitorStatsData::_internal_set_phasestatnums(uint64_t value) {
  
  _impl_.phasestatnums_ = value;
}
inline void MonitorStatsData::set_phasestatnums(uint64_t value) {
  _internal_set_phasestatnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.phaseStatNums)
}

// uint64 rtsNums = 10;
inline void MonitorStatsData::clear_rtsnums() {
  _impl_.rtsnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_rtsnums() const {
  return _impl_.rtsnums_;
}
inline uint64_t MonitorStatsData::rtsnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.rtsNums)
  return _internal_rtsnums();
}
inline void MonitorStatsData::_internal_set_rtsnums(uint64_t value) {
  
  _impl_.rtsnums_ = value;
}
inline void MonitorStatsData::set_rtsnums(uint64_t value) {
  _internal_set_rtsnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.rtsNums)
}

// uint64 cameraPathListNums = 11;
inline void MonitorStatsData::clear_camerapathlistnums() {
  _impl_.camerapathlistnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_camerapathlistnums() const {
  return _impl_.camerapathlistnums_;
}
inline uint64_t MonitorStatsData::camerapathlistnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.cameraPathListNums)
  return _internal_camerapathlistnums();
}
inline void MonitorStatsData::_internal_set_camerapathlistnums(uint64_t value) {
  
  _impl_.camerapathlistnums_ = value;
}
inline void MonitorStatsData::set_camerapathlistnums(uint64_t value) {
  _internal_set_camerapathlistnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.cameraPathListNums)
}

// uint64 cameraPathNums = 12;
inline void MonitorStatsData::clear_camerapathnums() {
  _impl_.camerapathnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_camerapathnums() const {
  return _impl_.camerapathnums_;
}
inline uint64_t MonitorStatsData::camerapathnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.cameraPathNums)
  return _internal_camerapathnums();
}
inline void MonitorStatsData::_internal_set_camerapathnums(uint64_t value) {
  
  _impl_.camerapathnums_ = value;
}
inline void MonitorStatsData::set_camerapathnums(uint64_t value) {
  _internal_set_camerapathnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.cameraPathNums)
}

// uint64 radarPathListNums = 13;
inline void MonitorStatsData::clear_radarpathlistnums() {
  _impl_.radarpathlistnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_radarpathlistnums() const {
  return _impl_.radarpathlistnums_;
}
inline uint64_t MonitorStatsData::radarpathlistnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.radarPathListNums)
  return _internal_radarpathlistnums();
}
inline void MonitorStatsData::_internal_set_radarpathlistnums(uint64_t value) {
  
  _impl_.radarpathlistnums_ = value;
}
inline void MonitorStatsData::set_radarpathlistnums(uint64_t value) {
  _internal_set_radarpathlistnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.radarPathListNums)
}

// uint64 radarPathNums = 14;
inline void MonitorStatsData::clear_radarpathnums() {
  _impl_.radarpathnums_ = uint64_t{0u};
}
inline uint64_t MonitorStatsData::_internal_radarpathnums() const {
  return _impl_.radarpathnums_;
}
inline uint64_t MonitorStatsData::radarpathnums() const {
  // @@protoc_insertion_point(field_get:cn.seisys.v2x.pb.MonitorStatsData.radarPathNums)
  return _internal_radarpathnums();
}
inline void MonitorStatsData::_internal_set_radarpathnums(uint64_t value) {
  
  _impl_.radarpathnums_ = value;
}
inline void MonitorStatsData::set_radarpathnums(uint64_t value) {
  _internal_set_radarpathnums(value);
  // @@protoc_insertion_point(field_set:cn.seisys.v2x.pb.MonitorStatsData.radarPathNums)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace v2x
}  // namespace seisys
}  // namespace cn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence>() {
  return ::cn::seisys::v2x::pb::PositionConfidenceSet_PositionConfidence_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence>() {
  return ::cn::seisys::v2x::pb::PositionConfidenceSet_ElevationConfidence_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence>() {
  return ::cn::seisys::v2x::pb::ParticipantSizeConfidence_SizeValueConfidence_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType>() {
  return ::cn::seisys::v2x::pb::RegulatorySpeedLimit_SpeedLimitType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence>() {
  return ::cn::seisys::v2x::pb::AccelerationConfidence_AccConfidence_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence>() {
  return ::cn::seisys::v2x::pb::AccelerationConfidence_AngularVConfidence_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence>() {
  return ::cn::seisys::v2x::pb::MotionConfidenceSet_SteeringWheelAngleConfidence_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::PhaseState_LightState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::PhaseState_LightState>() {
  return ::cn::seisys::v2x::pb::PhaseState_LightState_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus>() {
  return ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakePedalStatus_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus>() {
  return ::cn::seisys::v2x::pb::BrakeSystemStatus_TractionControlStatus_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus>() {
  return ::cn::seisys::v2x::pb::BrakeSystemStatus_AntiLockBrakeStatus_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus>() {
  return ::cn::seisys::v2x::pb::BrakeSystemStatus_StabilityControlStatus_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied>() {
  return ::cn::seisys::v2x::pb::BrakeSystemStatus_BrakeBoostApplied_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus>() {
  return ::cn::seisys::v2x::pb::BrakeSystemStatus_AuxiliaryBrakeStatus_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts>() {
  return ::cn::seisys::v2x::pb::ThrottleSystemStatus_ThrottlePedalStauts_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BsmData_TransmissionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BsmData_TransmissionState>() {
  return ::cn::seisys::v2x::pb::BsmData_TransmissionState_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BsmData_VehicleFuelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BsmData_VehicleFuelType>() {
  return ::cn::seisys::v2x::pb::BsmData_VehicleFuelType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BsmData_DriveStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BsmData_DriveStatus>() {
  return ::cn::seisys::v2x::pb::BsmData_DriveStatus_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BsmData_EmergenyStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BsmData_EmergenyStatus>() {
  return ::cn::seisys::v2x::pb::BsmData_EmergenyStatus_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BsmData_Wiper> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BsmData_Wiper>() {
  return ::cn::seisys::v2x::pb::BsmData_Wiper_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::BsmData_OutofControl> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::BsmData_OutofControl>() {
  return ::cn::seisys::v2x::pb::BsmData_OutofControl_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::ParticipantData_PlateColor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::ParticipantData_PlateColor>() {
  return ::cn::seisys::v2x::pb::ParticipantData_PlateColor_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::ParticipantData_VehicleColor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::ParticipantData_VehicleColor>() {
  return ::cn::seisys::v2x::pb::ParticipantData_VehicleColor_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt>() {
  return ::cn::seisys::v2x::pb::ParticipantData_ParticipantTypeExt_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::ObjIdValue_Role> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::ObjIdValue_Role>() {
  return ::cn::seisys::v2x::pb::ObjIdValue_Role_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::RteData_EventSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::RteData_EventSource>() {
  return ::cn::seisys::v2x::pb::RteData_EventSource_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::DriveRequest_ReqStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::DriveRequest_ReqStatus>() {
  return ::cn::seisys::v2x::pb::DriveRequest_ReqStatus_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::StatusData_StatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::StatusData_StatusType>() {
  return ::cn::seisys::v2x::pb::StatusData_StatusType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::Message_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::Message_Type>() {
  return ::cn::seisys::v2x::pb::Message_Type_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::DataSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::DataSource>() {
  return ::cn::seisys::v2x::pb::DataSource_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::TimeConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::TimeConfidence>() {
  return ::cn::seisys::v2x::pb::TimeConfidence_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::ParticipantType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::ParticipantType>() {
  return ::cn::seisys::v2x::pb::ParticipantType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::SpeedConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::SpeedConfidence>() {
  return ::cn::seisys::v2x::pb::SpeedConfidence_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::HeadingConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::HeadingConfidence>() {
  return ::cn::seisys::v2x::pb::HeadingConfidence_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::VehicleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::VehicleType>() {
  return ::cn::seisys::v2x::pb::VehicleType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::Maneuver> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::Maneuver>() {
  return ::cn::seisys::v2x::pb::Maneuver_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::MapElementType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::MapElementType>() {
  return ::cn::seisys::v2x::pb::MapElementType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::PlateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::PlateType>() {
  return ::cn::seisys::v2x::pb::PlateType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::ObstaclesType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::ObstaclesType>() {
  return ::cn::seisys::v2x::pb::ObstaclesType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::SceneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::SceneType>() {
  return ::cn::seisys::v2x::pb::SceneType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::v2x::pb::DeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::v2x::pb::DeviceType>() {
  return ::cn::seisys::v2x::pb::DeviceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_v2x_2eproto
