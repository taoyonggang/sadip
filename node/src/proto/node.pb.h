// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: node.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_node_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_node_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_node_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_node_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_node_2eproto;
namespace cn {
namespace seisys {
namespace dds {
class Cpu;
struct CpuDefaultTypeInternal;
extern CpuDefaultTypeInternal _Cpu_default_instance_;
class Disk;
struct DiskDefaultTypeInternal;
extern DiskDefaultTypeInternal _Disk_default_instance_;
class File;
struct FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class FileInfos;
struct FileInfosDefaultTypeInternal;
extern FileInfosDefaultTypeInternal _FileInfos_default_instance_;
class Gpu;
struct GpuDefaultTypeInternal;
extern GpuDefaultTypeInternal _Gpu_default_instance_;
class MachineState;
struct MachineStateDefaultTypeInternal;
extern MachineStateDefaultTypeInternal _MachineState_default_instance_;
class MainBoard;
struct MainBoardDefaultTypeInternal;
extern MainBoardDefaultTypeInternal _MainBoard_default_instance_;
class Network;
struct NetworkDefaultTypeInternal;
extern NetworkDefaultTypeInternal _Network_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class NodeCmd;
struct NodeCmdDefaultTypeInternal;
extern NodeCmdDefaultTypeInternal _NodeCmd_default_instance_;
class NodeCmdReply;
struct NodeCmdReplyDefaultTypeInternal;
extern NodeCmdReplyDefaultTypeInternal _NodeCmdReply_default_instance_;
class NodeReply;
struct NodeReplyDefaultTypeInternal;
extern NodeReplyDefaultTypeInternal _NodeReply_default_instance_;
class OSInfo;
struct OSInfoDefaultTypeInternal;
extern OSInfoDefaultTypeInternal _OSInfo_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Process;
struct ProcessDefaultTypeInternal;
extern ProcessDefaultTypeInternal _Process_default_instance_;
class ProcessTime;
struct ProcessTimeDefaultTypeInternal;
extern ProcessTimeDefaultTypeInternal _ProcessTime_default_instance_;
class Process_EnvEntry_DoNotUse;
struct Process_EnvEntry_DoNotUseDefaultTypeInternal;
extern Process_EnvEntry_DoNotUseDefaultTypeInternal _Process_EnvEntry_DoNotUse_default_instance_;
class Ram;
struct RamDefaultTypeInternal;
extern RamDefaultTypeInternal _Ram_default_instance_;
}  // namespace dds
}  // namespace seisys
}  // namespace cn
PROTOBUF_NAMESPACE_OPEN
template<> ::cn::seisys::dds::Cpu* Arena::CreateMaybeMessage<::cn::seisys::dds::Cpu>(Arena*);
template<> ::cn::seisys::dds::Disk* Arena::CreateMaybeMessage<::cn::seisys::dds::Disk>(Arena*);
template<> ::cn::seisys::dds::File* Arena::CreateMaybeMessage<::cn::seisys::dds::File>(Arena*);
template<> ::cn::seisys::dds::FileInfos* Arena::CreateMaybeMessage<::cn::seisys::dds::FileInfos>(Arena*);
template<> ::cn::seisys::dds::Gpu* Arena::CreateMaybeMessage<::cn::seisys::dds::Gpu>(Arena*);
template<> ::cn::seisys::dds::MachineState* Arena::CreateMaybeMessage<::cn::seisys::dds::MachineState>(Arena*);
template<> ::cn::seisys::dds::MainBoard* Arena::CreateMaybeMessage<::cn::seisys::dds::MainBoard>(Arena*);
template<> ::cn::seisys::dds::Network* Arena::CreateMaybeMessage<::cn::seisys::dds::Network>(Arena*);
template<> ::cn::seisys::dds::Node* Arena::CreateMaybeMessage<::cn::seisys::dds::Node>(Arena*);
template<> ::cn::seisys::dds::NodeCmd* Arena::CreateMaybeMessage<::cn::seisys::dds::NodeCmd>(Arena*);
template<> ::cn::seisys::dds::NodeCmdReply* Arena::CreateMaybeMessage<::cn::seisys::dds::NodeCmdReply>(Arena*);
template<> ::cn::seisys::dds::NodeReply* Arena::CreateMaybeMessage<::cn::seisys::dds::NodeReply>(Arena*);
template<> ::cn::seisys::dds::OSInfo* Arena::CreateMaybeMessage<::cn::seisys::dds::OSInfo>(Arena*);
template<> ::cn::seisys::dds::Ping* Arena::CreateMaybeMessage<::cn::seisys::dds::Ping>(Arena*);
template<> ::cn::seisys::dds::Process* Arena::CreateMaybeMessage<::cn::seisys::dds::Process>(Arena*);
template<> ::cn::seisys::dds::ProcessTime* Arena::CreateMaybeMessage<::cn::seisys::dds::ProcessTime>(Arena*);
template<> ::cn::seisys::dds::Process_EnvEntry_DoNotUse* Arena::CreateMaybeMessage<::cn::seisys::dds::Process_EnvEntry_DoNotUse>(Arena*);
template<> ::cn::seisys::dds::Ram* Arena::CreateMaybeMessage<::cn::seisys::dds::Ram>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cn {
namespace seisys {
namespace dds {

enum ArchType : int {
  ARCHTYPE_UNKNOWN = 0,
  AMD64 = 1,
  X86 = 2,
  ARM64V8 = 3,
  ArchType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ArchType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ArchType_IsValid(int value);
constexpr ArchType ArchType_MIN = ARCHTYPE_UNKNOWN;
constexpr ArchType ArchType_MAX = ARM64V8;
constexpr int ArchType_ARRAYSIZE = ArchType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArchType_descriptor();
template<typename T>
inline const std::string& ArchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArchType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArchType_descriptor(), enum_t_value);
}
inline bool ArchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArchType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArchType>(
    ArchType_descriptor(), name, value);
}
enum OSType : int {
  OSTYPE_NOWN = 0,
  WINDOWA = 1,
  LINUX = 2,
  OSType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OSType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OSType_IsValid(int value);
constexpr OSType OSType_MIN = OSTYPE_NOWN;
constexpr OSType OSType_MAX = LINUX;
constexpr int OSType_ARRAYSIZE = OSType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OSType_descriptor();
template<typename T>
inline const std::string& OSType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OSType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OSType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OSType_descriptor(), enum_t_value);
}
inline bool OSType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OSType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OSType>(
    OSType_descriptor(), name, value);
}
enum CmdType : int {
  CMDTYPE_UNKNOWN = 0,
  REBOOT = 1,
  RESTART = 2,
  LS = 3,
  MKDIR = 4,
  DEL = 5,
  DELDIR = 6,
  SENDFILE = 7,
  ADDAPP = 8,
  REMOVEAPP = 9,
  STARTAPP = 10,
  STOPAPP = 11,
  RESTARTAPP = 12,
  LSAPP = 13,
  ADDPLUGIN = 14,
  REMOVEPLUGIN = 15,
  STARTPLUGIN = 16,
  STOPPLUGIN = 17,
  RESTARTPLUGIN = 18,
  LSPLUGIN = 19,
  GETS3FILE = 20,
  PUTS3FILE = 21,
  LSS3DIR = 22,
  LSS3BUCKETS = 23,
  COPYS3FILE = 24,
  DELS3FILE = 25,
  ZIP = 26,
  DZIP = 27,
  ADDS3WATCH = 28,
  RMS3WATCH = 29,
  LSS3WATCH = 30,
  STARTTRACELOG = 31,
  STOPTRACELOG = 32,
  LSTRACELOG = 33,
  STARTEXEC = 34,
  STOPEXEC = 35,
  LSEXEC = 36,
  RMEXEC = 37,
  GETEXECRESULT = 38,
  MKFILE = 39,
  CPFILE = 40,
  PODMANCMD = 41,
  CmdType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CmdType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CmdType_IsValid(int value);
constexpr CmdType CmdType_MIN = CMDTYPE_UNKNOWN;
constexpr CmdType CmdType_MAX = PODMANCMD;
constexpr int CmdType_ARRAYSIZE = CmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CmdType_descriptor();
template<typename T>
inline const std::string& CmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CmdType_descriptor(), enum_t_value);
}
inline bool CmdType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CmdType>(
    CmdType_descriptor(), name, value);
}
enum NodeState : int {
  NODE_STATE_UNKNOWN = 0,
  ONLINE = 1,
  OFFLINE = 2,
  OVERLOAD = 3,
  NodeState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NodeState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NodeState_IsValid(int value);
constexpr NodeState NodeState_MIN = NODE_STATE_UNKNOWN;
constexpr NodeState NodeState_MAX = OVERLOAD;
constexpr int NodeState_ARRAYSIZE = NodeState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeState_descriptor();
template<typename T>
inline const std::string& NodeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeState_descriptor(), enum_t_value);
}
inline bool NodeState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NodeState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeState>(
    NodeState_descriptor(), name, value);
}
enum PodmanCmd : int {
  LIST_CONTAINERS = 0,
  CREATE_CONTAINER = 1,
  START_CONTAINER = 2,
  STOP_CONTAINER = 3,
  REMOVE_CONTAINER = 4,
  INSPECT_CONTAINER = 5,
  RESTART_CONTAINER = 6,
  PAUSE_CONTAINER = 7,
  UNPAUSE_CONTAINER = 8,
  EXEC_IN_CONTAINER = 9,
  LIST_IMAGES = 10,
  PULL_IMAGE = 11,
  REMOVE_IMAGE = 12,
  INSPECT_IMAGE = 13,
  TAG_IMAGE = 14,
  LIST_NETWORKS = 15,
  CREATE_NETWORK = 16,
  REMOVE_NETWORK = 17,
  INSPECT_NETWORK = 18,
  LIST_VOLUMES = 19,
  CREATE_VOLUME = 20,
  REMOVE_VOLUME = 21,
  INSPECT_VOLUME = 22,
  LIST_STACKS = 23,
  DEPLOY_STACK = 24,
  REMOVE_STACK = 25,
  INSPECT_STACK = 26,
  UPDATE_STACK = 27,
  START_STACK = 28,
  STOP_STACK = 29,
  RESTART_STACK = 30,
  PAUSE_STACK = 31,
  UNPAUSE_STACK = 32,
  SCALE_STACK = 33,
  GET_STACK_LOGS = 34,
  LIST_REGISTRIES = 35,
  ADD_REGISTRY = 36,
  REMOVE_REGISTRY = 37,
  LOGIN_REGISTRY = 38,
  PodmanCmd_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PodmanCmd_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PodmanCmd_IsValid(int value);
constexpr PodmanCmd PodmanCmd_MIN = LIST_CONTAINERS;
constexpr PodmanCmd PodmanCmd_MAX = LOGIN_REGISTRY;
constexpr int PodmanCmd_ARRAYSIZE = PodmanCmd_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PodmanCmd_descriptor();
template<typename T>
inline const std::string& PodmanCmd_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PodmanCmd>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PodmanCmd_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PodmanCmd_descriptor(), enum_t_value);
}
inline bool PodmanCmd_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PodmanCmd* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PodmanCmd>(
    PodmanCmd_descriptor(), name, value);
}
enum CommStatus : int {
  STATUS_UNKNOWN = 0,
  DOING = 1,
  SUCCESS = 2,
  INVALID = 3,
  OTHER = 4,
  CommStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CommStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CommStatus_IsValid(int value);
constexpr CommStatus CommStatus_MIN = STATUS_UNKNOWN;
constexpr CommStatus CommStatus_MAX = OTHER;
constexpr int CommStatus_ARRAYSIZE = CommStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommStatus_descriptor();
template<typename T>
inline const std::string& CommStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommStatus_descriptor(), enum_t_value);
}
inline bool CommStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommStatus>(
    CommStatus_descriptor(), name, value);
}
// ===================================================================

class File final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.File) */ {
 public:
  inline File() : File(nullptr) {}
  ~File() override;
  explicit PROTOBUF_CONSTEXPR File(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  File(const File& from);
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const File& default_instance() {
    return *internal_default_instance();
  }
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }
  inline void Swap(File* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<File>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const File& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const File& from) {
    File::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(File* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.File";
  }
  protected:
  explicit File(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathNameFieldNumber = 1,
    kFileSizeFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kIsDirFieldNumber = 2,
  };
  // bytes file_path_name = 1;
  void clear_file_path_name();
  const std::string& file_path_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path_name();
  PROTOBUF_NODISCARD std::string* release_file_path_name();
  void set_allocated_file_path_name(std::string* file_path_name);
  private:
  const std::string& _internal_file_path_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path_name(const std::string& value);
  std::string* _internal_mutable_file_path_name();
  public:

  // int64 file_size = 3;
  void clear_file_size();
  int64_t file_size() const;
  void set_file_size(int64_t value);
  private:
  int64_t _internal_file_size() const;
  void _internal_set_file_size(int64_t value);
  public:

  // int64 timestamp = 4;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // bool is_dir = 2;
  void clear_is_dir();
  bool is_dir() const;
  void set_is_dir(bool value);
  private:
  bool _internal_is_dir() const;
  void _internal_set_is_dir(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_name_;
    int64_t file_size_;
    int64_t timestamp_;
    bool is_dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class FileInfos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.FileInfos) */ {
 public:
  inline FileInfos() : FileInfos(nullptr) {}
  ~FileInfos() override;
  explicit PROTOBUF_CONSTEXPR FileInfos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileInfos(const FileInfos& from);
  FileInfos(FileInfos&& from) noexcept
    : FileInfos() {
    *this = ::std::move(from);
  }

  inline FileInfos& operator=(const FileInfos& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfos& operator=(FileInfos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfos& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfos* internal_default_instance() {
    return reinterpret_cast<const FileInfos*>(
               &_FileInfos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FileInfos& a, FileInfos& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileInfos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileInfos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileInfos& from) {
    FileInfos::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.FileInfos";
  }
  protected:
  explicit FileInfos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 1,
  };
  // repeated .cn.seisys.dds.File files = 1;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::cn::seisys::dds::File* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File >*
      mutable_files();
  private:
  const ::cn::seisys::dds::File& _internal_files(int index) const;
  ::cn::seisys::dds::File* _internal_add_files();
  public:
  const ::cn::seisys::dds::File& files(int index) const;
  ::cn::seisys::dds::File* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File >&
      files() const;

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.FileInfos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File > files_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  explicit PROTOBUF_CONSTEXPR Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ping& from) {
    Ping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToNodeIdFieldNumber = 1,
    kSrcNodeIdFieldNumber = 2,
    kNodeAppVerFieldNumber = 3,
    kNodeCfgVerFieldNumber = 4,
    kDescFieldNumber = 7,
    kCreatedAtFieldNumber = 6,
    kStateFieldNumber = 5,
  };
  // string to_node_id = 1;
  void clear_to_node_id();
  const std::string& to_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_node_id();
  PROTOBUF_NODISCARD std::string* release_to_node_id();
  void set_allocated_to_node_id(std::string* to_node_id);
  private:
  const std::string& _internal_to_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_node_id(const std::string& value);
  std::string* _internal_mutable_to_node_id();
  public:

  // string src_node_id = 2;
  void clear_src_node_id();
  const std::string& src_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_node_id();
  PROTOBUF_NODISCARD std::string* release_src_node_id();
  void set_allocated_src_node_id(std::string* src_node_id);
  private:
  const std::string& _internal_src_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_node_id(const std::string& value);
  std::string* _internal_mutable_src_node_id();
  public:

  // string node_app_ver = 3;
  void clear_node_app_ver();
  const std::string& node_app_ver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_app_ver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_app_ver();
  PROTOBUF_NODISCARD std::string* release_node_app_ver();
  void set_allocated_node_app_ver(std::string* node_app_ver);
  private:
  const std::string& _internal_node_app_ver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_app_ver(const std::string& value);
  std::string* _internal_mutable_node_app_ver();
  public:

  // string node_cfg_ver = 4;
  void clear_node_cfg_ver();
  const std::string& node_cfg_ver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_cfg_ver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_cfg_ver();
  PROTOBUF_NODISCARD std::string* release_node_cfg_ver();
  void set_allocated_node_cfg_ver(std::string* node_cfg_ver);
  private:
  const std::string& _internal_node_cfg_ver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_cfg_ver(const std::string& value);
  std::string* _internal_mutable_node_cfg_ver();
  public:

  // string desc = 7;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // int64 created_at = 6;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // .cn.seisys.dds.NodeState state = 5;
  void clear_state();
  ::cn::seisys::dds::NodeState state() const;
  void set_state(::cn::seisys::dds::NodeState value);
  private:
  ::cn::seisys::dds::NodeState _internal_state() const;
  void _internal_set_state(::cn::seisys::dds::NodeState value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_app_ver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_cfg_ver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
    int64_t created_at_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class Cpu final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.Cpu) */ {
 public:
  inline Cpu() : Cpu(nullptr) {}
  ~Cpu() override;
  explicit PROTOBUF_CONSTEXPR Cpu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cpu(const Cpu& from);
  Cpu(Cpu&& from) noexcept
    : Cpu() {
    *this = ::std::move(from);
  }

  inline Cpu& operator=(const Cpu& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cpu& operator=(Cpu&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cpu& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cpu* internal_default_instance() {
    return reinterpret_cast<const Cpu*>(
               &_Cpu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Cpu& a, Cpu& b) {
    a.Swap(&b);
  }
  inline void Swap(Cpu* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cpu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cpu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cpu>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cpu& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cpu& from) {
    Cpu::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cpu* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.Cpu";
  }
  protected:
  explicit Cpu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFrequencyFieldNumber = 8,
    kVendorFieldNumber = 1,
    kModelFieldNumber = 2,
    kPhysicalCoresFieldNumber = 3,
    kLogicalCoresFieldNumber = 4,
    kMaxFrequencyFieldNumber = 5,
    kRegularFrequencyFieldNumber = 6,
    kMinFrequencyFieldNumber = 7,
    kCacheSizeFieldNumber = 9,
    kCpuUsageFieldNumber = 10,
  };
  // repeated int64 current_frequency = 8;
  int current_frequency_size() const;
  private:
  int _internal_current_frequency_size() const;
  public:
  void clear_current_frequency();
  private:
  int64_t _internal_current_frequency(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_current_frequency() const;
  void _internal_add_current_frequency(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_current_frequency();
  public:
  int64_t current_frequency(int index) const;
  void set_current_frequency(int index, int64_t value);
  void add_current_frequency(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      current_frequency() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_current_frequency();

  // string vendor = 1;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // int32 physical_cores = 3;
  void clear_physical_cores();
  int32_t physical_cores() const;
  void set_physical_cores(int32_t value);
  private:
  int32_t _internal_physical_cores() const;
  void _internal_set_physical_cores(int32_t value);
  public:

  // int32 logical_cores = 4;
  void clear_logical_cores();
  int32_t logical_cores() const;
  void set_logical_cores(int32_t value);
  private:
  int32_t _internal_logical_cores() const;
  void _internal_set_logical_cores(int32_t value);
  public:

  // int64 max_frequency = 5;
  void clear_max_frequency();
  int64_t max_frequency() const;
  void set_max_frequency(int64_t value);
  private:
  int64_t _internal_max_frequency() const;
  void _internal_set_max_frequency(int64_t value);
  public:

  // int64 regular_frequency = 6;
  void clear_regular_frequency();
  int64_t regular_frequency() const;
  void set_regular_frequency(int64_t value);
  private:
  int64_t _internal_regular_frequency() const;
  void _internal_set_regular_frequency(int64_t value);
  public:

  // int64 min_frequency = 7;
  void clear_min_frequency();
  int64_t min_frequency() const;
  void set_min_frequency(int64_t value);
  private:
  int64_t _internal_min_frequency() const;
  void _internal_set_min_frequency(int64_t value);
  public:

  // int64 cache_size = 9;
  void clear_cache_size();
  int64_t cache_size() const;
  void set_cache_size(int64_t value);
  private:
  int64_t _internal_cache_size() const;
  void _internal_set_cache_size(int64_t value);
  public:

  // double cpu_usage = 10;
  void clear_cpu_usage();
  double cpu_usage() const;
  void set_cpu_usage(double value);
  private:
  double _internal_cpu_usage() const;
  void _internal_set_cpu_usage(double value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.Cpu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > current_frequency_;
    mutable std::atomic<int> _current_frequency_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    int32_t physical_cores_;
    int32_t logical_cores_;
    int64_t max_frequency_;
    int64_t regular_frequency_;
    int64_t min_frequency_;
    int64_t cache_size_;
    double cpu_usage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class Gpu final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.Gpu) */ {
 public:
  inline Gpu() : Gpu(nullptr) {}
  ~Gpu() override;
  explicit PROTOBUF_CONSTEXPR Gpu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gpu(const Gpu& from);
  Gpu(Gpu&& from) noexcept
    : Gpu() {
    *this = ::std::move(from);
  }

  inline Gpu& operator=(const Gpu& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gpu& operator=(Gpu&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gpu& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gpu* internal_default_instance() {
    return reinterpret_cast<const Gpu*>(
               &_Gpu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Gpu& a, Gpu& b) {
    a.Swap(&b);
  }
  inline void Swap(Gpu* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gpu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gpu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gpu>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gpu& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Gpu& from) {
    Gpu::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gpu* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.Gpu";
  }
  protected:
  explicit Gpu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorFieldNumber = 1,
    kModelFieldNumber = 2,
    kDriverVersionFieldNumber = 3,
    kMemoryFieldNumber = 4,
    kFrequencyFieldNumber = 5,
  };
  // string vendor = 1;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string driver_version = 3;
  void clear_driver_version();
  const std::string& driver_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_version();
  PROTOBUF_NODISCARD std::string* release_driver_version();
  void set_allocated_driver_version(std::string* driver_version);
  private:
  const std::string& _internal_driver_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_version(const std::string& value);
  std::string* _internal_mutable_driver_version();
  public:

  // double memory = 4;
  void clear_memory();
  double memory() const;
  void set_memory(double value);
  private:
  double _internal_memory() const;
  void _internal_set_memory(double value);
  public:

  // int64 frequency = 5;
  void clear_frequency();
  int64_t frequency() const;
  void set_frequency(int64_t value);
  private:
  int64_t _internal_frequency() const;
  void _internal_set_frequency(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.Gpu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_version_;
    double memory_;
    int64_t frequency_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class Ram final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.Ram) */ {
 public:
  inline Ram() : Ram(nullptr) {}
  ~Ram() override;
  explicit PROTOBUF_CONSTEXPR Ram(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ram(const Ram& from);
  Ram(Ram&& from) noexcept
    : Ram() {
    *this = ::std::move(from);
  }

  inline Ram& operator=(const Ram& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ram& operator=(Ram&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ram& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ram* internal_default_instance() {
    return reinterpret_cast<const Ram*>(
               &_Ram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Ram& a, Ram& b) {
    a.Swap(&b);
  }
  inline void Swap(Ram* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ram* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ram* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ram>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ram& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ram& from) {
    Ram::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ram* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.Ram";
  }
  protected:
  explicit Ram(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorFieldNumber = 1,
    kModelFieldNumber = 2,
    kNameFieldNumber = 3,
    kSerialNumberFieldNumber = 4,
    kSizeFieldNumber = 5,
    kFreeFieldNumber = 6,
    kAvailableFieldNumber = 7,
  };
  // string vendor = 1;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // bytes name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string serial_number = 4;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // int64 size = 5;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // int64 free = 6;
  void clear_free();
  int64_t free() const;
  void set_free(int64_t value);
  private:
  int64_t _internal_free() const;
  void _internal_set_free(int64_t value);
  public:

  // int64 available = 7;
  void clear_available();
  int64_t available() const;
  void set_available(int64_t value);
  private:
  int64_t _internal_available() const;
  void _internal_set_available(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.Ram)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
    int64_t size_;
    int64_t free_;
    int64_t available_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class Disk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.Disk) */ {
 public:
  inline Disk() : Disk(nullptr) {}
  ~Disk() override;
  explicit PROTOBUF_CONSTEXPR Disk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Disk(const Disk& from);
  Disk(Disk&& from) noexcept
    : Disk() {
    *this = ::std::move(from);
  }

  inline Disk& operator=(const Disk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Disk& operator=(Disk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Disk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Disk* internal_default_instance() {
    return reinterpret_cast<const Disk*>(
               &_Disk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Disk& a, Disk& b) {
    a.Swap(&b);
  }
  inline void Swap(Disk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Disk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Disk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Disk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Disk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Disk& from) {
    Disk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Disk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.Disk";
  }
  protected:
  explicit Disk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorFieldNumber = 1,
    kModelFieldNumber = 2,
    kSerialNumberFieldNumber = 3,
    kSizeFieldNumber = 4,
  };
  // bytes vendor = 1;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string serial_number = 3;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // int64 size = 4;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.Disk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
    int64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class MainBoard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.MainBoard) */ {
 public:
  inline MainBoard() : MainBoard(nullptr) {}
  ~MainBoard() override;
  explicit PROTOBUF_CONSTEXPR MainBoard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MainBoard(const MainBoard& from);
  MainBoard(MainBoard&& from) noexcept
    : MainBoard() {
    *this = ::std::move(from);
  }

  inline MainBoard& operator=(const MainBoard& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainBoard& operator=(MainBoard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MainBoard& default_instance() {
    return *internal_default_instance();
  }
  static inline const MainBoard* internal_default_instance() {
    return reinterpret_cast<const MainBoard*>(
               &_MainBoard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MainBoard& a, MainBoard& b) {
    a.Swap(&b);
  }
  inline void Swap(MainBoard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MainBoard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MainBoard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MainBoard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MainBoard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MainBoard& from) {
    MainBoard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainBoard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.MainBoard";
  }
  protected:
  explicit MainBoard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorFieldNumber = 1,
    kNameFieldNumber = 2,
    kVersionFieldNumber = 3,
    kSerialNumberFieldNumber = 4,
  };
  // string vendor = 1;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 3;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string serial_number = 4;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.MainBoard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class ProcessTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.ProcessTime) */ {
 public:
  inline ProcessTime() : ProcessTime(nullptr) {}
  ~ProcessTime() override;
  explicit PROTOBUF_CONSTEXPR ProcessTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessTime(const ProcessTime& from);
  ProcessTime(ProcessTime&& from) noexcept
    : ProcessTime() {
    *this = ::std::move(from);
  }

  inline ProcessTime& operator=(const ProcessTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessTime& operator=(ProcessTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessTime* internal_default_instance() {
    return reinterpret_cast<const ProcessTime*>(
               &_ProcessTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProcessTime& a, ProcessTime& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessTime& from) {
    ProcessTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.ProcessTime";
  }
  protected:
  explicit ProcessTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserTimeFieldNumber = 1,
    kKernelTimeFieldNumber = 2,
    kChildrenUsertimeFieldNumber = 3,
    kChildrenKernelTimeFieldNumber = 4,
  };
  // float user_time = 1;
  void clear_user_time();
  float user_time() const;
  void set_user_time(float value);
  private:
  float _internal_user_time() const;
  void _internal_set_user_time(float value);
  public:

  // float kernel_time = 2;
  void clear_kernel_time();
  float kernel_time() const;
  void set_kernel_time(float value);
  private:
  float _internal_kernel_time() const;
  void _internal_set_kernel_time(float value);
  public:

  // float children_usertime = 3;
  void clear_children_usertime();
  float children_usertime() const;
  void set_children_usertime(float value);
  private:
  float _internal_children_usertime() const;
  void _internal_set_children_usertime(float value);
  public:

  // float children_kernel_time = 4;
  void clear_children_kernel_time();
  float children_kernel_time() const;
  void set_children_kernel_time(float value);
  private:
  float _internal_children_kernel_time() const;
  void _internal_set_children_kernel_time(float value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.ProcessTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float user_time_;
    float kernel_time_;
    float children_usertime_;
    float children_kernel_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class Process_EnvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Process_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Process_EnvEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Process_EnvEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Process_EnvEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Process_EnvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Process_EnvEntry_DoNotUse& other);
  static const Process_EnvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Process_EnvEntry_DoNotUse*>(&_Process_EnvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "cn.seisys.dds.Process.EnvEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "cn.seisys.dds.Process.EnvEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_node_2eproto;
};

// -------------------------------------------------------------------

class Process final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.Process) */ {
 public:
  inline Process() : Process(nullptr) {}
  ~Process() override;
  explicit PROTOBUF_CONSTEXPR Process(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Process(const Process& from);
  Process(Process&& from) noexcept
    : Process() {
    *this = ::std::move(from);
  }

  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }
  inline Process& operator=(Process&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Process& default_instance() {
    return *internal_default_instance();
  }
  static inline const Process* internal_default_instance() {
    return reinterpret_cast<const Process*>(
               &_Process_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Process& a, Process& b) {
    a.Swap(&b);
  }
  inline void Swap(Process* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Process* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Process* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Process>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Process& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Process& from) {
    Process::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Process* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.Process";
  }
  protected:
  explicit Process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEnvFieldNumber = 11,
    kNameFieldNumber = 1,
    kWorkPathFieldNumber = 2,
    kArgsFieldNumber = 4,
    kCpuUsageFieldNumber = 5,
    kMemUsageFieldNumber = 6,
    kPidFieldNumber = 3,
    kRebootCountFieldNumber = 9,
    kStartTimeFieldNumber = 7,
    kStopTimeFieldNumber = 8,
    kPriorityFieldNumber = 10,
  };
  // map<string, string> env = 11;
  int env_size() const;
  private:
  int _internal_env_size() const;
  public:
  void clear_env();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_env();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      env() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_env();

  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string work_path = 2;
  void clear_work_path();
  const std::string& work_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_work_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_work_path();
  PROTOBUF_NODISCARD std::string* release_work_path();
  void set_allocated_work_path(std::string* work_path);
  private:
  const std::string& _internal_work_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_work_path(const std::string& value);
  std::string* _internal_mutable_work_path();
  public:

  // string args = 4;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // double cpu_usage = 5;
  void clear_cpu_usage();
  double cpu_usage() const;
  void set_cpu_usage(double value);
  private:
  double _internal_cpu_usage() const;
  void _internal_set_cpu_usage(double value);
  public:

  // double mem_usage = 6;
  void clear_mem_usage();
  double mem_usage() const;
  void set_mem_usage(double value);
  private:
  double _internal_mem_usage() const;
  void _internal_set_mem_usage(double value);
  public:

  // int32 pid = 3;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // int32 reboot_count = 9;
  void clear_reboot_count();
  int32_t reboot_count() const;
  void set_reboot_count(int32_t value);
  private:
  int32_t _internal_reboot_count() const;
  void _internal_set_reboot_count(int32_t value);
  public:

  // int64 start_time = 7;
  void clear_start_time();
  int64_t start_time() const;
  void set_start_time(int64_t value);
  private:
  int64_t _internal_start_time() const;
  void _internal_set_start_time(int64_t value);
  public:

  // int64 stop_time = 8;
  void clear_stop_time();
  int64_t stop_time() const;
  void set_stop_time(int64_t value);
  private:
  int64_t _internal_stop_time() const;
  void _internal_set_stop_time(int64_t value);
  public:

  // int32 priority = 10;
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.Process)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Process_EnvEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> env_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr work_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
    double cpu_usage_;
    double mem_usage_;
    int32_t pid_;
    int32_t reboot_count_;
    int64_t start_time_;
    int64_t stop_time_;
    int32_t priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class Network final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.Network) */ {
 public:
  inline Network() : Network(nullptr) {}
  ~Network() override;
  explicit PROTOBUF_CONSTEXPR Network(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Network(const Network& from);
  Network(Network&& from) noexcept
    : Network() {
    *this = ::std::move(from);
  }

  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }
  inline Network& operator=(Network&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Network& default_instance() {
    return *internal_default_instance();
  }
  static inline const Network* internal_default_instance() {
    return reinterpret_cast<const Network*>(
               &_Network_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Network& a, Network& b) {
    a.Swap(&b);
  }
  inline void Swap(Network* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Network* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Network* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Network>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Network& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Network& from) {
    Network::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Network* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.Network";
  }
  protected:
  explicit Network(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIpv4SFieldNumber = 2,
    kIpv6SFieldNumber = 3,
    kBroadbandFieldNumber = 4,
    kBroadbandUsingFieldNumber = 5,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string ipv4s = 2;
  void clear_ipv4s();
  const std::string& ipv4s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipv4s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipv4s();
  PROTOBUF_NODISCARD std::string* release_ipv4s();
  void set_allocated_ipv4s(std::string* ipv4s);
  private:
  const std::string& _internal_ipv4s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipv4s(const std::string& value);
  std::string* _internal_mutable_ipv4s();
  public:

  // string ipv6s = 3;
  void clear_ipv6s();
  const std::string& ipv6s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipv6s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipv6s();
  PROTOBUF_NODISCARD std::string* release_ipv6s();
  void set_allocated_ipv6s(std::string* ipv6s);
  private:
  const std::string& _internal_ipv6s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipv6s(const std::string& value);
  std::string* _internal_mutable_ipv6s();
  public:

  // int64 broadband = 4;
  void clear_broadband();
  int64_t broadband() const;
  void set_broadband(int64_t value);
  private:
  int64_t _internal_broadband() const;
  void _internal_set_broadband(int64_t value);
  public:

  // int64 broadband_using = 5;
  void clear_broadband_using();
  int64_t broadband_using() const;
  void set_broadband_using(int64_t value);
  private:
  int64_t _internal_broadband_using() const;
  void _internal_set_broadband_using(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.Network)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipv4s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipv6s_;
    int64_t broadband_;
    int64_t broadband_using_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class OSInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.OSInfo) */ {
 public:
  inline OSInfo() : OSInfo(nullptr) {}
  ~OSInfo() override;
  explicit PROTOBUF_CONSTEXPR OSInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OSInfo(const OSInfo& from);
  OSInfo(OSInfo&& from) noexcept
    : OSInfo() {
    *this = ::std::move(from);
  }

  inline OSInfo& operator=(const OSInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OSInfo& operator=(OSInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OSInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OSInfo* internal_default_instance() {
    return reinterpret_cast<const OSInfo*>(
               &_OSInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OSInfo& a, OSInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OSInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OSInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OSInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OSInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OSInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OSInfo& from) {
    OSInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OSInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.OSInfo";
  }
  protected:
  explicit OSInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperatingSystemFieldNumber = 1,
    kShortNameFieldNumber = 2,
    kVersionFieldNumber = 3,
    kKernelFieldNumber = 4,
    kArchitectureFieldNumber = 5,
    kEndianessFieldNumber = 6,
  };
  // bytes operating_system = 1;
  void clear_operating_system();
  const std::string& operating_system() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operating_system(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operating_system();
  PROTOBUF_NODISCARD std::string* release_operating_system();
  void set_allocated_operating_system(std::string* operating_system);
  private:
  const std::string& _internal_operating_system() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operating_system(const std::string& value);
  std::string* _internal_mutable_operating_system();
  public:

  // bytes short_name = 2;
  void clear_short_name();
  const std::string& short_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_short_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_short_name();
  PROTOBUF_NODISCARD std::string* release_short_name();
  void set_allocated_short_name(std::string* short_name);
  private:
  const std::string& _internal_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_name(const std::string& value);
  std::string* _internal_mutable_short_name();
  public:

  // string version = 3;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string kernel = 4;
  void clear_kernel();
  const std::string& kernel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kernel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kernel();
  PROTOBUF_NODISCARD std::string* release_kernel();
  void set_allocated_kernel(std::string* kernel);
  private:
  const std::string& _internal_kernel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kernel(const std::string& value);
  std::string* _internal_mutable_kernel();
  public:

  // string architecture = 5;
  void clear_architecture();
  const std::string& architecture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_architecture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_architecture();
  PROTOBUF_NODISCARD std::string* release_architecture();
  void set_allocated_architecture(std::string* architecture);
  private:
  const std::string& _internal_architecture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_architecture(const std::string& value);
  std::string* _internal_mutable_architecture();
  public:

  // string endianess = 6;
  void clear_endianess();
  const std::string& endianess() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endianess(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endianess();
  PROTOBUF_NODISCARD std::string* release_endianess();
  void set_allocated_endianess(std::string* endianess);
  private:
  const std::string& _internal_endianess() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endianess(const std::string& value);
  std::string* _internal_mutable_endianess();
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.OSInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operating_system_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr short_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kernel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr architecture_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endianess_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class MachineState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.MachineState) */ {
 public:
  inline MachineState() : MachineState(nullptr) {}
  ~MachineState() override;
  explicit PROTOBUF_CONSTEXPR MachineState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MachineState(const MachineState& from);
  MachineState(MachineState&& from) noexcept
    : MachineState() {
    *this = ::std::move(from);
  }

  inline MachineState& operator=(const MachineState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MachineState& operator=(MachineState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MachineState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MachineState* internal_default_instance() {
    return reinterpret_cast<const MachineState*>(
               &_MachineState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MachineState& a, MachineState& b) {
    a.Swap(&b);
  }
  inline void Swap(MachineState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MachineState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MachineState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MachineState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MachineState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MachineState& from) {
    MachineState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MachineState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.MachineState";
  }
  protected:
  explicit MachineState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCpusFieldNumber = 3,
    kGpusFieldNumber = 4,
    kDisksFieldNumber = 6,
    kNetworksFieldNumber = 7,
    kProcessesFieldNumber = 10,
    kToNodeIdFieldNumber = 1,
    kSrcNodeIdFieldNumber = 2,
    kRamsFieldNumber = 5,
    kMainBoardInfosFieldNumber = 8,
    kOsInfosFieldNumber = 9,
  };
  // repeated .cn.seisys.dds.Cpu cpus = 3;
  int cpus_size() const;
  private:
  int _internal_cpus_size() const;
  public:
  void clear_cpus();
  ::cn::seisys::dds::Cpu* mutable_cpus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Cpu >*
      mutable_cpus();
  private:
  const ::cn::seisys::dds::Cpu& _internal_cpus(int index) const;
  ::cn::seisys::dds::Cpu* _internal_add_cpus();
  public:
  const ::cn::seisys::dds::Cpu& cpus(int index) const;
  ::cn::seisys::dds::Cpu* add_cpus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Cpu >&
      cpus() const;

  // repeated .cn.seisys.dds.Gpu gpus = 4;
  int gpus_size() const;
  private:
  int _internal_gpus_size() const;
  public:
  void clear_gpus();
  ::cn::seisys::dds::Gpu* mutable_gpus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Gpu >*
      mutable_gpus();
  private:
  const ::cn::seisys::dds::Gpu& _internal_gpus(int index) const;
  ::cn::seisys::dds::Gpu* _internal_add_gpus();
  public:
  const ::cn::seisys::dds::Gpu& gpus(int index) const;
  ::cn::seisys::dds::Gpu* add_gpus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Gpu >&
      gpus() const;

  // repeated .cn.seisys.dds.Disk disks = 6;
  int disks_size() const;
  private:
  int _internal_disks_size() const;
  public:
  void clear_disks();
  ::cn::seisys::dds::Disk* mutable_disks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Disk >*
      mutable_disks();
  private:
  const ::cn::seisys::dds::Disk& _internal_disks(int index) const;
  ::cn::seisys::dds::Disk* _internal_add_disks();
  public:
  const ::cn::seisys::dds::Disk& disks(int index) const;
  ::cn::seisys::dds::Disk* add_disks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Disk >&
      disks() const;

  // repeated .cn.seisys.dds.Network networks = 7;
  int networks_size() const;
  private:
  int _internal_networks_size() const;
  public:
  void clear_networks();
  ::cn::seisys::dds::Network* mutable_networks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Network >*
      mutable_networks();
  private:
  const ::cn::seisys::dds::Network& _internal_networks(int index) const;
  ::cn::seisys::dds::Network* _internal_add_networks();
  public:
  const ::cn::seisys::dds::Network& networks(int index) const;
  ::cn::seisys::dds::Network* add_networks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Network >&
      networks() const;

  // repeated .cn.seisys.dds.Process processes = 10;
  int processes_size() const;
  private:
  int _internal_processes_size() const;
  public:
  void clear_processes();
  ::cn::seisys::dds::Process* mutable_processes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Process >*
      mutable_processes();
  private:
  const ::cn::seisys::dds::Process& _internal_processes(int index) const;
  ::cn::seisys::dds::Process* _internal_add_processes();
  public:
  const ::cn::seisys::dds::Process& processes(int index) const;
  ::cn::seisys::dds::Process* add_processes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Process >&
      processes() const;

  // string to_node_id = 1;
  void clear_to_node_id();
  const std::string& to_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_node_id();
  PROTOBUF_NODISCARD std::string* release_to_node_id();
  void set_allocated_to_node_id(std::string* to_node_id);
  private:
  const std::string& _internal_to_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_node_id(const std::string& value);
  std::string* _internal_mutable_to_node_id();
  public:

  // string src_node_id = 2;
  void clear_src_node_id();
  const std::string& src_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_node_id();
  PROTOBUF_NODISCARD std::string* release_src_node_id();
  void set_allocated_src_node_id(std::string* src_node_id);
  private:
  const std::string& _internal_src_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_node_id(const std::string& value);
  std::string* _internal_mutable_src_node_id();
  public:

  // .cn.seisys.dds.Ram rams = 5;
  bool has_rams() const;
  private:
  bool _internal_has_rams() const;
  public:
  void clear_rams();
  const ::cn::seisys::dds::Ram& rams() const;
  PROTOBUF_NODISCARD ::cn::seisys::dds::Ram* release_rams();
  ::cn::seisys::dds::Ram* mutable_rams();
  void set_allocated_rams(::cn::seisys::dds::Ram* rams);
  private:
  const ::cn::seisys::dds::Ram& _internal_rams() const;
  ::cn::seisys::dds::Ram* _internal_mutable_rams();
  public:
  void unsafe_arena_set_allocated_rams(
      ::cn::seisys::dds::Ram* rams);
  ::cn::seisys::dds::Ram* unsafe_arena_release_rams();

  // .cn.seisys.dds.MainBoard main_board_infos = 8;
  bool has_main_board_infos() const;
  private:
  bool _internal_has_main_board_infos() const;
  public:
  void clear_main_board_infos();
  const ::cn::seisys::dds::MainBoard& main_board_infos() const;
  PROTOBUF_NODISCARD ::cn::seisys::dds::MainBoard* release_main_board_infos();
  ::cn::seisys::dds::MainBoard* mutable_main_board_infos();
  void set_allocated_main_board_infos(::cn::seisys::dds::MainBoard* main_board_infos);
  private:
  const ::cn::seisys::dds::MainBoard& _internal_main_board_infos() const;
  ::cn::seisys::dds::MainBoard* _internal_mutable_main_board_infos();
  public:
  void unsafe_arena_set_allocated_main_board_infos(
      ::cn::seisys::dds::MainBoard* main_board_infos);
  ::cn::seisys::dds::MainBoard* unsafe_arena_release_main_board_infos();

  // .cn.seisys.dds.OSInfo os_infos = 9;
  bool has_os_infos() const;
  private:
  bool _internal_has_os_infos() const;
  public:
  void clear_os_infos();
  const ::cn::seisys::dds::OSInfo& os_infos() const;
  PROTOBUF_NODISCARD ::cn::seisys::dds::OSInfo* release_os_infos();
  ::cn::seisys::dds::OSInfo* mutable_os_infos();
  void set_allocated_os_infos(::cn::seisys::dds::OSInfo* os_infos);
  private:
  const ::cn::seisys::dds::OSInfo& _internal_os_infos() const;
  ::cn::seisys::dds::OSInfo* _internal_mutable_os_infos();
  public:
  void unsafe_arena_set_allocated_os_infos(
      ::cn::seisys::dds::OSInfo* os_infos);
  ::cn::seisys::dds::OSInfo* unsafe_arena_release_os_infos();

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.MachineState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Cpu > cpus_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Gpu > gpus_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Disk > disks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Network > networks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Process > processes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_node_id_;
    ::cn::seisys::dds::Ram* rams_;
    ::cn::seisys::dds::MainBoard* main_board_infos_;
    ::cn::seisys::dds::OSInfo* os_infos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit PROTOBUF_CONSTEXPR Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kToNodeIdFieldNumber = 2,
    kToNodeNameFieldNumber = 3,
    kSrcNodeIdFieldNumber = 4,
    kToGroupFieldNumber = 5,
    kUriFieldNumber = 8,
    kToConfigPathFieldNumber = 9,
    kSrcConfigPathFieldNumber = 10,
    kConfigFieldNumber = 12,
    kConfigHashFieldNumber = 13,
    kArchFieldNumber = 6,
    kOsFieldNumber = 7,
    kDomainFieldNumber = 11,
    kConfigSizeFieldNumber = 14,
    kCreatedAtFieldNumber = 16,
    kUpdatedAtFieldNumber = 17,
    kStateFieldNumber = 15,
  };
  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // string to_node_id = 2;
  void clear_to_node_id();
  const std::string& to_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_node_id();
  PROTOBUF_NODISCARD std::string* release_to_node_id();
  void set_allocated_to_node_id(std::string* to_node_id);
  private:
  const std::string& _internal_to_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_node_id(const std::string& value);
  std::string* _internal_mutable_to_node_id();
  public:

  // bytes to_node_name = 3;
  void clear_to_node_name();
  const std::string& to_node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_node_name();
  PROTOBUF_NODISCARD std::string* release_to_node_name();
  void set_allocated_to_node_name(std::string* to_node_name);
  private:
  const std::string& _internal_to_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_node_name(const std::string& value);
  std::string* _internal_mutable_to_node_name();
  public:

  // string src_node_id = 4;
  void clear_src_node_id();
  const std::string& src_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_node_id();
  PROTOBUF_NODISCARD std::string* release_src_node_id();
  void set_allocated_src_node_id(std::string* src_node_id);
  private:
  const std::string& _internal_src_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_node_id(const std::string& value);
  std::string* _internal_mutable_src_node_id();
  public:

  // string to_group = 5;
  void clear_to_group();
  const std::string& to_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_group();
  PROTOBUF_NODISCARD std::string* release_to_group();
  void set_allocated_to_group(std::string* to_group);
  private:
  const std::string& _internal_to_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_group(const std::string& value);
  std::string* _internal_mutable_to_group();
  public:

  // string uri = 8;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string to_config_path = 9;
  void clear_to_config_path();
  const std::string& to_config_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_config_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_config_path();
  PROTOBUF_NODISCARD std::string* release_to_config_path();
  void set_allocated_to_config_path(std::string* to_config_path);
  private:
  const std::string& _internal_to_config_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_config_path(const std::string& value);
  std::string* _internal_mutable_to_config_path();
  public:

  // string src_config_path = 10;
  void clear_src_config_path();
  const std::string& src_config_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_config_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_config_path();
  PROTOBUF_NODISCARD std::string* release_src_config_path();
  void set_allocated_src_config_path(std::string* src_config_path);
  private:
  const std::string& _internal_src_config_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_config_path(const std::string& value);
  std::string* _internal_mutable_src_config_path();
  public:

  // bytes config = 12;
  void clear_config();
  const std::string& config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config();
  PROTOBUF_NODISCARD std::string* release_config();
  void set_allocated_config(std::string* config);
  private:
  const std::string& _internal_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config(const std::string& value);
  std::string* _internal_mutable_config();
  public:

  // string config_hash = 13;
  void clear_config_hash();
  const std::string& config_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_hash();
  PROTOBUF_NODISCARD std::string* release_config_hash();
  void set_allocated_config_hash(std::string* config_hash);
  private:
  const std::string& _internal_config_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_hash(const std::string& value);
  std::string* _internal_mutable_config_hash();
  public:

  // .cn.seisys.dds.ArchType arch = 6;
  void clear_arch();
  ::cn::seisys::dds::ArchType arch() const;
  void set_arch(::cn::seisys::dds::ArchType value);
  private:
  ::cn::seisys::dds::ArchType _internal_arch() const;
  void _internal_set_arch(::cn::seisys::dds::ArchType value);
  public:

  // .cn.seisys.dds.OSType os = 7;
  void clear_os();
  ::cn::seisys::dds::OSType os() const;
  void set_os(::cn::seisys::dds::OSType value);
  private:
  ::cn::seisys::dds::OSType _internal_os() const;
  void _internal_set_os(::cn::seisys::dds::OSType value);
  public:

  // uint32 domain = 11;
  void clear_domain();
  uint32_t domain() const;
  void set_domain(uint32_t value);
  private:
  uint32_t _internal_domain() const;
  void _internal_set_domain(uint32_t value);
  public:

  // uint32 config_size = 14;
  void clear_config_size();
  uint32_t config_size() const;
  void set_config_size(uint32_t value);
  private:
  uint32_t _internal_config_size() const;
  void _internal_set_config_size(uint32_t value);
  public:

  // int64 created_at = 16;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // int64 updated_at = 17;
  void clear_updated_at();
  int64_t updated_at() const;
  void set_updated_at(int64_t value);
  private:
  int64_t _internal_updated_at() const;
  void _internal_set_updated_at(int64_t value);
  public:

  // .cn.seisys.dds.CommStatus state = 15;
  void clear_state();
  ::cn::seisys::dds::CommStatus state() const;
  void set_state(::cn::seisys::dds::CommStatus value);
  private:
  ::cn::seisys::dds::CommStatus _internal_state() const;
  void _internal_set_state(::cn::seisys::dds::CommStatus value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_node_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_config_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_config_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_hash_;
    int arch_;
    int os_;
    uint32_t domain_;
    uint32_t config_size_;
    int64_t created_at_;
    int64_t updated_at_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class NodeReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.NodeReply) */ {
 public:
  inline NodeReply() : NodeReply(nullptr) {}
  ~NodeReply() override;
  explicit PROTOBUF_CONSTEXPR NodeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeReply(const NodeReply& from);
  NodeReply(NodeReply&& from) noexcept
    : NodeReply() {
    *this = ::std::move(from);
  }

  inline NodeReply& operator=(const NodeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeReply& operator=(NodeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeReply* internal_default_instance() {
    return reinterpret_cast<const NodeReply*>(
               &_NodeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NodeReply& a, NodeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeReply& from) {
    NodeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.NodeReply";
  }
  protected:
  explicit NodeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kToNodeIdFieldNumber = 2,
    kToNodeNameFieldNumber = 3,
    kSrcNodeIdFieldNumber = 4,
    kToGroupFieldNumber = 5,
    kReplyUuidFieldNumber = 6,
    kDescFieldNumber = 8,
    kDescStrFieldNumber = 9,
    kCreatedAtFieldNumber = 10,
    kUpdatedAtFieldNumber = 11,
    kStatusFieldNumber = 7,
  };
  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // string to_node_id = 2;
  void clear_to_node_id();
  const std::string& to_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_node_id();
  PROTOBUF_NODISCARD std::string* release_to_node_id();
  void set_allocated_to_node_id(std::string* to_node_id);
  private:
  const std::string& _internal_to_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_node_id(const std::string& value);
  std::string* _internal_mutable_to_node_id();
  public:

  // bytes to_node_name = 3;
  void clear_to_node_name();
  const std::string& to_node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_node_name();
  PROTOBUF_NODISCARD std::string* release_to_node_name();
  void set_allocated_to_node_name(std::string* to_node_name);
  private:
  const std::string& _internal_to_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_node_name(const std::string& value);
  std::string* _internal_mutable_to_node_name();
  public:

  // string src_node_id = 4;
  void clear_src_node_id();
  const std::string& src_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_node_id();
  PROTOBUF_NODISCARD std::string* release_src_node_id();
  void set_allocated_src_node_id(std::string* src_node_id);
  private:
  const std::string& _internal_src_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_node_id(const std::string& value);
  std::string* _internal_mutable_src_node_id();
  public:

  // string to_group = 5;
  void clear_to_group();
  const std::string& to_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_group();
  PROTOBUF_NODISCARD std::string* release_to_group();
  void set_allocated_to_group(std::string* to_group);
  private:
  const std::string& _internal_to_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_group(const std::string& value);
  std::string* _internal_mutable_to_group();
  public:

  // string reply_uuid = 6;
  void clear_reply_uuid();
  const std::string& reply_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply_uuid();
  PROTOBUF_NODISCARD std::string* release_reply_uuid();
  void set_allocated_reply_uuid(std::string* reply_uuid);
  private:
  const std::string& _internal_reply_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply_uuid(const std::string& value);
  std::string* _internal_mutable_reply_uuid();
  public:

  // bytes desc = 8;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // bytes desc_str = 9;
  void clear_desc_str();
  const std::string& desc_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc_str();
  PROTOBUF_NODISCARD std::string* release_desc_str();
  void set_allocated_desc_str(std::string* desc_str);
  private:
  const std::string& _internal_desc_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc_str(const std::string& value);
  std::string* _internal_mutable_desc_str();
  public:

  // int64 created_at = 10;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // int64 updated_at = 11;
  void clear_updated_at();
  int64_t updated_at() const;
  void set_updated_at(int64_t value);
  private:
  int64_t _internal_updated_at() const;
  void _internal_set_updated_at(int64_t value);
  public:

  // .cn.seisys.dds.CommStatus status = 7;
  void clear_status();
  ::cn::seisys::dds::CommStatus status() const;
  void set_status(::cn::seisys::dds::CommStatus value);
  private:
  ::cn::seisys::dds::CommStatus _internal_status() const;
  void _internal_set_status(::cn::seisys::dds::CommStatus value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.NodeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_node_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_str_;
    int64_t created_at_;
    int64_t updated_at_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class NodeCmd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.NodeCmd) */ {
 public:
  inline NodeCmd() : NodeCmd(nullptr) {}
  ~NodeCmd() override;
  explicit PROTOBUF_CONSTEXPR NodeCmd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeCmd(const NodeCmd& from);
  NodeCmd(NodeCmd&& from) noexcept
    : NodeCmd() {
    *this = ::std::move(from);
  }

  inline NodeCmd& operator=(const NodeCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeCmd& operator=(NodeCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeCmd* internal_default_instance() {
    return reinterpret_cast<const NodeCmd*>(
               &_NodeCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NodeCmd& a, NodeCmd& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeCmd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeCmd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeCmd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeCmd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeCmd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeCmd& from) {
    NodeCmd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeCmd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.NodeCmd";
  }
  protected:
  explicit NodeCmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kSrcNodeIdFieldNumber = 2,
    kSrcNodeNameFieldNumber = 3,
    kToNodeIdFieldNumber = 4,
    kToGroupFieldNumber = 5,
    kCmdFieldNumber = 8,
    kParasFieldNumber = 9,
    kParas1FieldNumber = 10,
    kParas2FieldNumber = 11,
    kCmdTypeFieldNumber = 6,
    kPodmanCmdFieldNumber = 7,
    kCreatedAtFieldNumber = 12,
    kUpdatedAtFieldNumber = 13,
  };
  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // string src_node_id = 2;
  void clear_src_node_id();
  const std::string& src_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_node_id();
  PROTOBUF_NODISCARD std::string* release_src_node_id();
  void set_allocated_src_node_id(std::string* src_node_id);
  private:
  const std::string& _internal_src_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_node_id(const std::string& value);
  std::string* _internal_mutable_src_node_id();
  public:

  // bytes src_node_name = 3;
  void clear_src_node_name();
  const std::string& src_node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_node_name();
  PROTOBUF_NODISCARD std::string* release_src_node_name();
  void set_allocated_src_node_name(std::string* src_node_name);
  private:
  const std::string& _internal_src_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_node_name(const std::string& value);
  std::string* _internal_mutable_src_node_name();
  public:

  // string to_node_id = 4;
  void clear_to_node_id();
  const std::string& to_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_node_id();
  PROTOBUF_NODISCARD std::string* release_to_node_id();
  void set_allocated_to_node_id(std::string* to_node_id);
  private:
  const std::string& _internal_to_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_node_id(const std::string& value);
  std::string* _internal_mutable_to_node_id();
  public:

  // string to_group = 5;
  void clear_to_group();
  const std::string& to_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_group();
  PROTOBUF_NODISCARD std::string* release_to_group();
  void set_allocated_to_group(std::string* to_group);
  private:
  const std::string& _internal_to_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_group(const std::string& value);
  std::string* _internal_mutable_to_group();
  public:

  // string cmd = 8;
  void clear_cmd();
  const std::string& cmd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* cmd);
  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(const std::string& value);
  std::string* _internal_mutable_cmd();
  public:

  // string paras = 9;
  void clear_paras();
  const std::string& paras() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_paras(ArgT0&& arg0, ArgT... args);
  std::string* mutable_paras();
  PROTOBUF_NODISCARD std::string* release_paras();
  void set_allocated_paras(std::string* paras);
  private:
  const std::string& _internal_paras() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_paras(const std::string& value);
  std::string* _internal_mutable_paras();
  public:

  // string paras_1 = 10;
  void clear_paras_1();
  const std::string& paras_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_paras_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_paras_1();
  PROTOBUF_NODISCARD std::string* release_paras_1();
  void set_allocated_paras_1(std::string* paras_1);
  private:
  const std::string& _internal_paras_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_paras_1(const std::string& value);
  std::string* _internal_mutable_paras_1();
  public:

  // string paras_2 = 11;
  void clear_paras_2();
  const std::string& paras_2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_paras_2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_paras_2();
  PROTOBUF_NODISCARD std::string* release_paras_2();
  void set_allocated_paras_2(std::string* paras_2);
  private:
  const std::string& _internal_paras_2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_paras_2(const std::string& value);
  std::string* _internal_mutable_paras_2();
  public:

  // .cn.seisys.dds.CmdType cmd_type = 6;
  void clear_cmd_type();
  ::cn::seisys::dds::CmdType cmd_type() const;
  void set_cmd_type(::cn::seisys::dds::CmdType value);
  private:
  ::cn::seisys::dds::CmdType _internal_cmd_type() const;
  void _internal_set_cmd_type(::cn::seisys::dds::CmdType value);
  public:

  // .cn.seisys.dds.PodmanCmd podman_cmd = 7;
  void clear_podman_cmd();
  ::cn::seisys::dds::PodmanCmd podman_cmd() const;
  void set_podman_cmd(::cn::seisys::dds::PodmanCmd value);
  private:
  ::cn::seisys::dds::PodmanCmd _internal_podman_cmd() const;
  void _internal_set_podman_cmd(::cn::seisys::dds::PodmanCmd value);
  public:

  // int64 created_at = 12;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // int64 updated_at = 13;
  void clear_updated_at();
  int64_t updated_at() const;
  void set_updated_at(int64_t value);
  private:
  int64_t _internal_updated_at() const;
  void _internal_set_updated_at(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.NodeCmd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_node_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr paras_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr paras_1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr paras_2_;
    int cmd_type_;
    int podman_cmd_;
    int64_t created_at_;
    int64_t updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// -------------------------------------------------------------------

class NodeCmdReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.seisys.dds.NodeCmdReply) */ {
 public:
  inline NodeCmdReply() : NodeCmdReply(nullptr) {}
  ~NodeCmdReply() override;
  explicit PROTOBUF_CONSTEXPR NodeCmdReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeCmdReply(const NodeCmdReply& from);
  NodeCmdReply(NodeCmdReply&& from) noexcept
    : NodeCmdReply() {
    *this = ::std::move(from);
  }

  inline NodeCmdReply& operator=(const NodeCmdReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeCmdReply& operator=(NodeCmdReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeCmdReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeCmdReply* internal_default_instance() {
    return reinterpret_cast<const NodeCmdReply*>(
               &_NodeCmdReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(NodeCmdReply& a, NodeCmdReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeCmdReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeCmdReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeCmdReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeCmdReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeCmdReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeCmdReply& from) {
    NodeCmdReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeCmdReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.seisys.dds.NodeCmdReply";
  }
  protected:
  explicit NodeCmdReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 11,
    kUuidFieldNumber = 1,
    kSrcNodeIdFieldNumber = 2,
    kSrcNodeNameFieldNumber = 3,
    kToNodeIdFieldNumber = 4,
    kToNodeNameFieldNumber = 5,
    kCmdReplyUuidFieldNumber = 6,
    kDescFieldNumber = 9,
    kDescStrFieldNumber = 10,
    kCmdTypeFieldNumber = 7,
    kStatusFieldNumber = 8,
    kCreatedAtFieldNumber = 12,
    kUpdatedAtFieldNumber = 13,
  };
  // repeated .cn.seisys.dds.File result = 11;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  ::cn::seisys::dds::File* mutable_result(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File >*
      mutable_result();
  private:
  const ::cn::seisys::dds::File& _internal_result(int index) const;
  ::cn::seisys::dds::File* _internal_add_result();
  public:
  const ::cn::seisys::dds::File& result(int index) const;
  ::cn::seisys::dds::File* add_result();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File >&
      result() const;

  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // string src_node_id = 2;
  void clear_src_node_id();
  const std::string& src_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_node_id();
  PROTOBUF_NODISCARD std::string* release_src_node_id();
  void set_allocated_src_node_id(std::string* src_node_id);
  private:
  const std::string& _internal_src_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_node_id(const std::string& value);
  std::string* _internal_mutable_src_node_id();
  public:

  // bytes src_node_name = 3;
  void clear_src_node_name();
  const std::string& src_node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_node_name();
  PROTOBUF_NODISCARD std::string* release_src_node_name();
  void set_allocated_src_node_name(std::string* src_node_name);
  private:
  const std::string& _internal_src_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_node_name(const std::string& value);
  std::string* _internal_mutable_src_node_name();
  public:

  // string to_node_id = 4;
  void clear_to_node_id();
  const std::string& to_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_node_id();
  PROTOBUF_NODISCARD std::string* release_to_node_id();
  void set_allocated_to_node_id(std::string* to_node_id);
  private:
  const std::string& _internal_to_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_node_id(const std::string& value);
  std::string* _internal_mutable_to_node_id();
  public:

  // bytes to_node_name = 5;
  void clear_to_node_name();
  const std::string& to_node_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_node_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_node_name();
  PROTOBUF_NODISCARD std::string* release_to_node_name();
  void set_allocated_to_node_name(std::string* to_node_name);
  private:
  const std::string& _internal_to_node_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_node_name(const std::string& value);
  std::string* _internal_mutable_to_node_name();
  public:

  // string cmd_reply_uuid = 6;
  void clear_cmd_reply_uuid();
  const std::string& cmd_reply_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmd_reply_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmd_reply_uuid();
  PROTOBUF_NODISCARD std::string* release_cmd_reply_uuid();
  void set_allocated_cmd_reply_uuid(std::string* cmd_reply_uuid);
  private:
  const std::string& _internal_cmd_reply_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd_reply_uuid(const std::string& value);
  std::string* _internal_mutable_cmd_reply_uuid();
  public:

  // bytes desc = 9;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // bytes desc_str = 10;
  void clear_desc_str();
  const std::string& desc_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc_str();
  PROTOBUF_NODISCARD std::string* release_desc_str();
  void set_allocated_desc_str(std::string* desc_str);
  private:
  const std::string& _internal_desc_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc_str(const std::string& value);
  std::string* _internal_mutable_desc_str();
  public:

  // .cn.seisys.dds.CmdType cmd_type = 7;
  void clear_cmd_type();
  ::cn::seisys::dds::CmdType cmd_type() const;
  void set_cmd_type(::cn::seisys::dds::CmdType value);
  private:
  ::cn::seisys::dds::CmdType _internal_cmd_type() const;
  void _internal_set_cmd_type(::cn::seisys::dds::CmdType value);
  public:

  // .cn.seisys.dds.CommStatus status = 8;
  void clear_status();
  ::cn::seisys::dds::CommStatus status() const;
  void set_status(::cn::seisys::dds::CommStatus value);
  private:
  ::cn::seisys::dds::CommStatus _internal_status() const;
  void _internal_set_status(::cn::seisys::dds::CommStatus value);
  public:

  // int64 created_at = 12;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // int64 updated_at = 13;
  void clear_updated_at();
  int64_t updated_at() const;
  void set_updated_at(int64_t value);
  private:
  int64_t _internal_updated_at() const;
  void _internal_set_updated_at(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.seisys.dds.NodeCmdReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File > result_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_node_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_node_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_reply_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_str_;
    int cmd_type_;
    int status_;
    int64_t created_at_;
    int64_t updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_node_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// File

// bytes file_path_name = 1;
inline void File::clear_file_path_name() {
  _impl_.file_path_name_.ClearToEmpty();
}
inline const std::string& File::file_path_name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.File.file_path_name)
  return _internal_file_path_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_file_path_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_path_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.File.file_path_name)
}
inline std::string* File::mutable_file_path_name() {
  std::string* _s = _internal_mutable_file_path_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.File.file_path_name)
  return _s;
}
inline const std::string& File::_internal_file_path_name() const {
  return _impl_.file_path_name_.Get();
}
inline void File::_internal_set_file_path_name(const std::string& value) {
  
  _impl_.file_path_name_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_file_path_name() {
  
  return _impl_.file_path_name_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_file_path_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.File.file_path_name)
  return _impl_.file_path_name_.Release();
}
inline void File::set_allocated_file_path_name(std::string* file_path_name) {
  if (file_path_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_path_name_.SetAllocated(file_path_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_path_name_.IsDefault()) {
    _impl_.file_path_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.File.file_path_name)
}

// bool is_dir = 2;
inline void File::clear_is_dir() {
  _impl_.is_dir_ = false;
}
inline bool File::_internal_is_dir() const {
  return _impl_.is_dir_;
}
inline bool File::is_dir() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.File.is_dir)
  return _internal_is_dir();
}
inline void File::_internal_set_is_dir(bool value) {
  
  _impl_.is_dir_ = value;
}
inline void File::set_is_dir(bool value) {
  _internal_set_is_dir(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.File.is_dir)
}

// int64 file_size = 3;
inline void File::clear_file_size() {
  _impl_.file_size_ = int64_t{0};
}
inline int64_t File::_internal_file_size() const {
  return _impl_.file_size_;
}
inline int64_t File::file_size() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.File.file_size)
  return _internal_file_size();
}
inline void File::_internal_set_file_size(int64_t value) {
  
  _impl_.file_size_ = value;
}
inline void File::set_file_size(int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.File.file_size)
}

// int64 timestamp = 4;
inline void File::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t File::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t File::timestamp() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.File.timestamp)
  return _internal_timestamp();
}
inline void File::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void File::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.File.timestamp)
}

// -------------------------------------------------------------------

// FileInfos

// repeated .cn.seisys.dds.File files = 1;
inline int FileInfos::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int FileInfos::files_size() const {
  return _internal_files_size();
}
inline void FileInfos::clear_files() {
  _impl_.files_.Clear();
}
inline ::cn::seisys::dds::File* FileInfos::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.FileInfos.files)
  return _impl_.files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File >*
FileInfos::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.dds.FileInfos.files)
  return &_impl_.files_;
}
inline const ::cn::seisys::dds::File& FileInfos::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const ::cn::seisys::dds::File& FileInfos::files(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.FileInfos.files)
  return _internal_files(index);
}
inline ::cn::seisys::dds::File* FileInfos::_internal_add_files() {
  return _impl_.files_.Add();
}
inline ::cn::seisys::dds::File* FileInfos::add_files() {
  ::cn::seisys::dds::File* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:cn.seisys.dds.FileInfos.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File >&
FileInfos::files() const {
  // @@protoc_insertion_point(field_list:cn.seisys.dds.FileInfos.files)
  return _impl_.files_;
}

// -------------------------------------------------------------------

// Ping

// string to_node_id = 1;
inline void Ping::clear_to_node_id() {
  _impl_.to_node_id_.ClearToEmpty();
}
inline const std::string& Ping::to_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ping.to_node_id)
  return _internal_to_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ping::set_to_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ping.to_node_id)
}
inline std::string* Ping::mutable_to_node_id() {
  std::string* _s = _internal_mutable_to_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Ping.to_node_id)
  return _s;
}
inline const std::string& Ping::_internal_to_node_id() const {
  return _impl_.to_node_id_.Get();
}
inline void Ping::_internal_set_to_node_id(const std::string& value) {
  
  _impl_.to_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Ping::_internal_mutable_to_node_id() {
  
  return _impl_.to_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Ping::release_to_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Ping.to_node_id)
  return _impl_.to_node_id_.Release();
}
inline void Ping::set_allocated_to_node_id(std::string* to_node_id) {
  if (to_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.to_node_id_.SetAllocated(to_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_node_id_.IsDefault()) {
    _impl_.to_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Ping.to_node_id)
}

// string src_node_id = 2;
inline void Ping::clear_src_node_id() {
  _impl_.src_node_id_.ClearToEmpty();
}
inline const std::string& Ping::src_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ping.src_node_id)
  return _internal_src_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ping::set_src_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ping.src_node_id)
}
inline std::string* Ping::mutable_src_node_id() {
  std::string* _s = _internal_mutable_src_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Ping.src_node_id)
  return _s;
}
inline const std::string& Ping::_internal_src_node_id() const {
  return _impl_.src_node_id_.Get();
}
inline void Ping::_internal_set_src_node_id(const std::string& value) {
  
  _impl_.src_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Ping::_internal_mutable_src_node_id() {
  
  return _impl_.src_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Ping::release_src_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Ping.src_node_id)
  return _impl_.src_node_id_.Release();
}
inline void Ping::set_allocated_src_node_id(std::string* src_node_id) {
  if (src_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.src_node_id_.SetAllocated(src_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_node_id_.IsDefault()) {
    _impl_.src_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Ping.src_node_id)
}

// string node_app_ver = 3;
inline void Ping::clear_node_app_ver() {
  _impl_.node_app_ver_.ClearToEmpty();
}
inline const std::string& Ping::node_app_ver() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ping.node_app_ver)
  return _internal_node_app_ver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ping::set_node_app_ver(ArgT0&& arg0, ArgT... args) {
 
 _impl_.node_app_ver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ping.node_app_ver)
}
inline std::string* Ping::mutable_node_app_ver() {
  std::string* _s = _internal_mutable_node_app_ver();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Ping.node_app_ver)
  return _s;
}
inline const std::string& Ping::_internal_node_app_ver() const {
  return _impl_.node_app_ver_.Get();
}
inline void Ping::_internal_set_node_app_ver(const std::string& value) {
  
  _impl_.node_app_ver_.Set(value, GetArenaForAllocation());
}
inline std::string* Ping::_internal_mutable_node_app_ver() {
  
  return _impl_.node_app_ver_.Mutable(GetArenaForAllocation());
}
inline std::string* Ping::release_node_app_ver() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Ping.node_app_ver)
  return _impl_.node_app_ver_.Release();
}
inline void Ping::set_allocated_node_app_ver(std::string* node_app_ver) {
  if (node_app_ver != nullptr) {
    
  } else {
    
  }
  _impl_.node_app_ver_.SetAllocated(node_app_ver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_app_ver_.IsDefault()) {
    _impl_.node_app_ver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Ping.node_app_ver)
}

// string node_cfg_ver = 4;
inline void Ping::clear_node_cfg_ver() {
  _impl_.node_cfg_ver_.ClearToEmpty();
}
inline const std::string& Ping::node_cfg_ver() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ping.node_cfg_ver)
  return _internal_node_cfg_ver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ping::set_node_cfg_ver(ArgT0&& arg0, ArgT... args) {
 
 _impl_.node_cfg_ver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ping.node_cfg_ver)
}
inline std::string* Ping::mutable_node_cfg_ver() {
  std::string* _s = _internal_mutable_node_cfg_ver();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Ping.node_cfg_ver)
  return _s;
}
inline const std::string& Ping::_internal_node_cfg_ver() const {
  return _impl_.node_cfg_ver_.Get();
}
inline void Ping::_internal_set_node_cfg_ver(const std::string& value) {
  
  _impl_.node_cfg_ver_.Set(value, GetArenaForAllocation());
}
inline std::string* Ping::_internal_mutable_node_cfg_ver() {
  
  return _impl_.node_cfg_ver_.Mutable(GetArenaForAllocation());
}
inline std::string* Ping::release_node_cfg_ver() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Ping.node_cfg_ver)
  return _impl_.node_cfg_ver_.Release();
}
inline void Ping::set_allocated_node_cfg_ver(std::string* node_cfg_ver) {
  if (node_cfg_ver != nullptr) {
    
  } else {
    
  }
  _impl_.node_cfg_ver_.SetAllocated(node_cfg_ver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_cfg_ver_.IsDefault()) {
    _impl_.node_cfg_ver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Ping.node_cfg_ver)
}

// .cn.seisys.dds.NodeState state = 5;
inline void Ping::clear_state() {
  _impl_.state_ = 0;
}
inline ::cn::seisys::dds::NodeState Ping::_internal_state() const {
  return static_cast< ::cn::seisys::dds::NodeState >(_impl_.state_);
}
inline ::cn::seisys::dds::NodeState Ping::state() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ping.state)
  return _internal_state();
}
inline void Ping::_internal_set_state(::cn::seisys::dds::NodeState value) {
  
  _impl_.state_ = value;
}
inline void Ping::set_state(::cn::seisys::dds::NodeState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ping.state)
}

// int64 created_at = 6;
inline void Ping::clear_created_at() {
  _impl_.created_at_ = int64_t{0};
}
inline int64_t Ping::_internal_created_at() const {
  return _impl_.created_at_;
}
inline int64_t Ping::created_at() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ping.created_at)
  return _internal_created_at();
}
inline void Ping::_internal_set_created_at(int64_t value) {
  
  _impl_.created_at_ = value;
}
inline void Ping::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ping.created_at)
}

// string desc = 7;
inline void Ping::clear_desc() {
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& Ping::desc() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ping.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ping::set_desc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.desc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ping.desc)
}
inline std::string* Ping::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Ping.desc)
  return _s;
}
inline const std::string& Ping::_internal_desc() const {
  return _impl_.desc_.Get();
}
inline void Ping::_internal_set_desc(const std::string& value) {
  
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* Ping::_internal_mutable_desc() {
  
  return _impl_.desc_.Mutable(GetArenaForAllocation());
}
inline std::string* Ping::release_desc() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Ping.desc)
  return _impl_.desc_.Release();
}
inline void Ping::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  _impl_.desc_.SetAllocated(desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.desc_.IsDefault()) {
    _impl_.desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Ping.desc)
}

// -------------------------------------------------------------------

// Cpu

// string vendor = 1;
inline void Cpu::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
}
inline const std::string& Cpu::vendor() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cpu::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.vendor)
}
inline std::string* Cpu::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Cpu.vendor)
  return _s;
}
inline const std::string& Cpu::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void Cpu::_internal_set_vendor(const std::string& value) {
  
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* Cpu::_internal_mutable_vendor() {
  
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* Cpu::release_vendor() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Cpu.vendor)
  return _impl_.vendor_.Release();
}
inline void Cpu::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Cpu.vendor)
}

// string model = 2;
inline void Cpu::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& Cpu::model() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cpu::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.model)
}
inline std::string* Cpu::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Cpu.model)
  return _s;
}
inline const std::string& Cpu::_internal_model() const {
  return _impl_.model_.Get();
}
inline void Cpu::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* Cpu::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* Cpu::release_model() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Cpu.model)
  return _impl_.model_.Release();
}
inline void Cpu::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Cpu.model)
}

// int32 physical_cores = 3;
inline void Cpu::clear_physical_cores() {
  _impl_.physical_cores_ = 0;
}
inline int32_t Cpu::_internal_physical_cores() const {
  return _impl_.physical_cores_;
}
inline int32_t Cpu::physical_cores() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.physical_cores)
  return _internal_physical_cores();
}
inline void Cpu::_internal_set_physical_cores(int32_t value) {
  
  _impl_.physical_cores_ = value;
}
inline void Cpu::set_physical_cores(int32_t value) {
  _internal_set_physical_cores(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.physical_cores)
}

// int32 logical_cores = 4;
inline void Cpu::clear_logical_cores() {
  _impl_.logical_cores_ = 0;
}
inline int32_t Cpu::_internal_logical_cores() const {
  return _impl_.logical_cores_;
}
inline int32_t Cpu::logical_cores() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.logical_cores)
  return _internal_logical_cores();
}
inline void Cpu::_internal_set_logical_cores(int32_t value) {
  
  _impl_.logical_cores_ = value;
}
inline void Cpu::set_logical_cores(int32_t value) {
  _internal_set_logical_cores(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.logical_cores)
}

// int64 max_frequency = 5;
inline void Cpu::clear_max_frequency() {
  _impl_.max_frequency_ = int64_t{0};
}
inline int64_t Cpu::_internal_max_frequency() const {
  return _impl_.max_frequency_;
}
inline int64_t Cpu::max_frequency() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.max_frequency)
  return _internal_max_frequency();
}
inline void Cpu::_internal_set_max_frequency(int64_t value) {
  
  _impl_.max_frequency_ = value;
}
inline void Cpu::set_max_frequency(int64_t value) {
  _internal_set_max_frequency(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.max_frequency)
}

// int64 regular_frequency = 6;
inline void Cpu::clear_regular_frequency() {
  _impl_.regular_frequency_ = int64_t{0};
}
inline int64_t Cpu::_internal_regular_frequency() const {
  return _impl_.regular_frequency_;
}
inline int64_t Cpu::regular_frequency() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.regular_frequency)
  return _internal_regular_frequency();
}
inline void Cpu::_internal_set_regular_frequency(int64_t value) {
  
  _impl_.regular_frequency_ = value;
}
inline void Cpu::set_regular_frequency(int64_t value) {
  _internal_set_regular_frequency(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.regular_frequency)
}

// int64 min_frequency = 7;
inline void Cpu::clear_min_frequency() {
  _impl_.min_frequency_ = int64_t{0};
}
inline int64_t Cpu::_internal_min_frequency() const {
  return _impl_.min_frequency_;
}
inline int64_t Cpu::min_frequency() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.min_frequency)
  return _internal_min_frequency();
}
inline void Cpu::_internal_set_min_frequency(int64_t value) {
  
  _impl_.min_frequency_ = value;
}
inline void Cpu::set_min_frequency(int64_t value) {
  _internal_set_min_frequency(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.min_frequency)
}

// repeated int64 current_frequency = 8;
inline int Cpu::_internal_current_frequency_size() const {
  return _impl_.current_frequency_.size();
}
inline int Cpu::current_frequency_size() const {
  return _internal_current_frequency_size();
}
inline void Cpu::clear_current_frequency() {
  _impl_.current_frequency_.Clear();
}
inline int64_t Cpu::_internal_current_frequency(int index) const {
  return _impl_.current_frequency_.Get(index);
}
inline int64_t Cpu::current_frequency(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.current_frequency)
  return _internal_current_frequency(index);
}
inline void Cpu::set_current_frequency(int index, int64_t value) {
  _impl_.current_frequency_.Set(index, value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.current_frequency)
}
inline void Cpu::_internal_add_current_frequency(int64_t value) {
  _impl_.current_frequency_.Add(value);
}
inline void Cpu::add_current_frequency(int64_t value) {
  _internal_add_current_frequency(value);
  // @@protoc_insertion_point(field_add:cn.seisys.dds.Cpu.current_frequency)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Cpu::_internal_current_frequency() const {
  return _impl_.current_frequency_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Cpu::current_frequency() const {
  // @@protoc_insertion_point(field_list:cn.seisys.dds.Cpu.current_frequency)
  return _internal_current_frequency();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Cpu::_internal_mutable_current_frequency() {
  return &_impl_.current_frequency_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Cpu::mutable_current_frequency() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.dds.Cpu.current_frequency)
  return _internal_mutable_current_frequency();
}

// int64 cache_size = 9;
inline void Cpu::clear_cache_size() {
  _impl_.cache_size_ = int64_t{0};
}
inline int64_t Cpu::_internal_cache_size() const {
  return _impl_.cache_size_;
}
inline int64_t Cpu::cache_size() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.cache_size)
  return _internal_cache_size();
}
inline void Cpu::_internal_set_cache_size(int64_t value) {
  
  _impl_.cache_size_ = value;
}
inline void Cpu::set_cache_size(int64_t value) {
  _internal_set_cache_size(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.cache_size)
}

// double cpu_usage = 10;
inline void Cpu::clear_cpu_usage() {
  _impl_.cpu_usage_ = 0;
}
inline double Cpu::_internal_cpu_usage() const {
  return _impl_.cpu_usage_;
}
inline double Cpu::cpu_usage() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Cpu.cpu_usage)
  return _internal_cpu_usage();
}
inline void Cpu::_internal_set_cpu_usage(double value) {
  
  _impl_.cpu_usage_ = value;
}
inline void Cpu::set_cpu_usage(double value) {
  _internal_set_cpu_usage(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Cpu.cpu_usage)
}

// -------------------------------------------------------------------

// Gpu

// string vendor = 1;
inline void Gpu::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
}
inline const std::string& Gpu::vendor() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Gpu.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gpu::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Gpu.vendor)
}
inline std::string* Gpu::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Gpu.vendor)
  return _s;
}
inline const std::string& Gpu::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void Gpu::_internal_set_vendor(const std::string& value) {
  
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* Gpu::_internal_mutable_vendor() {
  
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* Gpu::release_vendor() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Gpu.vendor)
  return _impl_.vendor_.Release();
}
inline void Gpu::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Gpu.vendor)
}

// string model = 2;
inline void Gpu::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& Gpu::model() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Gpu.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gpu::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Gpu.model)
}
inline std::string* Gpu::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Gpu.model)
  return _s;
}
inline const std::string& Gpu::_internal_model() const {
  return _impl_.model_.Get();
}
inline void Gpu::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* Gpu::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* Gpu::release_model() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Gpu.model)
  return _impl_.model_.Release();
}
inline void Gpu::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Gpu.model)
}

// string driver_version = 3;
inline void Gpu::clear_driver_version() {
  _impl_.driver_version_.ClearToEmpty();
}
inline const std::string& Gpu::driver_version() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Gpu.driver_version)
  return _internal_driver_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gpu::set_driver_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.driver_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Gpu.driver_version)
}
inline std::string* Gpu::mutable_driver_version() {
  std::string* _s = _internal_mutable_driver_version();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Gpu.driver_version)
  return _s;
}
inline const std::string& Gpu::_internal_driver_version() const {
  return _impl_.driver_version_.Get();
}
inline void Gpu::_internal_set_driver_version(const std::string& value) {
  
  _impl_.driver_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Gpu::_internal_mutable_driver_version() {
  
  return _impl_.driver_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Gpu::release_driver_version() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Gpu.driver_version)
  return _impl_.driver_version_.Release();
}
inline void Gpu::set_allocated_driver_version(std::string* driver_version) {
  if (driver_version != nullptr) {
    
  } else {
    
  }
  _impl_.driver_version_.SetAllocated(driver_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.driver_version_.IsDefault()) {
    _impl_.driver_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Gpu.driver_version)
}

// double memory = 4;
inline void Gpu::clear_memory() {
  _impl_.memory_ = 0;
}
inline double Gpu::_internal_memory() const {
  return _impl_.memory_;
}
inline double Gpu::memory() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Gpu.memory)
  return _internal_memory();
}
inline void Gpu::_internal_set_memory(double value) {
  
  _impl_.memory_ = value;
}
inline void Gpu::set_memory(double value) {
  _internal_set_memory(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Gpu.memory)
}

// int64 frequency = 5;
inline void Gpu::clear_frequency() {
  _impl_.frequency_ = int64_t{0};
}
inline int64_t Gpu::_internal_frequency() const {
  return _impl_.frequency_;
}
inline int64_t Gpu::frequency() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Gpu.frequency)
  return _internal_frequency();
}
inline void Gpu::_internal_set_frequency(int64_t value) {
  
  _impl_.frequency_ = value;
}
inline void Gpu::set_frequency(int64_t value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Gpu.frequency)
}

// -------------------------------------------------------------------

// Ram

// string vendor = 1;
inline void Ram::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
}
inline const std::string& Ram::vendor() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ram.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ram::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ram.vendor)
}
inline std::string* Ram::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Ram.vendor)
  return _s;
}
inline const std::string& Ram::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void Ram::_internal_set_vendor(const std::string& value) {
  
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* Ram::_internal_mutable_vendor() {
  
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* Ram::release_vendor() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Ram.vendor)
  return _impl_.vendor_.Release();
}
inline void Ram::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Ram.vendor)
}

// string model = 2;
inline void Ram::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& Ram::model() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ram.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ram::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ram.model)
}
inline std::string* Ram::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Ram.model)
  return _s;
}
inline const std::string& Ram::_internal_model() const {
  return _impl_.model_.Get();
}
inline void Ram::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* Ram::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* Ram::release_model() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Ram.model)
  return _impl_.model_.Release();
}
inline void Ram::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Ram.model)
}

// bytes name = 3;
inline void Ram::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Ram::name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ram.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ram::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ram.name)
}
inline std::string* Ram::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Ram.name)
  return _s;
}
inline const std::string& Ram::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Ram::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Ram::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Ram::release_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Ram.name)
  return _impl_.name_.Release();
}
inline void Ram::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Ram.name)
}

// string serial_number = 4;
inline void Ram::clear_serial_number() {
  _impl_.serial_number_.ClearToEmpty();
}
inline const std::string& Ram::serial_number() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ram.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ram::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ram.serial_number)
}
inline std::string* Ram::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Ram.serial_number)
  return _s;
}
inline const std::string& Ram::_internal_serial_number() const {
  return _impl_.serial_number_.Get();
}
inline void Ram::_internal_set_serial_number(const std::string& value) {
  
  _impl_.serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* Ram::_internal_mutable_serial_number() {
  
  return _impl_.serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* Ram::release_serial_number() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Ram.serial_number)
  return _impl_.serial_number_.Release();
}
inline void Ram::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  _impl_.serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Ram.serial_number)
}

// int64 size = 5;
inline void Ram::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t Ram::_internal_size() const {
  return _impl_.size_;
}
inline int64_t Ram::size() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ram.size)
  return _internal_size();
}
inline void Ram::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void Ram::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ram.size)
}

// int64 free = 6;
inline void Ram::clear_free() {
  _impl_.free_ = int64_t{0};
}
inline int64_t Ram::_internal_free() const {
  return _impl_.free_;
}
inline int64_t Ram::free() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ram.free)
  return _internal_free();
}
inline void Ram::_internal_set_free(int64_t value) {
  
  _impl_.free_ = value;
}
inline void Ram::set_free(int64_t value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ram.free)
}

// int64 available = 7;
inline void Ram::clear_available() {
  _impl_.available_ = int64_t{0};
}
inline int64_t Ram::_internal_available() const {
  return _impl_.available_;
}
inline int64_t Ram::available() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Ram.available)
  return _internal_available();
}
inline void Ram::_internal_set_available(int64_t value) {
  
  _impl_.available_ = value;
}
inline void Ram::set_available(int64_t value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Ram.available)
}

// -------------------------------------------------------------------

// Disk

// bytes vendor = 1;
inline void Disk::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
}
inline const std::string& Disk::vendor() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Disk.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Disk::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Disk.vendor)
}
inline std::string* Disk::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Disk.vendor)
  return _s;
}
inline const std::string& Disk::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void Disk::_internal_set_vendor(const std::string& value) {
  
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* Disk::_internal_mutable_vendor() {
  
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* Disk::release_vendor() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Disk.vendor)
  return _impl_.vendor_.Release();
}
inline void Disk::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Disk.vendor)
}

// string model = 2;
inline void Disk::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& Disk::model() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Disk.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Disk::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Disk.model)
}
inline std::string* Disk::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Disk.model)
  return _s;
}
inline const std::string& Disk::_internal_model() const {
  return _impl_.model_.Get();
}
inline void Disk::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* Disk::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* Disk::release_model() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Disk.model)
  return _impl_.model_.Release();
}
inline void Disk::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Disk.model)
}

// string serial_number = 3;
inline void Disk::clear_serial_number() {
  _impl_.serial_number_.ClearToEmpty();
}
inline const std::string& Disk::serial_number() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Disk.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Disk::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Disk.serial_number)
}
inline std::string* Disk::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Disk.serial_number)
  return _s;
}
inline const std::string& Disk::_internal_serial_number() const {
  return _impl_.serial_number_.Get();
}
inline void Disk::_internal_set_serial_number(const std::string& value) {
  
  _impl_.serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* Disk::_internal_mutable_serial_number() {
  
  return _impl_.serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* Disk::release_serial_number() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Disk.serial_number)
  return _impl_.serial_number_.Release();
}
inline void Disk::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  _impl_.serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Disk.serial_number)
}

// int64 size = 4;
inline void Disk::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t Disk::_internal_size() const {
  return _impl_.size_;
}
inline int64_t Disk::size() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Disk.size)
  return _internal_size();
}
inline void Disk::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void Disk::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Disk.size)
}

// -------------------------------------------------------------------

// MainBoard

// string vendor = 1;
inline void MainBoard::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
}
inline const std::string& MainBoard::vendor() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MainBoard.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MainBoard::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.MainBoard.vendor)
}
inline std::string* MainBoard::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MainBoard.vendor)
  return _s;
}
inline const std::string& MainBoard::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void MainBoard::_internal_set_vendor(const std::string& value) {
  
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* MainBoard::_internal_mutable_vendor() {
  
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* MainBoard::release_vendor() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.MainBoard.vendor)
  return _impl_.vendor_.Release();
}
inline void MainBoard::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.MainBoard.vendor)
}

// bytes name = 2;
inline void MainBoard::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MainBoard::name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MainBoard.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MainBoard::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.MainBoard.name)
}
inline std::string* MainBoard::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MainBoard.name)
  return _s;
}
inline const std::string& MainBoard::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MainBoard::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MainBoard::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MainBoard::release_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.MainBoard.name)
  return _impl_.name_.Release();
}
inline void MainBoard::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.MainBoard.name)
}

// string version = 3;
inline void MainBoard::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& MainBoard::version() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MainBoard.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MainBoard::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.MainBoard.version)
}
inline std::string* MainBoard::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MainBoard.version)
  return _s;
}
inline const std::string& MainBoard::_internal_version() const {
  return _impl_.version_.Get();
}
inline void MainBoard::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* MainBoard::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* MainBoard::release_version() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.MainBoard.version)
  return _impl_.version_.Release();
}
inline void MainBoard::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.MainBoard.version)
}

// string serial_number = 4;
inline void MainBoard::clear_serial_number() {
  _impl_.serial_number_.ClearToEmpty();
}
inline const std::string& MainBoard::serial_number() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MainBoard.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MainBoard::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.MainBoard.serial_number)
}
inline std::string* MainBoard::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MainBoard.serial_number)
  return _s;
}
inline const std::string& MainBoard::_internal_serial_number() const {
  return _impl_.serial_number_.Get();
}
inline void MainBoard::_internal_set_serial_number(const std::string& value) {
  
  _impl_.serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* MainBoard::_internal_mutable_serial_number() {
  
  return _impl_.serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* MainBoard::release_serial_number() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.MainBoard.serial_number)
  return _impl_.serial_number_.Release();
}
inline void MainBoard::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  _impl_.serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.MainBoard.serial_number)
}

// -------------------------------------------------------------------

// ProcessTime

// float user_time = 1;
inline void ProcessTime::clear_user_time() {
  _impl_.user_time_ = 0;
}
inline float ProcessTime::_internal_user_time() const {
  return _impl_.user_time_;
}
inline float ProcessTime::user_time() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.ProcessTime.user_time)
  return _internal_user_time();
}
inline void ProcessTime::_internal_set_user_time(float value) {
  
  _impl_.user_time_ = value;
}
inline void ProcessTime::set_user_time(float value) {
  _internal_set_user_time(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.ProcessTime.user_time)
}

// float kernel_time = 2;
inline void ProcessTime::clear_kernel_time() {
  _impl_.kernel_time_ = 0;
}
inline float ProcessTime::_internal_kernel_time() const {
  return _impl_.kernel_time_;
}
inline float ProcessTime::kernel_time() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.ProcessTime.kernel_time)
  return _internal_kernel_time();
}
inline void ProcessTime::_internal_set_kernel_time(float value) {
  
  _impl_.kernel_time_ = value;
}
inline void ProcessTime::set_kernel_time(float value) {
  _internal_set_kernel_time(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.ProcessTime.kernel_time)
}

// float children_usertime = 3;
inline void ProcessTime::clear_children_usertime() {
  _impl_.children_usertime_ = 0;
}
inline float ProcessTime::_internal_children_usertime() const {
  return _impl_.children_usertime_;
}
inline float ProcessTime::children_usertime() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.ProcessTime.children_usertime)
  return _internal_children_usertime();
}
inline void ProcessTime::_internal_set_children_usertime(float value) {
  
  _impl_.children_usertime_ = value;
}
inline void ProcessTime::set_children_usertime(float value) {
  _internal_set_children_usertime(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.ProcessTime.children_usertime)
}

// float children_kernel_time = 4;
inline void ProcessTime::clear_children_kernel_time() {
  _impl_.children_kernel_time_ = 0;
}
inline float ProcessTime::_internal_children_kernel_time() const {
  return _impl_.children_kernel_time_;
}
inline float ProcessTime::children_kernel_time() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.ProcessTime.children_kernel_time)
  return _internal_children_kernel_time();
}
inline void ProcessTime::_internal_set_children_kernel_time(float value) {
  
  _impl_.children_kernel_time_ = value;
}
inline void ProcessTime::set_children_kernel_time(float value) {
  _internal_set_children_kernel_time(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.ProcessTime.children_kernel_time)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Process

// bytes name = 1;
inline void Process::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Process::name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.name)
}
inline std::string* Process::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Process.name)
  return _s;
}
inline const std::string& Process::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Process::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Process::release_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Process.name)
  return _impl_.name_.Release();
}
inline void Process::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Process.name)
}

// string work_path = 2;
inline void Process::clear_work_path() {
  _impl_.work_path_.ClearToEmpty();
}
inline const std::string& Process::work_path() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.work_path)
  return _internal_work_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_work_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.work_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.work_path)
}
inline std::string* Process::mutable_work_path() {
  std::string* _s = _internal_mutable_work_path();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Process.work_path)
  return _s;
}
inline const std::string& Process::_internal_work_path() const {
  return _impl_.work_path_.Get();
}
inline void Process::_internal_set_work_path(const std::string& value) {
  
  _impl_.work_path_.Set(value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_work_path() {
  
  return _impl_.work_path_.Mutable(GetArenaForAllocation());
}
inline std::string* Process::release_work_path() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Process.work_path)
  return _impl_.work_path_.Release();
}
inline void Process::set_allocated_work_path(std::string* work_path) {
  if (work_path != nullptr) {
    
  } else {
    
  }
  _impl_.work_path_.SetAllocated(work_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.work_path_.IsDefault()) {
    _impl_.work_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Process.work_path)
}

// int32 pid = 3;
inline void Process::clear_pid() {
  _impl_.pid_ = 0;
}
inline int32_t Process::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t Process::pid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.pid)
  return _internal_pid();
}
inline void Process::_internal_set_pid(int32_t value) {
  
  _impl_.pid_ = value;
}
inline void Process::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.pid)
}

// string args = 4;
inline void Process::clear_args() {
  _impl_.args_.ClearToEmpty();
}
inline const std::string& Process::args() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Process::set_args(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.args)
}
inline std::string* Process::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Process.args)
  return _s;
}
inline const std::string& Process::_internal_args() const {
  return _impl_.args_.Get();
}
inline void Process::_internal_set_args(const std::string& value) {
  
  _impl_.args_.Set(value, GetArenaForAllocation());
}
inline std::string* Process::_internal_mutable_args() {
  
  return _impl_.args_.Mutable(GetArenaForAllocation());
}
inline std::string* Process::release_args() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Process.args)
  return _impl_.args_.Release();
}
inline void Process::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  _impl_.args_.SetAllocated(args, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_.IsDefault()) {
    _impl_.args_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Process.args)
}

// double cpu_usage = 5;
inline void Process::clear_cpu_usage() {
  _impl_.cpu_usage_ = 0;
}
inline double Process::_internal_cpu_usage() const {
  return _impl_.cpu_usage_;
}
inline double Process::cpu_usage() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.cpu_usage)
  return _internal_cpu_usage();
}
inline void Process::_internal_set_cpu_usage(double value) {
  
  _impl_.cpu_usage_ = value;
}
inline void Process::set_cpu_usage(double value) {
  _internal_set_cpu_usage(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.cpu_usage)
}

// double mem_usage = 6;
inline void Process::clear_mem_usage() {
  _impl_.mem_usage_ = 0;
}
inline double Process::_internal_mem_usage() const {
  return _impl_.mem_usage_;
}
inline double Process::mem_usage() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.mem_usage)
  return _internal_mem_usage();
}
inline void Process::_internal_set_mem_usage(double value) {
  
  _impl_.mem_usage_ = value;
}
inline void Process::set_mem_usage(double value) {
  _internal_set_mem_usage(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.mem_usage)
}

// int64 start_time = 7;
inline void Process::clear_start_time() {
  _impl_.start_time_ = int64_t{0};
}
inline int64_t Process::_internal_start_time() const {
  return _impl_.start_time_;
}
inline int64_t Process::start_time() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.start_time)
  return _internal_start_time();
}
inline void Process::_internal_set_start_time(int64_t value) {
  
  _impl_.start_time_ = value;
}
inline void Process::set_start_time(int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.start_time)
}

// int64 stop_time = 8;
inline void Process::clear_stop_time() {
  _impl_.stop_time_ = int64_t{0};
}
inline int64_t Process::_internal_stop_time() const {
  return _impl_.stop_time_;
}
inline int64_t Process::stop_time() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.stop_time)
  return _internal_stop_time();
}
inline void Process::_internal_set_stop_time(int64_t value) {
  
  _impl_.stop_time_ = value;
}
inline void Process::set_stop_time(int64_t value) {
  _internal_set_stop_time(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.stop_time)
}

// int32 reboot_count = 9;
inline void Process::clear_reboot_count() {
  _impl_.reboot_count_ = 0;
}
inline int32_t Process::_internal_reboot_count() const {
  return _impl_.reboot_count_;
}
inline int32_t Process::reboot_count() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.reboot_count)
  return _internal_reboot_count();
}
inline void Process::_internal_set_reboot_count(int32_t value) {
  
  _impl_.reboot_count_ = value;
}
inline void Process::set_reboot_count(int32_t value) {
  _internal_set_reboot_count(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.reboot_count)
}

// int32 priority = 10;
inline void Process::clear_priority() {
  _impl_.priority_ = 0;
}
inline int32_t Process::_internal_priority() const {
  return _impl_.priority_;
}
inline int32_t Process::priority() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Process.priority)
  return _internal_priority();
}
inline void Process::_internal_set_priority(int32_t value) {
  
  _impl_.priority_ = value;
}
inline void Process::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Process.priority)
}

// map<string, string> env = 11;
inline int Process::_internal_env_size() const {
  return _impl_.env_.size();
}
inline int Process::env_size() const {
  return _internal_env_size();
}
inline void Process::clear_env() {
  _impl_.env_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Process::_internal_env() const {
  return _impl_.env_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Process::env() const {
  // @@protoc_insertion_point(field_map:cn.seisys.dds.Process.env)
  return _internal_env();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Process::_internal_mutable_env() {
  return _impl_.env_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Process::mutable_env() {
  // @@protoc_insertion_point(field_mutable_map:cn.seisys.dds.Process.env)
  return _internal_mutable_env();
}

// -------------------------------------------------------------------

// Network

// bytes name = 1;
inline void Network::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Network::name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Network.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Network.name)
}
inline std::string* Network::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Network.name)
  return _s;
}
inline const std::string& Network::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Network::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Network::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Network::release_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Network.name)
  return _impl_.name_.Release();
}
inline void Network::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Network.name)
}

// string ipv4s = 2;
inline void Network::clear_ipv4s() {
  _impl_.ipv4s_.ClearToEmpty();
}
inline const std::string& Network::ipv4s() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Network.ipv4s)
  return _internal_ipv4s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network::set_ipv4s(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipv4s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Network.ipv4s)
}
inline std::string* Network::mutable_ipv4s() {
  std::string* _s = _internal_mutable_ipv4s();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Network.ipv4s)
  return _s;
}
inline const std::string& Network::_internal_ipv4s() const {
  return _impl_.ipv4s_.Get();
}
inline void Network::_internal_set_ipv4s(const std::string& value) {
  
  _impl_.ipv4s_.Set(value, GetArenaForAllocation());
}
inline std::string* Network::_internal_mutable_ipv4s() {
  
  return _impl_.ipv4s_.Mutable(GetArenaForAllocation());
}
inline std::string* Network::release_ipv4s() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Network.ipv4s)
  return _impl_.ipv4s_.Release();
}
inline void Network::set_allocated_ipv4s(std::string* ipv4s) {
  if (ipv4s != nullptr) {
    
  } else {
    
  }
  _impl_.ipv4s_.SetAllocated(ipv4s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipv4s_.IsDefault()) {
    _impl_.ipv4s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Network.ipv4s)
}

// string ipv6s = 3;
inline void Network::clear_ipv6s() {
  _impl_.ipv6s_.ClearToEmpty();
}
inline const std::string& Network::ipv6s() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Network.ipv6s)
  return _internal_ipv6s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Network::set_ipv6s(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipv6s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Network.ipv6s)
}
inline std::string* Network::mutable_ipv6s() {
  std::string* _s = _internal_mutable_ipv6s();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Network.ipv6s)
  return _s;
}
inline const std::string& Network::_internal_ipv6s() const {
  return _impl_.ipv6s_.Get();
}
inline void Network::_internal_set_ipv6s(const std::string& value) {
  
  _impl_.ipv6s_.Set(value, GetArenaForAllocation());
}
inline std::string* Network::_internal_mutable_ipv6s() {
  
  return _impl_.ipv6s_.Mutable(GetArenaForAllocation());
}
inline std::string* Network::release_ipv6s() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Network.ipv6s)
  return _impl_.ipv6s_.Release();
}
inline void Network::set_allocated_ipv6s(std::string* ipv6s) {
  if (ipv6s != nullptr) {
    
  } else {
    
  }
  _impl_.ipv6s_.SetAllocated(ipv6s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipv6s_.IsDefault()) {
    _impl_.ipv6s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Network.ipv6s)
}

// int64 broadband = 4;
inline void Network::clear_broadband() {
  _impl_.broadband_ = int64_t{0};
}
inline int64_t Network::_internal_broadband() const {
  return _impl_.broadband_;
}
inline int64_t Network::broadband() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Network.broadband)
  return _internal_broadband();
}
inline void Network::_internal_set_broadband(int64_t value) {
  
  _impl_.broadband_ = value;
}
inline void Network::set_broadband(int64_t value) {
  _internal_set_broadband(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Network.broadband)
}

// int64 broadband_using = 5;
inline void Network::clear_broadband_using() {
  _impl_.broadband_using_ = int64_t{0};
}
inline int64_t Network::_internal_broadband_using() const {
  return _impl_.broadband_using_;
}
inline int64_t Network::broadband_using() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Network.broadband_using)
  return _internal_broadband_using();
}
inline void Network::_internal_set_broadband_using(int64_t value) {
  
  _impl_.broadband_using_ = value;
}
inline void Network::set_broadband_using(int64_t value) {
  _internal_set_broadband_using(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Network.broadband_using)
}

// -------------------------------------------------------------------

// OSInfo

// bytes operating_system = 1;
inline void OSInfo::clear_operating_system() {
  _impl_.operating_system_.ClearToEmpty();
}
inline const std::string& OSInfo::operating_system() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.OSInfo.operating_system)
  return _internal_operating_system();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OSInfo::set_operating_system(ArgT0&& arg0, ArgT... args) {
 
 _impl_.operating_system_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.OSInfo.operating_system)
}
inline std::string* OSInfo::mutable_operating_system() {
  std::string* _s = _internal_mutable_operating_system();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.OSInfo.operating_system)
  return _s;
}
inline const std::string& OSInfo::_internal_operating_system() const {
  return _impl_.operating_system_.Get();
}
inline void OSInfo::_internal_set_operating_system(const std::string& value) {
  
  _impl_.operating_system_.Set(value, GetArenaForAllocation());
}
inline std::string* OSInfo::_internal_mutable_operating_system() {
  
  return _impl_.operating_system_.Mutable(GetArenaForAllocation());
}
inline std::string* OSInfo::release_operating_system() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.OSInfo.operating_system)
  return _impl_.operating_system_.Release();
}
inline void OSInfo::set_allocated_operating_system(std::string* operating_system) {
  if (operating_system != nullptr) {
    
  } else {
    
  }
  _impl_.operating_system_.SetAllocated(operating_system, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operating_system_.IsDefault()) {
    _impl_.operating_system_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.OSInfo.operating_system)
}

// bytes short_name = 2;
inline void OSInfo::clear_short_name() {
  _impl_.short_name_.ClearToEmpty();
}
inline const std::string& OSInfo::short_name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.OSInfo.short_name)
  return _internal_short_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OSInfo::set_short_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.short_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.OSInfo.short_name)
}
inline std::string* OSInfo::mutable_short_name() {
  std::string* _s = _internal_mutable_short_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.OSInfo.short_name)
  return _s;
}
inline const std::string& OSInfo::_internal_short_name() const {
  return _impl_.short_name_.Get();
}
inline void OSInfo::_internal_set_short_name(const std::string& value) {
  
  _impl_.short_name_.Set(value, GetArenaForAllocation());
}
inline std::string* OSInfo::_internal_mutable_short_name() {
  
  return _impl_.short_name_.Mutable(GetArenaForAllocation());
}
inline std::string* OSInfo::release_short_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.OSInfo.short_name)
  return _impl_.short_name_.Release();
}
inline void OSInfo::set_allocated_short_name(std::string* short_name) {
  if (short_name != nullptr) {
    
  } else {
    
  }
  _impl_.short_name_.SetAllocated(short_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.short_name_.IsDefault()) {
    _impl_.short_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.OSInfo.short_name)
}

// string version = 3;
inline void OSInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& OSInfo::version() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.OSInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OSInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.OSInfo.version)
}
inline std::string* OSInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.OSInfo.version)
  return _s;
}
inline const std::string& OSInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void OSInfo::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* OSInfo::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* OSInfo::release_version() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.OSInfo.version)
  return _impl_.version_.Release();
}
inline void OSInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.OSInfo.version)
}

// string kernel = 4;
inline void OSInfo::clear_kernel() {
  _impl_.kernel_.ClearToEmpty();
}
inline const std::string& OSInfo::kernel() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.OSInfo.kernel)
  return _internal_kernel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OSInfo::set_kernel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.kernel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.OSInfo.kernel)
}
inline std::string* OSInfo::mutable_kernel() {
  std::string* _s = _internal_mutable_kernel();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.OSInfo.kernel)
  return _s;
}
inline const std::string& OSInfo::_internal_kernel() const {
  return _impl_.kernel_.Get();
}
inline void OSInfo::_internal_set_kernel(const std::string& value) {
  
  _impl_.kernel_.Set(value, GetArenaForAllocation());
}
inline std::string* OSInfo::_internal_mutable_kernel() {
  
  return _impl_.kernel_.Mutable(GetArenaForAllocation());
}
inline std::string* OSInfo::release_kernel() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.OSInfo.kernel)
  return _impl_.kernel_.Release();
}
inline void OSInfo::set_allocated_kernel(std::string* kernel) {
  if (kernel != nullptr) {
    
  } else {
    
  }
  _impl_.kernel_.SetAllocated(kernel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.kernel_.IsDefault()) {
    _impl_.kernel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.OSInfo.kernel)
}

// string architecture = 5;
inline void OSInfo::clear_architecture() {
  _impl_.architecture_.ClearToEmpty();
}
inline const std::string& OSInfo::architecture() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.OSInfo.architecture)
  return _internal_architecture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OSInfo::set_architecture(ArgT0&& arg0, ArgT... args) {
 
 _impl_.architecture_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.OSInfo.architecture)
}
inline std::string* OSInfo::mutable_architecture() {
  std::string* _s = _internal_mutable_architecture();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.OSInfo.architecture)
  return _s;
}
inline const std::string& OSInfo::_internal_architecture() const {
  return _impl_.architecture_.Get();
}
inline void OSInfo::_internal_set_architecture(const std::string& value) {
  
  _impl_.architecture_.Set(value, GetArenaForAllocation());
}
inline std::string* OSInfo::_internal_mutable_architecture() {
  
  return _impl_.architecture_.Mutable(GetArenaForAllocation());
}
inline std::string* OSInfo::release_architecture() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.OSInfo.architecture)
  return _impl_.architecture_.Release();
}
inline void OSInfo::set_allocated_architecture(std::string* architecture) {
  if (architecture != nullptr) {
    
  } else {
    
  }
  _impl_.architecture_.SetAllocated(architecture, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.architecture_.IsDefault()) {
    _impl_.architecture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.OSInfo.architecture)
}

// string endianess = 6;
inline void OSInfo::clear_endianess() {
  _impl_.endianess_.ClearToEmpty();
}
inline const std::string& OSInfo::endianess() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.OSInfo.endianess)
  return _internal_endianess();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OSInfo::set_endianess(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endianess_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.OSInfo.endianess)
}
inline std::string* OSInfo::mutable_endianess() {
  std::string* _s = _internal_mutable_endianess();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.OSInfo.endianess)
  return _s;
}
inline const std::string& OSInfo::_internal_endianess() const {
  return _impl_.endianess_.Get();
}
inline void OSInfo::_internal_set_endianess(const std::string& value) {
  
  _impl_.endianess_.Set(value, GetArenaForAllocation());
}
inline std::string* OSInfo::_internal_mutable_endianess() {
  
  return _impl_.endianess_.Mutable(GetArenaForAllocation());
}
inline std::string* OSInfo::release_endianess() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.OSInfo.endianess)
  return _impl_.endianess_.Release();
}
inline void OSInfo::set_allocated_endianess(std::string* endianess) {
  if (endianess != nullptr) {
    
  } else {
    
  }
  _impl_.endianess_.SetAllocated(endianess, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endianess_.IsDefault()) {
    _impl_.endianess_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.OSInfo.endianess)
}

// -------------------------------------------------------------------

// MachineState

// string to_node_id = 1;
inline void MachineState::clear_to_node_id() {
  _impl_.to_node_id_.ClearToEmpty();
}
inline const std::string& MachineState::to_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.to_node_id)
  return _internal_to_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MachineState::set_to_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.MachineState.to_node_id)
}
inline std::string* MachineState::mutable_to_node_id() {
  std::string* _s = _internal_mutable_to_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.to_node_id)
  return _s;
}
inline const std::string& MachineState::_internal_to_node_id() const {
  return _impl_.to_node_id_.Get();
}
inline void MachineState::_internal_set_to_node_id(const std::string& value) {
  
  _impl_.to_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MachineState::_internal_mutable_to_node_id() {
  
  return _impl_.to_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MachineState::release_to_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.MachineState.to_node_id)
  return _impl_.to_node_id_.Release();
}
inline void MachineState::set_allocated_to_node_id(std::string* to_node_id) {
  if (to_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.to_node_id_.SetAllocated(to_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_node_id_.IsDefault()) {
    _impl_.to_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.MachineState.to_node_id)
}

// string src_node_id = 2;
inline void MachineState::clear_src_node_id() {
  _impl_.src_node_id_.ClearToEmpty();
}
inline const std::string& MachineState::src_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.src_node_id)
  return _internal_src_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MachineState::set_src_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.MachineState.src_node_id)
}
inline std::string* MachineState::mutable_src_node_id() {
  std::string* _s = _internal_mutable_src_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.src_node_id)
  return _s;
}
inline const std::string& MachineState::_internal_src_node_id() const {
  return _impl_.src_node_id_.Get();
}
inline void MachineState::_internal_set_src_node_id(const std::string& value) {
  
  _impl_.src_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MachineState::_internal_mutable_src_node_id() {
  
  return _impl_.src_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MachineState::release_src_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.MachineState.src_node_id)
  return _impl_.src_node_id_.Release();
}
inline void MachineState::set_allocated_src_node_id(std::string* src_node_id) {
  if (src_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.src_node_id_.SetAllocated(src_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_node_id_.IsDefault()) {
    _impl_.src_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.MachineState.src_node_id)
}

// repeated .cn.seisys.dds.Cpu cpus = 3;
inline int MachineState::_internal_cpus_size() const {
  return _impl_.cpus_.size();
}
inline int MachineState::cpus_size() const {
  return _internal_cpus_size();
}
inline void MachineState::clear_cpus() {
  _impl_.cpus_.Clear();
}
inline ::cn::seisys::dds::Cpu* MachineState::mutable_cpus(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.cpus)
  return _impl_.cpus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Cpu >*
MachineState::mutable_cpus() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.dds.MachineState.cpus)
  return &_impl_.cpus_;
}
inline const ::cn::seisys::dds::Cpu& MachineState::_internal_cpus(int index) const {
  return _impl_.cpus_.Get(index);
}
inline const ::cn::seisys::dds::Cpu& MachineState::cpus(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.cpus)
  return _internal_cpus(index);
}
inline ::cn::seisys::dds::Cpu* MachineState::_internal_add_cpus() {
  return _impl_.cpus_.Add();
}
inline ::cn::seisys::dds::Cpu* MachineState::add_cpus() {
  ::cn::seisys::dds::Cpu* _add = _internal_add_cpus();
  // @@protoc_insertion_point(field_add:cn.seisys.dds.MachineState.cpus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Cpu >&
MachineState::cpus() const {
  // @@protoc_insertion_point(field_list:cn.seisys.dds.MachineState.cpus)
  return _impl_.cpus_;
}

// repeated .cn.seisys.dds.Gpu gpus = 4;
inline int MachineState::_internal_gpus_size() const {
  return _impl_.gpus_.size();
}
inline int MachineState::gpus_size() const {
  return _internal_gpus_size();
}
inline void MachineState::clear_gpus() {
  _impl_.gpus_.Clear();
}
inline ::cn::seisys::dds::Gpu* MachineState::mutable_gpus(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.gpus)
  return _impl_.gpus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Gpu >*
MachineState::mutable_gpus() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.dds.MachineState.gpus)
  return &_impl_.gpus_;
}
inline const ::cn::seisys::dds::Gpu& MachineState::_internal_gpus(int index) const {
  return _impl_.gpus_.Get(index);
}
inline const ::cn::seisys::dds::Gpu& MachineState::gpus(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.gpus)
  return _internal_gpus(index);
}
inline ::cn::seisys::dds::Gpu* MachineState::_internal_add_gpus() {
  return _impl_.gpus_.Add();
}
inline ::cn::seisys::dds::Gpu* MachineState::add_gpus() {
  ::cn::seisys::dds::Gpu* _add = _internal_add_gpus();
  // @@protoc_insertion_point(field_add:cn.seisys.dds.MachineState.gpus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Gpu >&
MachineState::gpus() const {
  // @@protoc_insertion_point(field_list:cn.seisys.dds.MachineState.gpus)
  return _impl_.gpus_;
}

// .cn.seisys.dds.Ram rams = 5;
inline bool MachineState::_internal_has_rams() const {
  return this != internal_default_instance() && _impl_.rams_ != nullptr;
}
inline bool MachineState::has_rams() const {
  return _internal_has_rams();
}
inline void MachineState::clear_rams() {
  if (GetArenaForAllocation() == nullptr && _impl_.rams_ != nullptr) {
    delete _impl_.rams_;
  }
  _impl_.rams_ = nullptr;
}
inline const ::cn::seisys::dds::Ram& MachineState::_internal_rams() const {
  const ::cn::seisys::dds::Ram* p = _impl_.rams_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::dds::Ram&>(
      ::cn::seisys::dds::_Ram_default_instance_);
}
inline const ::cn::seisys::dds::Ram& MachineState::rams() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.rams)
  return _internal_rams();
}
inline void MachineState::unsafe_arena_set_allocated_rams(
    ::cn::seisys::dds::Ram* rams) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rams_);
  }
  _impl_.rams_ = rams;
  if (rams) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.dds.MachineState.rams)
}
inline ::cn::seisys::dds::Ram* MachineState::release_rams() {
  
  ::cn::seisys::dds::Ram* temp = _impl_.rams_;
  _impl_.rams_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::dds::Ram* MachineState::unsafe_arena_release_rams() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.MachineState.rams)
  
  ::cn::seisys::dds::Ram* temp = _impl_.rams_;
  _impl_.rams_ = nullptr;
  return temp;
}
inline ::cn::seisys::dds::Ram* MachineState::_internal_mutable_rams() {
  
  if (_impl_.rams_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::dds::Ram>(GetArenaForAllocation());
    _impl_.rams_ = p;
  }
  return _impl_.rams_;
}
inline ::cn::seisys::dds::Ram* MachineState::mutable_rams() {
  ::cn::seisys::dds::Ram* _msg = _internal_mutable_rams();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.rams)
  return _msg;
}
inline void MachineState::set_allocated_rams(::cn::seisys::dds::Ram* rams) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rams_;
  }
  if (rams) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rams);
    if (message_arena != submessage_arena) {
      rams = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rams, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rams_ = rams;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.MachineState.rams)
}

// repeated .cn.seisys.dds.Disk disks = 6;
inline int MachineState::_internal_disks_size() const {
  return _impl_.disks_.size();
}
inline int MachineState::disks_size() const {
  return _internal_disks_size();
}
inline void MachineState::clear_disks() {
  _impl_.disks_.Clear();
}
inline ::cn::seisys::dds::Disk* MachineState::mutable_disks(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.disks)
  return _impl_.disks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Disk >*
MachineState::mutable_disks() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.dds.MachineState.disks)
  return &_impl_.disks_;
}
inline const ::cn::seisys::dds::Disk& MachineState::_internal_disks(int index) const {
  return _impl_.disks_.Get(index);
}
inline const ::cn::seisys::dds::Disk& MachineState::disks(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.disks)
  return _internal_disks(index);
}
inline ::cn::seisys::dds::Disk* MachineState::_internal_add_disks() {
  return _impl_.disks_.Add();
}
inline ::cn::seisys::dds::Disk* MachineState::add_disks() {
  ::cn::seisys::dds::Disk* _add = _internal_add_disks();
  // @@protoc_insertion_point(field_add:cn.seisys.dds.MachineState.disks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Disk >&
MachineState::disks() const {
  // @@protoc_insertion_point(field_list:cn.seisys.dds.MachineState.disks)
  return _impl_.disks_;
}

// repeated .cn.seisys.dds.Network networks = 7;
inline int MachineState::_internal_networks_size() const {
  return _impl_.networks_.size();
}
inline int MachineState::networks_size() const {
  return _internal_networks_size();
}
inline void MachineState::clear_networks() {
  _impl_.networks_.Clear();
}
inline ::cn::seisys::dds::Network* MachineState::mutable_networks(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.networks)
  return _impl_.networks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Network >*
MachineState::mutable_networks() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.dds.MachineState.networks)
  return &_impl_.networks_;
}
inline const ::cn::seisys::dds::Network& MachineState::_internal_networks(int index) const {
  return _impl_.networks_.Get(index);
}
inline const ::cn::seisys::dds::Network& MachineState::networks(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.networks)
  return _internal_networks(index);
}
inline ::cn::seisys::dds::Network* MachineState::_internal_add_networks() {
  return _impl_.networks_.Add();
}
inline ::cn::seisys::dds::Network* MachineState::add_networks() {
  ::cn::seisys::dds::Network* _add = _internal_add_networks();
  // @@protoc_insertion_point(field_add:cn.seisys.dds.MachineState.networks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Network >&
MachineState::networks() const {
  // @@protoc_insertion_point(field_list:cn.seisys.dds.MachineState.networks)
  return _impl_.networks_;
}

// .cn.seisys.dds.MainBoard main_board_infos = 8;
inline bool MachineState::_internal_has_main_board_infos() const {
  return this != internal_default_instance() && _impl_.main_board_infos_ != nullptr;
}
inline bool MachineState::has_main_board_infos() const {
  return _internal_has_main_board_infos();
}
inline void MachineState::clear_main_board_infos() {
  if (GetArenaForAllocation() == nullptr && _impl_.main_board_infos_ != nullptr) {
    delete _impl_.main_board_infos_;
  }
  _impl_.main_board_infos_ = nullptr;
}
inline const ::cn::seisys::dds::MainBoard& MachineState::_internal_main_board_infos() const {
  const ::cn::seisys::dds::MainBoard* p = _impl_.main_board_infos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::dds::MainBoard&>(
      ::cn::seisys::dds::_MainBoard_default_instance_);
}
inline const ::cn::seisys::dds::MainBoard& MachineState::main_board_infos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.main_board_infos)
  return _internal_main_board_infos();
}
inline void MachineState::unsafe_arena_set_allocated_main_board_infos(
    ::cn::seisys::dds::MainBoard* main_board_infos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.main_board_infos_);
  }
  _impl_.main_board_infos_ = main_board_infos;
  if (main_board_infos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.dds.MachineState.main_board_infos)
}
inline ::cn::seisys::dds::MainBoard* MachineState::release_main_board_infos() {
  
  ::cn::seisys::dds::MainBoard* temp = _impl_.main_board_infos_;
  _impl_.main_board_infos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::dds::MainBoard* MachineState::unsafe_arena_release_main_board_infos() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.MachineState.main_board_infos)
  
  ::cn::seisys::dds::MainBoard* temp = _impl_.main_board_infos_;
  _impl_.main_board_infos_ = nullptr;
  return temp;
}
inline ::cn::seisys::dds::MainBoard* MachineState::_internal_mutable_main_board_infos() {
  
  if (_impl_.main_board_infos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::dds::MainBoard>(GetArenaForAllocation());
    _impl_.main_board_infos_ = p;
  }
  return _impl_.main_board_infos_;
}
inline ::cn::seisys::dds::MainBoard* MachineState::mutable_main_board_infos() {
  ::cn::seisys::dds::MainBoard* _msg = _internal_mutable_main_board_infos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.main_board_infos)
  return _msg;
}
inline void MachineState::set_allocated_main_board_infos(::cn::seisys::dds::MainBoard* main_board_infos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.main_board_infos_;
  }
  if (main_board_infos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(main_board_infos);
    if (message_arena != submessage_arena) {
      main_board_infos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, main_board_infos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.main_board_infos_ = main_board_infos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.MachineState.main_board_infos)
}

// .cn.seisys.dds.OSInfo os_infos = 9;
inline bool MachineState::_internal_has_os_infos() const {
  return this != internal_default_instance() && _impl_.os_infos_ != nullptr;
}
inline bool MachineState::has_os_infos() const {
  return _internal_has_os_infos();
}
inline void MachineState::clear_os_infos() {
  if (GetArenaForAllocation() == nullptr && _impl_.os_infos_ != nullptr) {
    delete _impl_.os_infos_;
  }
  _impl_.os_infos_ = nullptr;
}
inline const ::cn::seisys::dds::OSInfo& MachineState::_internal_os_infos() const {
  const ::cn::seisys::dds::OSInfo* p = _impl_.os_infos_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::seisys::dds::OSInfo&>(
      ::cn::seisys::dds::_OSInfo_default_instance_);
}
inline const ::cn::seisys::dds::OSInfo& MachineState::os_infos() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.os_infos)
  return _internal_os_infos();
}
inline void MachineState::unsafe_arena_set_allocated_os_infos(
    ::cn::seisys::dds::OSInfo* os_infos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.os_infos_);
  }
  _impl_.os_infos_ = os_infos;
  if (os_infos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.seisys.dds.MachineState.os_infos)
}
inline ::cn::seisys::dds::OSInfo* MachineState::release_os_infos() {
  
  ::cn::seisys::dds::OSInfo* temp = _impl_.os_infos_;
  _impl_.os_infos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::seisys::dds::OSInfo* MachineState::unsafe_arena_release_os_infos() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.MachineState.os_infos)
  
  ::cn::seisys::dds::OSInfo* temp = _impl_.os_infos_;
  _impl_.os_infos_ = nullptr;
  return temp;
}
inline ::cn::seisys::dds::OSInfo* MachineState::_internal_mutable_os_infos() {
  
  if (_impl_.os_infos_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::seisys::dds::OSInfo>(GetArenaForAllocation());
    _impl_.os_infos_ = p;
  }
  return _impl_.os_infos_;
}
inline ::cn::seisys::dds::OSInfo* MachineState::mutable_os_infos() {
  ::cn::seisys::dds::OSInfo* _msg = _internal_mutable_os_infos();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.os_infos)
  return _msg;
}
inline void MachineState::set_allocated_os_infos(::cn::seisys::dds::OSInfo* os_infos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.os_infos_;
  }
  if (os_infos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(os_infos);
    if (message_arena != submessage_arena) {
      os_infos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, os_infos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.os_infos_ = os_infos;
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.MachineState.os_infos)
}

// repeated .cn.seisys.dds.Process processes = 10;
inline int MachineState::_internal_processes_size() const {
  return _impl_.processes_.size();
}
inline int MachineState::processes_size() const {
  return _internal_processes_size();
}
inline void MachineState::clear_processes() {
  _impl_.processes_.Clear();
}
inline ::cn::seisys::dds::Process* MachineState::mutable_processes(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.MachineState.processes)
  return _impl_.processes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Process >*
MachineState::mutable_processes() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.dds.MachineState.processes)
  return &_impl_.processes_;
}
inline const ::cn::seisys::dds::Process& MachineState::_internal_processes(int index) const {
  return _impl_.processes_.Get(index);
}
inline const ::cn::seisys::dds::Process& MachineState::processes(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.MachineState.processes)
  return _internal_processes(index);
}
inline ::cn::seisys::dds::Process* MachineState::_internal_add_processes() {
  return _impl_.processes_.Add();
}
inline ::cn::seisys::dds::Process* MachineState::add_processes() {
  ::cn::seisys::dds::Process* _add = _internal_add_processes();
  // @@protoc_insertion_point(field_add:cn.seisys.dds.MachineState.processes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::Process >&
MachineState::processes() const {
  // @@protoc_insertion_point(field_list:cn.seisys.dds.MachineState.processes)
  return _impl_.processes_;
}

// -------------------------------------------------------------------

// Node

// string uuid = 1;
inline void Node::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& Node::uuid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.uuid)
}
inline std::string* Node::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.uuid)
  return _s;
}
inline const std::string& Node::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void Node::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_uuid() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.uuid)
  return _impl_.uuid_.Release();
}
inline void Node::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.uuid)
}

// string to_node_id = 2;
inline void Node::clear_to_node_id() {
  _impl_.to_node_id_.ClearToEmpty();
}
inline const std::string& Node::to_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.to_node_id)
  return _internal_to_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_to_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.to_node_id)
}
inline std::string* Node::mutable_to_node_id() {
  std::string* _s = _internal_mutable_to_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.to_node_id)
  return _s;
}
inline const std::string& Node::_internal_to_node_id() const {
  return _impl_.to_node_id_.Get();
}
inline void Node::_internal_set_to_node_id(const std::string& value) {
  
  _impl_.to_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_to_node_id() {
  
  return _impl_.to_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_to_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.to_node_id)
  return _impl_.to_node_id_.Release();
}
inline void Node::set_allocated_to_node_id(std::string* to_node_id) {
  if (to_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.to_node_id_.SetAllocated(to_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_node_id_.IsDefault()) {
    _impl_.to_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.to_node_id)
}

// bytes to_node_name = 3;
inline void Node::clear_to_node_name() {
  _impl_.to_node_name_.ClearToEmpty();
}
inline const std::string& Node::to_node_name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.to_node_name)
  return _internal_to_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_to_node_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_node_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.to_node_name)
}
inline std::string* Node::mutable_to_node_name() {
  std::string* _s = _internal_mutable_to_node_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.to_node_name)
  return _s;
}
inline const std::string& Node::_internal_to_node_name() const {
  return _impl_.to_node_name_.Get();
}
inline void Node::_internal_set_to_node_name(const std::string& value) {
  
  _impl_.to_node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_to_node_name() {
  
  return _impl_.to_node_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_to_node_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.to_node_name)
  return _impl_.to_node_name_.Release();
}
inline void Node::set_allocated_to_node_name(std::string* to_node_name) {
  if (to_node_name != nullptr) {
    
  } else {
    
  }
  _impl_.to_node_name_.SetAllocated(to_node_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_node_name_.IsDefault()) {
    _impl_.to_node_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.to_node_name)
}

// string src_node_id = 4;
inline void Node::clear_src_node_id() {
  _impl_.src_node_id_.ClearToEmpty();
}
inline const std::string& Node::src_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.src_node_id)
  return _internal_src_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_src_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.src_node_id)
}
inline std::string* Node::mutable_src_node_id() {
  std::string* _s = _internal_mutable_src_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.src_node_id)
  return _s;
}
inline const std::string& Node::_internal_src_node_id() const {
  return _impl_.src_node_id_.Get();
}
inline void Node::_internal_set_src_node_id(const std::string& value) {
  
  _impl_.src_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_src_node_id() {
  
  return _impl_.src_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_src_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.src_node_id)
  return _impl_.src_node_id_.Release();
}
inline void Node::set_allocated_src_node_id(std::string* src_node_id) {
  if (src_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.src_node_id_.SetAllocated(src_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_node_id_.IsDefault()) {
    _impl_.src_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.src_node_id)
}

// string to_group = 5;
inline void Node::clear_to_group() {
  _impl_.to_group_.ClearToEmpty();
}
inline const std::string& Node::to_group() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.to_group)
  return _internal_to_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_to_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.to_group)
}
inline std::string* Node::mutable_to_group() {
  std::string* _s = _internal_mutable_to_group();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.to_group)
  return _s;
}
inline const std::string& Node::_internal_to_group() const {
  return _impl_.to_group_.Get();
}
inline void Node::_internal_set_to_group(const std::string& value) {
  
  _impl_.to_group_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_to_group() {
  
  return _impl_.to_group_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_to_group() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.to_group)
  return _impl_.to_group_.Release();
}
inline void Node::set_allocated_to_group(std::string* to_group) {
  if (to_group != nullptr) {
    
  } else {
    
  }
  _impl_.to_group_.SetAllocated(to_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_group_.IsDefault()) {
    _impl_.to_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.to_group)
}

// .cn.seisys.dds.ArchType arch = 6;
inline void Node::clear_arch() {
  _impl_.arch_ = 0;
}
inline ::cn::seisys::dds::ArchType Node::_internal_arch() const {
  return static_cast< ::cn::seisys::dds::ArchType >(_impl_.arch_);
}
inline ::cn::seisys::dds::ArchType Node::arch() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.arch)
  return _internal_arch();
}
inline void Node::_internal_set_arch(::cn::seisys::dds::ArchType value) {
  
  _impl_.arch_ = value;
}
inline void Node::set_arch(::cn::seisys::dds::ArchType value) {
  _internal_set_arch(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.arch)
}

// .cn.seisys.dds.OSType os = 7;
inline void Node::clear_os() {
  _impl_.os_ = 0;
}
inline ::cn::seisys::dds::OSType Node::_internal_os() const {
  return static_cast< ::cn::seisys::dds::OSType >(_impl_.os_);
}
inline ::cn::seisys::dds::OSType Node::os() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.os)
  return _internal_os();
}
inline void Node::_internal_set_os(::cn::seisys::dds::OSType value) {
  
  _impl_.os_ = value;
}
inline void Node::set_os(::cn::seisys::dds::OSType value) {
  _internal_set_os(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.os)
}

// string uri = 8;
inline void Node::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Node::uri() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.uri)
}
inline std::string* Node::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.uri)
  return _s;
}
inline const std::string& Node::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Node::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_uri() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.uri)
  return _impl_.uri_.Release();
}
inline void Node::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.uri)
}

// string to_config_path = 9;
inline void Node::clear_to_config_path() {
  _impl_.to_config_path_.ClearToEmpty();
}
inline const std::string& Node::to_config_path() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.to_config_path)
  return _internal_to_config_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_to_config_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_config_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.to_config_path)
}
inline std::string* Node::mutable_to_config_path() {
  std::string* _s = _internal_mutable_to_config_path();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.to_config_path)
  return _s;
}
inline const std::string& Node::_internal_to_config_path() const {
  return _impl_.to_config_path_.Get();
}
inline void Node::_internal_set_to_config_path(const std::string& value) {
  
  _impl_.to_config_path_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_to_config_path() {
  
  return _impl_.to_config_path_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_to_config_path() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.to_config_path)
  return _impl_.to_config_path_.Release();
}
inline void Node::set_allocated_to_config_path(std::string* to_config_path) {
  if (to_config_path != nullptr) {
    
  } else {
    
  }
  _impl_.to_config_path_.SetAllocated(to_config_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_config_path_.IsDefault()) {
    _impl_.to_config_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.to_config_path)
}

// string src_config_path = 10;
inline void Node::clear_src_config_path() {
  _impl_.src_config_path_.ClearToEmpty();
}
inline const std::string& Node::src_config_path() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.src_config_path)
  return _internal_src_config_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_src_config_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_config_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.src_config_path)
}
inline std::string* Node::mutable_src_config_path() {
  std::string* _s = _internal_mutable_src_config_path();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.src_config_path)
  return _s;
}
inline const std::string& Node::_internal_src_config_path() const {
  return _impl_.src_config_path_.Get();
}
inline void Node::_internal_set_src_config_path(const std::string& value) {
  
  _impl_.src_config_path_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_src_config_path() {
  
  return _impl_.src_config_path_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_src_config_path() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.src_config_path)
  return _impl_.src_config_path_.Release();
}
inline void Node::set_allocated_src_config_path(std::string* src_config_path) {
  if (src_config_path != nullptr) {
    
  } else {
    
  }
  _impl_.src_config_path_.SetAllocated(src_config_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_config_path_.IsDefault()) {
    _impl_.src_config_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.src_config_path)
}

// uint32 domain = 11;
inline void Node::clear_domain() {
  _impl_.domain_ = 0u;
}
inline uint32_t Node::_internal_domain() const {
  return _impl_.domain_;
}
inline uint32_t Node::domain() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.domain)
  return _internal_domain();
}
inline void Node::_internal_set_domain(uint32_t value) {
  
  _impl_.domain_ = value;
}
inline void Node::set_domain(uint32_t value) {
  _internal_set_domain(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.domain)
}

// bytes config = 12;
inline void Node::clear_config() {
  _impl_.config_.ClearToEmpty();
}
inline const std::string& Node::config() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.config)
  return _internal_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_config(ArgT0&& arg0, ArgT... args) {
 
 _impl_.config_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.config)
}
inline std::string* Node::mutable_config() {
  std::string* _s = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.config)
  return _s;
}
inline const std::string& Node::_internal_config() const {
  return _impl_.config_.Get();
}
inline void Node::_internal_set_config(const std::string& value) {
  
  _impl_.config_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_config() {
  
  return _impl_.config_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_config() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.config)
  return _impl_.config_.Release();
}
inline void Node::set_allocated_config(std::string* config) {
  if (config != nullptr) {
    
  } else {
    
  }
  _impl_.config_.SetAllocated(config, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_.IsDefault()) {
    _impl_.config_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.config)
}

// string config_hash = 13;
inline void Node::clear_config_hash() {
  _impl_.config_hash_.ClearToEmpty();
}
inline const std::string& Node::config_hash() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.config_hash)
  return _internal_config_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_config_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.config_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.config_hash)
}
inline std::string* Node::mutable_config_hash() {
  std::string* _s = _internal_mutable_config_hash();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.Node.config_hash)
  return _s;
}
inline const std::string& Node::_internal_config_hash() const {
  return _impl_.config_hash_.Get();
}
inline void Node::_internal_set_config_hash(const std::string& value) {
  
  _impl_.config_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_config_hash() {
  
  return _impl_.config_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_config_hash() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.Node.config_hash)
  return _impl_.config_hash_.Release();
}
inline void Node::set_allocated_config_hash(std::string* config_hash) {
  if (config_hash != nullptr) {
    
  } else {
    
  }
  _impl_.config_hash_.SetAllocated(config_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_hash_.IsDefault()) {
    _impl_.config_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.Node.config_hash)
}

// uint32 config_size = 14;
inline void Node::clear_config_size() {
  _impl_.config_size_ = 0u;
}
inline uint32_t Node::_internal_config_size() const {
  return _impl_.config_size_;
}
inline uint32_t Node::config_size() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.config_size)
  return _internal_config_size();
}
inline void Node::_internal_set_config_size(uint32_t value) {
  
  _impl_.config_size_ = value;
}
inline void Node::set_config_size(uint32_t value) {
  _internal_set_config_size(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.config_size)
}

// .cn.seisys.dds.CommStatus state = 15;
inline void Node::clear_state() {
  _impl_.state_ = 0;
}
inline ::cn::seisys::dds::CommStatus Node::_internal_state() const {
  return static_cast< ::cn::seisys::dds::CommStatus >(_impl_.state_);
}
inline ::cn::seisys::dds::CommStatus Node::state() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.state)
  return _internal_state();
}
inline void Node::_internal_set_state(::cn::seisys::dds::CommStatus value) {
  
  _impl_.state_ = value;
}
inline void Node::set_state(::cn::seisys::dds::CommStatus value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.state)
}

// int64 created_at = 16;
inline void Node::clear_created_at() {
  _impl_.created_at_ = int64_t{0};
}
inline int64_t Node::_internal_created_at() const {
  return _impl_.created_at_;
}
inline int64_t Node::created_at() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.created_at)
  return _internal_created_at();
}
inline void Node::_internal_set_created_at(int64_t value) {
  
  _impl_.created_at_ = value;
}
inline void Node::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.created_at)
}

// int64 updated_at = 17;
inline void Node::clear_updated_at() {
  _impl_.updated_at_ = int64_t{0};
}
inline int64_t Node::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline int64_t Node::updated_at() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.Node.updated_at)
  return _internal_updated_at();
}
inline void Node::_internal_set_updated_at(int64_t value) {
  
  _impl_.updated_at_ = value;
}
inline void Node::set_updated_at(int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.Node.updated_at)
}

// -------------------------------------------------------------------

// NodeReply

// string uuid = 1;
inline void NodeReply::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& NodeReply::uuid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeReply::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.uuid)
}
inline std::string* NodeReply::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeReply.uuid)
  return _s;
}
inline const std::string& NodeReply::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void NodeReply::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeReply::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeReply::release_uuid() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeReply.uuid)
  return _impl_.uuid_.Release();
}
inline void NodeReply::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeReply.uuid)
}

// string to_node_id = 2;
inline void NodeReply::clear_to_node_id() {
  _impl_.to_node_id_.ClearToEmpty();
}
inline const std::string& NodeReply::to_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.to_node_id)
  return _internal_to_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeReply::set_to_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.to_node_id)
}
inline std::string* NodeReply::mutable_to_node_id() {
  std::string* _s = _internal_mutable_to_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeReply.to_node_id)
  return _s;
}
inline const std::string& NodeReply::_internal_to_node_id() const {
  return _impl_.to_node_id_.Get();
}
inline void NodeReply::_internal_set_to_node_id(const std::string& value) {
  
  _impl_.to_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeReply::_internal_mutable_to_node_id() {
  
  return _impl_.to_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeReply::release_to_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeReply.to_node_id)
  return _impl_.to_node_id_.Release();
}
inline void NodeReply::set_allocated_to_node_id(std::string* to_node_id) {
  if (to_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.to_node_id_.SetAllocated(to_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_node_id_.IsDefault()) {
    _impl_.to_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeReply.to_node_id)
}

// bytes to_node_name = 3;
inline void NodeReply::clear_to_node_name() {
  _impl_.to_node_name_.ClearToEmpty();
}
inline const std::string& NodeReply::to_node_name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.to_node_name)
  return _internal_to_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeReply::set_to_node_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_node_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.to_node_name)
}
inline std::string* NodeReply::mutable_to_node_name() {
  std::string* _s = _internal_mutable_to_node_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeReply.to_node_name)
  return _s;
}
inline const std::string& NodeReply::_internal_to_node_name() const {
  return _impl_.to_node_name_.Get();
}
inline void NodeReply::_internal_set_to_node_name(const std::string& value) {
  
  _impl_.to_node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeReply::_internal_mutable_to_node_name() {
  
  return _impl_.to_node_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeReply::release_to_node_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeReply.to_node_name)
  return _impl_.to_node_name_.Release();
}
inline void NodeReply::set_allocated_to_node_name(std::string* to_node_name) {
  if (to_node_name != nullptr) {
    
  } else {
    
  }
  _impl_.to_node_name_.SetAllocated(to_node_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_node_name_.IsDefault()) {
    _impl_.to_node_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeReply.to_node_name)
}

// string src_node_id = 4;
inline void NodeReply::clear_src_node_id() {
  _impl_.src_node_id_.ClearToEmpty();
}
inline const std::string& NodeReply::src_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.src_node_id)
  return _internal_src_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeReply::set_src_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.src_node_id)
}
inline std::string* NodeReply::mutable_src_node_id() {
  std::string* _s = _internal_mutable_src_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeReply.src_node_id)
  return _s;
}
inline const std::string& NodeReply::_internal_src_node_id() const {
  return _impl_.src_node_id_.Get();
}
inline void NodeReply::_internal_set_src_node_id(const std::string& value) {
  
  _impl_.src_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeReply::_internal_mutable_src_node_id() {
  
  return _impl_.src_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeReply::release_src_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeReply.src_node_id)
  return _impl_.src_node_id_.Release();
}
inline void NodeReply::set_allocated_src_node_id(std::string* src_node_id) {
  if (src_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.src_node_id_.SetAllocated(src_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_node_id_.IsDefault()) {
    _impl_.src_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeReply.src_node_id)
}

// string to_group = 5;
inline void NodeReply::clear_to_group() {
  _impl_.to_group_.ClearToEmpty();
}
inline const std::string& NodeReply::to_group() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.to_group)
  return _internal_to_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeReply::set_to_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.to_group)
}
inline std::string* NodeReply::mutable_to_group() {
  std::string* _s = _internal_mutable_to_group();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeReply.to_group)
  return _s;
}
inline const std::string& NodeReply::_internal_to_group() const {
  return _impl_.to_group_.Get();
}
inline void NodeReply::_internal_set_to_group(const std::string& value) {
  
  _impl_.to_group_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeReply::_internal_mutable_to_group() {
  
  return _impl_.to_group_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeReply::release_to_group() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeReply.to_group)
  return _impl_.to_group_.Release();
}
inline void NodeReply::set_allocated_to_group(std::string* to_group) {
  if (to_group != nullptr) {
    
  } else {
    
  }
  _impl_.to_group_.SetAllocated(to_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_group_.IsDefault()) {
    _impl_.to_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeReply.to_group)
}

// string reply_uuid = 6;
inline void NodeReply::clear_reply_uuid() {
  _impl_.reply_uuid_.ClearToEmpty();
}
inline const std::string& NodeReply::reply_uuid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.reply_uuid)
  return _internal_reply_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeReply::set_reply_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.reply_uuid)
}
inline std::string* NodeReply::mutable_reply_uuid() {
  std::string* _s = _internal_mutable_reply_uuid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeReply.reply_uuid)
  return _s;
}
inline const std::string& NodeReply::_internal_reply_uuid() const {
  return _impl_.reply_uuid_.Get();
}
inline void NodeReply::_internal_set_reply_uuid(const std::string& value) {
  
  _impl_.reply_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeReply::_internal_mutable_reply_uuid() {
  
  return _impl_.reply_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeReply::release_reply_uuid() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeReply.reply_uuid)
  return _impl_.reply_uuid_.Release();
}
inline void NodeReply::set_allocated_reply_uuid(std::string* reply_uuid) {
  if (reply_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.reply_uuid_.SetAllocated(reply_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_uuid_.IsDefault()) {
    _impl_.reply_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeReply.reply_uuid)
}

// .cn.seisys.dds.CommStatus status = 7;
inline void NodeReply::clear_status() {
  _impl_.status_ = 0;
}
inline ::cn::seisys::dds::CommStatus NodeReply::_internal_status() const {
  return static_cast< ::cn::seisys::dds::CommStatus >(_impl_.status_);
}
inline ::cn::seisys::dds::CommStatus NodeReply::status() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.status)
  return _internal_status();
}
inline void NodeReply::_internal_set_status(::cn::seisys::dds::CommStatus value) {
  
  _impl_.status_ = value;
}
inline void NodeReply::set_status(::cn::seisys::dds::CommStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.status)
}

// bytes desc = 8;
inline void NodeReply::clear_desc() {
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& NodeReply::desc() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeReply::set_desc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.desc_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.desc)
}
inline std::string* NodeReply::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeReply.desc)
  return _s;
}
inline const std::string& NodeReply::_internal_desc() const {
  return _impl_.desc_.Get();
}
inline void NodeReply::_internal_set_desc(const std::string& value) {
  
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeReply::_internal_mutable_desc() {
  
  return _impl_.desc_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeReply::release_desc() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeReply.desc)
  return _impl_.desc_.Release();
}
inline void NodeReply::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  _impl_.desc_.SetAllocated(desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.desc_.IsDefault()) {
    _impl_.desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeReply.desc)
}

// bytes desc_str = 9;
inline void NodeReply::clear_desc_str() {
  _impl_.desc_str_.ClearToEmpty();
}
inline const std::string& NodeReply::desc_str() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.desc_str)
  return _internal_desc_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeReply::set_desc_str(ArgT0&& arg0, ArgT... args) {
 
 _impl_.desc_str_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.desc_str)
}
inline std::string* NodeReply::mutable_desc_str() {
  std::string* _s = _internal_mutable_desc_str();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeReply.desc_str)
  return _s;
}
inline const std::string& NodeReply::_internal_desc_str() const {
  return _impl_.desc_str_.Get();
}
inline void NodeReply::_internal_set_desc_str(const std::string& value) {
  
  _impl_.desc_str_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeReply::_internal_mutable_desc_str() {
  
  return _impl_.desc_str_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeReply::release_desc_str() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeReply.desc_str)
  return _impl_.desc_str_.Release();
}
inline void NodeReply::set_allocated_desc_str(std::string* desc_str) {
  if (desc_str != nullptr) {
    
  } else {
    
  }
  _impl_.desc_str_.SetAllocated(desc_str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.desc_str_.IsDefault()) {
    _impl_.desc_str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeReply.desc_str)
}

// int64 created_at = 10;
inline void NodeReply::clear_created_at() {
  _impl_.created_at_ = int64_t{0};
}
inline int64_t NodeReply::_internal_created_at() const {
  return _impl_.created_at_;
}
inline int64_t NodeReply::created_at() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.created_at)
  return _internal_created_at();
}
inline void NodeReply::_internal_set_created_at(int64_t value) {
  
  _impl_.created_at_ = value;
}
inline void NodeReply::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.created_at)
}

// int64 updated_at = 11;
inline void NodeReply::clear_updated_at() {
  _impl_.updated_at_ = int64_t{0};
}
inline int64_t NodeReply::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline int64_t NodeReply::updated_at() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeReply.updated_at)
  return _internal_updated_at();
}
inline void NodeReply::_internal_set_updated_at(int64_t value) {
  
  _impl_.updated_at_ = value;
}
inline void NodeReply::set_updated_at(int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeReply.updated_at)
}

// -------------------------------------------------------------------

// NodeCmd

// string uuid = 1;
inline void NodeCmd::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& NodeCmd::uuid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmd::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.uuid)
}
inline std::string* NodeCmd::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmd.uuid)
  return _s;
}
inline const std::string& NodeCmd::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void NodeCmd::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmd::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmd::release_uuid() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmd.uuid)
  return _impl_.uuid_.Release();
}
inline void NodeCmd::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmd.uuid)
}

// string src_node_id = 2;
inline void NodeCmd::clear_src_node_id() {
  _impl_.src_node_id_.ClearToEmpty();
}
inline const std::string& NodeCmd::src_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.src_node_id)
  return _internal_src_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmd::set_src_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.src_node_id)
}
inline std::string* NodeCmd::mutable_src_node_id() {
  std::string* _s = _internal_mutable_src_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmd.src_node_id)
  return _s;
}
inline const std::string& NodeCmd::_internal_src_node_id() const {
  return _impl_.src_node_id_.Get();
}
inline void NodeCmd::_internal_set_src_node_id(const std::string& value) {
  
  _impl_.src_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmd::_internal_mutable_src_node_id() {
  
  return _impl_.src_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmd::release_src_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmd.src_node_id)
  return _impl_.src_node_id_.Release();
}
inline void NodeCmd::set_allocated_src_node_id(std::string* src_node_id) {
  if (src_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.src_node_id_.SetAllocated(src_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_node_id_.IsDefault()) {
    _impl_.src_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmd.src_node_id)
}

// bytes src_node_name = 3;
inline void NodeCmd::clear_src_node_name() {
  _impl_.src_node_name_.ClearToEmpty();
}
inline const std::string& NodeCmd::src_node_name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.src_node_name)
  return _internal_src_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmd::set_src_node_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_node_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.src_node_name)
}
inline std::string* NodeCmd::mutable_src_node_name() {
  std::string* _s = _internal_mutable_src_node_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmd.src_node_name)
  return _s;
}
inline const std::string& NodeCmd::_internal_src_node_name() const {
  return _impl_.src_node_name_.Get();
}
inline void NodeCmd::_internal_set_src_node_name(const std::string& value) {
  
  _impl_.src_node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmd::_internal_mutable_src_node_name() {
  
  return _impl_.src_node_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmd::release_src_node_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmd.src_node_name)
  return _impl_.src_node_name_.Release();
}
inline void NodeCmd::set_allocated_src_node_name(std::string* src_node_name) {
  if (src_node_name != nullptr) {
    
  } else {
    
  }
  _impl_.src_node_name_.SetAllocated(src_node_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_node_name_.IsDefault()) {
    _impl_.src_node_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmd.src_node_name)
}

// string to_node_id = 4;
inline void NodeCmd::clear_to_node_id() {
  _impl_.to_node_id_.ClearToEmpty();
}
inline const std::string& NodeCmd::to_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.to_node_id)
  return _internal_to_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmd::set_to_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.to_node_id)
}
inline std::string* NodeCmd::mutable_to_node_id() {
  std::string* _s = _internal_mutable_to_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmd.to_node_id)
  return _s;
}
inline const std::string& NodeCmd::_internal_to_node_id() const {
  return _impl_.to_node_id_.Get();
}
inline void NodeCmd::_internal_set_to_node_id(const std::string& value) {
  
  _impl_.to_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmd::_internal_mutable_to_node_id() {
  
  return _impl_.to_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmd::release_to_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmd.to_node_id)
  return _impl_.to_node_id_.Release();
}
inline void NodeCmd::set_allocated_to_node_id(std::string* to_node_id) {
  if (to_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.to_node_id_.SetAllocated(to_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_node_id_.IsDefault()) {
    _impl_.to_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmd.to_node_id)
}

// string to_group = 5;
inline void NodeCmd::clear_to_group() {
  _impl_.to_group_.ClearToEmpty();
}
inline const std::string& NodeCmd::to_group() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.to_group)
  return _internal_to_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmd::set_to_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.to_group)
}
inline std::string* NodeCmd::mutable_to_group() {
  std::string* _s = _internal_mutable_to_group();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmd.to_group)
  return _s;
}
inline const std::string& NodeCmd::_internal_to_group() const {
  return _impl_.to_group_.Get();
}
inline void NodeCmd::_internal_set_to_group(const std::string& value) {
  
  _impl_.to_group_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmd::_internal_mutable_to_group() {
  
  return _impl_.to_group_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmd::release_to_group() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmd.to_group)
  return _impl_.to_group_.Release();
}
inline void NodeCmd::set_allocated_to_group(std::string* to_group) {
  if (to_group != nullptr) {
    
  } else {
    
  }
  _impl_.to_group_.SetAllocated(to_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_group_.IsDefault()) {
    _impl_.to_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmd.to_group)
}

// .cn.seisys.dds.CmdType cmd_type = 6;
inline void NodeCmd::clear_cmd_type() {
  _impl_.cmd_type_ = 0;
}
inline ::cn::seisys::dds::CmdType NodeCmd::_internal_cmd_type() const {
  return static_cast< ::cn::seisys::dds::CmdType >(_impl_.cmd_type_);
}
inline ::cn::seisys::dds::CmdType NodeCmd::cmd_type() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.cmd_type)
  return _internal_cmd_type();
}
inline void NodeCmd::_internal_set_cmd_type(::cn::seisys::dds::CmdType value) {
  
  _impl_.cmd_type_ = value;
}
inline void NodeCmd::set_cmd_type(::cn::seisys::dds::CmdType value) {
  _internal_set_cmd_type(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.cmd_type)
}

// .cn.seisys.dds.PodmanCmd podman_cmd = 7;
inline void NodeCmd::clear_podman_cmd() {
  _impl_.podman_cmd_ = 0;
}
inline ::cn::seisys::dds::PodmanCmd NodeCmd::_internal_podman_cmd() const {
  return static_cast< ::cn::seisys::dds::PodmanCmd >(_impl_.podman_cmd_);
}
inline ::cn::seisys::dds::PodmanCmd NodeCmd::podman_cmd() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.podman_cmd)
  return _internal_podman_cmd();
}
inline void NodeCmd::_internal_set_podman_cmd(::cn::seisys::dds::PodmanCmd value) {
  
  _impl_.podman_cmd_ = value;
}
inline void NodeCmd::set_podman_cmd(::cn::seisys::dds::PodmanCmd value) {
  _internal_set_podman_cmd(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.podman_cmd)
}

// string cmd = 8;
inline void NodeCmd::clear_cmd() {
  _impl_.cmd_.ClearToEmpty();
}
inline const std::string& NodeCmd::cmd() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.cmd)
  return _internal_cmd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmd::set_cmd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cmd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.cmd)
}
inline std::string* NodeCmd::mutable_cmd() {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmd.cmd)
  return _s;
}
inline const std::string& NodeCmd::_internal_cmd() const {
  return _impl_.cmd_.Get();
}
inline void NodeCmd::_internal_set_cmd(const std::string& value) {
  
  _impl_.cmd_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmd::_internal_mutable_cmd() {
  
  return _impl_.cmd_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmd::release_cmd() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmd.cmd)
  return _impl_.cmd_.Release();
}
inline void NodeCmd::set_allocated_cmd(std::string* cmd) {
  if (cmd != nullptr) {
    
  } else {
    
  }
  _impl_.cmd_.SetAllocated(cmd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cmd_.IsDefault()) {
    _impl_.cmd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmd.cmd)
}

// string paras = 9;
inline void NodeCmd::clear_paras() {
  _impl_.paras_.ClearToEmpty();
}
inline const std::string& NodeCmd::paras() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.paras)
  return _internal_paras();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmd::set_paras(ArgT0&& arg0, ArgT... args) {
 
 _impl_.paras_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.paras)
}
inline std::string* NodeCmd::mutable_paras() {
  std::string* _s = _internal_mutable_paras();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmd.paras)
  return _s;
}
inline const std::string& NodeCmd::_internal_paras() const {
  return _impl_.paras_.Get();
}
inline void NodeCmd::_internal_set_paras(const std::string& value) {
  
  _impl_.paras_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmd::_internal_mutable_paras() {
  
  return _impl_.paras_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmd::release_paras() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmd.paras)
  return _impl_.paras_.Release();
}
inline void NodeCmd::set_allocated_paras(std::string* paras) {
  if (paras != nullptr) {
    
  } else {
    
  }
  _impl_.paras_.SetAllocated(paras, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paras_.IsDefault()) {
    _impl_.paras_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmd.paras)
}

// string paras_1 = 10;
inline void NodeCmd::clear_paras_1() {
  _impl_.paras_1_.ClearToEmpty();
}
inline const std::string& NodeCmd::paras_1() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.paras_1)
  return _internal_paras_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmd::set_paras_1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.paras_1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.paras_1)
}
inline std::string* NodeCmd::mutable_paras_1() {
  std::string* _s = _internal_mutable_paras_1();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmd.paras_1)
  return _s;
}
inline const std::string& NodeCmd::_internal_paras_1() const {
  return _impl_.paras_1_.Get();
}
inline void NodeCmd::_internal_set_paras_1(const std::string& value) {
  
  _impl_.paras_1_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmd::_internal_mutable_paras_1() {
  
  return _impl_.paras_1_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmd::release_paras_1() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmd.paras_1)
  return _impl_.paras_1_.Release();
}
inline void NodeCmd::set_allocated_paras_1(std::string* paras_1) {
  if (paras_1 != nullptr) {
    
  } else {
    
  }
  _impl_.paras_1_.SetAllocated(paras_1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paras_1_.IsDefault()) {
    _impl_.paras_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmd.paras_1)
}

// string paras_2 = 11;
inline void NodeCmd::clear_paras_2() {
  _impl_.paras_2_.ClearToEmpty();
}
inline const std::string& NodeCmd::paras_2() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.paras_2)
  return _internal_paras_2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmd::set_paras_2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.paras_2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.paras_2)
}
inline std::string* NodeCmd::mutable_paras_2() {
  std::string* _s = _internal_mutable_paras_2();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmd.paras_2)
  return _s;
}
inline const std::string& NodeCmd::_internal_paras_2() const {
  return _impl_.paras_2_.Get();
}
inline void NodeCmd::_internal_set_paras_2(const std::string& value) {
  
  _impl_.paras_2_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmd::_internal_mutable_paras_2() {
  
  return _impl_.paras_2_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmd::release_paras_2() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmd.paras_2)
  return _impl_.paras_2_.Release();
}
inline void NodeCmd::set_allocated_paras_2(std::string* paras_2) {
  if (paras_2 != nullptr) {
    
  } else {
    
  }
  _impl_.paras_2_.SetAllocated(paras_2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paras_2_.IsDefault()) {
    _impl_.paras_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmd.paras_2)
}

// int64 created_at = 12;
inline void NodeCmd::clear_created_at() {
  _impl_.created_at_ = int64_t{0};
}
inline int64_t NodeCmd::_internal_created_at() const {
  return _impl_.created_at_;
}
inline int64_t NodeCmd::created_at() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.created_at)
  return _internal_created_at();
}
inline void NodeCmd::_internal_set_created_at(int64_t value) {
  
  _impl_.created_at_ = value;
}
inline void NodeCmd::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.created_at)
}

// int64 updated_at = 13;
inline void NodeCmd::clear_updated_at() {
  _impl_.updated_at_ = int64_t{0};
}
inline int64_t NodeCmd::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline int64_t NodeCmd::updated_at() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmd.updated_at)
  return _internal_updated_at();
}
inline void NodeCmd::_internal_set_updated_at(int64_t value) {
  
  _impl_.updated_at_ = value;
}
inline void NodeCmd::set_updated_at(int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmd.updated_at)
}

// -------------------------------------------------------------------

// NodeCmdReply

// string uuid = 1;
inline void NodeCmdReply::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& NodeCmdReply::uuid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmdReply::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.uuid)
}
inline std::string* NodeCmdReply::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmdReply.uuid)
  return _s;
}
inline const std::string& NodeCmdReply::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void NodeCmdReply::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmdReply::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmdReply::release_uuid() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmdReply.uuid)
  return _impl_.uuid_.Release();
}
inline void NodeCmdReply::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmdReply.uuid)
}

// string src_node_id = 2;
inline void NodeCmdReply::clear_src_node_id() {
  _impl_.src_node_id_.ClearToEmpty();
}
inline const std::string& NodeCmdReply::src_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.src_node_id)
  return _internal_src_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmdReply::set_src_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.src_node_id)
}
inline std::string* NodeCmdReply::mutable_src_node_id() {
  std::string* _s = _internal_mutable_src_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmdReply.src_node_id)
  return _s;
}
inline const std::string& NodeCmdReply::_internal_src_node_id() const {
  return _impl_.src_node_id_.Get();
}
inline void NodeCmdReply::_internal_set_src_node_id(const std::string& value) {
  
  _impl_.src_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmdReply::_internal_mutable_src_node_id() {
  
  return _impl_.src_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmdReply::release_src_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmdReply.src_node_id)
  return _impl_.src_node_id_.Release();
}
inline void NodeCmdReply::set_allocated_src_node_id(std::string* src_node_id) {
  if (src_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.src_node_id_.SetAllocated(src_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_node_id_.IsDefault()) {
    _impl_.src_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmdReply.src_node_id)
}

// bytes src_node_name = 3;
inline void NodeCmdReply::clear_src_node_name() {
  _impl_.src_node_name_.ClearToEmpty();
}
inline const std::string& NodeCmdReply::src_node_name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.src_node_name)
  return _internal_src_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmdReply::set_src_node_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_node_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.src_node_name)
}
inline std::string* NodeCmdReply::mutable_src_node_name() {
  std::string* _s = _internal_mutable_src_node_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmdReply.src_node_name)
  return _s;
}
inline const std::string& NodeCmdReply::_internal_src_node_name() const {
  return _impl_.src_node_name_.Get();
}
inline void NodeCmdReply::_internal_set_src_node_name(const std::string& value) {
  
  _impl_.src_node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmdReply::_internal_mutable_src_node_name() {
  
  return _impl_.src_node_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmdReply::release_src_node_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmdReply.src_node_name)
  return _impl_.src_node_name_.Release();
}
inline void NodeCmdReply::set_allocated_src_node_name(std::string* src_node_name) {
  if (src_node_name != nullptr) {
    
  } else {
    
  }
  _impl_.src_node_name_.SetAllocated(src_node_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_node_name_.IsDefault()) {
    _impl_.src_node_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmdReply.src_node_name)
}

// string to_node_id = 4;
inline void NodeCmdReply::clear_to_node_id() {
  _impl_.to_node_id_.ClearToEmpty();
}
inline const std::string& NodeCmdReply::to_node_id() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.to_node_id)
  return _internal_to_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmdReply::set_to_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.to_node_id)
}
inline std::string* NodeCmdReply::mutable_to_node_id() {
  std::string* _s = _internal_mutable_to_node_id();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmdReply.to_node_id)
  return _s;
}
inline const std::string& NodeCmdReply::_internal_to_node_id() const {
  return _impl_.to_node_id_.Get();
}
inline void NodeCmdReply::_internal_set_to_node_id(const std::string& value) {
  
  _impl_.to_node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmdReply::_internal_mutable_to_node_id() {
  
  return _impl_.to_node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmdReply::release_to_node_id() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmdReply.to_node_id)
  return _impl_.to_node_id_.Release();
}
inline void NodeCmdReply::set_allocated_to_node_id(std::string* to_node_id) {
  if (to_node_id != nullptr) {
    
  } else {
    
  }
  _impl_.to_node_id_.SetAllocated(to_node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_node_id_.IsDefault()) {
    _impl_.to_node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmdReply.to_node_id)
}

// bytes to_node_name = 5;
inline void NodeCmdReply::clear_to_node_name() {
  _impl_.to_node_name_.ClearToEmpty();
}
inline const std::string& NodeCmdReply::to_node_name() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.to_node_name)
  return _internal_to_node_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmdReply::set_to_node_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_node_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.to_node_name)
}
inline std::string* NodeCmdReply::mutable_to_node_name() {
  std::string* _s = _internal_mutable_to_node_name();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmdReply.to_node_name)
  return _s;
}
inline const std::string& NodeCmdReply::_internal_to_node_name() const {
  return _impl_.to_node_name_.Get();
}
inline void NodeCmdReply::_internal_set_to_node_name(const std::string& value) {
  
  _impl_.to_node_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmdReply::_internal_mutable_to_node_name() {
  
  return _impl_.to_node_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmdReply::release_to_node_name() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmdReply.to_node_name)
  return _impl_.to_node_name_.Release();
}
inline void NodeCmdReply::set_allocated_to_node_name(std::string* to_node_name) {
  if (to_node_name != nullptr) {
    
  } else {
    
  }
  _impl_.to_node_name_.SetAllocated(to_node_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_node_name_.IsDefault()) {
    _impl_.to_node_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmdReply.to_node_name)
}

// string cmd_reply_uuid = 6;
inline void NodeCmdReply::clear_cmd_reply_uuid() {
  _impl_.cmd_reply_uuid_.ClearToEmpty();
}
inline const std::string& NodeCmdReply::cmd_reply_uuid() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.cmd_reply_uuid)
  return _internal_cmd_reply_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmdReply::set_cmd_reply_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cmd_reply_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.cmd_reply_uuid)
}
inline std::string* NodeCmdReply::mutable_cmd_reply_uuid() {
  std::string* _s = _internal_mutable_cmd_reply_uuid();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmdReply.cmd_reply_uuid)
  return _s;
}
inline const std::string& NodeCmdReply::_internal_cmd_reply_uuid() const {
  return _impl_.cmd_reply_uuid_.Get();
}
inline void NodeCmdReply::_internal_set_cmd_reply_uuid(const std::string& value) {
  
  _impl_.cmd_reply_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmdReply::_internal_mutable_cmd_reply_uuid() {
  
  return _impl_.cmd_reply_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmdReply::release_cmd_reply_uuid() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmdReply.cmd_reply_uuid)
  return _impl_.cmd_reply_uuid_.Release();
}
inline void NodeCmdReply::set_allocated_cmd_reply_uuid(std::string* cmd_reply_uuid) {
  if (cmd_reply_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.cmd_reply_uuid_.SetAllocated(cmd_reply_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cmd_reply_uuid_.IsDefault()) {
    _impl_.cmd_reply_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmdReply.cmd_reply_uuid)
}

// .cn.seisys.dds.CmdType cmd_type = 7;
inline void NodeCmdReply::clear_cmd_type() {
  _impl_.cmd_type_ = 0;
}
inline ::cn::seisys::dds::CmdType NodeCmdReply::_internal_cmd_type() const {
  return static_cast< ::cn::seisys::dds::CmdType >(_impl_.cmd_type_);
}
inline ::cn::seisys::dds::CmdType NodeCmdReply::cmd_type() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.cmd_type)
  return _internal_cmd_type();
}
inline void NodeCmdReply::_internal_set_cmd_type(::cn::seisys::dds::CmdType value) {
  
  _impl_.cmd_type_ = value;
}
inline void NodeCmdReply::set_cmd_type(::cn::seisys::dds::CmdType value) {
  _internal_set_cmd_type(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.cmd_type)
}

// .cn.seisys.dds.CommStatus status = 8;
inline void NodeCmdReply::clear_status() {
  _impl_.status_ = 0;
}
inline ::cn::seisys::dds::CommStatus NodeCmdReply::_internal_status() const {
  return static_cast< ::cn::seisys::dds::CommStatus >(_impl_.status_);
}
inline ::cn::seisys::dds::CommStatus NodeCmdReply::status() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.status)
  return _internal_status();
}
inline void NodeCmdReply::_internal_set_status(::cn::seisys::dds::CommStatus value) {
  
  _impl_.status_ = value;
}
inline void NodeCmdReply::set_status(::cn::seisys::dds::CommStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.status)
}

// bytes desc = 9;
inline void NodeCmdReply::clear_desc() {
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& NodeCmdReply::desc() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmdReply::set_desc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.desc_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.desc)
}
inline std::string* NodeCmdReply::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmdReply.desc)
  return _s;
}
inline const std::string& NodeCmdReply::_internal_desc() const {
  return _impl_.desc_.Get();
}
inline void NodeCmdReply::_internal_set_desc(const std::string& value) {
  
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmdReply::_internal_mutable_desc() {
  
  return _impl_.desc_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmdReply::release_desc() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmdReply.desc)
  return _impl_.desc_.Release();
}
inline void NodeCmdReply::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  _impl_.desc_.SetAllocated(desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.desc_.IsDefault()) {
    _impl_.desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmdReply.desc)
}

// bytes desc_str = 10;
inline void NodeCmdReply::clear_desc_str() {
  _impl_.desc_str_.ClearToEmpty();
}
inline const std::string& NodeCmdReply::desc_str() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.desc_str)
  return _internal_desc_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeCmdReply::set_desc_str(ArgT0&& arg0, ArgT... args) {
 
 _impl_.desc_str_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.desc_str)
}
inline std::string* NodeCmdReply::mutable_desc_str() {
  std::string* _s = _internal_mutable_desc_str();
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmdReply.desc_str)
  return _s;
}
inline const std::string& NodeCmdReply::_internal_desc_str() const {
  return _impl_.desc_str_.Get();
}
inline void NodeCmdReply::_internal_set_desc_str(const std::string& value) {
  
  _impl_.desc_str_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeCmdReply::_internal_mutable_desc_str() {
  
  return _impl_.desc_str_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeCmdReply::release_desc_str() {
  // @@protoc_insertion_point(field_release:cn.seisys.dds.NodeCmdReply.desc_str)
  return _impl_.desc_str_.Release();
}
inline void NodeCmdReply::set_allocated_desc_str(std::string* desc_str) {
  if (desc_str != nullptr) {
    
  } else {
    
  }
  _impl_.desc_str_.SetAllocated(desc_str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.desc_str_.IsDefault()) {
    _impl_.desc_str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.seisys.dds.NodeCmdReply.desc_str)
}

// repeated .cn.seisys.dds.File result = 11;
inline int NodeCmdReply::_internal_result_size() const {
  return _impl_.result_.size();
}
inline int NodeCmdReply::result_size() const {
  return _internal_result_size();
}
inline void NodeCmdReply::clear_result() {
  _impl_.result_.Clear();
}
inline ::cn::seisys::dds::File* NodeCmdReply::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:cn.seisys.dds.NodeCmdReply.result)
  return _impl_.result_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File >*
NodeCmdReply::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:cn.seisys.dds.NodeCmdReply.result)
  return &_impl_.result_;
}
inline const ::cn::seisys::dds::File& NodeCmdReply::_internal_result(int index) const {
  return _impl_.result_.Get(index);
}
inline const ::cn::seisys::dds::File& NodeCmdReply::result(int index) const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.result)
  return _internal_result(index);
}
inline ::cn::seisys::dds::File* NodeCmdReply::_internal_add_result() {
  return _impl_.result_.Add();
}
inline ::cn::seisys::dds::File* NodeCmdReply::add_result() {
  ::cn::seisys::dds::File* _add = _internal_add_result();
  // @@protoc_insertion_point(field_add:cn.seisys.dds.NodeCmdReply.result)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::seisys::dds::File >&
NodeCmdReply::result() const {
  // @@protoc_insertion_point(field_list:cn.seisys.dds.NodeCmdReply.result)
  return _impl_.result_;
}

// int64 created_at = 12;
inline void NodeCmdReply::clear_created_at() {
  _impl_.created_at_ = int64_t{0};
}
inline int64_t NodeCmdReply::_internal_created_at() const {
  return _impl_.created_at_;
}
inline int64_t NodeCmdReply::created_at() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.created_at)
  return _internal_created_at();
}
inline void NodeCmdReply::_internal_set_created_at(int64_t value) {
  
  _impl_.created_at_ = value;
}
inline void NodeCmdReply::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.created_at)
}

// int64 updated_at = 13;
inline void NodeCmdReply::clear_updated_at() {
  _impl_.updated_at_ = int64_t{0};
}
inline int64_t NodeCmdReply::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline int64_t NodeCmdReply::updated_at() const {
  // @@protoc_insertion_point(field_get:cn.seisys.dds.NodeCmdReply.updated_at)
  return _internal_updated_at();
}
inline void NodeCmdReply::_internal_set_updated_at(int64_t value) {
  
  _impl_.updated_at_ = value;
}
inline void NodeCmdReply::set_updated_at(int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:cn.seisys.dds.NodeCmdReply.updated_at)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dds
}  // namespace seisys
}  // namespace cn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cn::seisys::dds::ArchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::dds::ArchType>() {
  return ::cn::seisys::dds::ArchType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::dds::OSType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::dds::OSType>() {
  return ::cn::seisys::dds::OSType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::dds::CmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::dds::CmdType>() {
  return ::cn::seisys::dds::CmdType_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::dds::NodeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::dds::NodeState>() {
  return ::cn::seisys::dds::NodeState_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::dds::PodmanCmd> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::dds::PodmanCmd>() {
  return ::cn::seisys::dds::PodmanCmd_descriptor();
}
template <> struct is_proto_enum< ::cn::seisys::dds::CommStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cn::seisys::dds::CommStatus>() {
  return ::cn::seisys::dds::CommStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_node_2eproto
